/*
 * osgi.specs Gradle build script
 */
import org.apache.tools.ant.filters.ReplaceTokens

version bnd('osgi.version')

ext.fop_home = new File(bnd.licensed, 'fop')
ext.fop_classpath = files(fileTree('dir': new File(fop_home, 'lib'), 'include': '*.jar'),
  fileTree('dir': new File(fop_home, 'build'), 'includes': ['fop.jar', 'fop-hyph.jar']))

task javadoc('overwrite': true, 'type': Javadoc) {
  description 'Build the docbook flavored javadoc.'
  group 'documentation'
  dependsOn compileJava
  destinationDir = new File(buildDir, 'javadoc')
  ext.javadocxml = new File(destinationDir, 'javadoc.xml')
  ext.stylesheet = file('docbook/xsl/javadoc2docbook.xsl')
  inputs.file stylesheet
  classpath = compileJava.classpath
  source bnd.allSrcDirs
  bnd.javadoc_specs.split(/\s*,\s*/).each {
    include it.replace('.','/')+'/**/*.java'
  }
  configure(options) {
    memberLevel = JavadocMemberLevel.PROTECTED
    encoding = 'UTF-8'
    title = ''
    doclet 'org.osgi.tools.xmldoclet.XmlDoclet'
    docletpath compileJava.destinationDir
  }
  doLast {
    ant.xslt('style': stylesheet,
      'in': javadocxml,
      'out': "${destinationDir}/docbook/javadoc.txt") {
      classpath('location': bnd.saxon)
      factory('name': 'com.icl.saxon.TransformerFactoryImpl')
      param('name': 'destdir', 'expression': "${destinationDir}/docbook")
      param('name': 'ddf.only', 'expression': '0')
    }
    ant.xslt('style': stylesheet,
      'in': javadocxml,
      'out': "${destinationDir}/docbook/ddf.txt") {
      classpath('location': bnd.saxon)
      factory('name': 'com.icl.saxon.TransformerFactoryImpl')
      param('name': 'destdir', 'expression': "${destinationDir}/docbook")
      param('name': 'ddf.only', 'expression': '1')
    }
  }
}

task('rdmtsummary') {
  description 'Build the docbook flavored Residential DMT summary.'
  group 'documentation'
  dependsOn compileJava
  ext.destinationDir = new File(buildDir, 'residentialdmt')
  ext.treesummaryxml = new File(destinationDir, 'treesummary.xml')
  inputs.files project(':dmforest').sourceSets.main.allJava
  outputs.dir destinationDir
  doFirst {
    project.mkdir(destinationDir)
  }
  doLast {
    treesummaryxml.withOutputStream { os ->
      javaexec {
        classpath sourceSets.main.runtimeClasspath
        main = 'org.osgi.tools.dmt.TreeSummary'
        standardOutput new BufferedOutputStream(os)
        args 'org.osgi.dmt.residential.$'
      }.assertNormalExitValue()
    }
  }
}

task('xmlns', 'type': Copy) {
  description 'Build the docbook flavored schemas.'
  group 'documentation'
  from rootProject.file('xmlns')
  into new File(buildDir, 'xmlns')
  include '**/*.xsd'
  includeEmptyDirs = false
  doLast {
    ant.replaceregexp('match': /.*(<(\w+:)?schema)/,
      'replace': /\1/,
      'flags': 's',
      'encoding': 'UTF-8') {
      fileset('dir': destinationDir, 'includes': '**/*.xsd')
    }
  }
}

tasks.addRule('Pattern: <name>.xml: Generate the docbook xml file for the book <name>.') { taskName ->
  if (taskName.endsWith('.xml') && !taskName.endsWith('-diff.xml')) {
    task(taskName) {
      ext.book = taskName - '.xml'
      description "Generate the docbook xml file for the book ${book}."
      group 'documentation'
      dependsOn compileJava
      ext.destinationDir = new File(buildDir, 'book')
      ext.stylesheet = file('docbook/xsl/identity.xsl')
      ext.bookxml = new File(destinationDir, taskName)
      inputs.files stylesheet, fileTree('dir': 'docbook', 'include': '**/*.xml')
      outputs.file bookxml
      doFirst {
        project.mkdir(destinationDir)
      }
      doLast {
        ant.xslt('style': stylesheet,
          'in': "docbook/${book}/book.xml",
          'out': bookxml,
          'force': true) {
          sysproperty('key': 'org.apache.xerces.xni.parser.XMLParserConfiguration',
            'value': 'org.apache.xerces.parsers.XIncludeParserConfiguration')
          classpath {
            fileset('dir': "${fop_home}/lib") {
              include('name': 'xercesImpl*.jar')
              include('name': 'xml-apis*.jar')
            }
            pathelement('location': bnd.saxon)
          }
          factory('name': 'com.icl.saxon.TransformerFactoryImpl')
        }
        javaexec {
          classpath sourceSets.main.runtimeClasspath
          main = 'org.osgi.tools.xmlvalidation.XmlValidator'
          args rootProject.file('licensed/docbook-xsd/docbook.xsd')
          args bookxml
        }.assertNormalExitValue()
      }
    }
  }
}

configure(tasks.getByPath('core.xml')) {
  [javadoc, xmlns].each {
    dependsOn it
    inputs.files it
  }
}
configure(tasks.getByPath('cmpn.xml')) {
  [javadoc, xmlns].each {
    dependsOn it
    inputs.files it
  }
}
configure(tasks.getByPath('enterprise.xml')) {
  [javadoc, xmlns].each {
    dependsOn it
    inputs.files it
  }
}
configure(tasks.getByPath('residential.xml')) {
  [javadoc, xmlns, rdmtsummary].each {
    dependsOn it
    inputs.files it
  }
}

tasks.addRule('Pattern: <name>-diff.xml: Generate the docbook diff xml file for the book <name>.') { taskName ->
  if (taskName.endsWith('-diff.xml')) {
    task(taskName) {
      ext.book = taskName - '-diff.xml'
      description "Generate the docbook diff xml file for the book ${book}."
      group 'documentation'
      def booktask = tasks.getByPath("${book}.xml")
      dependsOn booktask
      ext.destinationDir = new File(buildDir, 'book')
      ext.stylesheet = file("${bnd.licensed}/diffmk/style/docbook.xsl")
      ext.baselinexml = file("baseline/${book}.xml")
      ext.bookxml = new File(destinationDir, taskName)
      inputs.files stylesheet, baselinexml, booktask
      outputs.file bookxml
      doFirst {
        project.mkdir(destinationDir)
      }
      doLast {
        def tmpxml = new File(temporaryDir, 'diff.xml')
        javaexec {
          classpath "${bnd.licensed}/diffmk/bin/diffmk.jar"
          main = 'net.sf.diffmk.DiffMk'
          minHeapSize = '1024m'
          maxHeapSize = '2048m'
          args '--verbose'
          args '1'
          args '--words'
          args baselinexml
          args booktask.bookxml
          args tmpxml
        }.assertNormalExitValue()
        ant.xslt('style': stylesheet,
          'in': tmpxml,
          'out': bookxml) {
          classpath('location': bnd.saxon)
          factory('name': 'com.icl.saxon.TransformerFactoryImpl')
        }
      }
    }
  }
}

tasks.addRule('Pattern: <name>.fo: Generate the docbook fo file for the book <name>.') { taskName ->
  if (taskName.endsWith('.fo')) {
    task(taskName) {
      ext.book = taskName - '.fo'
      description "Generate the docbook fo file for the book ${book}."
      group 'documentation'
      def booktask = tasks.getByPath("${book}.xml")
      dependsOn booktask
      ext.destinationDir = new File(buildDir, 'fo')
      ext.stylesheet = file('docbook/xsl/custom-fo.xsl')
      ext.bookfo = new File(destinationDir, taskName)
      ext.watermark = 'docbook/graphics/draft.svg'
      inputs.files stylesheet, booktask
      outputs.file bookfo
      doFirst {
        project.mkdir(destinationDir)
      }
      doLast {
        ant.xslt('style': stylesheet,
          'in': booktask.bookxml,
          'out': bookfo) {
          classpath('location': bnd.saxon)
          factory('name': 'com.icl.saxon.TransformerFactoryImpl')
          param('name': 'draft.watermark.image', 'expression': watermark)
          param('name': 'copyright.year', 'expression': "2000, ${bnd('copyright.year')}")
        }
      }
    }
  }
}

tasks.addRule('Pattern: <name>.pdf: Generate the docbook pdf file for the book <name>.') { taskName ->
  if (taskName.endsWith('.pdf')) {
    task(taskName) {
      ext.book = taskName - '.pdf'
      description "Generate the docbook pdf file for the book ${book}."
      group 'documentation'
      def fotask = tasks.getByPath("${book}.fo")
      dependsOn fotask
      ext.destinationDir = buildDir
      ext.bookpdf = new File(destinationDir, "osgi.${book}-${version}.pdf")
      def fontbasedir = file('fonts')
      def fopxconf = file('docbook/fop/fop-osgi.xconf')
      def log4jprops = file('docbook/fop/log4j.properties')
      inputs.files fopxconf, log4jprops, fotask, fileTree('dir': 'docbook', 'include': '**/*.svg')
      inputs.dir fontbasedir
      outputs.file bookpdf
      doFirst {
        project.mkdir(destinationDir)
      }
      doLast {
        def basebook = book - '-diff'
        copy {
          from fopxconf
          into temporaryDir
          filter(ReplaceTokens,
            'tokens': ['book.base.url': file("docbook/${basebook}").toURI().toString(),
              'font.base.url': fontbasedir.toURI().toString(),
              'font.base.dir': fontbasedir.absolutePath])
        }
        javaexec {
          systemProperty('java.awt.headless', 'true')
          systemProperty('JAVA_FONTS', fontbasedir)
          systemProperty('log4j.configuration', log4jprops.toURI())
          classpath compileJava.destinationDir
          classpath bnd.log4j
          classpath fop_classpath
          main = 'org.osgi.tools.fop.FOPMain'
          minHeapSize = '1024m'
          maxHeapSize = '2048m'
          args '-c', new File(temporaryDir, fopxconf.name)
          args '-fo', fotask.bookfo
          args '-pdf', bookpdf
        }.assertNormalExitValue()
      }
    }
  }
}

tasks.addRule('Pattern: <name>.htmlresources: Copy the HTML resources for the book <name>.') { taskName ->
  if (taskName.endsWith('.htmlresources')) {
    task(taskName, type: Copy) {
      ext.book = taskName - '.htmlresources'
      description "Copy the HTML resources for the book ${book}."
      group 'documentation'

      from file('docbook/xsl/html-resources')
      into new File(buildDir, "html/${book}")
      from (new File(bnd.licensed, 'webresources')) {
        include 'highlight.js/highlight.pack.js','jquery/jquery-3.2.1.slim.min.js','jquery.modal/jquery.modal.min.js','js-cookie/js.cookie.js','senna.js/senna-min.js'
        into 'js'
        eachFile { cfd ->
          cfd.path = "js/${cfd.name}"
        }
      }
      from (new File(bnd.licensed, 'webresources')) {
        include 'highlight.js/styles/github.css'
        into 'css'
        eachFile { cfd ->
          cfd.path = "css/${cfd.name}"
        }
      }
      includeEmptyDirs = false
    }
  }
}

tasks.addRule('Pattern: <name>.rasterize: Rasterize SVGs for the book <name>.') { taskName ->
  if (taskName.endsWith('.rasterize')) {
    task(taskName) {
      ext.book = taskName - '.rasterize'
      description "Rasterize SVGs for the book ${book}."
      group 'documentation'

      def xmltask = tasks.getByPath("${book}.xml")
      dependsOn xmltask

      def imagesXSL = file('docbook/xsl/custom-html-images.xsl')
      def imagesFile = new File(temporaryDir, 'images.txt')
      def destinationDir = new File(buildDir, "html/${book}/images")

      inputs.files imagesXSL, fileTree('dir': "docbook", 'include': '**/*.svg')
      outputs.dir destinationDir

      def svgFiles = []

      doFirst {
        project.mkdir(destinationDir)

        ant.xslt('style': imagesXSL,
          'in': xmltask.bookxml,
          'out': imagesFile) {
          classpath('location': bnd.saxon)
          factory('name': 'com.icl.saxon.TransformerFactoryImpl')
        }

        imagesFile.eachLine { line ->
          svgFiles << file("docbook/${book}/${line}")
        }

        svgFiles << file("docbook/graphics/draft.svg")
      }
      doLast {
        javaexec {
          systemProperty('scale', '2')
          systemProperty('dpi', '300')
          systemProperty('JAVA_FONTS', file('fonts'))
          classpath sourceSets.main.runtimeClasspath
          main = 'org.osgi.tools.rasterizer.RasterizerMain'
          minHeapSize = '1024m'
          maxHeapSize = '2048m'
          args destinationDir
          args svgFiles
        }.assertNormalExitValue()
      }
    }
  }
}

tasks.addRule('Pattern: <name>.zip: Create a ZIP archive of the HTML produced for the book <name>.') { taskName ->
  if (taskName.endsWith('.zip')) {
    task(taskName, type: Zip) {
      ext.book = taskName - '.zip'
      description "Create a ZIP archive of the HTML produced for the book ${book}."
      group 'documentation'

      def htmltask = tasks.getByPath("${book}.html")
      dependsOn htmltask

      from new File(buildDir, "html/${book}")
      include '**/*'
      archiveName "osgi.${book}-${version}-html.zip"
      destinationDir(buildDir)
    }
  }
}

tasks.addRule('Pattern: <name>.html: Generate the docbook html file for the book <name>.') { taskName ->
  if (taskName.endsWith('.html')) {
    task(taskName) {
      ext.book = taskName - '.html'
      description "Generate the html files for the book ${book}."
      group 'documentation'

      def htmlresourcestask = tasks.getByPath("${book}.htmlresources")
      def rasterizetask = tasks.getByPath("${book}.rasterize")
      dependsOn htmlresourcestask, rasterizetask

      def stylesheet = file('docbook/xsl/custom-html.xsl')
      def commonXSL = file('docbook/xsl/custom-html-common.xsl')
      def profileXSL = file('docbook/xsl/custom-html-profile.xsl')
      def destinationDir = new File(buildDir, "html/${book}")

      inputs.files stylesheet, commonXSL, profileXSL
      outputs.dir destinationDir

      doFirst {
        project.mkdir(destinationDir)
      }
      doLast {
        def xmltask = tasks.getByPath("${book}.xml")
        def tmpxml = new File(temporaryDir, 'book.xml')

        ant.xslt('style': profileXSL,
          'in': xmltask.bookxml,
          'out': tmpxml) {
          classpath('location': bnd.saxon)
          factory('name': 'com.icl.saxon.TransformerFactoryImpl')
        }

        ant.xslt('style': stylesheet,
          'in': tmpxml,
          'out': new File(temporaryDir, 'book.txt')) {
          classpath('location': bnd.saxon)
          factory('name': 'com.icl.saxon.TransformerFactoryImpl')
          param('name': 'copyright.year', 'expression': "2000, ${bnd('copyright.year')}")
          param('name': 'draft.watermark.image', 'expression': 'draft.png')
          param('name': 'webhelp.base.dir', 'expression': destinationDir)
          param('name': 'chunked.filename.prefix', 'expression': "${book}-")
          param('name': 'webhelp.default.topic', 'expression': "${book}-index.html")
          param('name': 'release.version', 'expression': version)
        }
      }
    }
  }
}

task('fontmetrics') {
  description 'Build the font metrics.'
  group 'documentation'
  inputs.files fileTree('dir': file('fonts'), 'include': '*.ttf')
  outputs.files inputs.files.collect {
    it.absolutePath.replaceAll(/\.ttf$/, /.xml/)
  }
  doLast {
    inputs.files.each { ttf ->
      javaexec {
        classpath fop_classpath
        main = 'org.apache.fop.fonts.apps.TTFReader'
        args ttf.absolutePath
        args ttf.absolutePath.replaceAll(/\.ttf$/, /.xml/)
      }.assertNormalExitValue()
    }
  }
}

defaultTasks += 'specifications'

task('specifications') {
  description 'Generates all the specifications.'
  group 'documentation'
  dependsOn 'core.pdf', 'cmpn.pdf', 'enterprise.pdf', 'residential.pdf'
  dependsOn 'core.zip', 'cmpn.zip', 'enterprise.zip', 'residential.zip'
}
