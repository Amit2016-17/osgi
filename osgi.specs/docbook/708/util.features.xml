<?xml version="1.0" encoding="utf-8"?>
<chapter label="708"
         revision="$Id$"
         version="5.0" xml:id="util.features"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Features Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.util.feature-version"
    linkend="org.osgi.util.feature"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>
        OSGi has become a platform capable of running large applications for a variety of purposes, 
        including rich client applications, server-side systems and cloud and container based architectures. 
        As these applications are generally based on many bundles, describing each bundle individually 
        in an application definition becomes unwieldy once the number of bundles reaches a certain level. 
    </para>

    <para>
        When developing large scale applications it is often the case that few people know the role of every 
        single bundle or configuration item in the application. To keep the architecture understandable a grouping 
        mechanism is needed that allows for the representation of parts of the application into larger 
        entities that keep reasoning about the system manageable. In such a domain members of teams 
        spread across an organization will need to be able to both develop new parts for the application 
        as well as make tweaks or enhancements to parts developed by others such as adding configuration and 
        resources or changing one or more bundles relevant to their part of the application.
    </para>

    <para>
        The higher level constructs that define the application should be reusable in different contexts, 
        for example if one team has developed a component to handle job processing, different applications 
        should be able to use it, and if needed tune its configuration or other aspects so that it works in 
        each setting without having to know each and every detail that the job processing component is built 
        up from.
    </para>

    <para>
        Applications are often associated with additional resources or metadata, for example 
        database scripts or custom artifacts.
        By including these with the application definition, all the related entities are encapsulated in
        a single artifact. 
    </para>

    <para>
        By combining various applications 
        or subsystems together, systems are composed of existing, reusable building blocks, where all these 
        blocks can work together. 
        Architects of these systems need to think about components without having to dive into the 
        individual implementation details of each subcomponent. 
        The features defined in this specification can be used to model such applications. Features
        contain the definition of an application or component and can be composed into larger systems.
    </para>


    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Declarative</emphasis> - Features are declarative and can be mapped to different implementations.
          </para>
        </listitem>

        <listitem>
          <para><emphasis>Extensible</emphasis> - Features are extensible with custom content to allow all information related to 
          a feature to be co-located.
          </para>
        </listitem>

        <listitem>
          <para><emphasis>Human Readable</emphasis> - No special software is needed to read or author features.
          </para>
        </listitem>

        <listitem>
          <para><emphasis>Machine Readable</emphasis> - Features can easily be processed by tools.
          </para>
        </listitem>

      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <para>The following entities are used in this specification:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Feature</emphasis> - A feature contains a number of entities that, when provided to a 
          launcher can be turned into an executable system. Features can also be building blocks which 
          are assembled into larger systems.</para>
        </listitem>

        <listitem>
          <para><emphasis>Bundles</emphasis> - A feature can contain one ore more bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Capabilities</emphasis> and <emphasis>Requirements</emphasis> - A feature can declare additional capabilities and requirements.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration</emphasis> - A feature can contain configurations applied to the Configuration Admin service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Extension</emphasis> - A feature can contain a number of extensions with custom content.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>Launcher</emphasis> - A launcher can turn one or more features into an executable system.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>Processor</emphasis> - A feature processor can read features and perform a processing
          operation on them, such as validation, transformation or generation of new entities based on the features.</para>
        </listitem>

        <listitem>
          <para><emphasis>Properties</emphasis> - Framework properties can be specified in a feature.</para>
        </listitem>

      </itemizedlist>

	  <remark>Add a diagram here.</remark>

        <!--
      <figure pgwide="1">
        <title>Features Entity overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="4.100in"
                       contentwidth="6.000in" fileref="features-overview.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
        -->
    </section>
  </section>

  <section>
    <title>Feature</title>

    <para>
      Features are defined by declaring JSON documents or by using the
      <link linkend="org.osgi.util.feature" xrefstyle="hyperlink">Feature API</link>.
      Each Feature has a unique ID which includes a version. It can hold a number of entities, including a list of bundles, configurations, capabilities, requirements and others. Features are extensible, that is a Feature can also hold any number of custom entities which are related to the Feature.
    </para>

    <para>
Features may have dependencies on other Features. Features inherit the capabilities and requirements from all bundles listed in the Feature, and can also have additional capabilities and requirements declared on the Feature level. 
    </para>

    <para>
      Once created, a Feature is immutable. Its definition cannot be modified. However another Feature with a different identity can be created which is based on a given Feature using the prototype mechanism. 
    </para>

    <para>
      Additionally itâ€™s possible to record caching related information in a Feature through transient extensions, however this cached content is not significant for the definition of the Feature or part of its identity.
    </para>

    <section xml:id="util.feature-identifiers">
      <title>Identifiers</title>

      <para>
        Identifiers used throughout this specification are defined using the Maven Identifier model. They are composed of the following parts:

        <itemizedlist>
          <listitem><para>Group ID</para></listitem>
          <listitem><para>Artifact ID</para></listitem>
          <listitem><para>Version</para></listitem>
          <listitem><para>Type (optional)</para></listitem>
          <listitem><para>Classifier (optional)</para></listitem>
        </itemizedlist>
        For more information see <xref linkend="util.features-mvnpom.ref"/>.
        The format used to specify identifiers is as follows:
        <programlisting>group-id ':' artifact-id [ ':' type [ ':' classifier ] ] ':' version</programlisting>
      </para>
    </section>

    <section>
      <title>Feature Identifier</title>
      <para>
        Each Feature has a unique identifier. Apart from providing a persistent handle to the Feature it also provides enough information to find the Feature in an artifact repository. This identifier is defined using the format described in 
        <xref linkend="util.feature-identifiers"/>.
As Features are immutable, a given Feature identifier always refers to the same Feature.

    <remark>Mention the Maven artifact packaging type: osgifeature</remark>
      </para>
    </section>
    
    <section>
      <title>Attributes</title>
      <para>
        A feature can have the following attributes:
      </para>

      <table rowheader="firstcol">
        <title>Feature Attributes</title>

        <tgroup cols="4">
          <thead>
            <row>
              <entry>Attribute</entry>
              <entry>Data Type</entry>
              <entry>Kind</entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>name</entry>
              <entry>String</entry>
              <entry>Mandatory</entry>
              <entry>The short descriptive name of the feature.</entry>
            </row>

            <row>
              <entry>description</entry>
              <entry>String</entry>
              <entry>Optional</entry>
              <entry>A longer description of the feature.</entry>
            </row>

            <row>
              <entry>isComplete</entry>
              <entry>boolean</entry>
              <entry>Optional, defaults to <code>false</code></entry>
              <entry>Completeness of the feature. A feature is complete when it has no external dependencies.</entry>
            </row>

            <row>
              <entry>isFinal</entry>
              <entry>boolean</entry>
              <entry>Optional, defaults to <code>false</code></entry>
              <entry>If the feature is final. A final feature cannot be used as a prototype for another feature.</entry>
            </row>

            <row>
              <entry>license</entry>
              <entry>String</entry>
              <entry>Optional</entry>
              <entry>The license of the feature.</entry>
            </row>

            <row>
              <entry>vendor</entry>
              <entry>String</entry>
              <entry>Optional</entry>
              <entry>The vendor of the feature.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section>
    <title>Comments</title>
      <para>Comments in the form of <xref
      linkend="util.features-jsmin.ref"/> comments are supported, that
      is, any text on the same line after <code>//</code> is ignored and any
      text between <code>/* */</code> is ignored.</para>
  </section>
  
  <section>
    <title>Bundles</title>
    <para>
      Features often list a number of bundles that implement the functionality provided by the Feature. Bundles are listed by 
      referencing them in the <code>bundles</code> array so that they can be resolved from a repository. Bundles can have 
      metadata associated with them, such 
      as the relative start order of the bundle in the Feature. 
      Custom metadata can also be provided. A single Feature can 
      provide multiple versions of the same bundle, if desired.
    </para>
    <para>
      Bundles are referenced using the identifier format described in 
      <xref linkend="util.feature-identifiers"/>.
      This means that Bundles are referenced using their Maven coordinates. The <code>bundles</code> array can either contain
      <code>String</code> values referencing the bundles directly by their identifier, or JSON objects which can contain the bundle
      IDs with additional metadata. 
    </para>
    <para>
      The following example shows a simple feature model describing a small application with its dependencies:
      <programlisting>{
  "id": "org.acme:acmeapp:1.0.0",
    
  "name": "The Acme Application",
  "license": "https://opensource.org/licenses/Apache-2.0",
  "isComplete": true,

  "bundles": [
    "org.osgi:org.osgi.util.function:1.1.0",
    "org.osgi:org.osgi.util.promise:1.1.1",
    {
      "id": "org.apache.commons:commons-email:1.5",

      // This attribute is used by custom tooling to 
      // find the associated javadoc
      "org.acme.javadoc.link": 
        "https://commons.apache.org/proper/commons-email/javadocs/api-1.5"
    },
    "com.acme:acmelib:1.7.2"      
  ]
   
  /* 
    Additional feature model entities here 
    ...
  */
}</programlisting>
    </para>
    
    <section>
      <title>Bundle Metadata</title>
      
      <para>
        Arbitrary key-value pairs can be associated with bundle entries to store
        custom metadata alongside the bundle references.
        Reverse DNS naming should be used with the keys to avoid name clashes when
        metadata is provided by multiple entities. 
      </para>
      
      <para>
        Bundle metadata supports String keys and String values.
      </para>
    </section>
  </section>

  <section>
    <title>Configurations</title>
    <para>
      Features support configuration using the OSGi Configurator syntax, see 
      <xref linkend="service.configurator"/>. This can be specified with the 
      <code>configurations</code> key in the feature. A Launcher can apply 
      these configurations to the Configuration Admin service when starting 
      the system.
    </para>

    <para>
      It is an error to define the same PID (or Factory PID) twice in a single feature model.
    </para>
    
    <para>
      Example:
      <programlisting>{
    "id": "org.acme:acmeapp:osgifeature:configs:1.0.0",
    "configurations": {
        "org.apache.felix.http": {
            "org.osgi.service.http.port": 8080,
            "org.osgi.service.http.port.secure": 8443
        }
    }    
}</programlisting>
    </para>
  </section>

  <section>
    <title>Framework Properties</title>
    <para>
      When a Feature is launched in an OSGi framework it may be necessary to specify Framework properties. These can be provided in the Framework Properties section of the Feature Model.
      If a launcher is not able to set the Framework properties it may fail.
    </para>
    <remark>TODO to specify failure behavior in all sections.</remark>

    <para>
      Example:
      <programlisting>{
  "id": "org.acme:acmeapp:osgifeature:fw-props:2.0.0",
  "framework-properties": {
    "org.osgi.framework.system.packages.extra": 
      "javax.activation;version=\"1.1.1\"",
    "org.osgi.framework.bootdelegation": "javax.activation"
  }
}</programlisting>
  </para>
  </section>

  <section>
    <title>Variables</title>
    <para>
      Configurations and Framework Properties support late binding of values. This enables setting these items through a Launcher, 
      for example to specify a database user name, server port number or other information that may be variable between runtimes.
    </para>
    
    <para>
      Variables are declared in the <code>variables</code> section of the feature and they can have a default value specified.
      The default can be of type <code>String</code>, <code>number</code> or <code>boolean</code>. Variables can also be declared
      to <emphasis>not</emphasis> have a default, which means that they must be provided with a value through the Launcher. 
      This is done by specifying <code>null</code> as the default in the variable declaration.
    </para>
    
    <para>
      Example:
      <programlisting>{
    "id": "org.acme:acmeapp:osgifeature:configs:1.1.0",
    "variables": {
        "http.port": 8080,
        "db.username": "scott",
        "db.password": null
    },
    "configurations": {
        "org.acme.server.http": {
            "org.osgi.service.http.port:Integer": "${http.port}"
        },
        "org.acme.db": {
            "username": "${db.username}",
            "password": "${db.password}"
        }
    }    
}</programlisting>
      Variables are referenced with the curly brace placeholder syntax: <code>${</code> <emphasis><code>variable-name</code></emphasis> <code>}</code>
      in the configuration value or framework property value section.  
      To support conversion of variables to non-string types the configurator syntax
      specifying the datatype with the configuration key can be used, as in the above example.
    </para>
  </section>
 
  <section>
    <title>Capabilities &amp; Requirements</title>
    <para>
      Features inherit all capabilities and requirements from their bundles. Additional capabilities and requirements can be added 
      to the feature directly.
    </para>
    
    <para>
      Additional capabilities can be used when resolving a number of features together, to provide a capability that is needed
      in one of these.
    </para>
    
    <para>
      Additional requirements can mean that a feature is only complete, when these requirements are also satisfied, in addition 
      to the requirements provided in the bundles that are part of the feature.
    </para>
    
    <para>
      Example:
      <programlisting>{
  "id": "org.acme:acmeapp:osgifeature:capreq:1.0.0",
  
  // Requirements over and above the requirements in the bundles 
  // referenced by the feature.
  "requirements": [
    {
      "namespace": "osgi.contract",
      "directives": {
        "filter": "(&amp;(osgi.contract=JavaServlet)(version=3.1))"
      }
    }
  ],

  // Capabilities over and above the capabilities provided by the 
  // bundles referenced by the feature.
  "capabilities": [
    {
      "namespace": "osgi.service",
      "attributes": {
        "objectClass:List&lt;String&gt;": 
          "org.osgi.service.http.runtime.HttpServiceRuntime"
      }
    }
  ]
}</programlisting>      
    </para>
  </section>

  <section>
    <title>Prototype</title>
    <para>
      If a Feature is similar to another Feature but not exactly the same, it can use the other Feature as its prototype. Entities can be 
      removed from the prototype and additional entities can be added in the resulting Feature. Prototypes can be used to create variants 
      of existing Features. The newly created Features must have a different ID than the prototype theyâ€™re based on. 
    </para>
    
    <para>
      If a Feature has a prototype, the prototype Feature is declared by ID in the <code>prototype</code> section along with any 
      potential removals. This means that the listed entities will not be in the new feature that uses the prototype as its base. 
      Listed removals have no effect on the feature that serves as the prototype itself.
    </para>
    
    <para>
      The following entities can be declared in the <code>removals</code> section:
      
      <itemizedlist>
        <listitem>
          <para>
            <code>bundles</code> - an array of bundle IDs that will not be included from the prototype Feature. 
          </para>
        </listitem>

        <listitem>
          <para>
            <code>configurations</code> - an array of configuration PIDs that will not be included from the prototype.
          </para>
        </listitem>

        <listitem>
          <para>
            <code>framework-properties</code> - an arrays of Framework Property names that will not be included from the prototype. 
          </para>
        </listitem>
      </itemizedlist>
    </para>
    
    
    <remark>TODO we need to capture more detail on the behaviour here.</remark>
    
    <para>
      Example:
      <programlisting>{
  "id": "org.acme:acmeapptwo:1.0.0",
  "prototype": {
    "id": "org.acme:acmeapp:1.1.0",
    "removals": {
      "bundles": [
        // We don't need the email bundle
        "org.apache.commons:commons-email"        
      ],
      "configurations": [
        // Don't set this configuration PID
        "org.acme.EmailConfig"
      ]
    }
  },
  "bundles": [
    "org.acme:apptwobundle:1.0.0"
  ]
}</programlisting>
    </para>
  </section>
    
  <section>
    <title>Extensions</title>
    <para>
      Features can be extended with custom content. This makes it possible to keep entities and information relating to the feature
    together with the rest of the feature.</para>
    
    <para>
      Custom content is provided through feature extensions, and can be in one of the following formats:
    </para>
     
    <itemizedlist>
      <listitem>
        <para><emphasis>Text</emphasis> - A text extension contains a block of text.</para>
      </listitem>

      <listitem>
        <para><emphasis>JSON</emphasis> - A JSON extension contains embedded custom JSON content.</para>
      </listitem>

      <listitem>
        <para><emphasis>Artifacts</emphasis> - A list of custom artifacts associated with the feature.</para>
      </listitem>
    </itemizedlist>
    
    <para>
      Extensions can have a variety of consumers. For example they can be handled by a Feature Launcher
      or by an external tool which can process the extension at any point of the feature
      life cycle.
    </para>
    
    <para>
      Extensions can be marked as one of the following three kinds:
    </para>
    
    <itemizedlist>
      <listitem>
        <para><emphasis>Mandatory</emphasis> - The entity processing this feature 
        <emphasis>must</emphasis> know how to handle this extension.</para>
      </listitem>

      <listitem>
        <para><emphasis>Optional</emphasis> - This extension is optional. If the entity
        processing the feature cannot handle it, the extension can be skipped or ignored.
        This is the default.</para>
      </listitem>

      <listitem>
        <para><emphasis>Transient</emphasis> - This extension contains transient information
        which can be used to optimize the processing of the feature. It is not part of the 
        feature definition.</para>
      </listitem>
    </itemizedlist>
    
    <para>
      Extensions are specified as JSON objects under the <code>extensions</code> key in the feature. A feature can
      contain any number of extensions, as long as the extension keys are unique. It is recommended to use reverse
      DNS naming for extension keys to avoid name clashing of multiple extensions in a single feature. 
      Extensions names without DNS prefix are reserved for OSGi use.
    </para>
    
    <section>
      <title>Text Extensions</title>
      
      <para>
        Text extensions allow the addition of custom text content to the feature model. 
        The text is provided as JSON string values or as a JSON array of strings.
        If an array is used, the actual text value is the concatenation of the strings in the array.
        <remark>No linefeeds or spaces are inserted</remark>
      </para>
      
      <para>
        Example:
        
        <programlisting>{
    "id": "org.acme:acmeapp:2.0.0",
    
    "name": "The Acme Application",
    "license": "https://opensource.org/licenses/Apache-2.0",
    "isComplete": true,

    "bundles": [
        "org.osgi:org.osgi.util.function:1.1.0",
        "org.osgi:org.osgi.util.promise:1.1.1",
        "com.acme:acmelib:2.0.0"      
    ],
    
    "extensions": {
        "org.acme.mydoc": {
            "type": "text",
            "text": [
                "This application provides the main acme ",
                "functionality."
            ]
        }
    }
}</programlisting>
        
      </para>
    </section>
    
    <section>
      <title>JSON Extensions</title>
      
      <para>
        Custom JSON content can be added to features by using a JSON extension. The content can either be a
        JSON object or a JSON array.
      </para>

      <para>
        The following example extension declares under which execution environment the feature is complete,
        using a custom JSON object.       
        <programlisting>{
    "id": "org.acme:acmeapp:2.1.0",
    
    "name": "The Acme Application",
    "license": "https://opensource.org/licenses/Apache-2.0",
    "isComplete": true,

    "bundles": [
        "org.osgi:org.osgi.util.function:1.1.0",
        "org.osgi:org.osgi.util.promise:1.1.1",
        "com.acme:acmelib:2.0.0"      
    ],
    
    "extensions": {
        "execution-environment": {
            "type": "json",
            "json": {
                "environment-capabilities":
                    ["osgi.ee; filter:=\"(&amp;(osgi.ee=JavaSE)(version=11))\""], 
                "framework": "org.osgi:core:6.0.0",
                "provided-features": ["org.acme:platform:1.1"]
            }
        }
    }
}</programlisting>
      </para>
    </section>
      
    <section>
      <title>Artifact list Extension</title>
      
      <para>
        Custom extensions can also be used to associate artifacts that are not listed 
        as <code>bundles</code> with the feature.
      </para>
      
      <para>  
        For example, database definition resources can be listed as artifacts in a feature. In
        the following example, the extension <code>org.acme.ddlfiles</code> lists 
        Database Definition Resources which <emphasis>must</emphasis> be handled by 
        the launcher agent, that is, the database must be configured when the application is run:

        <programlisting>{
    "id": "org.acme:acmeapp:2.2.0",
    
    "name": "The Acme Application",
    "license": "https://opensource.org/licenses/Apache-2.0",
    "isComplete": true,

    "bundles": [
        "org.osgi:org.osgi.util.function:1.1.0",
        "org.osgi:org.osgi.util.promise:1.1.1",
        "com.acme:acmelib:2.0.0"      
    ],
    
    "extensions": {
        "org.acme.ddlfiles": {
            "kind": "mandatory",
            "type": "artifacts",
            "artifacts": ["org.acme:appddl:1.2.1"]
        }
    }
}</programlisting>
<remark>Do we want to support metadata for artifacts?</remark>
      </para>
        
    </section>
  </section>
  
  <section>
    <title>Security</title>

    <para>
    ...</para>
  </section>

  <section>
    <title>JSON Schema</title>

    <para>
    ...</para>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.util.feature.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="util.features-json.ref"><title>JSON
      (JavaScript Object Notation) </title><biblioid class="uri"><link
      xlink:href="https://www.json.org"/></biblioid></bibliomixed>

      <bibliomixed xml:id="util.features-jsmin.ref"><title>JSMin (The
      JavaScript Minifier) </title><biblioid class="uri"><link
      xlink:href="https://www.crockford.com/javascript/jsmin.html"/></biblioid></bibliomixed>
      
      <bibliomixed xml:id="util.features-mvnpom.ref"><title>Apache Maven Pom 
      Reference </title><biblioid class="uri"><link
      xlink:href="https://maven.apache.org/pom.html"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
