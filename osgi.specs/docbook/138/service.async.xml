<?xml version="1.0" encoding="utf-8"?>
<chapter label="138" revision="$Id:" version="5" xml:id="service.async"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Asynchronous Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.async-version"
    linkend="org.osgi.service.async"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>OSGi Bundles collaborate using loosely coupled services registered
    in the OSGi service registry. This is a powerful and flexible model, and
    allows for the dynamic replacement of services at runtime. OSGi services
    are therefore a very common interaction pattern within OSGi.</para>

    <para>As with most Java APIs and Objects, OSGi services are primarily
    synchronous in operation. This has several benefits; synchronous APIs are
    typically easier to write and to use than asynchronous ones; synchronous
    APIs provide immediate feedback; synchronous implementations typically
    have a less complex threading model.</para>

    <para>Asynchronous APIs, however, have different advantages. Asynchronous
    APIs can reduce bottlenecks by encouraging more effective use of
    parallelism, improving the responsiveness of the application. In many
    cases high throughput systems can be written more simply and elegantly
    using asynchronous programming techniques.</para>

    <para>The <xref linkend="util.promise"/> provides powerful primitives for
    asynchronous programming, including the ability to compose flows in a
    functional style. There are, however, many existing services that do not
    use the Promise API. The purpose of the Asynchronous Service is to bridge
    the gap between these existing, primarily synchronous, services in the
    OSGi service registry, and asynchronous programming. The Asynchronous
    Service therefore provides a way to invoke arbitrary OSGi services
    asynchronously, providing results and failure notifications through the
    Promise API.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Async Invocation</emphasis> - A single method call
          that is to be executed without blocking the requesting
          thread.</para>
        </listitem>

        <listitem>
          <para><emphasis>Client</emphasis> - Application code that wishes to
          invoke one or more OSGi services asynchronously.</para>
        </listitem>

        <listitem>
          <para><emphasis>Async Service</emphasis> - The OSGi service
          representing the Asynchronous Services implementation. Used by the
          client to make one or more <emphasis>Async
          Invocations</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Async Mediator</emphasis> - A mediator object
          created by the <emphasis>Async Service</emphasis> which represents
          the target service. Used by the <emphasis>Client</emphasis> to
          register async invocations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Success Callback</emphasis> - A callback made when
          an async invocation exits with a normal return value.</para>
        </listitem>

        <listitem>
          <para><emphasis>Failure Callback</emphasis> - A callback made when
          an async invocation exits by throwing an exception.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Async Service</emphasis> - A service that can create
          Async Mediators and run Async Invocations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Target Service</emphasis> - A service that is to be
          called asynchronously by the client.</para>
        </listitem>

        <listitem>
          <para><emphasis>Client</emphasis> - The code that makes async
          invocations using the Async Service</para>
        </listitem>

        <listitem>
          <para><emphasis>Promise</emphasis> - A promise, representing the
          result of the Async Invocation.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Class and Service overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.100in"
                       contentwidth="7.000in" fileref="async-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Usage</title>

    <para>This section is an introduction in the usage of the Async service.
    It is not the formal specification, the normative part starts at <xref
    linkend="service.async-main.body"/>. This section leaves out some of the
    details for clarity.</para>

    <section>
      <title>Synopsis</title>

      <para>The Async service provides a mechanism for a client to
      <emphasis>asynchronously</emphasis> invoke methods on a target service.
      The service may be aware of the asynchronous nature of the call and
      actively participate in it, or be unaware and execute normally. In
      either case the client's thread will not block, and will continue
      executing its next instructions. Clients are notified of the completion
      of their task, and whether it was successful or not, through the use of
      the Promise API.</para>

      <para>Each async invocation is registered by the client making a method
      call on an <emphasis>Async Mediator</emphasis>, and then started by
      making a call to the Async service that created the mediator. This call
      returns a Promise that will eventually be resolved with the return value
      from the async invocation.</para>

      <para>An Async Mediator can be created by the client, either from an
      Object, or directly from a Service Reference. Using a service reference
      has the advantage that the mediator will track the underlying service.
      This means that if the service is unregistered before the asynchronous
      call begins then the Promise will resolve with a failure, rather than
      continuing using an invalid service object.</para>
    </section>

    <section>
      <title>Making Async Invocations</title>

      <para>The general pattern for a client is to obtain the Async service,
      and a service reference for the target service. The client then creates
      an Async Mediator for the target service, invokes a method on the
      mediator, then starts the asynchronous call. This is demonstrated in the
      following example:</para>

      <programlisting>
      
private Async asyncService;
private ServiceReference&lt;Foo&gt; fooRef;
private Foo mediated;

@Reference
void setAsync(Async async) {
    asyncService = async;
}

@Reference(service = Foo.class)
void setList(ServiceReference&lt;Foo&gt; foo) {
    fooRef = foo;
}

@Activate
void start() {
    mediated = asyncService.mediate(fooRef, Foo.class);
}

public synchronized void doStuff() {
    Promise&lt;Boolean&gt; promise = asyncService
           .call(mediated.booleanMethod(“aValue”));
    ...
}

      </programlisting>

      <para>This example demonstrates how simply clients can make asynchronous
      calls using the Async service. The eventual result can be obtained from
      the promise using one of the relevant callbacks.</para>

      <para>One important thing to note is that whilst the call to
      <code>asyncService.call(...)</code> causes the async invocation to
      begin, the actual execution of the underlying task may be queued until a
      thread is available to run it. If the service has been unregistered
      before the execution actually begins then the promise will be resolved
      with a Service Exception. The type of the service exception will be
      <code>ASYNC_ERROR</code>.</para>
    </section>

    <section>
      <title>Async invocations of void methods</title>

      <para>The return value of the mediator method call is used to provide
      type information to the Async service. This, however, does not work for
      <code>void</code> methods that have no return value. In this case the
      client can either pass an arbitrary object to the <code>call</code>
      method, or use the zero argument version of the <code>call</code>
      method. In either case the returned promise will eventually resolve with
      a value of <code>null</code>. This is demonstrated in below.</para>

      <programlisting>
private Async asyncService;
private ServiceReference&lt;Foo&gt; fooRef;
private Foo mediated;

@Reference
void setAsync(Async async) {
    asyncService = async;
}

@Reference(service = Foo.class)
void setList(ServiceReference&lt;Foo&gt; foo) {
    fooRef = foo;
}

@Activate
void start() {
    mediated = asyncService.mediate(fooRef, Foo.class);
}

public synchronized void doStuff() {
    mediated.voidMethod();
    Promise&lt;Void&gt; promise = asyncService
           .call();
    ...
}</programlisting>
    </section>

    <section>
      <title>Fire and Forget calls</title>

      <para>Sometimes a client does not require any notification that an async
      invocation has completed. In this case the client could use one of the
      <code>call()</code> methods and simply discard the returned Promise
      object. This, however, can be wasteful of resources. The act of
      resolving the Promise object may be expensive, for example it may
      involve serializing the return value over a network if the remote call
      was asynchronous.</para>

      <para>If the client knows that no Promise object representing the result
      of the asynchronous task is needed then it can signal this to the Async
      service. This allows the Async service to better optimise the async
      invocation by not providing a result.</para>

      <para>To indicate that the client wants to make a fire-and-forget style
      call the client invokes the mediator as normal, but then begins the
      asynchronous invocation using the <code>execute()</code> method as show
      below.</para>

      <programlisting>
private Async asyncService;
private ServiceReference&lt;Foo&gt; fooRef;

private Foo mediated;

@Reference
void setAsync(Async async) {
    asyncService = async;
}

@Reference(service = Foo.class)
void setList(ServiceReference&lt;Foo&gt; foo) {
    fooRef = foo;
}

@Activate
void start() {
    mediated = asyncService.mediate(fooRef, Foo.class);
}

public synchronized void doStuff() {
    mediated.someMethod();
    asyncService.execute();
    ...
}</programlisting>

      <para>Note that the <code>execute()</code> method does still return a
      <code>Promise</code>. This Promise is not the same as the ones returned
      by <code>call()</code>, its resolution value does not provide access to
      the result, but instead indicates whether the fire-and forget call could
      be successfully started. If there is a failure which prevents the task
      from being executed then this is used to fail the returned
      promise.</para>
    </section>

    <section>
      <title>Multi Threading</title>

      <para>By their very definition asychronous tasks do not run inline, and
      typically they will not run on the same thread as the caller. This is
      not, however, a guarantee. A valid implementation of the Async service
      may have only one worker thread, which may be the thread currently
      running in the client code. Async invocations also have the same
      threading model as the Promise API. This means that callbacks may run on
      arbitrary threads, which may, or may not, be the same as the client
      thread, or the thread which executed the asynchronous work.</para>

      <para>It is important for multi-threaded clients to note that calls to
      the mediator and async service must occur on the same thread. For
      example it is not supported to invoke a mediator using one thread, and
      then to begin the async invocation by calling one of the
      <code>Async.call(...)</code> methods on a different thread.</para>
    </section>
  </section>

  <section xml:id="service.async-main.body">
    <title>Async Service</title>

    <para>The Async service is the primary interaction point between a client
    and the Async service implementation. An Async service implementation must
    expose a service implementing the
    <code>org.osgi.service.async.Async</code> interface. Clients obtain an
    instance of the Async service using the normal OSGi service registry
    mechanisms, either directly using the OSGi framework API, or using
    dependency injection.</para>

    <para>The Async service is used to:</para>

    <itemizedlist>
      <listitem>
        <para>Create async mediators</para>
      </listitem>

      <listitem>
        <para>Begin async invocations</para>
      </listitem>

      <listitem>
        <para>Obtain Promise objects representing the result of the async
        invocation</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Using the Async service</title>

      <para>The first action that a client wishing to make an async invocation
      must take is to create an async mediator using one of the
      <code>mediate</code> methods. Once created the client invokes the method
      that should be run asynchronously, supplying the arguments that should
      be used. This call records the invocation, but does not start the
      asynchronous task. The asynchronous task begins when the client invokes
      one of the <code>call</code> or <code>execute</code> methods on the
      Async service. The <code>call</code> methods must return a Promise
      representing the async invocation. The promise must resolve with the
      value returned by the async invocation, or fail with the failure thrown
      by the async invocation.</para>

      <para>If the client attempts to begin an async invocation without first
      having called a method on the mediator object then the Async service
      must detect this usage error and throw an
      <code>IllegalStateException</code> to the client. This applies to all
      methods that begin an async invocation.</para>
    </section>

    <section xml:id="service.async-main.failures">
      <title>Asynchronous failures</title>

      <para>There are a variety of reasons that async invocations may be
      started correctly by the client, but then fail without running the
      asynchronous task. In any of these cases the Promise representing the
      async invocation must fail with a Service Exception. This service
      exception must be initialised with a type of <code>ASYNC_ERROR</code>.
      If there is no promise representing the async invocation then there is
      no way to notify the client of the failure, therefore the service
      exception must be logged by the Async service using all available Log
      Service implementations.</para>

      <para>The following list of scenarios is not exhaustive, but indicates
      failure scenarios that must result in a service exception with a type of
      async</para>

      <itemizedlist>
        <listitem>
          <para>If the client is using a service reference backed mediator and
          the client bundle's bundle context becomes invalid before looking up
          the target service.</para>
        </listitem>

        <listitem>
          <para>If the client is using a service reference backed mediator and
          the service is unregistered before making the async
          invocation.</para>
        </listitem>

        <listitem>
          <para>If the client is using a service reference backed mediator and
          the service lookup returns <code>null</code></para>
        </listitem>

        <listitem>
          <para>If the Async service is unable to accept new work, for example
          it is in the process of being shut down.</para>
        </listitem>

        <listitem>
          <para>If the type of the mediator object does not match the type of
          the service object to be invoked.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Thread safety and instance sharing</title>

      <para>Implementations of the Async service must be thread safe and may
      be used simultaneously across multiple clients and from multiple threads
      within the same client. Whilst the async service is able to be used
      across multiple threads, if a client wishes to make an async invocation
      then the call to the mediator and the call to begin the async invocation
      must occur on the same thread. The returned Promise may then be shared
      between threads if required.</para>

      <para>It is expected, although not required, that the Async service
      implementation will use a Service Factory to create customized
      implementations for each client bundle. This simplifies the tracking of
      the relevant client bundle context to use when performing service
      lookups on the client bundle's behalf. Clients should therefore not
      share instances of the Async service with other bundles. Instead both
      bundles should obtain their own instances from the service
      registry.</para>
    </section>

    <section>
      <title>Service Object Lifecycle management</title>

      <para>If the Async Service is being used to call an OSGi service object
      and the service reference is available then the service object should be
      looked up immediately before the asynchronous task begins executing.
      This ensures that the service is still available at the point it is
      eventually called. Any call to <code>getService()</code> must have a
      corresponding call to <code>ungetService()</code> after the mediated
      method invoked has returned and, if available, the promise is resolved,
      but before the asynchronous task releases its thread of
      execution.</para>
    </section>
  </section>

  <section>
    <title>The Async Mediator</title>

    <para>Async mediators are dynamically created objects that have the same
    type or interface as the object being mediated, and are used to record
    method invocations and arguments. Mediator objects are specific to an
    Async service implementation, and must only be used in conjunction with
    the async service object that they were created by.</para>

    <para>Mediators may be created either from a <code>ServiceReference</code>
    or from a service object. The actions and overall result are similar for
    both <code>mediate(...)</code> methods, with the primary difference being
    that mediated objects created from a <code>ServiceReference</code> will
    validate whether the service object is still available immdiately before
    the asynchronous task is executed.</para>

    <section>
      <title>Building the mediator object</title>

      <para>The client passes in a <code>Class</code> indicating the type that
      should be mediated. If the class object represents an interface type
      then the generated mediator object must implement that interface. If the
      class object represents a Java class type then the mediator object must
      either be an instance of that type or extend it.</para>

      <para>When building a mediator object the Async service has the
      opportunity to detect numerous problems, for example if the service
      reference to be mediated has been unregistered. Although fail-fast
      behaviour is usually preferable, in this case it would force the client
      to handle errors in two places; both when creating the mediator, and for
      the returned Promise. To simplify client usage, error cases detected
      when creating a mediator must not prevent the mediator from being
      created and must not result in an exception being thrown. The only
      reason that the Async service may fail to create a mediator is if the
      class object passed in cannot be mediated.</para>

      <para>There are three reasons why the Async service may not be able to
      mediate a class type:</para>

      <itemizedlist>
        <listitem>
          <para>The class object passed in represents a final type</para>
        </listitem>

        <listitem>
          <para>The class object passed in represents a type that has no
          zero-argument constructor</para>
        </listitem>

        <listitem>
          <para>The class object passed in represents a type which has one or
          more public final methods present in its type hierarchy (other than
          those declared by java.lang.Object)</para>
        </listitem>
      </itemizedlist>

      <para>If any of these constraints are violated and prevent the Async
      service from creating a mediator then the Async service must throw an
      <code>IllegalArgumentException</code>.</para>
    </section>

    <section>
      <title>Async mediator behaviours</title>

      <para>When invoked the Async mediator must record the method call, and
      its arguments, and then return rapidly (i.e. it should not perform
      blocking operations). The values returned by the mediator object are
      opaque, and the client should not attempt to interpret the returned
      value. The value may be null (or null-like in the case of primitives) or
      contain implementation specific information. If the mediated method call
      has a return type, specifically it is non-void, then this object must be
      passed to the the async service's <code>call</code> method when
      beginning the async invocation</para>

      <para>Async mediators should make a best-effort attempt to detect
      incorrect API usage from the client. If this incorrect usage is detected
      then the mediator object must throw an IllegalStateException when
      invoked. An example of incorrect usage that must be detected is when a
      client makes multiple invocations on a single mediator object from the
      same thread without making any calls to the Async service.</para>

      <para>After a usage error has been detected and an IllegalStateException
      has been thrown the mediator object must be reset so that a subsequent
      invocation from the client thread can proceed normally.</para>
    </section>

    <section>
      <title>Thread safety and instance sharing</title>

      <para>Async mediators, like instances of the Async service, are required
      to be thread safe. Clients may therefore share mediator objects accross
      threads, and can safely store them as instance fields. Whilst mediators
      are thread safe, if a client wishes to make an async invocation then the
      call to the mediator and the call to <code>async.call(...)</code> must
      occur on the same thread. The returned Promise may then be shared
      between threads if required.</para>

      <para>Async mediators created from <code>ServiceReference</code> objects
      remain directly associated with the service reference and client bundle
      after creation. Clients should therefore not share mediator objects with
      other bundles. Instead both bundles should create their own
      mediators.</para>
    </section>
  </section>

  <section>
    <title>Fire and Forget invocations</title>

    <para>The Async service provides <code>call()</code> methods for clients
    to use when they wish to receive results from asynchronous tasks. Clients
    that do not need the result can simply discard the returned Promise
    object. This, however, can be wasteful of resources. The act of resolving
    the Promise object may be expensive, for example it may involve
    serializing the return value over a network.</para>

    <para>To address this use case the Async service must provide the
    <code>execute()</code> method, which behaves similarly to
    <code>call()</code>, but does not provide access to the eventual result.
    Instead the <code>execute()</code> method returns a <code>Promise</code>
    that indicates whether the fire-and forget call is able to be be
    successfully started.</para>

    <para>The returned Promise must be resolved with <code>null</code> if the
    asynchronous task begins executing successfully. There is no
    happens-before relationship required, meaning that if the Promise resolves
    successfully then the task may, or may not, have started or finished. The
    primary usage of the Promise is actually to detect failures. If the fire
    and forget task cannot be executed for some reason, for example the
    backing service has been unregistered, then the returned promise must be
    failed appropriately using the same rules as defined in <xref
    linkend="service.async-main.failures"/>. If the returned Promise is failed
    then the fire-and-forget task has not executed and will not execute in the
    future.</para>
  </section>

  <section>
    <title>Delegating to asynchronous implementations</title>

    <para>Some service APIs are already asynchronous in operation, and others
    are partly asynchronous, in that some methods run asynchronously and
    others do not. There are also services which have a synchronous API, but
    could run asynchronously because they are a proxy to another service. A
    good example of this kind of service is a remote service. Remote services
    are local views of a remote endpoint, and depending upon the
    implementation of the endpoint it may be possible to make the remote call
    asynchronously, optimizing the thread usage of any local asynchronous
    call.</para>

    <para>Services that already have some level of asynchronous support may
    advertise this to clients and to the Async service by implementing
    <code>org.osgi.service.async.delegate.AsyncDelegate</code>. This interface
    can be used by the Async service implementation, or by the client
    directly, to make an asynchronous call on the service.</para>

    <para>Because the Async Delegate behaviour is transparently handled by the
    async service, clients of the async service do not need to know whether
    the target service implements Async Delegate or not, their usage pattern
    can remain unchanged.</para>

    <para>When making an async invocation the async service must check to see
    whether the target service implements Async Delegate. If the target
    service does implement AsyncDelegate then the async service must attempt
    to delegate the asynchronous call. The exact delegation pattern depends on
    whether a Promise is required.</para>

    <section>
      <title>Obtaining a Promise from an Async Delegate</title>

      <para>If a promise is needed by the client then the async service must
      attempt to delegate to the <code>async</code> method. The delegation
      proceeds as follows:</para>

      <itemizedlist>
        <listitem>
          <para>If the call to the Async Delegate returns a Promise, then the
          Promise returned by the async service must be resolved with that
          Promise.</para>
        </listitem>

        <listitem>
          <para>If the call to the Async Delegate throws an exception then
          this must be used to fail the promise returned by the Async
          service.</para>
        </listitem>

        <listitem>
          <para>If the Async Delegate is unable to optimise the call then it
          may return a <code>null</code> Promise from the <code>async</code>
          method. In this case the Async service must continue processing the
          async invocation, treating the service as a normal object.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Delegating fire and forget calls to an Async Delegate</title>

      <para>If no promise is needed by the client then the async service must
      attempt to delegate to the <code>execute</code> method. This gives the
      Async Delegate implementation the opportunity to further optimise its
      processing. The delegation proceeds as follows:</para>

      <itemizedlist>
        <listitem>
          <para>If the call to the Async Delegate returns <code>true</code>
          then the async service should return a successfully resolved Promise
          to the client.</para>
        </listitem>

        <listitem>
          <para>If the call to the Async Delegate throws an exception then
          this must be logged to any available Log Services, and must be used
          to fail the Promise returned to the client.</para>
        </listitem>

        <listitem>
          <para>If the Async Delegate is unable to optimise the call then it
          may return <code>false</code> from the <code>execute</code> method.
          In this case the Async service must continue processing the async
          invocation, treating the service as a normal object.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Lifecycle for Async Delegate Services</title>

      <para>If an Async Delegate service implementation accepts an
      asynchronous task, either via a call to <code>execute()</code> or
      <code>async()</code>, then it is responsible for continuing to process
      the work until completion. This means that if the service is
      unregistered for some reason then the task must be properly cleaned up
      and succeed or fail as appropriate.</para>

      <para>If the Async services implementation used a service reference to
      obtain the Async Delegate service object then it must release the
      service object after the task has been accepted. This means that if the
      Async Delegate service object is provided by a service factory then the
      service object should take extra care not to destroy its internal state
      when released. The service object must remain valid until all executing
      asynchronous tasks are either completed or failed.</para>

      <para>In the case where an AsyncDelegate service rejects an asynchronous
      task with a return of <code>false</code> or <code>null</code>, the Async
      service implementation will take over the execution of the task. In this
      case the Async service should not release the service object until the
      asynchronous task is completed. If the asynchronous task is rejected
      with an Exception then the service must be released immediately.</para>
    </section>
  </section>

  <section xml:id="service.async-security">
    <title>Security</title>

    <para>Asynchronous Services implementations must be careful to avoid
    elevating the privileges of client bundles when calling services
    asynchronously, and also to avoid restricting the privileges of clients
    that are permitted to make a call. This means that the implementation
    must:</para>

    <itemizedlist>
      <listitem>
        <para>Be granted <code>AllPermission</code>. As the Async service will
        always be on the stack when invoking a service object asynchronously
        it must be granted <code>AllPermission</code> so that it does not
        interfere with security any checks made by the service object.</para>
      </listitem>

      <listitem>
        <para>Establish the caller's <code>AccessControlContext</code> in a
        worker thread before starting to call the service object. This
        prevents a bundle from being able to call a service asynchronously
        that it would not normally be able to call. The
        <code>AccessControlContext</code> must be collected during any call to
        <code>call()</code> or <code>execute()</code></para>
      </listitem>

      <listitem>
        <para>Use a <code>doPrivileged</code> block when mediating a concrete
        type. A no-args constructor in a concrete type may perform actions
        that the client may not have permission to perform. This should not
        prevent the client from mediating the object, as the client is not
        directly performing these actions.</para>
      </listitem>

      <listitem>
        <para>If the mediator object was created using a service reference,
        then the Async services implementation must use the client's bundle
        context when retrieving the target service. If the service lookup
        occurs on a worker thread then the lookup must use the
        <code>AccessControlContext</code>. collected during the call to
        <code>call()</code> or <code>execute()</code>. This prevents the
        client bundle from being able to make calls on a service object that
        they do not have permission to obtain, and ensures that an
        appropriately customised object is returned if the service is
        implemented using a service factory.</para>
      </listitem>
    </itemizedlist>

    <para>Further security considerations can be addressed using normal OSGi
    security rules. For example access to the Async service can be controlled
    using ServicePermission[Async, GET].</para>
  </section>

  <section xml:id="service.async-capabilities">
    <title>Capabilities</title>

    <para>Implementations of the Asynchronous Service specification must
    provide the following capabilities.</para>

    <itemizedlist>
      <listitem>
        <para>A capability in the <code>osgi.implementation</code> namespace
        declaring the implemented specification to be <code>osgi.async</code>.
        This capability must also declare a uses constraint for the
        <code>org.osgi.service.async</code> package. For example:</para>

        <programlisting>Provide-Capability: osgi.implementation;
    osgi.implementation="osgi.async";
    version:Version="1.0";
    uses:="org.osgi.service.async"</programlisting>

        <para>This capability must follow the rules defined for the <xref
        linkend="service.namespaces-osgi.implementation.namespace"/>.</para>
      </listitem>

      <listitem>
        <para>A capability in the <code>osgi.service</code> namespace
        representing the <xref linkend="org.osgi.service.async.Async"
        xrefstyle="hyperlink"/> service. This capability must also declare a
        uses constraint for the <code>org.osgi.service.async</code> package.
        For example:</para>

        <programlisting>Provide-Capability: osgi.service;
    objectClass:List&lt;String&gt;="org.osgi.service.async.Async";
    uses:="org.osgi.service.async"</programlisting>

        <para>This capability must follow the rules defined for the <xref
        linkend="service.namespaces-osgi.service.namespace"/>.</para>
      </listitem>
    </itemizedlist>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.async.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.async.delegate.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>http://www.osgi.org/Specifications/HomePage</bibliomixed>
    </bibliolist>
  </section>
</chapter>
