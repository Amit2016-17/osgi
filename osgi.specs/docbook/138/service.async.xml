<?xml version="1.0" encoding="utf-8"?>
<chapter label="138" revision="$Id:" version="5" xml:id="service.async"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Asynchronous Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.async-version"
    linkend="org.osgi.service.async"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>OSGi Bundles collaborate using loosely coupled services registered
    in the OSGi service registry. This is a powerful and flexible model, and
    allows for the dynamic replacement of services at runtime. OSGi services
    are therefore a very common interaction pattern within OSGi.</para>

    <para>As with most Java APIs and Objects, OSGi services are primarily
    synchronous in operation. This has several benefits; synchronous APIs are
    typically easier to write and to use than asynchronous ones; synchronous
    APIs provide immediate feedback; synchronous implementations typically
    have a less complex threading model.</para>

    <para>Asynchronous APIs, however, have different advantages. Asynchronous
    APIs can reduce bottlenecks by encouraging more effective use of
    parallelism, improving the responsiveness of the application. In many
    cases high throughput systems can be written more simply and elegantly
    using asynchronous programming techniques.</para>

    <para>The OSGi Promise API <remark>needs a ref</remark> provides powerful
    primitives for asynchronous programming, including the ability to compose
    flows in a functional style. There are, however, many existing services
    that do not use the Promise API. The purpose of the Asynchronous Service
    is to bridge the gap between these existing, primarily synchronous,
    services in the OSGi service registry, and asynchronous programming. The
    Asynchronous Service therefore provides a way to invoke arbitrary OSGi
    services asynchronously, providing results and failure notifications
    through the OSGi Promise API.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Async Invocation</emphasis> - A single method call
          that is to be executed without blocking the requesting
          thread.</para>
        </listitem>

        <listitem>
          <para><emphasis>Client</emphasis> - Application code that wishes to
          invoke one or more OSGi services asynchronously.</para>
        </listitem>

        <listitem>
          <para><emphasis>Async Service</emphasis> - The OSGi service
          representing the Asynchronous Services implementation. Used by the
          client to make one or more <emphasis>Async
          Invocations</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Async Mediator</emphasis> - A mediator object
          created by the <emphasis>Async Service</emphasis> which represents
          the target service. Used by the <emphasis>Client</emphasis> to
          register async invocations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Success Callback</emphasis> - A callback made when
          an async invocation exits with a normal return value.</para>
        </listitem>

        <listitem>
          <para><emphasis>Failure Callback</emphasis> - A callback made when
          an async invocation exits by throwing an exception.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Async Service</emphasis> - A service that can create
          Async Mediators and run Async Invocations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Target Service</emphasis> - A service that is to be
          called asynchronously by the client.</para>
        </listitem>

        <listitem>
          <para><emphasis>Client</emphasis> - The code that makes async
          invocations using the Async Service</para>
        </listitem>

        <listitem>
          <para><emphasis>Promise</emphasis> - An OSGi promise, representing
          the result of the Async Invocation.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Class and Service overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.100in"
                       contentwidth="7.000in" fileref="async-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Usage</title>

    <para>This section is an introduction in the usage of the Async service.
    It is not the formal specification, the normative part starts at <xref
    linkend="async_service_main_body"/>. This section leaves out some of the
    details for clarity.</para>

    <section>
      <title>Synopsis</title>

      <para>The Async service provides a mechanism for a client to
      <emphasis>asynchronously</emphasis> invoke methods on a target service.
      The service may be aware of the asynchronous nature of the call and
      actively participate in it, or be unaware and execute normally. In
      either case the client's thread will not block, and will continue
      executing its next instructions. Clients are notified of the completion
      of their task, and whether it was successful or not, through the use of
      the OSGi Promise API.</para>

      <para>Each async invocation is registered by the client making a method
      call on an <emphasis>Async Mediator</emphasis>, and then started by
      making a call to the Async service that created the mediator. This call
      returns a Promise that will eventually be resolved with the return value
      from the async invocation.</para>

      <para>An Async Mediator can be created by the client, either from an
      Object, or directly from a Service Reference. Using a service reference
      has the advantage that the mediator will track the underlying service.
      This means that if the service is unregistered before the asynchronous
      call begins then the Promise will resolve with a failure, rather than
      continuing using an invalid service object.</para>
    </section>

    <section>
      <title>Making Async Invocations</title>

      <para>The general pattern for a client is to obtain the Async service,
      and a service reference for the target service. The client then creates
      an Async Mediator for the target service, invokes a method on the
      mediator, then starts the asynchronous call. This is demonstrated in the
      following example:</para>

      <programlisting>
      
private Async asyncService;
private ServiceReference&lt;Foo&gt; fooRef;

@Reference
void setAsync(Async async) {
    asyncService = async;
}

@Reference(service = Foo.class)
void setList(ServiceReference&lt;Foo&gt; foo) {
    fooRef = foo;
}

public synchronized void doStuff() {
    Foo mediator = asyncService.mediate(fooRef);
    Promise&lt;Boolean&gt; promise = asyncService
           .call(mediator.booleanMethod(“aValue”));
    ...
}

      </programlisting>

      <para>This example demonstrates how simply clients can make asynchronous
      calls using the Async service. The eventual result can be obtained from
      the promise using one of the relevant callbacks.</para>

      <para>One important thing to note is that whilst the call to
      <code>asyncService.call(...)</code> causes the async invocation to
      begin, the actual execution of the underlying task may be queued until a
      thread is available to run it. If the service has been unregistered
      before the execution actually begins then the promise will be resolved
      with a <code>ServiceException</code>. The type of the service exception
      will be <code>ServiceException#ASYNC</code> <remark>needs a
      ref</remark></para>
    </section>

    <section>
      <title>Async invocations of void methods</title>

      <para>The return value of the mediator method call is used to provide
      type information to the Async service. This, however, does not work for
      <code>void</code> methods that have no return value. In this case the
      client can either pass an arbitrary object to the <code>call</code>
      method, or use the zero argument version of the <code>call</code>
      method. In either case the returned promise will eventually resolve with
      a value of <code>null</code>. This is demonstrated in below.</para>

      <programlisting>private Async asyncService;
private ServiceReference&lt;Foo&gt; fooRef;

@Reference
void setAsync(Async async) {
    asyncService = async;
}

@Reference(service = Foo.class)
void setList(ServiceReference&lt;Foo&gt; foo) {
    fooRef = foo;
}

public synchronized void doStuff() {
    Foo mediator = asyncService.mediate(fooRef);
    mediator.voidMethod();
    Promise&lt;Void&gt; promise = asyncService
           .call();
    ...
}</programlisting>
    </section>

    <section>
      <title>Fire and Forget calls</title>

      <para>Sometimes a client does not require any notification that an async
      invocation has completed. In this case the client could use one of the
      <code>call()</code> methods and simply discard the returned Promise
      object. This, however, can be wasteful of resources. The act of
      resolving the Promise object may be expensive, for example it may
      involve serializing the return value over a network if the remote call
      was asynchronous.</para>

      <para>If the client knows that no Promise object is needed then it can
      signal this to the Async service. This allows the Async service to
      optimise the async invocation by not creating and resolving a Promise.
      To indicate that the client wants to make a fire-and-forget style call
      the client invokes the mediator as normal, but then begins the
      asynchronous invocation using the <code>execute()</code> method as show
      below.</para>

      <programlisting>private Async asyncService;
private ServiceReference&lt;Foo&gt; fooRef;

@Reference
void setAsync(Async async) {
    asyncService = async;
}

@Reference(service = Foo.class)
void setList(ServiceReference&lt;Foo&gt; foo) {
    fooRef = foo;
}

public void doStuff() {
    Foo mediator = asyncService.mediate(fooRef);
    mediator.someMethod();
    asyncService.execute();
    ...
}</programlisting>
    </section>

    <section>
      <title>Multi Threading</title>

      <para>By their very definition asychronous tasks do not run inline, and
      typically they will not run on the same thread as the caller. This is
      not, however, a guarantee. A valid implementation of the Async service
      may have only one worker thread, which may be the thread currently
      running in the client code. Async invocations also have the same
      threading model as the OSGi Promise API. This means that callbacks may
      run on arbitrary threads, which may, or may not, be the same as the
      client thread, or the thread which executed the asynchronous
      work.</para>

      <para>It is important for multi-threaded clients to note that calls to
      the mediator and async service must occur on the same thread. For
      example it is not supported to invoke a mediator using one thread, and
      then to begin the async invocation by calling one of the
      <code>Async.call(...)</code> methods on a different thread.</para>
    </section>
  </section>

  <section xml:id="async_service_main_body">
    <title>Async Service</title>

    <para>The Async service is the primary interaction point between a client
    and the Async service implementation. An Async service implementation must
    expose a service implementing the
    <code>org.osgi.service.async.Async</code> interface. Clients obtain an
    instance of the Async service using the normal OSGi service registry
    mechanisms, either directly using the OSGi framework API, or using
    dependency injection.</para>

    <para>The Async service is used to:</para>

    <itemizedlist>
      <listitem>
        <para>Create async mediators</para>
      </listitem>

      <listitem>
        <para>Begin async invocations</para>
      </listitem>

      <listitem>
        <para>Obtain Promise objects representing the result of the async
        invocation</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Using the Async service</title>

      <para>The first action that a client wishing to make an async invocation
      must take is to create an async mediator using one of the
      <code>mediate</code> methods. Once created the client invokes the method
      that should be run asynchronously, supplying the arguments that should
      be used. This call records the invocation, but does not start the
      asynchronous task. The asynchronous task begins when the client makes
      invokes one of the <code>call</code> or <code>execute</code> methods on
      the Async service. The <code>call</code> methods must return a Promise
      representing the async invocation. The promise must resolve with the
      value returned by the async invocation, or fail with the failure thrown
      by the async invocation.</para>

      <para>If the client attempts to begin an async invocation without first
      having called a method on the mediator object then the Async service
      must detect this usage error and throw an
      <code>IllegalStateException</code> to the client. This applies to all
      methods that begin an async invocation.</para>
    </section>

    <section>
      <title>Asynchronous failures</title>

      <para>There are a variety of reasons that async invocations may be
      started correctly by the client, but then fail without running the
      asynchronous task. In any of these cases the Promise representing the
      async invocation must fail with an
      <code>org.osgi.framework.ServiceException</code>. This service exception
      must be initialised with a type of <code>ServiceException#ASYNC</code>
      <remark>needs a ref</remark>. If there is no promise representing the
      async invocation then there is no way to notify the client of the
      failure, therefore the service exception must be logged by the Async
      service using all available Log Service implementations.</para>

      <para>The following list of scenarios is not exhaustive, but indicates
      failure scenarios that must result in a service exception with a type of
      async</para>

      <itemizedlist>
        <listitem>
          <para>If the client is using a service reference backed mediator and
          the client bundle's bundle context becomes invalid before looking up
          the target service.</para>
        </listitem>

        <listitem>
          <para>If the client is using a service reference backed mediator and
          the service is unregistered before making the async
          invocation.</para>
        </listitem>

        <listitem>
          <para>If the client is using a service reference backed mediator and
          the service lookup returns <code>null</code></para>
        </listitem>

        <listitem>
          <para>If the Async service is unable to accept new work, for example
          it is in the process of being shut down.</para>
        </listitem>

        <listitem>
          <para>If the target service is unable to be invoked using the
          recorded arguments. This error should never occur for properly
          packaged bundles, however it can occur if there are missing uses
          constraints for one or more service packages.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Thread safety and instance sharing</title>

      <para>Implementations of the Async service must be thread safe and may
      be used simultaneously across multiple clients and from multiple threads
      within the same client. Whilst the async service is able to be used
      across multiple threads, if a client wishes to make an async invocation
      then the call to the mediator and the call to begin the async invocation
      must occur on the same thread. The returned Promise may then be shared
      between threads if required.</para>

      <para>It is expected, although not required, that the Async service
      implementation will use a Service Factory to create customized
      implementations for each client bundle. This simplifies the tracking of
      the relevant client bundle context to use when performing service
      lookups on the client bundle's behalf. Clients should therefore not
      share instances of the Async service with other bundles. Instead both
      bundles should obtain their own instances from the service
      registry.</para>
    </section>
  </section>

  <section>
    <title>The Async Mediator</title>

    <para>Async mediators are dynamically created objects that have the same
    type or interface as the object being mediated, and are used to record
    method invocations and arguments. Mediator objects are specific to an
    Async service implementation, and must only be used in conjunction with
    the async service object that they were created by.</para>

    <para>Mediators may be created either from a <code>ServiceReference</code>
    or from a service object. The actions and overall result are similar for
    both <code>mediate(...)</code> methods, with the primary difference being
    the manner in which the types to be mediated are determined.</para>

    <section>
      <title>Determining the mediated types for a service reference</title>

      <para>When creating an Async mediator object for a service reference the
      Async service must not introspect the service object to determine which
      types are mediated, but instead it must use the types listed in the
      objectClass property of the service reference. The mediator object must
      be type compatible with the service object for all types listed in the
      objectClass property.</para>
    </section>

    <section>
      <title>Determining the mediated types for a service object</title>

      <para>When mediating a service object there are no advertised types,
      therefore the service object must be introspected to determine the
      mediated types. In this case the type to be mediated is the type
      returned by calls to <code>serviceObject.getClass()</code>.</para>
    </section>

    <section>
      <title>Building the mediator object</title>

      <para>Once the set of types to be mediated has been determined then the
      set must be filtered into java interface types and java class types. The
      generated mediator object must extend the most specialised class type,
      and implement all of the provided interfaces. If there is no class type
      to be extended then the mediated object should extend
      <code>java.lang.Object</code>.</para>

      <para>There are three reasons why the Async service may not be able to
      mediate a class type:</para>

      <itemizedlist>
        <listitem>
          <para>The most specialised class type is final</para>
        </listitem>

        <listitem>
          <para>The most specialised class type has no zero-argument
          constructor</para>
        </listitem>

        <listitem>
          <para>One or more public methods present in the type hierarchy
          (other than those declared by java.lang.Object) are final</para>
        </listitem>
      </itemizedlist>

      <para>If any of these constraints are violated then the Async service
      should fall back to the next most specialised type, creating an
      interface-only mediator if necessary.</para>
    </section>

    <section>
      <title>Async mediator behaviours</title>

      <para>When invoked the Async mediator must record the method call, and
      its arguments, and then return rapidly (i.e. it should not perform
      blocking operations). The values returned by the mediator object are
      opaque, and the client should not attempt to interpret the returned
      value. The value may be null (or null-like in the case of primitives) or
      contain implementation specific information. If the mediated method call
      has a return type, specifically it is non-void, then this object must be
      passed to the the async service's <code>call</code> method when
      beginning the async invocation</para>

      <para>Async mediators should make a best-effort attempt to detect
      incorrect API usage from the client. If this incorrect usage is detected
      then the mediator object should throw an IllegalStateException when
      invoked. An example of incorrect usage is for a client to make multiple
      invocations on a mediator object without making any calls to the Async
      service.</para>
    </section>

    <section>
      <title>Thread safety and instance sharing</title>

      <para>Async mediators, unlike instances of the Async service, are not
      required to be thread safe. Clients should not share mediator objects
      with other bundles, or accross threads. Also, if a client wishes to make
      an async invocation then the call to the mediator and the call to
      <code>async.call(...)</code> must occur on the same thread. The returned
      Promise may then be shared between threads if required.</para>

      <para>Async mediators created from <code>ServiceReference</code> objects
      remain directly associated with the service reference and client bundle
      after creation. Clients should therefore not share mediator objects with
      other bundles. Instead both bundles should create their own
      mediators.</para>
    </section>
  </section>

  <section>
    <title>Delegating to asynchronous implementations</title>

    <para>Some service APIs are already asynchronous in operation, and others
    are partly asynchronous, in that some methods run asynchronously and
    others do not. There are also services which have a synchronous API, but
    could run asynchronously because they are a proxy to another service. A
    good example of this kind of service is a remote service. Remote services
    are local views of a remote endpoint, and depending upon the
    implementation of the endpoint it may be possible to make the remote call
    asynchronously, optimizing the thread usage of any local asynchronous
    call.</para>

    <para>Services that already have some level of asynchronous support may
    advertise this to clients and to the Async service by implementing
    <code>org.osgi.service.async.delegate.AsyncDelegate</code>. This interface
    can be used by the Async service implementation, or by the client
    directly, to make an asynchronous call on the service.</para>

    <para>Because the Async Delegate behaviour is transparently handled by the
    async service, clients of the async service do not need to know whether
    the target service implements Async Delegate or not, their usage pattern
    can remain unchanged.</para>

    <para>When making an async invocation the async service must check to see
    whether the target service implements Async Delegate. If the target
    service does implement AsyncDelegate then the async service must attempt
    to delegate the asynchronous call. The exact delegation pattern depends on
    whether a Promise is required.</para>

    <section>
      <title>Obtaining a Promise from an Async Delegate</title>

      <para>If a promise is needed by the client then the async service must
      attempt to delegate to the <code>async</code> method. The delegation
      proceeds as follows:</para>

      <itemizedlist>
        <listitem>
          <para>If the call to the Async Delegate returns a Promise, then the
          Promise returned by the async service must be resolved with that
          Promise.</para>
        </listitem>

        <listitem>
          <para>If the call to the Async Delegate throws an exception then
          this must be used to fail the promise returned by the Async
          service.</para>
        </listitem>

        <listitem>
          <para>If the Async Delegate is unable to optimise the call then it
          may return a <code>null</code> Promise from the <code>async</code>
          method. In this case the Async service must continue processing the
          async invocation, treating the service as a normal object.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Delegating fire and forget calls to an Async Delegate</title>

      <para>If no promise is needed by the client then the async service must
      attempt to delegate to the <code>execute</code> method. This gives the
      Async Delegate implementation the opportunity to further optimise its
      processing. The delegation proceeds as follows:</para>

      <itemizedlist>
        <listitem>
          <para>If the call to the Async Delegate returns <code>true</code>
          then the async service should return control to the client.</para>
        </listitem>

        <listitem>
          <para>If the call to the Async Delegate throws an exception then
          this must be logged to any available Log Services</para>
        </listitem>

        <listitem>
          <para>If the Async Delegate is unable to optimise the call then it
          may return <code>false</code> from the <code>execute</code> method.
          In this case the Async service must continue processing the async
          invocation, treating the service as a normal object.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="service.async.security">
    <title>Security</title>

    <para>Asynchronous Services implementations must be careful to avoid
    elevating the privileges of client bundles when calling services
    asynchronously. This means that the implementation must:</para>

    <itemizedlist>
      <listitem>
        <para>Use the client bundle to load interfaces when generating the
        asynchronous mediator. This prevents clients from gaining access to
        interfaces they would not normally be permitted to import.</para>
      </listitem>

      <listitem>
        <para>Use the client's bundle context when retrieving the target
        service. This prevents the client bundle from being able to make calls
        on a service object that they would normally be forbidden from
        obtaining.</para>
      </listitem>
    </itemizedlist>

    <para>Further security considerations can be addressed using normal OSGi
    security rules. For example access to the Async service can be controlled
    using ServicePermission[Async, GET].</para>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.async.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>http://www.osgi.org/Specifications/HomePage</bibliomixed>
    </bibliolist>
  </section>
</chapter>
