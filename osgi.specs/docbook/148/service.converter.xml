<?xml version="1.0" encoding="utf-8"?>
<chapter label="148"
         revision="$Id$"
         version="5" xml:id="service.converter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Converter Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.converter-version"
    linkend="org.osgi.service.converter"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>
    
    <para>...
    </para>
  </section> 
  
  <section>
    <title>Entities</title>
    
    <para>The following entities are used in this specification</para>
    
    <itemizedlist>
      <listitem>
        <para><emphasis>source</emphasis> - the object to be converted.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>result</emphasis> - the result of the conversion.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>source type</emphasis> - the type of the source to be converted.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>target type</emphasis> - the desired type of the conversion result.</para>
      </listitem>
    </itemizedlist>
    <remark>Add entity diagram</remark>
  </section> 

  <section>
    <title>Converter Service</title>
    
    <para>...</para>
    
    <section>
      <title>Adapting converters</title>
      <para>...</para>
    </section>
  </section> 

  <section>
    <title>Conversions</title>
    
    <para>Unless otherwise noted, conversions are only performed when the target type is not compatible
    with the source type. For example, when requesting to convert a <code>java.math.BigDecimal</code> to a 
    <code>java.lang.Number</code> the big decimal is simply used as-is as this type is assignable to the 
    requested target type.</para>
    
    <para>Note that in the case of Arrays, Collections and Map-like structures a deep copy is always returned, 
    even if the target type is compatible with the source type. This copy can be owned and optionally further
    modified by the caller.</para>
    
    <section>
      <title>Scalars</title>
          
      <section>
        <title>Conversion between scalars</title>
        
        <para>Direct conversion between certain scalar types is supported. For all other 
        scalar types conversion is done by converting to <code>String</code> and then converting 
        into the target type.
        </para>
  
        <table pgwide="1" rowheader="firstcol">
          <title>Direct conversions between scalar types</title>
          
          <tgroup cols="5">
            <colspec colnum="1" colwidth="0.5*"/>
            <colspec colnum="5" colwidth="0.5*"/>
           
            <thead>
              <row>
                <entry><subscript>to</subscript> \ <superscript>from</superscript></entry>
                <entry>Boolean</entry>
                <entry>Character</entry>
                <entry><emphasis>Number</emphasis></entry>
                <entry><code>null</code></entry>
              </row>
            </thead>
            
            <tbody>
              <row>
                <entry>boolean</entry>
                <entry><code>v.booleanValue()</code></entry>
                <entry><code>v.charValue() != 0</code></entry>
                <entry><code>v.</code><emphasis>number</emphasis><code>Value() != 0</code></entry>
                <entry><code>false</code></entry>
              </row>
            
              <row>
                <entry>char</entry>
                <entry><code>v.booleanValue() ? 1 : 0</code></entry>
                <entry><code>v.charValue()</code></entry>
                <entry><code>(char) v.intValue()</code></entry>
                <entry>0</entry>
              </row>
              
              <row>
                <entry><emphasis>number</emphasis></entry>
                <entry><code>v.booleanValue() ? 1 : 0</code></entry>
                <entry><code>(</code><emphasis>number</emphasis><code>) v.charValue()</code></entry>
                <entry><code>v.</code><emphasis>number</emphasis><code>Value()</code></entry>
                <entry>0</entry>
              </row>
            </tbody>
          </tgroup>
        </table>   
        
        <para>Where conversion is done from corresponding primitive types, these types
        are boxed before converting. Where conversion is done to corresponding boxed types,
        the types are boxed after converting.</para>     
      </section>
  
      <section>
        <title>Conversion to String</title>
        
        <para>Conversion to <code>String</code> is done by calling <code>toString()</code> on the object to
        be converted. In the case of a primitive type, the object is boxed first.</para>
        
        <para>A <code>null</code> object results in a <code>null</code> String value.</para>
      </section>
      
      <section>
        <title>Conversion from String</title>
        
        <para>Conversion from String is done by attempting to invoke the following methods, in order: 
        
          <orderedlist>
            <listitem>
              <para><code>static valueOf(String s)</code></para>
            </listitem>
  
            <listitem>
              <para>public constructor taking a single <code>String</code> argument.</para>
            </listitem>
          </orderedlist>
          
          Many types have special rules for converting from String
          values. See below.
        </para>
      </section>
      <section xml:id="service.converter.special.cases.string">
        <title>Special cases converting from String</title>
        <table>
          <title>Special cases converting from String</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry><code>boolean / Boolean</code></entry>
                <entry><code>Boolean.parseBoolean(v)</code></entry>
              </row>
                
              <row>
                <entry><code>char / Character</code></entry>
                <entry><code>v.length() > 0 ? v.charAt(0) : 0</code></entry>
              </row>
                
              <row>
                <entry><emphasis><code>number / Number</code></emphasis></entry>
                <entry><emphasis>Number</emphasis><code>.parse</code><emphasis>Number</emphasis><code>(v) </code></entry>
              </row>
  
              <row>
                <entry><code>java.lang.Class</code></entry>
                <entry><code>Bundle.loadClass(v)</code></entry>
              </row>
                            
              <row>
                <entry><code>java.time.LocalDate</code></entry>
                <entry><code>LocalDate.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.LocalDateTime</code></entry>
                <entry><code>LocalDateTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.LocalTime</code></entry>
                <entry><code>LocalTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.OffsetTime</code></entry>
                <entry><code>OffsetTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.ZonedDateTime</code></entry>
                <entry><code>ZonedDateTime.parse(v)</code></entry>
              </row>
              
              <row>
                <entry><code>java.util.UUID</code></entry>
                <entry><code>UUID.fromString(v)</code></entry>
              </row>              
  
              <row>
                <entry><code>java.util.regex.Pattern</code></entry>
                <entry><code>Pattern.compile(v)</code></entry>
              </row>
            </tbody>   
          </tgroup>
        </table>
      </section>
      
      <section>
        <title>Date and Calendar</title>
        <para>A <code>java.util.Date</code> instance is converted to 
        a <code>long</code> value by calling <code>Date.getTime()</code>.
        Converting a <code>long</code> into a <code>java.util.Date</code>
        is done by calling <code>new Date(long)</code>.</para> 
        
        <para>Converting a Date to a String is done by
          <remark>@@@ TODO UTC</remark>
        </para>
        
        <para>Converting into other types is done by converting via a String as intermediary.</para>
  
        <para>Conversions from Calendar objects are done by converting the Calendar
        to a Date via getTime() first. Convertions to a Calendar object are done by 
        constructing a Date object with the desired time (UTC) and then setting the 
        time in the Calendar object via setTime().</para>
      </section>
        
        <section>
          <title>Enums</title>
          <para>Conversions to Enum types are supported as follows.</para>
          <table>
            <title>Converting to Enum types</title>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>Source</entry>
                  <entry>Method</entry>
                </row>
              </thead>         
              <tbody>
              <row>
                <entry><emphasis>Number</emphasis></entry>
                <entry><emphasis>EnumType</emphasis><code>.values()[v.intValue()]</code></entry>
              </row>
                
              <row>
                <entry><code>String</code></entry>
                <entry><emphasis>EnumType</emphasis><code>.valueOf(v)</code>. If no matching enum value can be found
                a case-insensitive lookup if done for a matching enum value.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>  
        <para>
        Primitives are boxed before conversion is done.
          Other source types are converted to String before converting to Enum.</para>
      </section>
        
      <section xml:id="service.converter.special.cases.map.entry">
        <title>Map.Entry</title>
        <para>Conversion of <code>Map.Entry&lt;K,V&gt;</code> to a target type is done by evaluating the compatibility of the 
        target type with both the key and the value in the entry and then using the best match. This is done in this order:
        <orderedlist>
          <listitem><para>If one of the key or value is the same as the target type, then this is used.</para></listitem>
          <listitem><para>If one of the key or value type is assignable to the target type, then this is used.</para></listitem>
          <listitem><para>If one of the key or value is of type <code>String</code>, this is used and converted to the target type.</para></listitem>
          <listitem><para>If none of the above matches the key is converted into a <code>String</code> and this
          value is then converted to the target type.</para></listitem>
        </orderedlist>
        If the key or value of the <code>Map.Entry&lt;K,V&gt;</code> equally match, the key is used.</para>
                        
        <para>Conversion to <code>Map.Entry</code> from another type is not supported.</para>
      </section>
      </section>
    
    <section>
      <title>Aggregates</title>
  
      <para>Collections and Arrays...</para>
      
      <section>
        <title>Converting to a scalar</title>
        <para>
        If a Collection or array needs to be converted to a target which is not a 
        Collection, Array or Map-like structure (as described
        in <xref linkend="service.converter.special.cases.maps"/>)
        the first element is taken and converted into the target type.</para>
        
        <para>If the collection or array has no elements, the <code>null</code> value is
        used to convert into the target type.</para>
        
        <para><emphasis>Note: </emphasis>deviations from this mechanism can be achieved by using an 
          <xref linkend="org.osgi.service.converter.Adapter" xrefstyle="hyperlink"/>. For example:
          <programlisting>Converter converter = ...; // from service registry
String s = converter.convert(new String[] {"A","B"}).to(String.class)); // s="A"
          
// Use an adapter to modify converter behavior          
Adapter ca = converter.getAdapter();
ca.rule(String[].class, String.class,
  v -> Stream.of(v).collect(Collectors.joining(",")),
  v -> v.split(","));

String s2 = ca.convert(new String[] {"A","B"}).to(String.class)); // s2="A,B"
String[] sa = ca.convert("A,B").to(String[].class); // sa={"A","B"}</programlisting> 
        </para>
      </section>
      
      <section>
        <title>Converting to an Array or Collection</title>
        <para>A new object is always created to be returned and owned by the caller.
        This is true even it the target type is compatible with the source type.</para>
        
        <table>
          <title>Collection / Array result creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry>Collection interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>java.util.List</code> then the implementation can create a
                <code>java.util.ArrayList</code>. When converting to a <code>java.util.Set</code>
                the converter must choose a set implementation that preserves iteration order.</entry>
              </row>
              <row>
                <entry>Collection concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> on the 
                provided type. For example if the target type is <code>LinkedList</code> then the 
                converter creates a target object by calling <code>LinkedList.class.newInstance()</code>.</entry>
              </row>
              <row>
                <entry><code>T[]</code></entry>
                <entry><code>Array.newInstance(Class&lt;T&gt; cls, int x)</code> where 
                <code>x</code> is the required size of the target collection.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Before inserting values into the resulting collection/array they are converted to the desired
        target type first. In the case of arrays this is the type of the array. When inserting into a 
        Collection generic type information about the target type can be made available by using the
        <xref linkend="org.osgi.service.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.service.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. For example, 
        to convert an array of <code>String</code>s into a list of <code>Integer</code>s:
        
        <programlisting>List&lt;Integer&gt; result =
  converter.convert(Arrays.asList("1","2","3")).
    to(new TypeReference&lt;List&lt;Integer&gt;&gt;() {});</programlisting>
    
        The following example converts an array of <code>int</code>s into a set of <code>Double</code>s. Note that
        the resulting set should preserve the same iteration order as the original array:
        
        <programlisting>Set&lt;Double&gt; result =
  converter.convert(new int[] {1,2,3}).
    to(new TypeReference&lt;Set&lt;Double&gt;&gt;() {})
        </programlisting>
        
        Values are inserted in the resulting Collection/array as follows:
        
          <itemizedlist>
            <listitem>
              <para>If the source object is <code>null</code>, an empty collection/array is produced.</para>
            </listitem>
            
            <listitem>
              <para>If the value is not a Collection, Array or Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) a result with
              a single element is produced. The value is first converted into the desired
              target type.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Collection or Array, then each of its elements is converted 
              into desired target type before inserting. Elements are inserted into the target
              collection in their normal iteration order.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) then <code>Map.Entry</code> elements 
              are obtained from it via <code>Map.entrySet()</code>. 
              Each <code>Map.Entry</code> element is then converted into the target type before inserting in the
              result.</para>
            </listitem>
          </itemizedlist> 
        </para>
      </section>
    </section>
    
    <section xml:id="service.converter.special.cases.maps">
      <title>Maps, Interfaces, Java Beans, DTOs and Annotations</title>
      <para>Entities that can hold multiple key-value pairs are all treated in a similar way. These entities
      include Maps, Dictionaries, Interfaces, Java Beans, Annotations and OSGi DTOs. Additionally objects that provide a map view
      are supported.</para>
      
      <para>When converting between map-like types, a map is used as intermediary.
      When converting to other structures, the map is converted into a collection of
      <code>Map.Entry</code> values which in turn is converted into the target type.
      </para>
      
      <para>A new object is always created to be returned and owned by the caller.
      This is true even it the target type is compatible with the source type.</para>
      
      <section>
        <title>Map</title>
        <table>
          <title>Map result creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry>Map interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>ConcurrentNavigableMap</code> then the implementation can create a 
                <code>ConcurrentSkipListMap</code>.</entry>
              </row>
              <row>
                <entry>Map concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> 
                on the provided type. For example if the target type is <code>HashMap</code> 
                then the converter creates a target object by calling
                <code>HashMap.class.newInstance()</code>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Each key-value pair in the source map is converted to desired types of the target map
        using the generic information if available.
        
        Map type information about the target type can be made available by using the
        <xref linkend="org.osgi.service.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.service.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods.        
        </para>      
      </section>
      
      <section>
        <title>Dictionary</title>
        <para>Converting between a map and a <code>Dictionary</code> is done by iterating over the
        source and inserting the key value pairs in the result, converting them to the requested target 
        type. As with other generic types, target type information for Dictionaries can be provided
        via a <xref linkend="org.osgi.service.converter.TypeReference" xrefstyle="hyperlink"/>.</para> 
      </section>
      
      <section>
        <title>Interface</title>
        <para>When converting into an interface the converter will create a dynamic proxy to 
        implement the interface. The name of the method returning the value should match the key 
        of the map entry, taking into account the mapping rules specified in 
        <xref linkend="service.converter-key.mapping"/>.
        The key of the map may need to be converted into a <code>String</code> first.</para>
        
        <para>Conversion is done <emphasis>on demand</emphasis>: only when the method on 
        the interface is actually invoked. This avoids conversion errors on methods 
        for which the information is missing or cannot be converted, but which the caller 
        does not require.</para>
        
        <para>Interfaces can provide methods for default values by providing a single-argument method
        override in addition to the no-arg method matching the key name. If the type of the default
        does not match the target type it is converted first. 
        For example:  
        <programlisting>interface Config {
  int my_value(); // no default, used when converting from the interface
  int my_value(int defVal);
  int my_value(String defVal); // String value is automatically converted to int
  boolean my_other_value();
}

// Usage
Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;(); // an example map
myMap.put("my.other.value", "true");
Config cfg = converter.convert(myMap).to(Config.class);
int val = cfg.my_value(17); // if not set then use 17
boolean val2 = cfg.my_other_value(); // val2=true
</programlisting>
        Default values are used when the key is not present in the map for the method. If a key is 
        present with a <code>null</code> value, then <code>null</code> is taken as the value and 
        converted to the target type.</para>
        
      <section xml:id="service.converter-key.mapping">
        <title>Key Mapping</title>

        <para>Each no-argument and each single-argument method that has a non-void return value of the interface is mapped to 
        a key in the map. The key name is derived from the method name.
        Certain common property name characters, such as full stop (<code>'.'
        \u002E</code>) are not valid in Java identifiers. So the name of a
        method must be converted to its corresponding property name as
        follows:<itemizedlist>
            <listitem>
              <para>A single dollar sign (<code>'$' \u0024</code>) is removed
              unless it is followed by another dollar sign in which case the
              two consecutive dollar signs (<code>"$$"</code>) are converted
              to a single dollar sign.</para>
            </listitem>

            <listitem>
              <para>A single low line (<code>'_' \u005F</code>) is converted
              into a full stop (<code>'.' \u002E</code>) unless is it followed
              by another low line in which case the two consecutive low lines
              (<code>"__"</code>) are converted to a single low line.</para>
            </listitem>

            <listitem>
              <para>All other characters are unchanged.</para>
            </listitem>
          </itemizedlist></para>

        <para><xref
        linkend="service.converter-key.name.mapping"/> contains
        some name mapping examples.</para>

        <table xml:id="service.converter-key.name.mapping">
          <title>Component Property Name Mapping Examples</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="1*"/>

            <colspec colnum="2" colwidth="1*"/>

            <thead>
              <row>
                <entry>Component Property Type Method Name</entry>

                <entry>Component Property Name</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>myProperty143</code></entry>

                <entry><code>myProperty143</code></entry>
              </row>

              <row>
                <entry><code>$new</code></entry>

                <entry><code>new</code></entry>
              </row>

              <row>
                <entry><code>my$$prop</code></entry>

                <entry><code>my$prop</code></entry>
              </row>

              <row>
                <entry><code>dot_prop</code></entry>

                <entry><code>dot.prop</code></entry>
              </row>

              <row>
                <entry><code>_secret</code></entry>

                <entry><code>.secret</code></entry>
              </row>

              <row>
                <entry><code>another__prop</code></entry>

                <entry><code>another_prop</code></entry>
              </row>

              <row>
                <entry><code>three___prop</code></entry>

                <entry><code>three_.prop</code></entry>
              </row>

              <row>
                <entry><code>four_$__prop</code></entry>

                <entry><code>four._prop</code></entry>
              </row>

              <row>
                <entry><code>five_$_prop</code></entry>

                <entry><code>five..prop</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
        
      </section>
      
      <section>
        <title>Annotation</title>
        <para>Conversion to and from annotations is behaves identical to 
        interface conversion with the added capability of specifying a default in the annotation definition.
        </para>
        
        <para>Below a few examples of conversions to an annotation:
        <programlisting>@interface MyAnnotation {
  String[] args() default {"arg1", "arg2"};
}

// Will set sa={"args1", "arg2"}
String[] sa = converter.convert(new HashMap()).to(MyAnnotation.class).args();

// Will set a={"x", "y", "z"}
Map m = Collections.singletonMap("args", new String [] {"x", "y", "z"});
String[] a = converter.convert(m).to(MyAnnotation.class).args();

// Will set a1={}
Map m1 = Collections.singletonMap("args", null)
String[] a1 = converter.convert(m1).to(MyAnnotation.class).args();

// Will set a2={""}
Map m2 = Collections.singletonMap("args", "")
String[] a2 = converter.convert(m2).to(MyAnnotation.class).args();

// Will set a3={","}
Map m3 = Collections.singletonMap("args", ",")
String[] a3 = converter.convert(m3).to(MyAnnotation.class).args();</programlisting>
        </para>
      </section>
      
      <section>
        <title>Java Beans</title>
        <para>Java Beans are objects that follow a naming convention. They provide getters and setters to
        access their properties and have a public no-arg constructor. When converting from a Java Bean introspection
        is used to find the read accessors. A read accessor must have no arguments and a non-<code>void</code> return 
        value. The method name must start with get followed by a capitalized property name, 
        e.g. <code>getSize()</code> provides access to the property <code>size</code>. 
        For <code>boolean/Boolean</code> properties a prefix of <code>is</code>
        is also permitted.</para> 
        <para>When converting to a Java Bean, the bean is constructed eagerly. All available properties
            are set in the bean using the bean's write accessors, i.e. public setters methods with a single argument. 
            All methods of the bean class itself and its 
            super classes are considered. 
            If a property cannot be converted this will cause a 
            <xref linkend="org.osgi.service.converter.ConversionException" xrefstyle="hyperlink"/>.
            </para>
        <para><emphasis>Note: </emphasis>access via indexed bean properties is not supported as there is no way to 
        find out the size of the array via these accessors.
        </para>
        <para><emphasis>Note: </emphasis>the <code>getClass()</code> method of the <code>java.lang.Object</code>
        class is not considered an accessor.
        </para>
        <remark>Need to make sure to define priority. Some types described elsewhere are also JavaBeans and/or 
        interfaces at the same time</remark>
        <remark>Do we need explicitly call out certain types that are not treated as JavaBeans? E.g. String?</remark>
      </section>
      
      <section>
        <title>OSGi DTO</title>
        <para>
        DTOs are classes with public non-static fields and no methods other than the ones provided by the 
        <code>java.lang.Object class</code>. OSGi DTOs extend the <code>org.osgi.dto.DTO</code> class but the converter 
        should ignore this. This is to keep the converter API itself clean from OSGi dependencies. 
        DTOs may have static fields, these can also be ignored by the converter.</para>
        
        <para>When converting to a DTO, the converter attempts to find fields that match the key of each 
        entry in the map and then converting the value to the field type before assigning it. They key of
        the map entries may need to be converted into a String first. Keys are mapped according to 
        table 112.9 of the R6 Declarative Service specification.<remark>proper xref</remark></para>
        <remark>Do we not take the same approach as with JavaBeans/interfaces: Proying?</remark>
        
        <para>When converting from a DTO the value of each public non-static field is put in the target 
        map, taking the field name as its String key.
        </para>
      </section>
      
      <section>
        <title>Types with getProperties()</title>
        
        <para>The converter uses reflection to find a <code>java.util.Map getProperties()</code> or 
        <code>java.util.Dictionary getProperties()</code> method on the source type to obtain a map view over
        the source object. This map view can be used to convert the source object to another map-like structure.</para>
        
        <para><emphasis>Note: </emphasis>this mechanism can only be used to convert <emphasis>to</emphasis> another type. 
        The reverse is not supported</para>
                
        <remark>Need to describe what happens if something is a JavaBean that also has getProperties()</remark>
      </section>
      
      <section>
        <title>Conversion between maps and other types</title>
        <para>Map-like structures are converted to other types by converting the map into a collection of entries
        by calling <code>Map.entrySet()</code>. Then this collection is converted into the target type.</para>
        <para>To convert from other types to a map, a Collection of <code>Map.Entry</code> objects is constructed
        first. Subsequently each entry is inserted into the target map.</para>
      </section>
    </section>
    
    <section>
      <title>Conversion failures</title>
      <para>...</para>
    </section>
  </section>

  <section>
    <title>Codecs</title>
    <para>...</para>
  </section> 

  <section>
    <title>Security</title>
    <para>...</para>
  </section> 

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.converter.xml"/>
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.converter.util.xml"/>
 
  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
