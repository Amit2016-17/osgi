<?xml version="1.0" encoding="utf-8"?>
<chapter label="148"
         revision="$Id$"
         version="5" xml:id="service.converter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Converter Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.converter-version"
    linkend="org.osgi.service.converter"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>
    
    <para>...
    </para>
  </section> 
  
  <section>
    <title>Entities</title>
    
    <para>The following entities are used in this specification</para>
    
    <itemizedlist>
      <listitem>
        <para><emphasis>source</emphasis> - the object to be converted.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>result</emphasis> - the result of the conversion.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>source type</emphasis> - the type of the source to be converted.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>target type</emphasis> - the desired type of the conversion result.</para>
      </listitem>
    </itemizedlist>
  </section> 

  <section>
    <title>Converter Service</title>
    
    <para>...</para>
  </section> 

  <section>
    <title>Conversions</title>
    
    <para>Unless otherwise noted, conversions are only performed when the target object is not compatible
    with the source type. For example when requesting to convert a <code>java.math.BigDecimal</code> to a 
    <code>java.lang.Number</code> the big decimal is simply used as-is as this type is assignable to the 
    requested target type.</para>
    
    <para>Note that in the case of Arrays, Collections and Map-like structures a copy is always returned, 
    even if the target type is compatible with the source. This copy can be owned and optionally further
    modified by the caller.</para>
    
    <section>
      <title>Conversion between scalars</title>
      
      <para>Direct conversion between certain scalar types is supported. For all other 
      scalar types conversion is done by converting to <code>String</code> and then converting 
      into the target type.
      </para>

      <table pgwide="1" rowheader="firstcol">
        <title>Direct conversions between scalar types</title>
        
        <tgroup cols="5">
          <colspec colnum="1" colwidth="0.5*"/>
          <colspec colnum="5" colwidth="0.5*"/>
         
          <thead>
            <row>
              <entry><subscript>to</subscript> \ <superscript>from</superscript></entry>
              <entry>Boolean</entry>
              <entry>Character</entry>
              <entry><emphasis>Number</emphasis></entry>
              <entry><code>null</code></entry>
            </row>
          </thead>
          
          <tbody>
            <row>
              <entry>boolean</entry>
              <entry><code>v.booleanValue()</code></entry>
              <entry><code>v.charValue() != 0</code></entry>
              <entry><code>v.</code><emphasis>number</emphasis><code>Value() != 0</code></entry>
              <entry><code>false</code></entry>
            </row>
          
            <row>
              <entry>char</entry>
              <entry><code>v.booleanValue() ? 1 : 0</code></entry>
              <entry><code>v.charValue()</code></entry>
              <entry><code>(char) v.intValue()</code></entry>
              <entry>0</entry>
            </row>
            
            <row>
              <entry><emphasis>number</emphasis></entry>
              <entry><code>v.booleanValue() ? 1 : 0</code></entry>
              <entry><code>(</code><emphasis>number</emphasis><code>) v.charValue()</code></entry>
              <entry><code>v.</code><emphasis>number</emphasis><code>Value()</code></entry>
              <entry><code>null</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>   
      
      <para>Where conversion is done from corresponding primitive types, these types
      are boxed before converting. Where conversion is done to corresponding boxed types,
      the types are boxed after converting.</para>     
    </section>

    <section>
      <title>Conversion to String</title>
      
      <para>Conversion to <code>String</code> is done by calling <code>toString()</code> on the object to
      be converted. In the case of a primitive type, the object is boxed first.</para>
      
      <para>A <code>null</code> object results in a <code>null</code> String value.</para>
    </section>
    
    <section>
      <title>Conversion from String</title>
      
      <para>Conversion from String is done by trying to invoke the following methods: 
      
        <orderedlist>
          <listitem>
            <para><code>static valueOf(String s)</code></para>
          </listitem>

          <listitem>
            <para>String constructor.</para>
          </listitem>
        </orderedlist>
        
        Many types have special rules for converting from String
        values. See <xref linkend="service.converter.special.cases.string"/>.
      </para>
    </section>
    <section xml:id="service.converter.special.cases.string">
      <title>Special cases converting from String</title>
      <table>
        <title>Special cases converting from String</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Target</entry>
              <entry>Method</entry>
            </row>
          </thead>         
          <tbody>
            <row>
              <entry><code>boolean / Boolean</code></entry>
              <entry><code>Boolean.parseBoolean(v)</code></entry>
            </row>
              
            <row>
              <entry><code>char / Character</code></entry>
              <entry><code>v.lenght() > 0 ? v.charAt(0) : 0</code></entry>
            </row>
              
            <row>
              <entry><emphasis><code>number / Number</code></emphasis></entry>
              <entry><emphasis>Number</emphasis><code>.parse</code><emphasis>Number</emphasis><code>(v) </code></entry>
            </row>

            <row>
              <entry><code>java.lang.Class</code></entry>
              <entry><code>Bundle.loadClass(v)</code></entry>
            </row>
                          
            <row>
              <entry><code>java.time.LocalDate</code></entry>
              <entry><code>LocalDate.parse(v)</code></entry>
            </row>

            <row>
              <entry><code>java.time.LocalDateTime</code></entry>
              <entry><code>LocalDateTime.parse(v)</code></entry>
            </row>

            <row>
              <entry><code>java.time.LocalTime</code></entry>
              <entry><code>LocalTime.parse(v)</code></entry>
            </row>

            <row>
              <entry><code>java.time.OffsetTime</code></entry>
              <entry><code>OffsetTime.parse(v)</code></entry>
            </row>

            <row>
              <entry><code>java.time.ZonedDateTime</code></entry>
              <entry><code>ZonedDateTime.parse(v)</code></entry>
            </row>
            
            <row>
              <entry><code>java.util.UUID</code></entry>
              <entry><code>UUID.fromString(v)</code></entry>
            </row>              

            <row>
              <entry><code>java.util.regex.Pattern</code></entry>
              <entry><code>Pattern.compile(v)</code></entry>
            </row>
          </tbody>   
        </tgroup>
      </table>
    </section>
    
    <section>
      <title>Date and Calendar</title>
      <para>A <code>java.util.Date</code> instance is converted to 
      a <code>long</code> value by calling <code>Date.getTime()</code>.
      Converting a <code>long</code> into a <code>java.util.Date</code>
      is done by calling <code>new Date(long)</code>.</para> 
      
      <para>Converting a Date to a String is done by
        <remark>@@@ TODO UTC</remark>
      </para>
      
      <para>Converting into other types is done by converting via a String as intermediary.</para>

      <para>Conversions from Calendar objects are done by converting the Calendar
      to a Date via getTime() first. Convertions to a Calendar object are done by 
      constructing a Date object with the desired time (UTC) and then setting the 
      time in the Calendar object via setTime().</para>
    </section>
      
      <section>
        <title>Enums</title>
        <para>Conversions to Enum types are supported as follows.</para>
        <table>
          <title>Converting to Enum types</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Source</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
            <row>
              <entry><code>Boolean</code></entry>
              <entry><emphasis>EnumType</emphasis><code>.valueOf(v.toString().toUpperCase())</code></entry>
            </row>
              
            <row>
              <entry><code>Character</code></entry>
              <entry><emphasis>EnumType</emphasis><code>.valueOf(Character.toString(v))</code></entry>
            </row>
              
            <row>
              <entry><emphasis>Number</emphasis></entry>
              <entry><emphasis>EnumType</emphasis><code>.values()[v.intValue()]</code></entry>
            </row>
              
            <row>
              <entry><code>String</code></entry>
              <entry><emphasis>EnumType</emphasis><code>.valueOf(v)</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>  
      <para>Primitives are boxed before conversion is done.
        Other source types are converted to String before converting to Enum.</para>
    </section>
      
    <section xml:id="service.converter.special.cases.map.entry">
      <title>Map.Entry</title>
      <para>Conversion of <code>Map.Entry</code> to a target type is done by evaluating the compatibility of the 
      target type with both the key and the value in the entry and then using the best match.
      <remark>Need to make crisp what 'best match' means.</remark>
      If the target type matches the key type, the key type is used. If the target matches 
      the value type then the value type is used.</para>
      
      <para>Conversion of <code>Map.Entry</code> to <code>String</code> is be done by converting both key and value to 
      String and concatenating both with an <code>=</code> character.</para>
      <remark>does this override the previous rule? What if key is of type String and value is Long?</remark>
      
      <para>Conversion of a <code>Map.Entry</code> to any other type is done by converting the value to 
      <code>String</code> and then converting the result to the target type.</para>
      
      <para>Converting to a Map.Entry can only be done from <code>String</code> values which contain an <code>=</code> 
      character. The <emphasis>left hand side</emphasis>  
      is assigned to the key and the <emphasis>right hand side</emphasis> is the value. 
      Key and value must be converted in the requested 
      target type where this type information is available. Strings without an <code>=</code> 
      sign result in a conversion failure.</para>
    </section>
    
    <section>
      <title>Collections and Arrays</title>
  
      <para>...</para>
      
      <section>
        <title>Converting to a single value</title>
        <para>
        If a Collection or array needs to be converted to a target which is not a 
        Collection, Array or Map-like structure (as described
        in <xref linkend="service.converter.special.cases.maps"/>)
        The first element is taken and converted into the target type.</para>
        
        <para>If the collection or array has no elements, the <code>null</code> value is
        used to convert into the target type.</para>
        
        <para><emphasis>Note: </emphasis>deviations from this mechanism can be achieved by using an 
          <xref linkend="org.osgi.service.converter.Adapter" xrefstyle="hyperlink"/>. For example:
          <programlisting>Converter converter = ...; // from service registry
          
Adapter ca = converter.getAdapter();
ca.rule(String[].class, String.class,
  v -> Stream.of(v).collect(Collectors.joining(",")),
  v -> v.split(","));

String s = ca.convert(new String[] {"A", "B"}).to(String.class)); // s="A,B"
String[] sa = ca.convert("A,B").to(String[].class); // sa={"A","B"}</programlisting> 
        </para>
      </section>
      
      <section>
        <title>Converting to an Array or Collection</title>
        <para>A new object is always created to be returned and owned by the caller.
        This is true even it the target type is compatible with the source type.</para>
        
        <table>
          <title>Collection / Array result creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry>Collection interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>java.util.List</code> then the implementation can create a
                <code>java.util.ArrayList</code>. When converting to a <code>java.util.Set</code>
                the converter must choose a set implementation that preserves iteration order.</entry>
              </row>
              <row>
                <entry>Collection concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> on the 
                provided type. For example if the target type is <code>LinkedList</code> then the 
                converter creates a target object by calling <code>LinkedList.class.newInstance()</code>.</entry>
              </row>
              <row>
                <entry><code>T[]</code></entry>
                <entry><code>Array.newInstance(Class&lt;T&gt; cls, int x)</code> where 
                <code>x</code> is the required size of the target collection.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Before inserting values into the resulting collection/array they are converted to the desired
        target type first. In the case of arrays this is the type of the array. When inserting into a 
        Collection type information about the target type can be made available by using the
        <xref linkend="org.osgi.service.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.service.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. For example, 
        to convert an array of <code>String</code>s into a list of <code>Integer</code>s:
        
        <programlisting>List&lt;Integer&gt; result =
  converter.convert(Arrays.asList("1","2","3")).
    to(new TypeReference&lt;List&lt;Integer&gt;&gt;() {});</programlisting>
    
        The following example converts an array of <code>int</code>s into a set of Doubles. Note that
        the resulting set should preserve the same iteration order as the original array:
        
        <programlisting>Set&lt;Double&gt; result =
  converter.convert(new int[] {1,2,3}).
    to(new TypeReference&lt;Set&lt;Double&gt;&gt;() {})
        </programlisting>
        
        Values are inserted in the resulting Collection/array as follows:
        
          <itemizedlist>
            <listitem>
              <para>If the source object is <code>null</code>, an empty collection/array is produced.</para>
            </listitem>
            
            <listitem>
              <para>If the value is not a Collection, Array or Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) a result with
              a single element is produced. The value is first converted into the desired
              target type.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Collection or Array, then each of its elements is converted 
              into desired target type before inserting. Elements are inserted into the target
              collection in their normal iteration order.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) then <code>Map.Entry</code> elements 
              are obtained from it using an iterator that adheres to the normal iteration order. 
              Each <code>Map.Entry</code> element is then converted into the target type before inserting in the
              result.</para>
            </listitem>
          </itemizedlist> 
        </para>
      </section>
    </section>
    
    <section xml:id="service.converter.special.cases.maps">
      <title>Maps, Interfaces, Java Beans, DTOs and Annotations</title>
      <para>Entities that can hold multiple key-value pairs are all treated in a similar way. These entities
      include Maps, Dictionaries, Interfaces, Java Beans, Annotations and OSGi DTOs. Additionally objects that provide a map view
      can be handled.</para>
      
      <para>When converting between map-like types, a map is used as the canonical structure used as an intermediary
      when converting between types. When converting to other structures, the map is converted into a collection of
      <code>Map.Entry</code> values which in turn is converted into the target type.
      </para>
      
      <section>
        <title>Map</title>
        <para>A new object is always created to be returned and owned by the caller.
        This is true even it the target type is compatible with the source type.
        <table>
          <title>Map result creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry>Map interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>ConcurrentNavigableMap</code> then the implementation can create a 
                <code>ConcurrentSkipListMap</code>.</entry>
              </row>
              <row>
                <entry>Map concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> 
                on the provided type. For example if the target type is <code>HashMap</code> 
                then the converter creates a target object by calling
                <code>HashMap.class.newInstance()</code>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        Each key-value pair in the source map is converted to desired types of the target map
        using the generic information if available.
        
        Map type information about the target type can be made available by using the
        <xref linkend="org.osgi.service.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.service.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods.        
        </para>      
      </section>
      
      <section>
        <title>Dictionary</title>
        <para>Converting between a map and a <code>Dictionary</code> is done by iterating over the
        source and inserting the key value pairs in the result, converting them to the requested target 
        type. As with other generic types, target type information for Dictionaries can be provided
        via a <xref linkend="org.osgi.service.converter.TypeReference" xrefstyle="hyperlink"/>.</para> 
      </section>
      
      <section>
        <title>Interface</title>
        <para>When converting into an interface the converter will create a dynamic proxy to 
        implement the interface. The name of the method returning the value should match the key 
        of the map entry, taking into account the mapping rules specified in 
        table 112.9 of the R6 Declarative Service specification. <remark>proper xref</remark> 
        The key of the map may need to be converted into a String first.</para>
        
        <para>Conversion is done <emphasis>on demand</emphasis>: only when the method on 
        the interface is actually invoked. This avoids conversion errors on methods 
        for which the information is missing or cannot be converted, which the caller 
        may not be interested.</para>
        
        <para>Interfaces can provide methods for default values by providing a single-argument method
        override in addition to the no-arg method matching the key name. If the type of the default
        does not match the target type it is converted using the active converter or adapter first. 
        For example:  
        <programlisting>interface Config {
  int my_value(); // no default, used when converting from the interface
  int my_value(int defVal);
  int my_value(String defVal); // default value is automatically converted to the target type
  boolean my_other_value();
}

// Usage
Map&lt;String, ?&gt; myMap = ... // an example map
Config cfg = converter.convert(myMap).to(Config.class);
int val = cfg.my_value(17); // if not set then use 17
</programlisting>
        Default values are used when the key is not present in the map for the method. If a key is 
        present with a <code>null</code> value, then <code>null</code> is taken as the value and 
        converted to the target type.</para>
      </section>
      
      <section>
        <title>Annotation</title>
        <para>Conversion to and from annotations is behaves identical to conversion from
        interface but with the added capability of specifying a default in the annotation definition.
        </para>
        
        <para>Below a few examples of conversions to annotations:
        <programlisting>@interface Config {
  String[] args() default {"arg1", "arg2"};
}

// Will set a={"args1", "arg2"}
String[] a = converter.convert(new HashMap()).to(Config.class).args();

// Will set a1={}
Map m1 = Collections.singletonMap("args", null)
String[] a1 = converter.convert(m1).to(Config.class).args();

// Will set a2={""}
Map m2 = Collections.singletonMap("args", "")
String[] a2 = converter.convert(m2).to(Config.class).args();

// Will set a3={","}
Map m3 = Collections.singletonMap("args", ",")
String[] a3 = converter.convert(m3).to(Config.class).args();

// Will set a4={"",""}, non-default conversion via adapter
Map m4 = Collections.singletonMap("args", ",")
Adapter ca = c.getAdapter();
ca.rule(String[].class, String.class,
  v -> Stream.of(v).collect(Collectors.joining(","))),
  v -> v.split(","));
String[] a4 = converter.convert(m4).to(Config.class).args();
</programlisting>
        </para>
      </section>
      
      <section>
        <title>Java Beans</title>
        <para>Java Beans are objects that follow a naming convention. They provide getters and setters to
        access their properties and have a no-arg constructor. When converting from a Java Bean introspection
        is used to find the read accessors. A read accessor must have no arguments and a non-void return 
        value. The method name must start with get followed by a capitalized property name, 
        e.g. <code>getName()</code>. For <code>boolean/Boolean</code> properties a prefix of <code>is</code>
        is also permitted.</para> 
        <para>When converting to a Java Bean, the following strategies are used:</para>
        <orderedlist>
          <listitem>
            <para>If the Java Bean is a non-final class, a subclass is dynamically generated and conversion
            is done on-demand when any of the getter methods are called, similar to interfaces and annotations.
            </para>
          </listitem>
          
          <listitem>
            <para>If the Java Bean is a final class, the bean is constructed eagerly. All available properties
            are set in the bean using the bean's write accessors, i.e. public setters methods with a single argument. 
            All methods of the bean class itself and its 
            super classes are considered. However accessor methods inherited from <code>java.lang.Object</code> are 
            ignored; i.e. the <code>getClass()</code> method inherited from Object is not considered an accessor.
            If a property cannot be converted this will cause a 
            <xref linkend="org.osgi.service.converter.ConversionException" xrefstyle="hyperlink"/>.
            </para>
          </listitem>
        </orderedlist>
        <para><emphasis>Note: </emphasis>access via indexed bean properties is not supported as there is no way to 
        find out the size of the array via these accessors.
        </para>
        <remark>Need to make sure to define priority. Some types described elsewhere are also JavaBeans</remark>
      </section>
      
      <section>
        <title>OSGi DTO</title>
        <para>Objects that extend (either directly or indirectly) the <code>org.osgi.dto.DTO</code> class ...</para>
      </section>
      
      <section>
        <title>Types with getProperties()</title>
        <para><remark>Need to describe what happens if something is a JavaBean that also has getProperties()</remark></para>
      </section>
    </section>
    
    <section>
      <title>Conversion failures</title>
      <para>...</para>
    </section>
  </section>

  <section>
    <title>Codecs</title>
    <para>...</para>
  </section> 

  <section>
    <title>Security</title>
    <para>...</para>
  </section> 

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.converter.xml"/>
 
  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
