<?xml version="1.0" encoding="utf-8"?>
<chapter label="148"
         revision="$Id$"
         version="5" xml:id="service.converter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Converter Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.converter-version"
    linkend="org.osgi.service.converter"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>
    
    <para>...
    </para>
  </section> 
  
  <section>
    <title>Usage</title>
    
    <para>...</para>
  </section> 

  <section>
    <title>Converter Service</title>
    
    <para>...</para>
  </section> 

  <section>
    <title>Conversions</title>
    
    <para>Unless otherwise noted, conversions are only performed when the target object is not compatible
    with the source type. For example when requesting to convert a <code>java.math.BigDecimal</code> to a 
    <code>java.lang.Number</code> the big decimal is simply used as-is as this type is assignable to the 
    requested target type.</para>
    
    <para>Note that in the case of Arrays, Collections and Map-like structures a copy is always returned, 
    even if the target type is compatible with the source. This copy can be owned and optionally further
    modified by the caller.</para>
    
    <section>
      <title>Conversion between scalars</title>
      
      <para>Direct conversion between certain scalar types is supported. For all other 
      scalar types conversion is done by converting to <code>String</code> and then converting 
      into the target type.
      </para>

      <table pgwide="1" rowheader="firstcol">
        <title>Direct conversions between scalar types</title>
        
        <tgroup cols="5">
          <colspec colnum="1" colwidth="0.5*"/>
          <colspec colnum="5" colwidth="0.5*"/>
         
          <thead>
            <row>
              <entry><subscript>to</subscript> \ <superscript>from</superscript></entry>
              <entry>Boolean</entry>
              <entry>Character</entry>
              <entry><emphasis>Number</emphasis></entry>
              <entry><code>null</code></entry>
            </row>
          </thead>
          
          <tbody>
            <row>
              <entry>boolean</entry>
              <entry><code>v.booleanValue()</code></entry>
              <entry><code>v.charValue() != 0</code></entry>
              <entry><code>v.</code><emphasis>number</emphasis><code>Value() != 0</code></entry>
              <entry><code>false</code></entry>
            </row>
          
            <row>
              <entry>char</entry>
              <entry><code>v.booleanValue() ? 1 : 0</code></entry>
              <entry><code>v.charValue()</code></entry>
              <entry><code>(char) v.intValue()</code></entry>
              <entry>0</entry>
            </row>
            
            <row>
              <entry><emphasis>number</emphasis></entry>
              <entry><code>v.booleanValue() ? 1 : 0</code></entry>
              <entry><code>(</code><emphasis>number</emphasis><code>) v.charValue()</code></entry>
              <entry><code>v.</code><emphasis>number</emphasis><code>Value()</code></entry>
              <entry><code>null</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>   
      
      <para>Where conversion is done from corresponding primitive types, these types
      are boxed before converting. Where conversion is done to corresponding boxed types,
      the types are boxed after converting.</para>     
    </section>

    <section>
      <title>Conversion to String</title>
      
      <para>Conversion to <code>String</code> is done by calling <code>toString()</code> on the object to
      be converted. In the case of a primitive type, the object is boxed first.</para>
      
      <para>A <code>null</code> object results in a <code>null</code> String value.</para>
    </section>
    
    <section>
      <title>Conversion from String</title>
      
      <para>Conversion from String is done by trying to invoke the following methods: 
      
        <orderedlist>
          <listitem>
            <para><code>static valueOf(String s)</code></para>
          </listitem>

          <listitem>
            <para>String constructor.</para>
          </listitem>
        </orderedlist>
        
        Many types have special rules for converting from String
        values. See <xref linkend="service.converter.special.cases.string"/>.
      </para>
    </section>
    <section xml:id="service.converter.special.cases.string">
      <title>Special cases converting from String</title>
      <table>
        <title>Special cases converting from String</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Target</entry>
              <entry>Method</entry>
            </row>
          </thead>         
          <tbody>
            <row>
              <entry><code>boolean / Boolean</code></entry>
              <entry><code>Boolean.parseBoolean(v)</code></entry>
            </row>
              
            <row>
              <entry><code>char / Character</code></entry>
              <entry><code>v.lenght() > 0 ? v.charAt(0) : 0</code></entry>
            </row>
              
            <row>
              <entry><emphasis><code>number / Number</code></emphasis></entry>
              <entry><emphasis>Number</emphasis><code>.parse</code><emphasis>Number</emphasis><code>(v) </code></entry>
            </row>

            <row>
              <entry><code>java.lang.Class</code></entry>
              <entry><code>Bundle.loadClass(v)</code></entry>
            </row>
                          
            <row>
              <entry><code>java.time.LocalDate</code></entry>
              <entry><code>LocalDate.parse(v)</code></entry>
            </row>

            <row>
              <entry><code>java.time.LocalDateTime</code></entry>
              <entry><code>LocalDateTime.parse(v)</code></entry>
            </row>

            <row>
              <entry><code>java.time.LocalTime</code></entry>
              <entry><code>LocalTime.parse(v)</code></entry>
            </row>

            <row>
              <entry><code>java.time.OffsetTime</code></entry>
              <entry><code>OffsetTime.parse(v)</code></entry>
            </row>

            <row>
              <entry><code>java.time.ZonedDateTime</code></entry>
              <entry><code>ZonedDateTime.parse(v)</code></entry>
            </row>
            
            <row>
              <entry><code>java.util.UUID</code></entry>
              <entry><code>UUID.fromString(v)</code></entry>
            </row>              

            <row>
              <entry><code>java.util.regex.Pattern</code></entry>
              <entry><code>Pattern.compile(v)</code></entry>
            </row>
          </tbody>   
        </tgroup>
      </table>
    </section>
    
    <section>
      <title>Date and Calendar</title>
      <para>A <code>java.util.Date</code> instance is converted to 
      a <code>long</code> value by calling <code>Date.getTime()</code>.
      Converting a <code>long</code> into a <code>java.util.Date</code>
      is done by calling <code>new Date(long)</code>.</para> 
      
      <para>Converting a Date to a String is done by
        <remark>@@@ TODO UTC</remark>
      </para>
      
      <para>Converting into other types is done by converting via a String as intermediary.</para>

      <para>Conversions from Calendar objects are done by converting the Calendar
      to a Date via getTime() first. Convertions to a Calendar object are done by 
      constructing a Date object with the desired time (UTC) and then setting the 
      time in the Calendar object via setTime().</para>
    </section>
      
      <section>
        <title>Enums</title>
        <para>Conversions to Enum types are supported as follows.</para>
        <table>
          <title>Converting to Enum types</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Source</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
            <row>
              <entry><code>Boolean</code></entry>
              <entry><emphasis>EnumType</emphasis><code>.valueOf(v.toString().toUpperCase())</code></entry>
            </row>
              
            <row>
              <entry><code>Character</code></entry>
              <entry><emphasis>EnumType</emphasis><code>.valueOf(Character.toString(v))</code></entry>
            </row>
              
            <row>
              <entry><emphasis>Number</emphasis></entry>
              <entry><emphasis>EnumType</emphasis><code>.values()[v.intValue()]</code></entry>
            </row>
              
            <row>
              <entry><code>String</code></entry>
              <entry><emphasis>EnumType</emphasis><code>.valueOf(v)</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>  
      <para>Primitives are boxed before conversion is done.
        Other source types are converted to String before converting to Enum.</para>
    </section>
      
    <section xml:id="service.converter.special.cases.map.entry">
      <title>Map.Entry</title>
      <para>Conversion of <code>Map.Entry</code> to a target type is done by evaluating the compatibility of the 
      target type with both the key and the value in the entry and then using the best match.
      <remark>Need to make crisp what 'best match' means.</remark>
      If the target type matches the key type, the key type is used. If the target matches 
      the value type then the value type is used.</para>
      
      <para>Conversion of <code>Map.Entry</code> to <code>String</code> is be done by converting both key and value to 
      String and concatenating both with an <code>=</code> character.</para>
      <remark>does this override the previous rule? What if key is of type String and value is Long?</remark>
      
      <para>Conversion of a <code>Map.Entry</code> to any other type is done by converting the value to 
      <code>String</code> and then converting the result to the target type.</para>
      
      <para>Converting to a Map.Entry can only be done from <code>String</code> values which contain an <code>=</code> 
      character. The <emphasis>left hand side</emphasis>  
      is assigned to the key and the <emphasis>right hand side</emphasis> is the value. 
      Key and value must be converted in the requested 
      target type where this type information is available. Strings without an <code>=</code> 
      sign result in a conversion failure.</para>
    </section>
    
    <section>
      <title>Collections and Arrays</title>
  
      <para>...</para>
      
      <section>
        <title>Converting to a single value</title>
        <para>
        If a Collection or array needs to be converted to a target which is not a 
        Collection, Array or Map-like structure (as described
        in <xref linkend="service.converter.special.cases.maps"/>)
        The first element is taken and converted into the target type.</para>
        
        <para>If the collection or array has no elements, the <code>null</code> value is
        used to convert into the target type.</para>
        
        <para><emphasis>Note: </emphasis>deviations from this mechanism can be achieved by using an 
          <xref linkend="org.osgi.service.converter.Adapter" xrefstyle="hyperlink"/>. For example:
          <programlisting>Converter converter = ...; // from service registry
          
Adapter ca = converter.getAdapter();
ca.rule(String[].class, String.class,
  v -> Stream.of(v).collect(Collectors.joining(",")),
  v -> v.split(","));

String s = ca.convert(new String[] {"A", "B"}).to(String.class)); // s="A,B"
String[] sa = ca.convert("A,B").to(String[].class); // sa={"A","B"}</programlisting> 
        </para>
      </section>
      
      <section>
        <title>Converting to an Array or Collection</title>
        <para>A new object is always created to be returned and owned by the caller.
        This is true even it the target type is compatible with the source type.</para>
        
        <table>
          <title>Collection / Array resulting object creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry>Collection interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>java.util.List</code> then the implementation can create a
                <code>java.util.ArrayList</code>. When converting to a <code>java.util.Set</code>
                the converter must choose a set implementation that preserves iteration order.</entry>
              </row>
              <row>
                <entry>Collection concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> on the 
                provided type. For example if the target type is <code>LinkedList</code> then the 
                converter creates a target object by calling <code>LinkedList.class.newInstance()</code>.</entry>
              </row>
              <row>
                <entry><code>T[]</code></entry>
                <entry><code>Array.newInstance(Class&lt;T&gt; cls, int x)</code> where 
                <code>x</code> is the required size of the target collection.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Before inserting values into the resulting collection/array they are converted to the desired
        target type first. In the case of arrays this is the type of the array. When inserting into a 
        Collection type information about the target type can be made available by using the
        <xref linkend="org.osgi.service.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.service.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. For example, 
        to convert an array of <code>String</code>s into a list of <code>Integer</code>s:
        
        <programlisting>List&lt;Integer&gt; result =
  converter.convert(Arrays.asList("1","2","3")).
    to(new TypeReference&lt;List&lt;Integer&gt;&gt;() {});</programlisting>
    
        The following example converts an array of <code>int</code>s into a set of Doubles. Note that
        the resulting set should preserve the same iteration order as the original array:
        
        <programlisting>Set&lt;Double&gt; result =
  converter.convert(new int[] {1,2,3}).
    to(new TypeReference&lt;Set&lt;Double&gt;&gt;() {})
        </programlisting>
        
        Values are inserted in the resulting Collection/array as follows:
        
          <itemizedlist>
            <listitem>
              <para>If the source object is <code>null</code>, an empty collection/array is produced.</para>
            </listitem>
            
            <listitem>
              <para>If the value is not a Collection, Array or Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) a result with
              a single element is produced. The value is first converted into the desired
              target type.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Collection or Array, then each of its elements is converted 
              into desired target type before inserting. Elements are inserted into the target
              collection in their normal iteration order.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) then <code>Map.Entry</code> elements 
              are obtained from it using an iterator that adheres to the normal iteration order. 
              Each <code>Map.Entry</code> element is then converted into the target type before inserting in the
              result.</para>
            </listitem>
          </itemizedlist> 
        </para>
      </section>
    </section>
    
    <section xml:id="service.converter.special.cases.maps">
      <title>Maps, Classes, Interfaces and Annotations</title>
      <para>...</para>
    </section>
    
    <section>
      <title>Conversion failures</title>
      <para>...</para>
    </section>
  </section>

  <section>
    <title>Security</title>
    
    <para>...</para>
  </section> 

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.converter.xml"/>
 
  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
