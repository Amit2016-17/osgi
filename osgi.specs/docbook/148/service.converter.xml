<?xml version="1.0" encoding="utf-8"?>
<chapter label="148"
         revision="$Id$"
         version="5" xml:id="service.converter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Converter Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.converter-version"
    linkend="org.osgi.service.converter"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>
    
    <para>Data conversion is an inherent part of writing 
     software in a type safe language. In Java, converting strings to proper types or to convert one type to a more 
     convenient type is often done manually. Any errors are then handled inline.</para>
      
	<para>In release 6, the OSGi specifications introduced Data Transfer Objects (DTOs). DTOs are public objects without 
	open generics that only contain public instance fields based on simple types, arrays, and collections. 
	In many ways DTOs can be used as an alternative to Java beans. 
	Java beans are hiding their fields and provide access methods which separates 
	the contract (the public interface) from the internal usage. Though this model has advantages in technical applications 
    it tends to add overhead. DTOs unify the specification with the data since the data is what is already public 
	when it is sent to another process or serialized.</para>
	
    <para>This specification defines the OSGi Converter that makes it easy to convert many types to other types, including scalars,
    Collections, Maps, Beans, Interfaces and DTOs without having to write the boilerplate conversion code. The converter
    strictly adheres to the rule specified in this chapter. Converters can also be customized using converter
    builders. 
    </para>
  </section> 
  
  <section>
    <title>Entities</title>
    
    <para>The following entities are used in this specification</para>
    
    <itemizedlist>
      <listitem>
        <para><emphasis>Converter</emphasis> - a converter implements the Converter interface and can perform conversion operations.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Standard Converter</emphasis> - a converter implementation that follows this specification.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Converter Builder</emphasis> - can create customized converters by specifying rules for specific conversions.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Source</emphasis> - the object to be converted.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Result</emphasis> - the result of the conversion.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Source Type</emphasis> - the type of the source to be converted.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Target Type</emphasis> - the desired type of the conversion result.</para>
      </listitem>
    </itemizedlist>
    <remark>Add entity diagram</remark>
  </section> 

  <section>
    <title>Standard Converter</title>
    
    <para>The Standard Converter is a converter that follows precisely what is described in this 
    specification. It converts objects to the desired target type if a suitable conversion is 
    available. Otherwise it will throw a Conversion Exception.
    An instance can be obtained by creating a <code>new StandardConverter()</code>.</para> 
    
    <para>Some example conversions:
    <programlisting>Converter c = new StandardConverter();
    
// Scalar conversions    
MyEnum e = c.convert(MyOtherEnum.BLUE).to(MyEnum.class);
BigDecimal bd = c.convert(12345).to(BigDecimal.class);

// Aggregate conversions
List&lt;String&gt; ls = Arrays.asList("978", "142", "-99");
long[] la = c.convert(ls).to(long[].class);

// Map conversions
Map someMap = new HashMap();
someMap.put("mykey", 700); 
MyInterface mi = c.convert(someMap).to(MyInterface.class);</programlisting>
    </para>
    
    <section>
      <title>Customizing converters</title>
      <para>The Standard Converter applies the conversion rules described in this specification. While this is 
      useful for many applications, in some cases deviations from the specified rules may be necessary.
      This can be done by creating customized converter. 
      Customized converters are created based on an existing converter with additional rules specified that
      override the existing converter's behavior.
      A customized converter is created through a 
      <xref linkend="org.osgi.service.converter.ConverterBuilder" xrefstyle="hyperlink"/>. Customized converters
      implement the converter interface and as such can be used to create further customized converters.
      Converters are immutable, once created they cannot be modified, so they can be freely shared without the 
      risk of modification to the converter's behavior.
      </para>
      
      <para>For example converting a Date to a String may require a specific format. The default 
      <code>Date</code> to <code>String</code> conversion produces a String in the format 
      <code>yyyy-MM-ddTHH:mm:ss.SSSZ</code>. If we want to produce a String in the format 
      <code>yyMMddHHmmssZ</code> instead it can be done as follows. 
      This example shows the conversion with such a type from a JavaBean to a Map.
      <programlisting>class MyBean {
  //... fields ommitted
  boolean getEnabled() { /* ... */ }
  void setEnabled(boolean e)  { /* ... */ }
  Date getStartDate() { /* ... */ }
  void setStartDate(Date d) { /* ... */ }
}

MyBean mb = new MyBean();
mb.setStartDate(new Date());
mb.setEnabled(true);

SimpleDateFormat sdf = new SimpleDateFormat("yyMMddHHmmssZ");
ConverterBuilder cb = new StandardConverter().newConverterBuilder();
cb.rule(Date.class, String.class, v -&gt; sdf.format(v), v -&gt; sdf.parse(v));
Converter ca = cb.build();

Map&lt;String, String&gt; m = ca.convert(mb).to(new TypeReference&lt;Map&lt;String, String&gt;&gt;(){});
String en = m.get("enabled");   // en = "true"
String sd = m.get("startDate"); // sd = "160923102853+0100" or similar</programlisting></para>
    </section>
  </section> 

  <section>
    <title>Conversions</title>
    
    <para>For scalars, conversions are only performed when the target type is not compatible
    with the source type. For example, when requesting to convert a <code>java.math.BigDecimal</code> to a 
    <code>java.lang.Number</code> the big decimal is simply used as-is as this type is assignable to the 
    requested target type.</para>
    
    <para>In the case of Aggregates (Arrays and Collections) and Map-like structures a deep copy is always returned, 
    even if the target type is compatible with the source type. This copy can be owned and optionally further
    modified by the caller.</para>
    
    <section>
      <title>Generics</title>
      <para>When converting to a target type with generic type parameters it is necessary to capture 
      the generic type parameters to instruct the converter to produce the correct parameterized type.
      This can be achieved with the <code>TypeReference</code> based APIs, for example:
      <programlisting>Converter c = new StandardConverter();
List&lt;Long&gt; list = c.convert("123").to(new TypeReference&lt;Set&lt;Long&gt;&gt;());
// list will contain the Long value 123L</programlisting></para>
    </section>
    
    <section>
      <title>Scalars</title>
          
      <section>
        <title>Direct conversion between scalars</title>
        
        <para>Direct conversion between certain scalar types is supported. For all other 
        scalar types conversion is done by converting to <code>String</code> and then converting 
        into the target type.
        </para>
  
        <table pgwide="1" rowheader="firstcol">
          <title>Direct conversions between scalar types</title>
          
          <tgroup cols="5">
            <colspec colnum="1" colwidth="0.5*"/>
            <colspec colnum="5" colwidth="0.5*"/>
           
            <thead>
              <row>
                <entry><subscript>to</subscript> \ <superscript>from</superscript></entry>
                <entry>Boolean</entry>
                <entry>Character</entry>
                <entry><emphasis>Number</emphasis></entry>
                <entry><code>null</code></entry>
              </row>
            </thead>
            
            <tbody>
              <row>
                <entry>boolean</entry>
                <entry><code>v.booleanValue()</code></entry>
                <entry><code>v.charValue() != 0</code></entry>
                <entry><code>v.</code><emphasis>number</emphasis><code>Value() != 0</code></entry>
                <entry><code>false</code></entry>
              </row>
            
              <row>
                <entry>char</entry>
                <entry><code>v.booleanValue() ? 1 : 0</code></entry>
                <entry><code>v.charValue()</code></entry>
                <entry><code>(char) v.intValue()</code></entry>
                <entry>0</entry>
              </row>
              
              <row>
                <entry><emphasis>number</emphasis></entry>
                <entry><code>v.booleanValue() ? 1 : 0</code></entry>
                <entry><code>(</code><emphasis>number</emphasis><code>) v.charValue()</code></entry>
                <entry><code>v.</code><emphasis>number</emphasis><code>Value()</code></entry>
                <entry>0</entry>
              </row>
            </tbody>
          </tgroup>
        </table>   
        
        <para>Where conversion is done from corresponding primitive types, these types
        are boxed before converting. Where conversion is done to corresponding boxed types,
        the types are boxed after converting.</para>     
      </section>
  
      <section>
        <title>Conversion to String</title>
        
        <para>Conversion to <code>String</code> is done by calling <code>toString()</code> on the object to
        be converted. In the case of a primitive type, the object is boxed first.</para>
        
        <para>A <code>null</code> object results in a <code>null</code> String value.</para>
        
        <para><emphasis>Exception: </emphasis><code>java.util.Calendar</code> and 
        <code>java.util.Date</code> are converted to <code>String</code> as described in 
        <xref linkend="service.converter.date.calendar"/>.
        </para>
      </section>
      
      <section>
        <title>Conversion from String</title>
        
        <para>Conversion from String is done by attempting to invoke the following methods, in order: 
        
          <orderedlist>
            <listitem>
              <para><code>static valueOf(String s)</code></para>
            </listitem>
  
            <listitem>
              <para>public constructor taking a single <code>String</code> argument.</para>
            </listitem>
          </orderedlist>
          
          Some types have special rules for converting from String
          values. See below.
        </para>
      </section>
      <section xml:id="service.converter.special.cases.string">
        <title>Special cases converting from String</title>
        <table>
          <title>Special cases converting from String</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry><code>boolean / Boolean</code></entry>
                <entry><code>Boolean.parseBoolean(v)</code></entry>
              </row>
                
              <row>
                <entry><code>char / Character</code></entry>
                <entry><code>v.length() > 0 ? v.charAt(0) : 0</code></entry>
              </row>
                
              <row>
                <entry><emphasis><code>number / Number</code></emphasis></entry>
                <entry><emphasis>Number</emphasis><code>.parse</code><emphasis>Number</emphasis><code>(v) </code></entry>
              </row>
  
              <row>
                <entry><code>java.time.Instant</code></entry>
                <entry><code>Instant.parse(v)</code></entry>
              </row>

              <row>
                <entry><code>java.time.LocalDate</code></entry>
                <entry><code>LocalDate.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.LocalDateTime</code></entry>
                <entry><code>LocalDateTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.LocalTime</code></entry>
                <entry><code>LocalTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.OffsetTime</code></entry>
                <entry><code>OffsetTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.ZonedDateTime</code></entry>
                <entry><code>ZonedDateTime.parse(v)</code></entry>
              </row>
              
              <row>
                <entry><code>java.util.Calendar</code></entry>
                <entry>See <xref linkend="service.converter.date.calendar"/>.</entry>
              </row>

              <row>
                <entry><code>java.util.Date</code></entry>
                <entry><code>Date.from(Instant.parse(v))</code></entry>
              </row>
              
              <row>
                <entry><code>java.util.UUID</code></entry>
                <entry><code>UUID.fromString(v)</code></entry>
              </row>              
  
              <row>
                <entry><code>java.util.regex.Pattern</code></entry>
                <entry><code>Pattern.compile(v)</code></entry>
              </row>
            </tbody>   
          </tgroup>
        </table>
      </section>
      
      <section xml:id="service.converter.date.calendar">
        <title>Date and Calendar</title>
        <para>A <code>java.util.Date</code> instance is converted to 
        a <code>long</code> value by calling <code>Date.getTime()</code>.
        Converting a <code>long</code> into a <code>java.util.Date</code>
        is done by calling <code>new Date(long)</code>.</para> 
        
        <para>Converting a Date to a String is done by converting it to an 
        <code>Instant</code> and then calling <code>Instant.toString()</code>.
        This will produce a ISO-8601 UTC date/time string in the following 
        format: <code>2011-12-03T10:15:30Z</code>. Converting a String to
        a date is done by calling <code>Date.from(Instant.parse(v))</code>
        which can convert this ISO-8601 format back into a Date.
        </para>
          
        <para>Conversions from Calendar objects are done by converting the Calendar
        to a Date via getTime() first, and then converting the resulting Date to the 
        target type. Convertions to a Calendar object are done by converting the
        source to a Date object with the desired time (UTC) and then setting the 
        time in the Calendar object via setTime().</para>
      </section>
        
        <section>
          <title>Enums</title>
          <para>Conversions to Enum types are supported as follows.</para>
          <table>
            <title>Converting to Enum types</title>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>Source</entry>
                  <entry>Method</entry>
                </row>
              </thead>         
              <tbody>
              <row>
                <entry><emphasis>Number</emphasis></entry>
                <entry><emphasis>EnumType</emphasis><code>.values()[v.intValue()]</code></entry>
              </row>
                
              <row>
                <entry><code>String</code></entry>
                <entry><emphasis>EnumType</emphasis><code>.valueOf(v)</code>. If no matching enum value can be found
                a case-insensitive lookup if done for a matching enum value.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>  
        <para>
        Primitives are boxed before conversion is done.
          Other source types are converted to String before converting to Enum.</para>
      </section>
        
      <section xml:id="service.converter.special.cases.map.entry">
        <title>Map.Entry</title>
        <para>Conversion of <code>Map.Entry&lt;K,V&gt;</code> to a target type is done by evaluating the compatibility of the 
        target type with both the key and the value in the entry and then using the best match. This is done in this order:
        <orderedlist>
          <listitem><para>If one of the key or value is the same as the target type, then this is used.
          If both match, the key is used.</para></listitem>
          <listitem><para>If one of the key or value type is assignable to the target type, then this is used.
          It both are assignable the most specific is used. If key and value type are both assignable and equal
          the key is used.</para></listitem>
          <listitem><para>If one of the key or value is of type <code>String</code>, this is used and converted to the target type.</para></listitem>
          <listitem><para>If none of the above matches the key is converted into a <code>String</code> and this
          value is then converted to the target type.</para></listitem>
        </orderedlist>
        </para>
                        
        <para>Conversion to <code>Map.Entry</code> from another type is not supported.</para>
      </section>
      </section>
    
    <section>
      <title>Aggregates</title>
  
      <para>Aggregates represent Collections and Arrays, including Lists and Sets.</para>
      
      <section>
        <title>Converting to a scalar</title>
        <para>
        If a Collection or array needs to be converted to a scalar,
        the first element is taken and converted into the target type. Example:
        <programlisting>Converter converter = new StandardConverter();
String s = converter.convert(new String[] {"A","B"}).to(String.class)); // s="A"</programlisting></para>
        
        <para>If the collection or array has no elements, the <code>null</code> value is
        used to convert into the target type.</para>
        
        <para><emphasis>Note: </emphasis>deviations from this mechanism can be achieved by using an 
          <xref linkend="org.osgi.service.converter.ConverterBuilder" xrefstyle="hyperlink"/>. For example:
          <programlisting>
// Use an ConverterBuilder to create a customized converter          
ConverterBuilder cb = converter.newConverterBuilder();
cb.rule(String[].class, String.class,
  v -&gt; Stream.of(v).collect(Collectors.joining(",")),
  v -&gt; v.split(","));
Converter c = cb.build();

String s2 = c.convert(new String[] {"A","B"}).to(String.class)); // s2="A,B"
String[] sa = c.convert("A,B").to(String[].class); // sa={"A","B"}</programlisting> 
        </para>
      </section>
      
      <section>
        <title>Converting to an Array or Collection</title>
        <para>A new object is always created to be returned and owned by the caller.
        This is true even it the target type is compatible with the source type.</para>
        
        <table>
          <title>Collection / Array result creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry>Collection interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>java.util.List</code> then the converter can create a
                <code>java.util.ArrayList</code>. When converting to a <code>java.util.Set</code>
                the converter must choose a set implementation that preserves iteration order.</entry>
              </row>
              <row>
                <entry>Collection concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> on the 
                provided type. For example if the target type is <code>LinkedList</code> then the 
                converter creates a target object by calling <code>LinkedList.class.newInstance()</code>.
                The converter may choose to use a call a well-known constructor to optimize the
                creation of the collection.</entry>
              </row>
              <row>
                <entry><code>T[]</code></entry>
                <entry>A new array is created via <code>Array.newInstance(Class&lt;T&gt; cls, int x)</code> where 
                <code>x</code> is the required size of the target collection.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Before inserting values into the resulting collection/array they are converted to the desired
        target type first. In the case of arrays this is the type of the array. When inserting into a 
        Collection generic type information about the target type can be made available by using the
        <xref linkend="org.osgi.service.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.service.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. If no type information is available, source elements are inserted into the target 
        aggregate as-is.</para>
        
        <para>Example: 
        to convert an array of <code>String</code>s into a list of <code>Integer</code>s:
        
        <programlisting>List&lt;Integer&gt; result =
  converter.convert(Arrays.asList("1","2","3")).
    to(new TypeReference&lt;List&lt;Integer&gt;&gt;() {});</programlisting>
    
        The following example converts an array of <code>int</code>s into a set of <code>Double</code>s. Note that
        the resulting set should preserve the same iteration order as the original array:
        
        <programlisting>Set&lt;Double&gt; result =
  converter.convert(new int[] {3,2,1}).
    to(new TypeReference&lt;Set&lt;Double&gt;&gt;() {})
        </programlisting>
        
        Values are inserted in the resulting Collection/array as follows:
        
          <itemizedlist>
            <listitem>
              <para>If the source object is <code>null</code>, an empty collection/array is produced.</para>
            </listitem>
            
            <listitem>
              <para>If the value is not a Collection, Array or Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) a result with
              a single element is produced. The value is first converted into the desired
              target type, if the target type is known.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Collection or Array, then each of its elements is converted 
              into desired target type, if known, before inserting. Elements are inserted into the target
              collection in their normal iteration order.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) then <code>Map.Entry</code> elements 
              are obtained from it via <code>Map.entrySet()</code>. 
              Each <code>Map.Entry</code> element is then converted into the target type before inserting in the
              result.</para>
            </listitem>
          </itemizedlist>         
        </para>
      </section>
      
      <section>
        <title>Converting to maps</title>
        <para>Conversion to a map-like structure from an aggregate is not supported by the Standard Converter.</para>
      </section>
    </section>
    
    <section xml:id="service.converter.special.cases.maps">
      <title>Maps, Interfaces, Java Beans, DTOs and Annotations</title>
      <para>Entities that can hold multiple key-value pairs are all treated in a similar way. These entities
      include Maps, Dictionaries, Interfaces, Java Beans, Annotations and OSGi DTOs. We will call these map-like types.
      Additionally objects that provide a map view
      are supported.</para>
      
      <para>When converting between map-like types, a <code>Map</code> can be used as intermediary.
      When converting to other structures, the map is converted into a collection of
      <code>Map.Entry</code> values which in turn is converted into the target type.
      </para>
      
      <para>When converting to a map-like type, a new object is always created to be returned and owned by the caller.
      This is true even it the target type is compatible with the source type.</para>
      
      <section>
        <title>Converting to a Map</title>
        <table>
          <title>Map result creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry>Map interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>ConcurrentNavigableMap</code> then the implementation can create a 
                <code>ConcurrentSkipListMap</code>.</entry>
              </row>
              <row>
                <entry>Map concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> 
                on the provided type. For example if the target type is <code>HashMap</code> 
                then the converter creates a target object by calling
                <code>HashMap.class.newInstance()</code>.
                The converter may choose to use a call a well-known constructor to optimize the
                creation of the map.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Each key-value pair in the source map is converted to desired types of the target map
        using the generic information if available.
        
        Map type information for the target type can be made available by using the
        <xref linkend="org.osgi.service.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.service.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. If no type information is available, key-value pairs are inserted into the map as-is.    
        </para>      
      </section>
      
      <section>
        <title>Dictionary</title>
        <para>Converting between a map and a <code>Dictionary</code> is done by iterating over the
        source and inserting the key value pairs in the result, converting them to the requested target 
        type, if known. As with other generic types, target type information for Dictionaries can be provided
        via a <xref linkend="org.osgi.service.converter.TypeReference" xrefstyle="hyperlink"/>.</para> 
      </section>
      
      <section>
        <title>Interface</title>
        <para>Conversions to and from an interface are done in a lazy fashion meaning that
        values are only obtained when they are actually needed. When converting to an interface, 
        defaults can be specified using the one-arg overloads in the interface. Converting from an 
        interface does not provide this mechanism for defaults. Annotations can provide a good
        alternative to interfaces as they make it possible to specify the default in the annotation
        code.</para>
        <section>
        <title>Converting to an Interface</title>
        <para>When converting into an interface the converter will create a dynamic proxy to 
        implement the interface. The name of the method returning the value should match the key 
        of the map entry, taking into account the mapping rules specified in 
        <xref linkend="service.converter-key.mapping"/>.
        The key of the map may need to be converted into a <code>String</code> first.</para>
        
        <para>Conversion is done <emphasis>on demand</emphasis>: only when the method on 
        the interface is actually invoked. This avoids conversion errors on methods 
        for which the information is missing or cannot be converted, but which the caller 
        does not require.</para>
        
        <para>Note that the converter will not copy the source map when converting to an interface
        so any changes to the source map will be reflected live to the proxy.</para>
        
        <para>Interfaces can provide methods for default values by providing a single-argument method
        override in addition to the no-arg method matching the key name. If the type of the default
        does not match the target type it is converted first. 
        For example:  
        <programlisting>interface Config {
  int my_value(); // no default
  int my_value(int defVal);
  int my_value(String defVal); // String value is automatically converted to int
  boolean my_other_value();
}

// Usage
Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;(); // an example map
myMap.put("my.other.value", "true");
Config cfg = converter.convert(myMap).to(Config.class);
int val = cfg.my_value(17); // if not set then use 17
boolean val2 = cfg.my_other_value(); // val2=true
</programlisting>
        Default values are used when the key is not present in the map for the method. If a key is 
        present with a <code>null</code> value, then <code>null</code> is taken as the value and 
        converted to the target type.</para>
        
        <para>If no default is specified and a requested value is not present in the map,
        a <code>ConversionException</code> is thrown.</para>
      </section>
      <section>
        <title>Converting from an Interface</title>
        <para>
        Whether a conversion source object is an interface is determined dynamically, taking the
        <xref linkend="service.converter-priorities"/> into account. When an object implements multiple interfaces
        only the first interface from these is taken as the source type. 
        </para>
        <para>
        When converting from an interface to another map-like structure, the converter returns 
        a lazy map of which all the keys are pre-populated from any non-void no-arg methods in the interface. 
        The mapping rules as described in
        <xref linkend="service.converter-key.mapping"/> are taken into account when mapping the 
        method names to keys in the map.
        Values are retrieved from the underlying interface in a lazy manner. Only when the client looks up a
        given key or iterates through all entries or values these are obtained from the underlying map. 
        </para>
      </section>
      <section xml:id="service.converter-key.mapping">
        <title>Key Mapping</title>

        <para>The key name is derived from the method name.
        Certain common property name characters, such as full stop (<code>'.'
        \u002E</code>) are not valid in Java identifiers. So the name of a
        method must be converted to its corresponding property name as
        follows:<itemizedlist>
            <listitem>
              <para>A single dollar sign (<code>'$' \u0024</code>) is removed
              unless it is followed by another dollar sign in which case the
              two consecutive dollar signs (<code>"$$"</code>) are converted
              to a single dollar sign.</para>
            </listitem>

            <listitem>
              <para>A single low line (<code>'_' \u005F</code>) is converted
              into a full stop (<code>'.' \u002E</code>) unless is it followed
              by another low line in which case the two consecutive low lines
              (<code>"__"</code>) are converted to a single low line.</para>
            </listitem>

            <listitem>
              <para>All other characters are unchanged.</para>
            </listitem>
          </itemizedlist></para>

        <para><xref
        linkend="service.converter-key.name.mapping"/> contains
        some name mapping examples.</para>

        <table xml:id="service.converter-key.name.mapping">
          <title>Name Mapping Examples</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="1*"/>

            <colspec colnum="2" colwidth="1*"/>

            <thead>
              <row>
                <entry>Method Name</entry>

                <entry>Property Name</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>myProperty143</code></entry>

                <entry><code>myProperty143</code></entry>
              </row>

              <row>
                <entry><code>$new</code></entry>

                <entry><code>new</code></entry>
              </row>

              <row>
                <entry><code>my$$prop</code></entry>

                <entry><code>my$prop</code></entry>
              </row>

              <row>
                <entry><code>dot_prop</code></entry>

                <entry><code>dot.prop</code></entry>
              </row>

              <row>
                <entry><code>_secret</code></entry>

                <entry><code>.secret</code></entry>
              </row>

              <row>
                <entry><code>another__prop</code></entry>

                <entry><code>another_prop</code></entry>
              </row>

              <row>
                <entry><code>three___prop</code></entry>

                <entry><code>three_.prop</code></entry>
              </row>

              <row>
                <entry><code>four_$__prop</code></entry>

                <entry><code>four._prop</code></entry>
              </row>

              <row>
                <entry><code>five_$_prop</code></entry>

                <entry><code>five..prop</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
        
      </section>
      
      <section>
        <title>Annotation</title>
        <para>Conversion to and from annotations behaves identical to 
        interface conversion with the added capability of specifying a default in the annotation definition.
        </para>
        
        <para>Below a few examples of conversions to an annotation:
        <programlisting>@interface MyAnnotation {
  String[] args() default {"arg1", "arg2"};
}

// Will set sa={"args1", "arg2"}
String[] sa = converter.convert(new HashMap()).to(MyAnnotation.class).args();

// Will set a={"x", "y", "z"}
Map m = Collections.singletonMap("args", new String [] {"x", "y", "z"});
String[] a = converter.convert(m).to(MyAnnotation.class).args();

// Will set a1={}
Map m1 = Collections.singletonMap("args", null)
String[] a1 = converter.convert(m1).to(MyAnnotation.class).args();

// Will set a2={""}
Map m2 = Collections.singletonMap("args", "")
String[] a2 = converter.convert(m2).to(MyAnnotation.class).args();

// Will set a3={","}
Map m3 = Collections.singletonMap("args", ",")
String[] a3 = converter.convert(m3).to(MyAnnotation.class).args();</programlisting>
        </para>
      </section>
      
      <section>
        <title>Java Beans</title>
        <para>Java Beans are concrete (non-abstract) classes that follow a naming convention. They provide 
        public getters and setters to
        access their properties and have a public no-arg constructor. When converting from a Java Bean introspection
        is used to find the read accessors. A read accessor must have no arguments and a non-<code>void</code> return 
        value. The method name must start with get followed by a capitalized property name, 
        e.g. <code>getSize()</code> provides access to the property <code>size</code>. 
        For <code>boolean/Boolean</code> properties a prefix of <code>is</code>
        is also permitted.</para> 
        <para>When converting to a Java Bean, the bean is constructed eagerly. All available properties
            are set in the bean using the bean's write accessors, i.e. public setters methods with a single argument. 
            All methods of the bean class itself and its 
            super classes are considered. 
            If a property cannot be converted this will cause a 
            <xref linkend="org.osgi.service.converter.ConversionException" xrefstyle="hyperlink"/>.
            </para>
        <para><emphasis>Note: </emphasis>access via indexed bean properties is not supported as there is no way to 
        find out the size of the array via these accessors.
        </para>
        <para><emphasis>Note: </emphasis>the <code>getClass()</code> method of the <code>java.lang.Object</code>
        class is not considered an accessor.
        </para>
        <remark>Do we need explicitly call out certain types that are not treated as JavaBeans? E.g. String?</remark>
      </section>
      
      <section>
        <title>DTOs</title>
        <para>
        DTOs are classes with public non-static fields and no methods other than the ones provided by the 
        <code>java.lang.Object class</code>. OSGi DTOs extend the <code>org.osgi.dto.DTO</code> class. 
        DTOs may have static fields, these are ignored by the converter.</para>
        
        <para>When converting to a DTO, the converter attempts to find fields that match the key of each 
        entry in the map and then converting the value to the field type before assigning it. They key of
        the map entries may need to be converted into a String first. Keys are mapped according to 
        <xref linkend="service.converter-key.mapping"/>.</para>
        
        <para>When converting from a DTO the value of each public non-static field is put in the target 
        map, taking the field name as its String key.
        </para>
      </section>
      
      <section>
        <title>Types with getProperties()</title>
        
        <para>The converter uses reflection to find a <code>java.util.Map getProperties()</code> or 
        <code>java.util.Dictionary getProperties()</code> method on the source type to obtain a map view over
        the source object. This map view can be used to convert the source object to another map-like structure.</para>
        
        <para><emphasis>Note: </emphasis>this mechanism can only be used to convert <emphasis>to</emphasis> another type. 
        The reverse is not supported</para>
      </section>
    </section>
    
    <section xml:id="service.converter-priorities">
      <title>Priority</title>
      
      <para>In case multiple conversion rules match, the rule with the highest priority is used, where 1 is the highest overall priority.
      </para>
      <table>
        <title>Conversion rule priority</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Priority</entry>
              <entry>Rule</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>array</entry>
            </row>

            <row>
              <entry>2</entry>
              <entry>Java bean</entry>
            </row>
            
            <row>
              <entry>3</entry>
              <entry>annotation</entry>
            </row>
            
            <row>
              <entry>4</entry>
              <entry>interface (including Collections and Maps)</entry>
            </row>

            <row>
              <entry>5</entry>
              <entry><emphasis>entity.</emphasis><code>getProperties()</code></entry>
            </row>
            
            <row>
              <entry>6</entry>
              <entry>DTO</entry>
            </row>
            
            <row>
              <entry>7</entry>
              <entry>scalar</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <remark>What if something is both a JavaBean and a scalar? E.g. String or UUID? How do we decide to that it is treated as a scalar vs a map-like structure?
      Can we make it depend on the target class? I.e. UUID -&gt; scalar via toString() and UUID -&gt; map via JavaBean accessors?</remark>
    </section>
    
    <section>
      <title>Conversion failures</title>
      <para>...</para>
    </section>
  </section>

  <section>
    <title>Security</title>
    <para>...</para>
  </section> 

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.converter.xml"/>
 
  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
