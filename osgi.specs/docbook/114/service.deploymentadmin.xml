<?xml version="1.0" encoding="utf-8"?>
<chapter label="114"
         revision="$Id$"
         version="5" xml:id="i1610676" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Deployment Admin Specification</title>

  <info xml:id="i1724530">
    <releaseinfo>Version 1.1</releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The ability to install new software components after the time of
    manufacture is of increasing interest to manufacturers, operators, and end
    users. End users already are, or soon will be, accustomed to installing
    applications or services on their devices from remote servers.</para>

    <para>The OSGi Service Platform provides mechanisms to manage the
    lifecycle of bundles, configuration objects, and permission objects, but
    the overall consistency of the runtime configuration is the responsibility
    of the <emphasis>management agent</emphasis>. In other words, the
    management agent decides to install, update, or uninstall bundles, create
    or delete configuration or permission objects, and manage other resource
    types.</para>

    <para>The task of the management agent is extensive because it must track
    the sometimes fine-grained dependencies and constraints between the
    different resource types. This model, though extremely flexible, leaves
    many details up to the implementation—significantly hindering the
    inter-operability of devices because it does not unify the management
    aspects from the management systems point of view. This specification,
    therefore, introduces the <emphasis>Deployment Admin service</emphasis>
    that standardizes the access to some of the responsibilities of the
    management agent: that is, the life-cycle management of interlinked
    resources on an OSGi Service Platform.The role of the Deployment Admin
    service is depicted in <phrase role="xref"> <xref linkend="i1373114"
    xrefstyle="FigureNumber"/></phrase> .</para>

    <figure xml:id="i1373114">
      <title>Deployment Admin role</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.772in"
                     contentwidth="4.947in" fileref="deploymentadmin-role.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Installing/Uninstalling</emphasis> – Provide a
          Deployment Package concept to install and uninstall bundles and
          related resources on an OSGi Service Platform as an atomic
          unit.</para>
        </listitem>

        <listitem>
          <para><emphasis>Tamper Detection</emphasis> – Provide detection of
          changes to a Deployment Package.</para>
        </listitem>

        <listitem>
          <para><emphasis>Securing</emphasis> – Provide a security model that
          allows Operators to control the Deployment Packages that are
          installed on an OSGi Service Platform.</para>
        </listitem>

        <listitem>
          <para><emphasis>Media Independence</emphasis> – Deployment Packages
          must have the capacity to load from different media such as CD-ROM,
          over the air, wireless, etc.</para>
        </listitem>

        <listitem>
          <para><emphasis>Management</emphasis> – Management of a repository
          of Deployment Packages must be possible locally on the device as
          well as remotely.</para>
        </listitem>

        <listitem>
          <para><emphasis>Customizing</emphasis> – The author of a Deployment
          Package must be permitted to customize the environment during the
          installation and uninstallation operations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Extending</emphasis> – The resource types that are
          used in a Deployment Package must be easy to extend.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Resource </emphasis>– A file in a Deployment Package
          that is processed to create artifacts in the Service Platform. For
          example, bundles, configurations, and permissions are different
          resources.</para>
        </listitem>

        <listitem>
          <para><emphasis>Deployment Admin Service </emphasis>– The service
          that is used to install and uninstall Deployment Packages, as well
          as to provide information about the repository of Deployment
          Packages.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resource Processor </emphasis>– A service that can
          handle the lifecycle of a specific resource type. It processes a
          resource to create a number of artifacts that are removed when the
          resource is dropped.</para>
        </listitem>

        <listitem>
          <para><emphasis>Deployment Package</emphasis> – A group of resources
          that must be treated as a unit. Unbreakable dependencies exist among
          these resources.</para>
        </listitem>

        <listitem>
          <para><emphasis>Artifact</emphasis> – A construct that is created
          from a Resource in a Deployment Package. A resource can have zero or
          more artifacts related to it. Artifacts do not have a common
          interface because their nature differs and their existence is
          abstracted by the Resource Processor services. Artifacts must be
          removed when their related resources are dropped. An example of an
          artifact is a Configuration object that is created from an
          configuration file in a Deployment Package.</para>
        </listitem>

        <listitem>
          <para><emphasis>Customizer</emphasis> – A bundle carried in a
          Deployment Package that can perform initialization during an install
          operation and cleanup during an uninstall operation.</para>
        </listitem>

        <listitem>
          <para><emphasis>Fix Package</emphasis> – A Deployment Package that
          is an update to an resident Deployment Package, which does not carry
          some resources because they are unchanged.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Deployment Admin Service, org.osgi.service.deploymentadmin
        package</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.471in"
                       contentwidth="7.000in"
                       fileref="deploymentadmin-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Synopsis</title>

      <para>A developer can package a number of resources in a Deployment
      Package. A Deployment Package is stored in a JAR file, with a format
      that is similar to bundles. A Deployment Package JAR can be installed
      via the Deployment Admin service via an input stream. The Deployment
      Admin service manages the bundle resources itself, but processes every
      other resource in the Deployment Package by handing them off to a
      Resource Processor service that is designated for that resource. The
      Resource Processor service will then process the resource to create a
      number of artifacts.</para>

      <para>The uninstallation and update of a Deployment Package works in a
      similar manner. All Resource Processor services are notified about any
      resources that are dropped or changed.</para>

      <para>If all resources have been processed, the changes are committed.
      If an operation on the Deployment Admin service fails, all changes are
      rolled back. The Deployment Admin service is not, however, guaranteed to
      support all features of transactions.</para>
    </section>
  </section>

  <section xml:id="i1604402">
    <title>Deployment Package</title>

    <para>A Deployment Package is a set of related
    <emphasis>resources</emphasis> that need to be managed as a
    <emphasis>unit</emphasis> rather than individual pieces. For example, a
    Deployment Package can contain both a bundle and its configuration data.
    The resources of a Deployment Package are tightly coupled to the
    Deployment Package and cannot be shared with other Deployment
    Packages.</para>

    <para>A Deployment Package is not a script that brings the system from one
    consistent state to another; several deployment packages may be needed to
    achieve a new consistent state. Like a bundle, a Deployment Package does
    not have to be self-contained. Its bundle resources can have dependencies
    on Java packages and services provided by other Deployment
    Packages.</para>

    <para>For example, a suite of games shares some parts that are common to
    both games. The suite contains two games: Chess
    (<code>com.acme.chess</code>) and Backgammon
    (<code>com.acme.backg</code>). Both share a top-score database as well as
    a 3D graphic library.</para>

    <itemizedlist>
      <listitem>
        <para><code>com.third.3d</code> – The 3D graphic library comes from a
        third-party provider. It is a Deployment Package of its own, composed
        of several bundles and possible configuration objects.</para>
      </listitem>

      <listitem>
        <para><code>com.acme.score</code> – The top-score database would also
        be its own Deployment Package, and would in fact be optional. It
        offers a service for storing top scores, but games can function
        without this service.</para>
      </listitem>
    </itemizedlist>

    <para>Each game is a Deployment Package, allowing them to be installed
    independently. Alternatively, the two games can be packaged into the same
    Deployment Package, but in this case they must be installed and removed
    together and can no longer be deployed independently.</para>

    <para>These two different packaging strategies cannot be used
    simultaneously. Once the games are deployed separately, they can no longer
    be grouped later in an update, because that action would move ownership of
    the bundle resource to another Deployment Package—which is specifically
    not allowed. A bundle resource can belong to only one Deployment
    Package.</para>

    <para>These two packaging scenarios are depicted in <phrase role="xref">
    <xref linkend="i1377011" xrefstyle="FigureNumber"/></phrase> .</para>

    <figure xml:id="i1377011">
      <title>Packaged game</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.702in"
                     contentwidth="4.913in" fileref="packaged-game.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Deployment Packages are managed as <emphasis>first-class
    citizens</emphasis> during runtime, similar to bundles. The
    <code>DeploymentPackage</code> object represents this concept in
    runtime.</para>

    <section>
      <title>Resources</title>

      <para>A Deployment Package consists of installable
      <emphasis>resources</emphasis>. Resources are described in the
      <emphasis>Name sections</emphasis> of the Manifest. They are stored in
      the JAR file under a path. This path is called the <emphasis>resource
      id</emphasis>.</para>

      <para>Subsets of these resources are the bundles. Bundles are treated
      differently from the other resources by the Deployment Admin service.
      Non-bundle resources are called <emphasis>processed
      resources</emphasis>.</para>

      <para>Bundles are managed by the Deployment Admin service directly. When
      installing a new bundle, the Deployment Admin service must set the
      bundle location to the following URL:</para>

      <programlisting>location ::= 'osgi-dp:' bsn
bsn      ::= unique-name     // See <phrase role="xref">1.3.2</phrase> Core</programlisting>

      <para>The <code>bsn</code> stands for the bundle’s Bundle Symbolic Name,
      without any parameters, which implies that only a single version of a
      bundle can be installed at any moment in time. The <code>osgi-dp:</code>
      scheme is not required to have a valid URL handler.</para>

      <para>Processed resources are not managed directly by the Deployment
      Admin service; their management must be handed off to a Resource
      Processor service that is selected in the Name section. The logical
      structure and processing of resources is depicted in <phrase
      role="xref"> <xref linkend="i1599199"
      xrefstyle="FigureNumber"/></phrase> .</para>

      <figure xml:id="i1599199">
        <title>Structure of a Deployment Package</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.373in"
                       contentwidth="4.967in"
                       fileref="structure-deployment-package.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Atomicity and Sharing</title>

      <para>A Deployment Package is a reified concept, like a bundle, in an
      OSGi Service Platform. It is created and managed by the Deployment Admin
      service. As a unit, a Deployment Package should be installed or
      uninstalled atomically.</para>

      <para>Deployment packages provide an ownership model for resources
      installed in an OSGi Service Platform. A Deployment Package contains
      resources, which once processed, will result in the creation of a number
      of artifacts in the OSGi Platform such as:</para>

      <itemizedlist>
        <listitem>
          <para>Installed bundles</para>
        </listitem>

        <listitem>
          <para>Configuration objects</para>
        </listitem>

        <listitem>
          <para>System properties</para>
        </listitem>

        <listitem>
          <para>Certificates</para>
        </listitem>

        <listitem>
          <para>Wiring schemes</para>
        </listitem>
      </itemizedlist>

      <para>A Deployment Package will <emphasis>own</emphasis> its resources.
      If a Deployment Package is uninstalled, all its resources, and thus its
      artifacts, must be removed as well. The ownership model follows a
      <emphasis>no-sharing</emphasis> principle: equal resources are not
      shared between deployment packages.</para>

      <para>The meaning of "equal" is dependent on the resource type. For
      example, two bundles are considered equal if their bundle symbolic name
      is equal, regardless of the version.</para>

      <para>A sharing violation must be considered an error. The install or
      update of the offending Deployment Package must fail if a resource would
      be affected by another Deployment Package. The verification of this rule
      is delegated to the Resource Processor services, or the Deployment Admin
      service in case of bundles.</para>

      <para>For example, a Deployment Package could be used to install bundles
      and configuration objects for Managed Services (singleton
      configurations). Because of the no-sharing principle, an installed
      bundle must belong to one—and only one—Deployment Package (as defined by
      its Bundle Symbolic Name). A singleton configuration can be set only
      when the associated bundle is in the same Deployment Package. Trying to
      install a Deployment Package when one of the bundles or one of the
      configuration objects is already present and associated with another
      Deployment Package is an error, and the install must fail in such a
      case.</para>

      <para>This strong no-sharing rule ensures a clean and robust lifecycle.
      It allows the simple cleanup rule: the Deployment Package that installs
      a resource is the one that must uninstall it.</para>
    </section>

    <section xml:id="i1601053">
      <title>Naming</title>

      <para>Every Deployment Package must have a name and a version. Package
      authors should use unique reverse domain naming, like the naming used
      for Java packages. The version syntax must follow the rules defined in
      <phrase role="xref">Version on page 27</phrase> in <phrase role="xref">
      <xref linkend="i1516004" xrefstyle="Reference"/></phrase> ; the version
      must be specified.</para>

      <para>The name is set with a Manifest header. This name is used to
      detect whether an install is an update (an Deployment Package has the
      given name) or an install (no such Deployment Package exists). The name
      must be compared in a case-sensitive manner.</para>

      <para>Together, the name and version specify a unique Deployment
      Package; a device will consider any Deployment Package with the same
      name and version pairs to be identical. Installing a Deployment Package
      with a name version identical to the existing Deployment Package must
      not result in any actions.</para>

      <para>Deployment packages with the same name but different versions are
      considered to be <emphasis>versions</emphasis> of the
      <emphasis>same</emphasis> deployment package. The Deployment Admin
      service maintains a repository of installed Deployment Packages. This
      set must not contain multiple versions of the same Deployment Package.
      Installing a deployment package when a prior or later version was
      already present must cause replacement of the existing deployment
      package. In terms of version, this action can be either an upgrade or
      downgrade.</para>
    </section>
  </section>

  <section>
    <title>File Format</title>

    <para>A Deployment Package is a standard JAR file as specified in <phrase
    role="xref"> <xref linkend="i1515091" xrefstyle="Reference"/></phrase> .
    The extension of a Deployment Package JAR file name should be
    <code>.dp</code>. The MIME type of a Deployment Package JAR should
    be:</para>

    <programlisting>application/vnd.osgi.dp</programlisting>

    <para>For example, valid Deployment Package JAR names are:</para>

    <programlisting>com.acme.chess.dp
chess.dp</programlisting>

    <para>A Deployment Package must be formed in such a way that it can be
    read with a <code>JarInputStream</code> object. Therefore, the order of
    the files in the JAR file is important. The order must be:</para>

    <orderedlist>
      <listitem>
        <para><code>META-INF/MANIFEST.MF</code> – A Deployment Package must
        begin with a standard Java Manifest file. This rule is not explicitly
        defined in the Java JAR file specification; it is implied, however, by
        the known <code>JarInputStream</code> class implementations.</para>
      </listitem>

      <listitem>
        <para><code>META-INF/*.SF, META-INF/*.DSA, META-INF/*.RS</code> – If
        the Deployment Package is signed, subsequent files in the JAR must be
        the signature files as defined in the manifest specification. The
        signature files are not considered resources. Signing is discussed in
        <phrase role="xref"> <xref linkend="i1599278"
        xrefstyle="seeHeadingPage"/></phrase> .</para>
      </listitem>

      <listitem>
        <para><emphasis>Localization files</emphasis> – Any manifest
        localization files are normally stored in the <code>OSGI-INF</code>
        directory. Localization files must precede the other files because the
        resource processors can require localized information.</para>
      </listitem>

      <listitem>
        <para><emphasis>Bundles</emphasis> must come before any other resource
        types so that they can be installed before any processed
        resources.</para>
      </listitem>

      <listitem>
        <para><emphasis>Resources</emphasis> – Any processed resources needed
        for this package. Resources are processed in the order in which they
        appear in the JAR file, and dropped in reverse order.</para>
      </listitem>
    </orderedlist>

    <para>The order of all the resources in the JAR file is significant, and
    is called the <emphasis>resource order</emphasis>. The purpose of the
    resource order is to allow the JAR to be processed as a stream. It is not
    necessary to buffer the input stream in memory or to hard disk, or to
    allow random access to its contents. The specification allows access to
    the stream sequentially. To increase the determinism, the resource order
    must also determine the processing order of the bundles and the
    resources.</para>

    <para>The format is shown graphically in <phrase role="xref"> <xref
    linkend="i1599435" xrefstyle="FigureNumber"/></phrase> .</para>

    <figure xml:id="i1599435">
      <title>Deployment Package JAR format</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.965in"
                     contentwidth="5.024in" fileref="jar-format.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section xml:id="i1599278">
      <title>Signing</title>

      <para>Deployment packages are optionally signed by JAR signing,
      compatible with the operation of the standard
      java.<code>util.jar.JarInputStream</code> class, i.e. as defined in
      <phrase role="xref">JAR Structure and Manifest on page 10</phrase> of
      <phrase role="xref"> <xref linkend="i1516004"
      xrefstyle="Reference"/></phrase> . This compatibility requires that the
      manifest must be the first file in the input stream, and the signature
      files must follow directly thereafter.</para>

      <para>A Deployment Package must follow the same rules for signing as
      bundles, described in the Framework specification, <phrase
      role="xref">Digitally Signed JAR Files on page 10</phrase> in <phrase
      role="xref"> <xref linkend="i1516004" xrefstyle="Reference"/></phrase>
      .</para>

      <para>The Deployment Admin service must reject a Deployment Package that
      has an invalid signature.</para>
    </section>

    <section xml:id="i1599719">
      <title>Path Names</title>

      <para>Path names must be limited to remove some of the unnecessary
      complexities that are caused by path names that can contain any Unicode
      character. Therefore, a path name must not contain any character
      except:</para>

      <programlisting>[A-Za-z0-9_.-]</programlisting>

      <para>Directories are separated by a forward slash character (<code> ’/’
      \u002F</code>).</para>
    </section>

    <section>
      <title>Deployment Package Manifest</title>

      <para>The Manifest of a Deployment Package consists of a
      <emphasis>global section</emphasis> and separate sections for each
      resource contained within it, called the <emphasis>Name
      sections</emphasis>. The global section of a Deployment Package Manifest
      can contain the following headers that have a defined meaning in this
      specification:</para>

      <itemizedlist>
        <listitem>
          <para><code>DeploymentPackage-SymbolicName</code> – The name of the
          deployment package as a reverse domain name. For example,
          <code>com.acme.chess</code>. See further <phrase role="xref"> <xref
          linkend="i1515351" xrefstyle="seeHeadingPage"/></phrase> .</para>
        </listitem>

        <listitem>
          <para><code>DeploymentPackage-Version</code> – The version of the
          deployment package as defined in <phrase role="xref"> <xref
          linkend="i1516004" xrefstyle="Reference"/></phrase> . See further
          <phrase role="xref"> <xref linkend="i1515367"
          xrefstyle="seeHeadingPage"/></phrase> .</para>
        </listitem>

        <listitem>
          <para><code>DeploymentPackage-FixPack</code> – Marks this deployment
          package as a partial update to a resident deployment package. See
          <phrase role="xref"> <xref linkend="i1588451"
          xrefstyle="seeHeadingPage"/></phrase> .</para>
        </listitem>
      </itemizedlist>

      <para>The following headers provide information about the Deployment
      Package, but are not interpreted by the Deployment Admin service.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>DeploymentPackage-Name – </emphasis>A human readable
          of this deployment package. This name can be localized.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-Copyright</emphasis> – Specifies
          the copyright statement for this Deployment Package.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-ContactAddress</emphasis> – How to
          contact the vendor/developer of this Deployment Package.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-Description</emphasis> – A short
          description of this Deployment Package.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-DocURL</emphasis> – A URL to any
          documentation that is available for this Deployment Package. The URL
          can be relative to the JAR file.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-Icon</emphasis> – A URL to an
          image file that is an icon for this deployment package. The URL can
          be relative to the JAR file.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-Vendor</emphasis> – The vendor of
          the Deployment Package.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-License</emphasis> – A URL to a
          license file. The URL can be relative to the Deployment Package JAR
          file.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-RequiredStorage</emphasis> – The
          minimum amount of persistent storage required by the deployment
          package after successful install or update.</para>
        </listitem>
      </itemizedlist>

      <para>As with any JAR file Manifest, additional headers can be added and
      must be ignored by the Deployment Admin service. If any fields have
      human readable content, localization can be provided through property
      files as described in <phrase role="xref">Localization on
      page 64</phrase> in <phrase role="xref"> <xref linkend="i1516004"
      xrefstyle="Reference"/></phrase> . The Deployment Admin service must
      always use the raw, untranslated version of the header values.</para>

      <para>For example, the global section of a Deployment Package Manifest
      could look like:</para>

      <programlisting>Manifest-Version: 1.0
DeploymentPackage-SymbolicName: com.third._3d
DeploymentPacakge-Version: 1.2.3.build22032005
DeploymentPackage-Copyright: ACME Inc. (c) 2003
<symbol>↵</symbol></programlisting>

      <para>Additionally, the Deployment Package Manifest must carry a
      <emphasis>Name section</emphasis> for each resource in the JAR file
      (except the resources in the <code>META-INF</code> directory). Each name
      section must start with an empty line (carriage return and line feed,
      shown as <symbol>↵</symbol> when its usage could be ambiguous).</para>

      <para>The Name section must start with a <code>Name</code> header that
      contains the path name of the resource. This path name is also used as
      resource id. The path name must be constructed with the characters as
      defined in <phrase role="xref"> <xref linkend="i1599719"
      xrefstyle="seeHeadingPage"/></phrase> . For example:</para>

      <programlisting>Name: bundles/3dlib.jar</programlisting>

      <para>The name section can include any additional relevant meta data for
      the named resource. For bundles, only the specification of the
      <code>Bundle-SymbolicName</code> and <code>Bundle-Version</code> headers
      are required, but other headers can be added. Unrecognized headers are
      allowed and must be ignored by the Deployment Admin service. The Name
      section is also used by the JAR signing to include digests of the actual
      resources.</para>

      <para>The following headers are architected for the Name section in the
      manifest of a deployment package:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Bundle-SymbolicName</emphasis> – Only for bundle
          resources. This header must be identical to the Bundle Symbolic Name
          of the named bundle. If there is a discrepancy, the install of the
          Deployment Package must fail. If the bundle resource has no
          Bundle-SymbolicName in its manifest, however, the Deployment Admin
          must use the given symbolic name for the calculation of the location
          of this bundle.</para>
        </listitem>

        <listitem>
          <para><emphasis>Bundle-Version</emphasis> – Only for bundle
          resources. This header must be identical to the bundle version of
          the named bundle. Its syntax must follow the version syntax as
          defined in the Framework specification. The installation must fail
          if incorrect.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-Missing</emphasis> –
          (<code>true|false</code>) Indicates that the resource is logically
          part of the Deployment Package but that a previous version of the
          Deployment Package already contained this resource—there is no data
          for this resource. See <phrase role="xref"> <xref linkend="i1588451"
          xrefstyle="seeHeadingPage"/></phrase> for a further
          explanation.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resource-Processor</emphasis> – The PID of the
          Resource Processor service that must install the given
          resource.</para>
        </listitem>

        <listitem>
          <para><emphasis>DeploymentPackage-Customizer</emphasis> –
          (<code>true|false</code>) Indicates whether this bundle is a
          customizer bundle by listing a PID for the customizer service. See a
          further discussion in <phrase role="xref"> <xref linkend="i1474626"
          xrefstyle="seeHeadingPage"/></phrase> .</para>
        </listitem>
      </itemizedlist>

      <para>An example Manifest of a Deployment Package that deploys the 3D
      package, consisting of two bundles and no resources, could look
      like:</para>

      <programlisting>Manifest-Version: 1.0
DeploymentPackage-Icon: %icon
DeploymentPackage-SymbolicName: com.third._3d
DeploymentPacakge-Version: 1.2.3.build22032005
<symbol>↵</symbol>
Name: bundles/3dlib.jar
SHA1-Digest: MOez1l4gXHBo8ycYdAxstK3UvEg=
Bundle-SymbolicName: com.third._3d
Bundle-Version: 2.3.1
<symbol>↵</symbol>
Name: bundles/3dnative.jar
SHA1-Digest: N8Ow2UY4yjnHZv5zeq2I1Uv/+uE=
Bundle-SymbolicName: com.third._3d.native
Bundle-Version: 1.5.3
<symbol>↵</symbol>
Name: OSGI-INF/autoconf.xml
SHA1-Digest: M78w24912HgiZv5zeq2X1Uv-+uF=
Resource-Processor:      
  org.osgi.deployment.rp.autoconf 
<symbol>↵</symbol></programlisting>
    </section>

    <section>
      <title>Deployment Package Headers</title>

      <para>This section contains a detailed description of the different
      headers for a Deployment Package with their value syntax.</para>

      <section xml:id="i1515351">
        <title>DeploymentPackage-SymbolicName</title>

        <para>The name of the deployment package. A name must follow the same
        rules as Java packages. The grammar is as follows:</para>

        <programlisting>DeploymentPackage-SymbolicName ::= unique-name 
                                    // See <phrase role="xref">1.3.2</phrase> Core</programlisting>

        <para>This header is mandatory and must not be localized.</para>

        <para>An example is:</para>

        <programlisting>DeploymentPackage-SymbolicName: com.acme.chess</programlisting>
      </section>

      <section xml:id="i1515367">
        <title>DeploymentPackage-Version</title>

        <para>This header defines the version of the deployment package. The
        syntax follows the standard OSGi Framework rules for versions.</para>

        <programlisting>DeploymentPackage-Version ::= version    //See <phrase
            role="xref">3.2.5</phrase> Core</programlisting>

        <para>This header is mandatory and must follow the syntax of the
        version. It must not be localized.</para>

        <para>An example:</para>

        <programlisting>DeploymentPackage-Version: 1.2.3.build200501041230</programlisting>
      </section>

      <section>
        <title>DeploymentPackage-FixPack</title>

        <para>A fix package can be distinguished from the full format
        Deployment Package through the presence of the
        DeploymentPackage-FixPack header, contained within the global section
        of the Manifest. The format of this header is:</para>

        <programlisting>DeploymentPackage-FixPack ::= version-range 
                                    // See <phrase role="xref">3.2.6</phrase> Core</programlisting>

        <para>The version range syntax is identical to the Framework module’s
        layer version range as defined in <phrase role="xref"> <xref
        linkend="i1516004" xrefstyle="Reference"/></phrase> . For example, a
        Manifest header that denotes a fix package which is only applicable to
        versions 1.3 through 3.4 of a given deployment package looks
        like:</para>

        <programlisting>DeploymentPackage-FixPack: [1.3,3.4]</programlisting>

        <para>See <phrase role="xref"> <xref linkend="i1588451"
        xrefstyle="seeHeadingPage"/></phrase> for more information about Fix
        Packages.</para>
      </section>

      <section xml:id="i1774992">
        <title>DeploymentPackage-Icon</title>

        <para>This header contains a URL (absolute or relative to the JAR
        file) to an image resource that represents this deployment package.
        Implementations should support at least the HTTP protocol as well as
        the PNG image file. This URL can be localized. The Deployment Admin
        service must maintain a local copy of the image resource. A URL to
        this local resource can be obtained with the <phrase
        role="xref">getIcon()</phrase> method.</para>

        <programlisting>DeploymentPackage-Icon ::= url
url ::= &lt;absolute or relative URL or localization name&gt;</programlisting>

        <para>For example:</para>

        <programlisting>DeploymentPackage-Icon: %icon</programlisting>
      </section>

      <section>
        <title>DeploymentPackage-Name</title>

        <para>This header is available as the <code>DeploymentPackage</code>
        <code>getDisplayName</code> method. It provides a human readable name
        that can be localized. It is available through the <phrase
        role="xref">getDisplayName()</phrase> method. This name can be
        localized.</para>

        <programlisting>DeploymentPackage ::= name
name              ::= &lt;any value or a localization name&gt;</programlisting>

        <para>Example:</para>

        <programlisting>DeploymentPackage: 3D-Library</programlisting>
      </section>

      <section xml:id="i1774844">
        <title>DeploymentPackage-RequiredStorage</title>

        <para>This header specifies the minimum amount of persistent storage
        required by the deployment package after successful install or update.
        The value is an integer that represent kilo-bytes. The value includes
        the size of the bundles and any persistent storage needs and storage
        needed to run the resource processors and customizers. An installation
        agent can verify the availability of sufficient memory before
        installing the package. A fix-pack must specify the minimum memory
        requirements of the complete deployment package after the it is
        applied.</para>

        <programlisting>DeploymentPackage-RequiredStorage ::= number</programlisting>

        <para>Example</para>

        <programlisting>DeploymentPackage-RequiredStorage: 15</programlisting>
      </section>

      <section>
        <title>Bundle-SymbolicName (Name Section)</title>

        <para>The <code>Bundle-SymbolicName</code> header must be a copy of
        the <code>Bundle-SymbolicName</code> header in the named bundle,
        including any parameters. This header must match the
        Bundle-SymbolicName of the actual bundle; if it does not, the install
        or update must fail. The parameters, however, can differ between
        updates. The header has the following format:</para>

        <programlisting>Bundle-SymbolicName: unique-name (’;’ parameter) *</programlisting>

        <para>If the bundle resource has no Bundle-SymbolicName header, the
        given symbolic name must be used to calculate the location of the
        bundle.</para>

        <para>For example:</para>

        <programlisting>Name: bundles/http.jar
Bundle-SymbolicName: com.acme.http; singleton=true</programlisting>
      </section>

      <section>
        <title>Bundle-Version (Name Section)</title>

        <para>The Bundle-Version header must be equal to the Bundle-Version
        header in the named bundle. It must follow the format as defined for
        the <code>version</code> clause in <phrase role="xref"> <xref
        linkend="i1516004" xrefstyle="Reference"/></phrase> .</para>

        <programlisting>Bundle-Version ::= version     // See <phrase
            role="xref">3.2.5</phrase> Core</programlisting>

        <para>A mismatch between the version indicated in the Manifest of the
        Deployment Package and the actual value in the Bundle’s Manifest must
        cause an installation or update to fail.</para>

        <para>For example</para>

        <programlisting>Bundle-Version: 1.2</programlisting>
      </section>

      <section xml:id="i1553906">
        <title>Resource-Processor (Name Section)</title>

        <para>The <code>Resource-Processor</code> header selects an OSGi
        Resource Processor service for this resource by selecting the
        Resource-Processor service with the given PID as
        <code>service.id</code> service property. This header is optional, so
        that the Deployment Package can carry resources that are not
        processed: for example, license and documentation files. The format of
        the header is:</para>

        <programlisting>Resource-Processor ::= pid     // See <phrase
            role="xref">1.3.2</phrase> Core</programlisting>

        <para>For example:</para>

        <programlisting>Name: certificate/certificates.xml
SHA1-Digest: M78w249126182Ak5zeq2X1Uv-+uF=
Resource-Processor: com.securitas.keystore</programlisting>

        <para>In the example, the <code>certificates.xml</code> in the
        <code>certificate</code> directory will be processed by the Resource
        Processor service registered with the service property
        <code>service.pid</code> set to <code>com.securitas.keystore</code>.
        The <code>service.pid</code> is a standard Framework property to
        uniquely identify a service instance called a Persistent IDentity
        a.k.a. PID.</para>
      </section>

      <section>
        <title>DeploymentPackage-Missing (Name Section)</title>

        <para>Fix packs (see <phrase role="xref"> <xref linkend="i1588451"
        xrefstyle="seeHeadingPage"/></phrase> ) are Deployment Packages that
        do not contain all the resources for a full install. This header
        indicates the Bundle Symbolic Name of a bundle that is not present in
        the enclosing JAR file but should be part of a prior version of this
        Deployment Package. The format is:</para>

        <programlisting>DeploymentPackage-Missing ::= ’true’ | ’false’</programlisting>

        <para>The default value for this header is <code>false</code>. An
        error results if this header is <code>true</code> and the resource is
        not present in the existing Deployment Package.</para>

        <para>For example:</para>

        <programlisting>Name: bundles/3dlib.jar
DeploymentPackage-Missing: true
Bundle-SymbolicName: com.acme.http
Bundle-Version: 3.0</programlisting>
      </section>

      <section>
        <title>DeploymentPackage-Customizer (Name Section)</title>

        <para>This header is used to indicated that a resource is a customizer
        bundle, as described in <phrase role="xref"> <xref linkend="i1474626"
        xrefstyle="seeHeadingPage"/></phrase> . The syntax of this optional
        header is:</para>

        <programlisting>DeploymentPackage-Customizer ::= ’true’ |’false’</programlisting>

        <para>The default for this header is <code>false</code>.</para>

        <para>For example:</para>

        <programlisting>Name: bundles/3dlibcustomizer.jar
DeploymentPackage-Customizer: true
Bundle-SymbolicName: com.acme.customizer
Bundle-Version: 3.6</programlisting>
      </section>
    </section>

    <section xml:id="i1568170">
      <title>Localization</title>

      <para>All human readable headers can be localized using the same
      mechanism as is used to localize the manifest of a bundle. This
      mechanism is described in <phrase role="xref">Localization on
      page 64</phrase> of the <phrase role="xref"> <xref linkend="i1516004"
      xrefstyle="Reference"/></phrase> .</para>

      <para>For example, a Manifest could look like:</para>

      <programlisting>Manifest-Version: 1.0
DeploymentPackage-ManifestVersion: 1
DeploymentPackage-SymbolicName: com.third._3d
DeploymentPacakge-Version: 1.2.3.build22032005
DeploymentPackage-Copyright: %copyright
DeploymentPackage-Vendor: %vendor
DeploymentPackage-License: %licenseurl
DeploymentPackage-Description: %3dlib
DeploymentPackage-Icon: %iconurl
DeploymentPackage-Name: %name
Bundle-Localization: <code>OSGI-INF/l10n/dp</code>
<symbol>↵</symbol>
Name: bundles/3dlib.jar
SHA1-Digest: MOez1l4gXHBo8ycYdAxstK3UvEg=
Bundle-SymbolicName: com.third._3d
Bundle-Version: 2.3.1
<symbol>↵</symbol>
Name: OSGI-INF/autoconf.xml
SHA1-Digest: M78w24912HgiZv5zeq2X1Uv-+uF=
Resource-Processor:      
  org.osgi.deployment.rp.autoconf
<symbol>↵</symbol>
Name: icon_nl.gif
SHA1-Digest: n72w21124hGiZV5zQeAXxUvaaUf=
<symbol>↵</symbol>
Name: OSGI-INF/l10n/dp.properties
SHA1-Digest: V5zQeAXxUvaaUfn72w21124hGiZ=
<symbol>↵</symbol>
Name: OSGI-INF/l10n/dp_nl.properties
SHA1-Digest: xUvaaUfn72w21124hGiZV5zQeAXx
<symbol>↵</symbol></programlisting>

      <para>Different language translations can be provided, such as:</para>

      <programlisting>OSGI-INF/l10n/dp.properties:
copyright=ACME Inc. (c) 2005
vendor=ACME Inc.
license=OSGI-INF/license.en.txt
3dlib=High performance graphic library
name=3D-Lib
icon=htpp:/www.acm.com/3dlib/icon.gif

OSGI-INF/l10n/dp_nl.properties:
copyright=ACME Holland BV (c) 2005
vendor=ACME Holland BV.
license=OSGI-INF/licentie.txt
3dlib=Zeer snelle 3D grafische routine bibliotheek
icon = icon_nl.gif
name = 3D-Bibliotheek</programlisting>

      <para>The language translation resources should appear in the Name
      section of the manifest so they can be signed.</para>
    </section>
  </section>

  <section xml:id="i1588451">
    <title>Fix Package</title>

    <para>A Fix Package is a Deployment Package that minimizes download time
    by excluding resources that are not required to upgrade or downgrade a
    Deployment Package. It can only be installed on a Service Platform if a
    previous version of that Deployment Package is already installed. The Fix
    Package contains only the changed and new resources. A Fix Package (called
    the <emphasis>source</emphasis>) therefore must specify the range of
    versions that the existing Deployment Package (called the
    <emphasis>target</emphasis>) must have installed. This range is specified
    with the <code>DeploymentPackage-FixPack</code> header in the manifest of
    the source.</para>

    <para>The Manifest format for a Fix Package is, except for the Fix Package
    header, the same as for a Deployment Package manifest: each resource must
    be named in the Name section of the Manifest. Resources that are absent,
    however, must be marked in the named section with the
    DeploymentPackage-Missing header set to <code>true</code>.</para>

    <para>Thus, the name sections of the manifest of a Fix Package must list
    <emphasis>all</emphasis> resources, absent or present, in order to
    distinguish between resources that must be removed or resources that are
    absent. Name sections that specify the DeploymentPackage-Missing header,
    however, indicate that the actual content of the resource is not carried
    in the Deployment Package—that is, the resource content is absent. Only a
    Fix Package is permitted to contain the DeploymentPackage-Missing
    headers.</para>

    <para>For example, the following headers define a valid Fix Package that
    can update an existing Deployment Package, only if the version is between
    1 and 2.</para>

    <programlisting>Manifest-Version: 1.0
DeploymentPackage-SymbolicName: com.acme.package.chess
DeploymentPackage-Version: 2.1
DeploymentPackage-FixPack: [1,2)
<symbol>↵</symbol>
Name: chess.jar
Bundle-SymbolicName: com.acme.bundle.chess
DeploymentPackage-Missing: true
Bundle-Version: 5.7
<symbol>↵</symbol>
Name: score.jar
Bundle-SymbolicName: com.acme.bundle.chessscore
Bundle-Version: 5.7
<symbol>↵</symbol></programlisting>

    <para>In this example, the Fix Package requires that version 1.x.y of the
    deployment package is already installed. The presence of the
    <code>com.acme.bundle. chess</code> bundle on the Service Platform is
    assumed, and it must be part of the existing Deployment Package
    <code>com.acme.package.chess</code>. After installation, this Deployment
    Package must contain the two listed bundles.</para>
  </section>

  <section xml:id="i1474626">
    <title>Customizer</title>

    <para>The standardized Deployment Admin service installation and
    uninstallation functions do not always cover the needs of a developer. In
    certain cases, running custom code at install and uninstall time is
    required. This need is supported with the Deployment Package
    <emphasis>Customizer</emphasis>. Typical Customizer bundles are:</para>

    <itemizedlist>
      <listitem>
        <para>Database initialization</para>
      </listitem>

      <listitem>
        <para>Data conversion</para>
      </listitem>

      <listitem>
        <para>Wiring</para>
      </listitem>
    </itemizedlist>

    <para>A Customizer bundle is indicated by a DeploymentPackage-Customizer
    header in a Name section for a bundle resource. A Deployment Package can
    have a number of customizers, or none. A Customizer bundle must be
    installed and started by the Deployment Admin service
    <emphasis>before</emphasis> any of the resources are processed.</para>

    <para>As a Customizer bundle is started, it should register one or more
    Resource Processor services. These Resource Processor services must only
    be used by resources originating from the same Deployment Package.
    Customizer bundles must never process a resource from another Deployment
    Package, which must be ensured by the Deployment Admin service.</para>

    <para>Customizers are installed and started in the order that they appear
    in the Deployment Package.</para>

    <section>
      <title>Bundle’s Data File Area</title>

      <para>Each bundle in the OSGi Framework has its own persistent private
      storage area. This private area is accessed by a bundle with the
      <code>getDataFile</code> method on the Bundle Context. The location in
      the file system where these files are stored is not defined, and thus is
      implementation-dependent. A Customizer bundle, however, typically needs
      access to this private storage area.</para>

      <para>The Deployment Admin service provides access to the Bundle private
      storage area with the <phrase role="xref">getDataFile(Bundle)</phrase>
      method on the <phrase role="xref">DeploymentSession</phrase> object.
      This method returns a <code>File</code> object to the root of the data
      directory.</para>

      <para>The location of a bundle's private storage area is impossible to
      determine because it depends on the implementation of the OSGi
      Framework. It is therefore impossible to give a Customizer bundle an
      appropriate File Permission for customization of a bundle’s data
      area.</para>

      <para>Therefore, if a Customizer bundle calls the
      <code>getDataFile</code> method for a specific bundle, the Deployment
      Admin must add to the Customizer bundle the required File Permission to
      access this area. This File Permission must be removed after the session
      ends.</para>
    </section>

    <section>
      <title>Customizers and Update</title>

      <para>The lifecycle of a customizer bundle is intertwined with the
      lifecycle of the resources it processes. Care should be taken to ensure
      that updates and uninstallations are handled correctly. A Customizer
      bundle is updated <emphasis>before</emphasis> a resource is
      processed—implying that a deployment session n is always dropped or
      processed by the customizer from session n+1. In this case, a session is
      an install or uninstall of a Deployment or Fix Package.</para>

      <figure xml:id="i1523870">
        <title>Time line for customizer versus resource versions</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.127in"
                       contentwidth="4.978in"
                       fileref="customizer-resource-timeline.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>In <phrase role="xref"> <xref linkend="i1523870"
      xrefstyle="FigureNumber"/></phrase> , Customizer bundle 2.0 must update
      the resource from version 1.0, and customizer 3.0 must drop the resource
      from version 2.0. As a consequence, the Customizer bundle that processes
      a resource will be a different version than the one that processes or
      drops it.</para>

      <para>The same ordering issue is also relevant with respect to the
      Autoconf resources (see <phrase role="xref">Auto Configuration
      Specification on page 489</phrase> ). Autoconf resources will not be
      available until the <code>commit</code> method is called. This condition
      implies that a customizer cannot receive fresh configuration information
      from the Deployment Package.</para>
    </section>
  </section>

  <section xml:id="i1606245">
    <title>Deployment Admin Service</title>

    <para>The Deployment Admin service provides the following services:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Introspecting</emphasis> – Provide information about
        the Deployment Package repository. Introspecting is further discussed
        on <phrase role="xref"> <xref linkend="i1587039"
        xrefstyle="seeHeadingPage"/></phrase> .</para>
      </listitem>

      <listitem>
        <para><emphasis>Install</emphasis> – The installation of a Deployment
        Package is described in <phrase role="xref"> <xref linkend="i1469879"
        xrefstyle="seeHeadingPage"/></phrase> .</para>
      </listitem>

      <listitem>
        <para><emphasis>Uninstall</emphasis> – The uninstallation of a
        Deployment Package is described in <phrase role="xref"> <xref
        linkend="i1469902" xrefstyle="seeHeadingPage"/></phrase> .</para>
      </listitem>

      <listitem>
        <para><emphasis>Canceling</emphasis> – An ongoing session can be
        canceled with the <code>cancel</code> method described in <phrase
        role="xref"> <xref linkend="i1588782"
        xrefstyle="seeHeadingPage"/></phrase> .</para>
      </listitem>
    </itemizedlist>

    <para>An important concept of the Deployment Admin service is the
    <emphasis>session</emphasis>. Installations and uninstallations of
    Deployment Packages take place inside a session. This session is
    represented by a <code>DeploymentSession</code> object. The session
    provides access to the Deployment Package that is being (un)installed, as
    well as access to the data area of bundles. The transactional aspects of
    this sessions are discussed in <phrase role="xref"> <xref
    linkend="i1609646" xrefstyle="seeHeadingPage"/></phrase> .</para>

    <section xml:id="i1587039">
      <title>Introspection</title>

      <para>The Deployment Admin service can provide the list of currently
      installed Deployment Packages with the <phrase
      role="xref">listDeploymentPackages()</phrase> method. Given a name, it
      is also possible to get a Deployment Package with <phrase
      role="xref">getDeploymentPackage(String)</phrase> using the name, or
      <phrase role="xref">getDeploymentPackage(Bundle)</phrase> for the
      Deployment Package of a specific bundle.</para>

      <para>The <phrase role="xref">listDeploymentPackages()</phrase> method
      returns an array of <phrase role="xref">DeploymentPackage</phrase>
      objects. This list of Deployment Packages must contain only valid
      installed packages. During an installation or upgrade of an existing
      package, the target must remain in this list until the installation
      process is complete, after which the source replaces the target. If the
      installation fails, the source must never become visible, even
      transiently.</para>

      <para><code>DeploymentPackage</code> objects provide access to the
      following identity information:</para>

      <itemizedlist>
        <listitem>
          <para><phrase role="xref">getName()</phrase> – The name of the
          Deployment Package.</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">getVersion()</phrase> – The version of the
          Deployment Package.</para>
        </listitem>
      </itemizedlist>

      <para>The Deployment Package also provides access to the bundles that
      are associated with a Deployment Package.</para>

      <itemizedlist>
        <listitem>
          <para><phrase role="xref">getBundleInfos()</phrase> – Returns an
          array of information about all bundles that are
          <emphasis>owned</emphasis> by this Deployment Package. The return
          type is a <phrase role="xref">BundleInfo</phrase> object that has a
          <phrase role="xref">getVersion()</phrase> and <phrase
          role="xref">getSymbolicName()</phrase> method.</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">getBundle(String)</phrase> – Returns the
          bundle with the given Bundle Symbolic Name that is associated with
          this Deployment Package. As this instance is transient—for example,
          a bundle can be removed at any time because of the dynamic nature of
          the OSGi platform—this method may also return <code>null</code>, if
          the bundle is part of this deployment package but is temporarily not
          defined in the Framework.</para>
        </listitem>
      </itemizedlist>

      <para>The Deployment Package also provides access to the headers in its
      Manifest. The global section and the Name sections are both supported.
      This information can be used to provide human-readable information to
      the end user. If the Manifest is using localization, this information
      must be returned in the default locale. It is not possible to specify a
      specific locale. See <phrase role="xref"> <xref linkend="i1568170"
      xrefstyle="seeHeadingPage"/></phrase> for more information.</para>

      <itemizedlist>
        <listitem>
          <para><phrase role="xref">getHeader(String)</phrase> – Provides
          access to the Deployment Package’s Manifest header global section.
          Header names must be matched in a case-insensitive manner.</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">getResourceHeader(String,String)</phrase>
          – Provides access to a header in the Name section. The first
          argument specifies the resource id (JAR path); the second argument
          is the (case insensitive) header name.</para>
        </listitem>
      </itemizedlist>

      <para>The Deployment Package contains a number of resources. Each
      resource can be queried for its associated Resource Processor
      service.</para>

      <itemizedlist>
        <listitem>
          <para><phrase role="xref">getResourceProcessor(String)</phrase> –
          Return the Service Reference of the Resource Processor service that
          is associated with the given resource. For a Bundle resource, the
          returned Resource Processor must be <code>null</code>.</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">getResources()</phrase> – Return an array
          of resource names. This array must include the Bundle
          resources.</para>
        </listitem>
      </itemizedlist>

      <para>The <phrase role="xref">isStale()</phrase> method returns true
      when DeploymentPackage object is no longer available.</para>
    </section>

    <section xml:id="i1588782">
      <title>Canceling</title>

      <para>An ongoing session can be canceled with the Deployment Admin
      service’s <phrase role="xref">cancel()</phrase> method. This method must
      find the currently executing Resource Processor service and call its
      <code>cancel</code> method. The remainder of the session must be
      immediately rolled back after the Resource Processor returns from the
      active method.</para>
    </section>
  </section>

  <section xml:id="i1609646">
    <title>Sessions</title>

    <para>The (un)installation or upgrade of a deployment package requires the
    cooperation and interaction of a large number of services. This operation,
    therefore, takes place in a <emphasis>session</emphasis>. A session must
    be created by the Deployment Admin service before any activity on behalf
    of the Deployment Package takes place, including any bundle installations.
    Sessions are not visible to the clients of Deployment Admin
    service.</para>

    <para>Before using a resource processor in a session, the Deployment Admin
    service must <emphasis>join</emphasis> the Resource Processor service to
    the session. The <phrase role="xref">begin(DeploymentSession)</phrase>
    method must be called before a Resource Processor service calls the
    <code>process</code>, <code> drop, </code>or<code> dropAllResources
    </code>method. For brevity, this joining is not shown in the following
    sections, but must be assumed to have taken place before any of the
    methods is called.</para>

    <para>A Resource Processor has <emphasis>joined the session</emphasis>
    when it has returned from its <phrase
    role="xref">begin(DeploymentSession)</phrase> method without an Exception
    being thrown. A Resource Processor service must not be joined to more than
    a single session at any moment in time—implying that a Resource Processor
    can assume that only one install takes place at a time.</para>

    <para>A roll back can take place at any moment during a session. It can be
    caused by a Resource Processor service that throws an Exception during a
    method call, or it can be caused by canceling the session (see <phrase
    role="xref"> <xref linkend="i1588782"
    xrefstyle="seeHeadingPage"/></phrase> ).</para>

    <para>If all methods in a session are executed without throwing
    Exceptions, then the session must be committed. Commitment first requires
    a vote about the outcome of the session in the so-called
    <emphasis>prepare</emphasis> phase. The Deployment Admin service must
    therefore call the <code>prepare</code> method on all Resource Processor
    services that have joined the session. The Resource Processor services
    must be called in the reverse order of joining.</para>

    <para>Any Resource Processor that wants to roll back the session in the
    prepare phase can, at that moment, still throw an Exception. The
    <code>prepare</code> method can also be used to persist some of the
    changes, although the possibility remains that the session will be rolled
    back and that those changes must then be undone.</para>

    <para>If all joined Resource Processors have successfully executed the
    <code>prepare</code> method, the Deployment Admin service must call the
    <code>commit</code> method on all Resource Processor services that have
    joined the session. The Resource Processor services must be called in the
    reverse order of joining. Resource Processor services must not throw an
    Exception in this method; they should only finalize the commit. Any
    Exceptions thrown should be logged, but must be ignored by the Deployment
    Admin service.</para>

    <section>
      <title>Roll Back</title>

      <para>At the moment of the roll back, a number of Resource Processor
      services can have joined the session and bundles could have been
      installed. For each of these joined Resource Processor services, the
      Deployment Admin service must call the <phrase
      role="xref">rollback()</phrase> method. A roll back can be caused by a
      thrown Exception during an operation, or can be initiated by the caller.
      The roll back can even happen after the <phrase
      role="xref">prepare()</phrase> method has been called if another
      Resource Processor throws an Exception in its <code>prepare</code>
      method. The Resource Processor services must be called in the reverse
      order of joining for the <code>rollback</code> method.</para>

      <para>The system should make every attempt to roll back the situation to
      its pre-session state:</para>

      <itemizedlist>
        <listitem>
          <para>Changed artifacts must be restored to their prior state</para>
        </listitem>

        <listitem>
          <para>New artifacts must be removed</para>
        </listitem>

        <listitem>
          <para>Stale artifacts must be created again</para>
        </listitem>

        <listitem>
          <para>Any installed or updated bundles must be removed</para>
        </listitem>

        <listitem>
          <para>The state of the target bundles must be restored</para>
        </listitem>
      </itemizedlist>

      <para>If the target bundles were started before, and the state can be
      restored successfully, the target bundles must be refreshed (the
      <code>PackageAdmin</code> <code>refreshPackages</code> method) and
      started again before the method returns.</para>

      <para>If the roll back cannot completely restore the state of the target
      bundles, the target bundles that were restored must not be restarted, in
      order to prevent running bundles with incompatible versions. An
      appropriate warning should be logged in this case.</para>

      <para>After the <code>commit</code> or <code>rollback</code> method, the
      <code>DeploymentAdminSession</code> object is no longer usable.</para>

      <para>The transactional aspects of the session are depicted in <phrase
      role="xref"> <xref linkend="i1609680"
      xrefstyle="FigureNumber"/></phrase> .</para>

      <figure xml:id="i1609680">
        <title>Transactional Sessions</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="3.653in"
                       contentwidth="4.911in"
                       fileref="transactional-sessions.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Deployment Admin service must uninstall any new bundles and
      install <emphasis>stale</emphasis> bundles (bundles that were
      uninstalled during the session), and should roll back updated bundles.
      Rolling back a bundle update, as well as reinstalling a stale bundle,
      requires an implementation-dependent back door into the OSGi Framework,
      because the Framework specification is not transactional over multiple
      lifecycle operations. Therefore, this specification does not mandate
      full transactional behavior.</para>

      <para>After a roll back, however, a Deployment Package must still be
      removable with all its resources and bundles dropped. A roll back must
      not bring the Deployment Package to a state where it can no longer be
      removed, or where resources become orphaned.</para>
    </section>

    <section xml:id="i1587082">
      <title>Bundle Events During Deployment</title>

      <para>Deployment operations usually result in bundles being installed or
      uninstalled. These deployment operations can fail in mid-operation, and
      cause a roll back by Deployment Admin—meaning that the platform can go
      through some transient states in which bundles are installed, then
      uninstalled due to roll back.</para>

      <para>Therefore, the order of Bundle events produced by a transactional
      implementation must be compatible with the Bundle events produced by a
      non-transactional implementation. A transactional implementation,
      however, can choose to postpone all events while maintaining ordering
      until the end of the session and thereby canceling any events that
      cancel each other (e.g. install and uninstall). A non-transactional
      Deployment Admin service must send out the events as they occur.</para>

      <para>In the following example, a simple Deployment Package consists of
      bundles <code>A</code>,<code> B</code>, and <code>C</code>. If this
      Deployment Package is successfully installed, an implementation must
      produce the following Bundle events (in order):</para>

      <orderedlist>
        <listitem>
          <para><code>BundleEvent(INSTALLED) for bundle A</code></para>
        </listitem>

        <listitem>
          <para><code>BundleEvent(INSTALLED) for bundle B</code></para>
        </listitem>

        <listitem>
          <para><code>BundleEvent(INSTALLED) for bundle C</code></para>
        </listitem>
      </orderedlist>

      <para>If an operation of this Deployment Package was unsuccessful
      because, for example, Bundle <code>C</code> could not be installed due
      to an error, then the Deployment Admin service must roll back the
      deployment operation to return the platform to its original state. If
      the Deployment Admin service is transactional, then it must not expose
      the events because no persistent bundle changes were made to the
      platform.</para>

      <para>On the other hand, a non-transactional implementation must expose
      the transient bundle states that occur during the deployment operation.
      In this case, the following bundle events could have been generated (in
      order):</para>

      <orderedlist>
        <listitem>
          <para><code>BundleEvent(INSTALLED) for bundle A</code></para>
        </listitem>

        <listitem>
          <para><code>BundleEvent(INSTALLED) for bundle B</code></para>
        </listitem>

        <listitem>
          <para><code>BundleEvent(UNINSTALLED) for bundle A</code></para>
        </listitem>

        <listitem>
          <para><code>BundleEvent(UNINSTALLED) for bundle B</code></para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section xml:id="i1469879">
    <title>Installing a Deployment Package</title>

    <para>Installation starts with the <phrase
    role="xref">installDeploymentPackage(InputStream)</phrase> . No separate
    function exists for an update; if the given Deployment Package already
    exists, it must be replaced with this new version. The purpose of the
    <code>installDeploymentPackage</code> method is to replace the
    <emphasis>target</emphasis> Deployment Package (existing) with the
    <emphasis>source</emphasis> Deployment Package (contained in the Input
    Stream).</para>

    <para>The <code>InputStream</code> object must stream the bytes of a valid
    Deployment Package JAR; it is called the <emphasis>source</emphasis>
    deployment package. The <code>InputStream</code> object must be a general
    <code>InputStream</code> object and not an instance of the
    <code>JarInputStream</code> class, because these objects do not read the
    JAR file as bytes.</para>

    <para>If an installed Deployment Package has the same name as the source,
    it is called the <emphasis>target</emphasis> Deployment Package. If no
    target exists, an invisible empty target with a version of 0.0.0. must be
    assumed without any bundles and resources.</para>

    <para>The installation of a deployment package can result in these
    qualifications for any resource r:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>r</emphasis> <symbol>∈</symbol>
        <emphasis>source</emphasis>, <emphasis>r</emphasis> <symbol>∉</symbol>
        <emphasis>target – </emphasis>New resource</para>
      </listitem>

      <listitem>
        <para><emphasis>r</emphasis> <symbol>∉</symbol>
        <emphasis>source</emphasis>, <emphasis>r</emphasis> <symbol>∈</symbol>
        <emphasis>target </emphasis>– Stale resource</para>
      </listitem>

      <listitem>
        <para><emphasis>r</emphasis> <symbol>∈</symbol>
        <emphasis>source</emphasis>, <emphasis>r</emphasis> <symbol>∈</symbol>
        <emphasis>target – </emphasis>Updated resource</para>
      </listitem>
    </itemizedlist>

    <para>The short scenario for an install is depicted in <phrase
    role="xref"> <xref linkend="i1490678" xrefstyle="FigureNumber"/></phrase>
    .</para>

    <figure xml:id="i1490678">
      <title>Overview of install process</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="6.863in"
                     contentwidth="4.985in"
                     fileref="install-process-overview.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In more detail, to install a Deployment Package, a Deployment Admin
    service must:</para>

    <orderedlist>
      <listitem>
        <para>Create a Deployment Session</para>
      </listitem>

      <listitem>
        <para>Assert that the Manifest file is the first resource in the
        Deployment Package JAR file.</para>
      </listitem>

      <listitem>
        <para>Assert the following:</para>

        <itemizedlist>
          <listitem>
            <para>The source must not contain any bundle that exists in other
            deployment packages, except for the target. The source bundles, as
            defined by the symbolic name, must belong to the target or be
            absent.</para>
          </listitem>
        </itemizedlist>

        <para>If the source is a Fix Package, assert that:</para>

        <itemizedlist>
          <listitem>
            <para>The version of the target matches the required source
            version range.</para>
          </listitem>

          <listitem>
            <para>All the missing source bundles are present in the
            target.</para>
          </listitem>
        </itemizedlist>

        <para>Otherwise:</para>

        <itemizedlist>
          <listitem>
            <para>Assert that are no missing resources or bundles
            declared.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Process the localization files, see <phrase role="xref"> <xref
        linkend="i1568170" xrefstyle="seeHeadingPage"/></phrase> .</para>
      </listitem>

      <listitem>
        <para>All target bundles must be stopped in reverse target resource
        order. Exceptions thrown during stopping must be ignored, but should
        be logged as warnings.</para>
      </listitem>
    </orderedlist>

    <para>The target is now stopped; none of its bundles are running any
    longer. The next step requires the sequential processing of the resources
    from the source JAR file in source resource order. The bundles must be
    processed first (if present), and can be followed by any number of
    resources, or none.</para>

    <para>For each bundle read from the source JAR stream:</para>

    <orderedlist continuation="continues">
      <listitem>
        <para>If the bundle symbolic name already exists in the system with a
        different version number, update that bundle with the resource stream.
        If the version is identical, the resource stream must be ignored. The
        <code>update</code> method must follow the semantics of the OSGi
        Framework <code>update</code> method. An exception thrown during the
        update must roll back the session.</para>

        <para>Otherwise, install the bundle according to the semantics of the
        OSGi Framework <code>installBundle</code> method. The location of the
        bundle must be set to the Bundle Symbolic Name without any parameters
        and be prefixed with the <code>osgi-dp:</code> scheme. An exception
        thrown during the install must roll back the session.</para>

        <para>Framework events are discussed in <phrase role="xref"> <xref
        linkend="i1587082" xrefstyle="seeHeadingPage"/></phrase> .</para>
      </listitem>

      <listitem>
        <para>Assert that the installed bundle has the Bundle Symbolic Name
        and version as defined by the source manifest. If not, the session
        must be rolled back.</para>
      </listitem>
    </orderedlist>

    <para>All the source’s bundles are now installed or updated successfully.
    Next, any customizers must be started so that they can participate in the
    resource processing:</para>

    <orderedlist continuation="continues">
      <listitem>
        <para>If Customizer bundles or stale customizers are defined, start
        them. If any Customizer bundle’s start method throws an exception, the
        session must be rolled back.</para>
      </listitem>
    </orderedlist>

    <para>For each resource read from the JAR stream:</para>

    <orderedlist continuation="continues">
      <listitem>
        <para>Find the Resource Processor service that processes the resource
        by using the PID in the Resource-Processor header. If it cannot be
        found, the session must be rolled back.</para>
      </listitem>

      <listitem>
        <para>Assert that the matched Resource Processor service is not from a
        Customizer bundle in another Deployment Package.</para>
      </listitem>

      <listitem>
        <para>Call the matched Resource Processor service <phrase
        role="xref">process(String,InputStream)</phrase> method. The argument
        is the JAR path of the resource. Any Exceptions thrown during this
        method must abort the installation.</para>
      </listitem>
    </orderedlist>

    <para>All resource updates and installs have now occurred. The next steps
    must remove any stale resources. First the stale resources are dropped,
    and then the bundles are uninstalled. Exceptions are ignored in this phase
    to allow repairs to always succeed, even if the existing package is
    corrupted.</para>

    <orderedlist continuation="continues">
      <listitem>
        <para>In reverse target order, drop all the resources that are in the
        target but not in the source by calling the matching Resource
        Processor service <phrase role="xref">dropped(String)</phrase> method.
        Any exceptions thrown during this method should be logged as warnings,
        but must be ignored.</para>
      </listitem>

      <listitem>
        <para>Uninstall all stale bundles in reverse target order, using the
        OSGi Framework <code>uninstall</code> method semantics. Any exceptions
        thrown should be logged as warnings, but must be ignored.</para>
      </listitem>
    </orderedlist>

    <para>The deployment package is now cleaned up, and can be activated and
    committed.</para>

    <orderedlist continuation="continues">
      <listitem>
        <para>All the Resource Processor services that have joined the session
        must now prepare to commit, which is achieved by calling the <phrase
        role="xref">prepare()</phrase> method. If any Resource Processor
        throws an Exception, the session must roll back. The Resource
        Processors must be called in the reverse order of joining.</para>
      </listitem>

      <listitem>
        <para>If all the Resource Processors have successfully prepared their
        changes, then all the Resource Processor services that have joined the
        session must now be committed, which is achieved by calling the
        <phrase role="xref">commit()</phrase> method. The Resource Processors
        must be called in the reverse order of joining. Any exceptions should
        be logged as warnings, but must be ignored.</para>
      </listitem>

      <listitem>
        <para>Call the Package Admin service <code>refreshPackages</code>
        method so that any new packages are resolved.</para>
      </listitem>

      <listitem>
        <para>Wait until the refresh is finished.</para>
      </listitem>

      <listitem>
        <para>Start the bundles in the source resource order. Exceptions
        thrown during the start must be logged, but must not abort the
        deployment operation.</para>
      </listitem>
    </orderedlist>

    <para>The session is closed and the source replaces the target in the
    Deployment Admin service’s repository.</para>

    <para>The <code>installDeploymentPackage</code> method returns the source
    Deployment Package object.</para>

    <section>
      <title>Example Installation</title>

      <para>The target Deployment Package has the following manifest:</para>

      <programlisting>Manifest-Version: 1.0
DeploymentPackage-SymbolicName: com.acme.daffy
DeploymentPackage-Version: 1
<symbol>↵</symbol>
Name: bundle-1.jar
Bundle-SymbolicName: com.acme.1
Bundle-Version: 5.7
<symbol>↵</symbol>
Name: r0.x
Resource-Processor: RP-x
<symbol>↵</symbol>
Name: r1.x
Resource-Processor: RP-x
<symbol>↵</symbol>
Name: r1.y
Resource-Processor: RP-y
<symbol>↵</symbol></programlisting>

      <para>This deployment package is updated with a new version, with the
      following manifest:</para>

      <programlisting>Manifest-Version: 1.0
DeploymentPackage-SymbolicName: com.acme.daffy
DeploymentPackage-Version: 2
<symbol>↵</symbol>
Name: bundle-2.jar
Bundle-SymbolicName: com.acme.2
Bundle-Version: 5.7
<symbol>↵</symbol>
Name: r1.x
Resource-Processor: RP-x
<symbol>↵</symbol>
Name: r2.x
Resource-Processor: RP-x
<symbol>↵</symbol>
Name: r1.y
Resource-Processor: RP-y
<symbol>↵</symbol></programlisting>

      <para>The delta between version 1 and version 2 of the
      <code>com.acme.daffy</code> Deployment Package is depicted in <phrase
      role="xref"> <xref linkend="i1602560"
      xrefstyle="FigureNumber"/></phrase> . <code>Bundle-1</code> must be
      uninstalled because it is no longer present in the Deployment Package
      <code>com.acme.daffy</code> version 2. <code>Bundle-2</code> is a new
      bundle and thus must be installed. The resource <code>r0.x</code> must
      be dropped and <code>r1.x</code> must be updated (this must be detected
      and treated accordingly by Resource Processor <code>RP-x</code>).
      <code>r2.x</code> is a new resource. The resource <code>r1.y</code> is
      updated by Resource Processor <code>RP-y</code>).</para>

      <figure xml:id="i1602560">
        <title>Delta</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.794in"
                       contentwidth="4.808in" fileref="delta.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The sequence diagram for the installation is shown in <phrase
      role="xref"> <xref linkend="i1522278"
      xrefstyle="FigureNumber"/></phrase> .</para>

      <figure xml:id="i1522278">
        <title>Sequence Diagram for a Resource Processor</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="4.087in"
                       contentwidth="4.926in"
                       fileref="resource-processor-sequence.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section xml:id="i1469902">
    <title>Uninstalling a Deployment Package</title>

    <para>Uninstalling a Deployment Package must remove all the effects of its
    installation(s). The uninstall is started by calling <phrase
    role="xref">uninstall()</phrase> or <phrase
    role="xref">uninstallForced()</phrase> method on a
    <emphasis>target</emphasis> <code>DeploymentPackage</code> object.</para>

    <para>The Deployment Packages are uninstalled explicitly, which may break
    the overall runtime configuration. No attempt is made to ensure that the
    uninstalled Deployment Package is required as a provider of Java packages
    or services, or fulfills other dependencies.</para>

    <para>The Deployment Admin service must take the following actions to
    remove the <code>target</code> Deployment Package when <phrase
    role="xref">uninstall()</phrase> is called. This procedure must run inside
    a Deployment Admin session. A Resource Processor that is called must first
    join the session as described in <phrase role="xref"> <xref
    linkend="i1609646" xrefstyle="seeHeadingPage"/></phrase> .</para>

    <para>Uninstalling is composed of the following steps:</para>

    <orderedlist>
      <listitem>
        <para>Start a new Deployment Admin session.</para>
      </listitem>

      <listitem>
        <para>Stop all the bundles owned by the Deployment Package. If this
        step throws a Bundle Exception, this error should be logged but must
        be ignored.</para>
      </listitem>

      <listitem>
        <para>Call the <phrase role="xref">dropAllResources()</phrase> method
        on all the Resource Processor services that are owned by this
        Deployment Package. Absent Resource Processor services or Exceptions
        that are thrown must immediately roll back this session.</para>
      </listitem>

      <listitem>
        <para>Call the <code>prepare</code> method on the Resource Processor
        services that joined the session. If any Resource Processor service
        throws an Exception, the session must be rolled back.</para>
      </listitem>

      <listitem>
        <para>Call the <code>commit</code> method on the Resource Processors
        that joined the session.</para>
      </listitem>

      <listitem>
        <para>Uninstall all owned bundles.</para>
      </listitem>
    </orderedlist>

    <para>Uninstalling a Deployment Package can break the overall runtime
    configuration. No attempt is made to ensure that a Deployment Package
    being uninstalled is not necessary as a provider of Java packages or
    services, or fulfills other dependencies.</para>

    <para>An error condition results if the Resource Processor services are no
    longer present when uninstalling or updating a deployment package. A
    request to carry out an uninstall operation on such a Deployment Package
    must be refused until the Resource Processor services are all available. A
    means must be provided, however, to handle permanent unavailability of
    these services.</para>

    <para>To address this issue, the <code>DeploymentPackage</code> interface
    provides a method, <phrase role="xref">uninstallForced()</phrase> , which
    forces removal of the Deployment Package from the repository maintained by
    the Deployment Admin service. This method follows the same steps described
    earlier. Any errors, or the absence of Resource Processor services, should
    be logged but ignored; they must not cause a roll back.</para>

    <para>If errors occur or Resource Processor services are absent, it is
    likely that the uninstallation will be incomplete, and that some residual
    artifacts will remain on the platform. Whether this residue is eventually
    cleaned up, and how, is left up to the implementation.</para>
  </section>

  <section xml:id="i1477114">
    <title>Resource Processors</title>

    <para>The Resource Processor service interprets the byte stream of a
    resource. Typically, the stream is parsed and its information is stored as
    <emphasis>artifacts</emphasis>. Examples of resource processors
    are:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Configuration Management</emphasis> – This processor
        is standardized by the OSGi and more information can be found in
        <phrase role="xref">Auto Configuration Specification on
        page 489</phrase> .</para>
      </listitem>

      <listitem>
        <para><emphasis>Certificate Keystore</emphasis> – A Certificate
        Keystore processor could extract certificates from a bundle and
        install them in a keystore.</para>
      </listitem>

      <listitem>
        <para><emphasis>SyncML Script</emphasis> – Execute a series of SyncML
        commands.</para>
      </listitem>
    </itemizedlist>

    <para>The Deployment Admin service maintains the list of
    <emphasis>resource ids</emphasis> (the path name in the JAR) that are
    contained in a Deployment Package. Each resource is uniquely identified
    within a Deployment Package by its path name—hence the term "resource id."
    The Deployment Package’s <phrase role="xref">getResources()</phrase>
    method provides a list of the resources ids.</para>

    <para>The Resource Processor service is responsible for actually creating
    and deleting the resource related artifacts. The Resource Processor
    service must be able to remove the artifacts related to a resource that is
    being dropped using only the resource id.</para>

    <para>The <code>ResourceProcessor</code> interface is based on a session
    (see <phrase role="xref"> <xref linkend="i1609646"
    xrefstyle="seeHeadingPage"/></phrase> ). The transactionality is limited
    to the bracketing of any processing or dropping of resources.The
    bracketing begins when a Resource Processor joins an install session. A
    Resource Processor service can assume that it is never in two sessions at
    the same time (see <phrase role="xref"> <xref linkend="i1610495"
    xrefstyle="seeHeadingPage"/></phrase> ). It can, however, be called
    multiple times during the session to process different resources.</para>

    <para>Before the Resource Processor service is used in an install or
    uninstall session, the Deployment Admin service must call the <phrase
    role="xref">begin(DeploymentSession)</phrase> method; this action makes
    the Resource Processor service join the session. This method must be used
    by the Resource Processor service to mark any changes for potential roll
    back, from this time until the <phrase role="xref">prepare()</phrase> /
    <phrase role="xref">commit()</phrase> or <phrase
    role="xref">rollback()</phrase> method is called.</para>

    <para>When the session is opened, the Deployment Admin service can call
    the following methods on the Resource Processor service:</para>

    <itemizedlist>
      <listitem>
        <para><phrase role="xref">process(String,InputStream)</phrase> – The
        Resource processor must parse the Input Stream and persistently
        associate the resulting artifacts with the given resource id. It must
        be possible to remove those artifacts in a future time, potentially
        after a complete system restart. Keep in mind that a resource can be
        processed many times. A Deployment Package that updates to a newer
        version is likely to contain the same resources again. Care should be
        taken to ensure that these updates are real updates and do not add
        new, unwanted artifacts.</para>
      </listitem>

      <listitem>
        <para><phrase role="xref">dropped(String)</phrase> – The artifacts
        that were associated with the given resource id must be removed. If
        the named resource does not exist, a warning should be logged but no
        Exception should be thrown.</para>
      </listitem>

      <listitem>
        <para><phrase role="xref">dropAllResources()</phrase> – Remove all
        artifacts that are related to the current target Deployment Package.
        This method is called when a Deployment Package is uninstalled.</para>
      </listitem>

      <listitem>
        <para><phrase role="xref">cancel()</phrase> – This method is called
        when the Resource Processor is in the <phrase
        role="xref">process(String,InputStream)</phrase> , <phrase
        role="xref">dropped(String)</phrase> or <phrase
        role="xref">dropAllResources()</phrase> method, allowing the caller to
        cancel a long-running session. In that case, the Deployment Admin must
        call the <phrase role="xref">cancel()</phrase> method for the active
        Resource Processor service. The Resource Processor service should
        terminate its action as quickly as possible. The Resource Processor
        service must still handle a roll back of the session after it has
        returned.</para>
      </listitem>
    </itemizedlist>

    <para>All methods must perform any integrity checks immediately and throw
    an Exception with an appropriate code if the verification fails. These
    checks must not be delayed until the <code>prepare</code> or
    <code>commit</code> method. As stated earlier, changes must be recorded,
    but it should be possible to roll back the changes when the
    <code>rollback</code> method is called.</para>

    <para>Deployment Packages can be upgraded or downgraded. Resource
    Processor services must therefore be capable of processing resources that
    have a lower, equal, or higher version.</para>

    <section>
      <title>Example Resource Processor</title>

      <para>An example is a Resource Processor service that wires services
      with the Wire Admin service. The Wire Admin service creates wires
      between a <emphasis>producer</emphasis> and a
      <emphasis>consumer</emphasis> service, each identified by a PID. Wires
      are the artifacts that are installed and removed. Each wire contains a
      <code>Dictionary</code> object that is a convenient place to tag wires
      with the Deployment Package name and resource id. The Wire Admin stores
      this information persistently, which makes it very suitable for use in a
      transactional model. This small example supports full transactionality,
      although without crash recovery.</para>

      <para>For simplicity, the wire definitions are stored in a format
      compatible with the <code>java.util.Properties</code> format (because it
      can simply be loaded from an Input Stream object). The key is the
      producer and the value is the consumer. A sample wiring could look
      like:</para>

      <programlisting>com.acme.gps = com.acme.navigation
com.acme.asn = com.acme.navigation
com.acme.navigation = com.acme.poi </programlisting>

      <para>This wiring is depicted in <phrase role="xref"> <xref
      linkend="i1581035" xrefstyle="FigureNumber"/></phrase> .</para>

      <figure xml:id="i1581035">
        <title>Sample Wiring</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="0.897in"
                       contentwidth="4.938in" fileref="sample-wiring.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>This resource is stored in a Deployment Package JAR file. In this
      example there are no bundles, so the Deployment Package’s manifest would
      look like:</para>

      <programlisting>Manifest-Version: 1.0
DeploymentPackage-SymbolicName: com.acme.model.E45.wiring
DeploymentPackage-Version: 1.2832
<symbol>↵</symbol>
Name: sample.wiring
Resource-Processor: wire.admin.processor
<symbol>↵</symbol></programlisting>

      <para>To reduce the size of the code in this example, the Wire Admin
      service is received as a parameter. The constructor registers the object
      as a Resource Processor service with the required
      <code>wire.admin.processor</code> PID.</para>

      <para>The transaction strategy of this code is to create wires when new
      wires have to be created, but to delay the deletion of wires until the
      end of the session. Any created wires are kept in the
      <code>createdWires</code> field, and the wires that are to be deleted
      are kept in the <code>toBeDeletedWires</code> field.</para>

      <para>The current <code>DeploymentPackage</code> object is saved in the
      <code>current</code> field when the <code>begin</code> method is
      called.</para>

      <programlisting>public class WireAdminProcessor implementsResourceProcessor {
    WireAdmin         admin;
    DeploymentPackage current;
    List              createdWires     = new Vector();
    List              toBeDeletedWires = new Vector();

    public WireAdminProcessor(
            WireAdmin admin, BundleContext context)
            throws Exception {
        this.admin = admin;
        Dictionary properties = new Hashtable();
        properties.put(Constants.SERVICE_PID,
                "wire.admin.processor");
            context.registerService(
                ResourceProcessor.class.getName(), this,
                properties);
    }</programlisting>

      <para>When the Deployment Admin service is installing a Deployment
      Package JAR, it must call the Resource Processor service’s
      <code>begin</code> method before the first time it calls a Resource
      Processor service to join it to the current session. In this case, only
      the source <code>DeploymentPackage</code> object is saved in the
      <code>current</code> field.</para>

      <programlisting>    public void begin(DeploymentSession session){
        current = session.getSourceDeploymentPackage();
    }</programlisting>

      <para>The most complicated method that must be implemented is the
      <code>process</code> method. This method receives the resource id and an
      input stream with the contents. In this case, the stream is easily
      converted to a <code>java.util.Properties</code> object that contains
      the definitions of the wires.</para>

      <para>The key and value of the <code>Properties</code> object are the
      producer and consumer respectively, which are used to create new wires.
      Each wire has a Dictionary object in the Wire Admin service. This
      Dictionary object is used to store the following properties:</para>

      <itemizedlist>
        <listitem>
          <para><code>deployment.package</code> – The symbolic name of the
          current (target) deployment package. This property associates the
          wire with a specific deployment package.</para>
        </listitem>

        <listitem>
          <para><code>resource.id</code> – The resource id, or JAR path name.
          This id associates the specific resource with the wire.</para>
        </listitem>
      </itemizedlist>

      <para>Associating these fields with the wire simplifies finding all
      wires related to a Deployment Package or all wires related to a specific
      resource id and Deployment Package. The Wire Admin service supports a
      search method for wires that takes a filter as argument, further
      simplifying this process.</para>

      <para>After a wire is created, it is stored in the
      <code>createdWires</code> list so that the wires can be deleted if the
      session is rolled back.</para>

      <para>The <code>process</code> method looks as follows:</para>

      <programlisting>    public void process(String resourceId, InputStreamin) 
                throws Exception {
        Properties properties = new Properties();
        properties.load(in);
        Dictionary dict = new Hashtable();
        dict.put("deployment.package", current.getName());
        for (Iterator i = properties.values().iterator();
                i.hasNext();) {
            dict.put("resource.id", resourceId );
            String producer = (String) i.next();
            String consumer = properties.getProperty(producer);
            Wire wire = admin.createWire(producer, 
                consumer, dict);
            createdWires.add(wire);
        }
    }</programlisting>

      <para>If a resource is not in the source but is in the target Deployment
      Package, it must be dropped from the Resource Processor service. The
      Deployment Admin will call the <phrase
      role="xref">dropped(String)</phrase> method for those resources.
      Therefore, the wires that are tagged with the given resource id and
      Deployment Package name must be deleted.</para>

      <para>The Wire Admin service has a convenient function to get all the
      wires that match a filter. This method is used to list all the wires
      that belong to the current Deployment Package as well as those that have
      the matching resource id. This array is added to the
      <code>toBeDeletedWires</code> field so that it can be deleted when the
      session is successfully completed—that is, wires are not deleted until
      the commit phase. When the session is rolled back, the list of wires to
      be deleted can be discarded, because they were never really
      deleted.</para>

      <programlisting>    public void dropped(String name) throws Exception{
        List list = getWires(
            "(&amp;(resource.id=" + name + ")(deployment.package="
                + current.getName() + "))");
        toBeDeletedWires.addAll(list);
    }</programlisting>

      <para>If the session concludes without errors, the Deployment Admin
      service must call the <phrase role="xref">prepare()</phrase> method. In
      this example, it is possible to roll back the persistent changes made so
      far. The method can therefore just return.</para>

      <programlisting>    public void prepare() {}</programlisting>

      <para>The <phrase role="xref">commit()</phrase> method must now actually
      delete the wires that were removed during the session. After these wires
      are deleted, the method can throw away the list of wires that were
      created. This list was only kept to remove the wires in case of a roll
      back.</para>

      <programlisting>    public void commit() {
        delete(toBeDeletedWires);
        toBeDeletedWires.clear();
        createdWires.clear();
    }</programlisting>

      <para>The <phrase role="xref">rollback()</phrase> method is the reverse
      of the commit. Any created wires must now be deleted to undo their
      creations in this session. The wires that are to be deleted can now be
      discarded, because they have not been deleted yet and therefore do not
      have to be rolled back.</para>

      <programlisting>    public void rollback() {
        delete(createdWires);
        toBeDeletedWires.clear();
        createdWires.clear();
    }</programlisting>

      <para>The <phrase role="xref">dropAllResources()</phrase> method must
      drop all the wires that were created on behalf of the current Deployment
      Package. The filter on the <code>getWires</code> method makes this
      process very straightforward. Just delete all the wires that were tagged
      with the Deployment Package name.</para>

      <programlisting>    public void dropAllResources() {
        List list = getWires("(deployment.package=" 
            + current.getName() + ")");
        toBeDeletedWires.addAll(list);
    }</programlisting>

      <para>The <phrase role="xref">cancel()</phrase> method must cancel
      ongoing operations. This example does not have any long-running
      operations. The <code>cancel</code> method can therefore just
      return.</para>

      <programlisting>    public void cancel() {}</programlisting>

      <para>And finally, some helper methods should be
      self-explanatory.</para>

      <programlisting>    void delete(List wires) {
        while ( ! wires.isEmpty() )
            admin.deleteWire((Wire) wires.remove(0));
    }

    List getWires(String filter) {
        try {
            Wire[] wires = admin.getWires(filter);
            return Arrays.asList(wires);
        }
        catch (InvalidSyntaxException ise) {
            ise.printStackTrace();
        }
        return new Vector();
    }
}</programlisting>

      <para>This example is obviously not an "industrial-strength"
      implementation; its only purpose is to highlight the different problems
      that must be addressed. Implementers should therefore consider the
      following additional issues when implementing a Resource Processor
      service.</para>

      <itemizedlist>
        <listitem>
          <para>Changes could have been made to the Deployment Package objects
          when a Resource Processor’s bundle was updated or has been offline
          for some time, which can happen when the
          <code>uninstallForced</code> method has been used. The Deployment
          Admin service can provide sufficient information to verify its
          repository to the information maintained in the Resource Processor
          service.</para>
        </listitem>

        <listitem>
          <para>A Resource Processor service should have a strategy for
          transactions that can handle crash recovery. For example, in the
          previous code the list of <code>createdWires</code> and
          <code>toBeDeletedWires</code> should have been logged. Logging these
          lists would have allowed full crash recovery.</para>
        </listitem>

        <listitem>
          <para>Better file formats should be considered. The
          <code>Properties</code> class is too restrictive because it can only
          have a single wire per <code>Producer</code> object. The Properties
          class was only chosen for its convenience.</para>
        </listitem>

        <listitem>
          <para>Multi-threading issues may exist with the <code>cancel</code>
          method.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Events</title>

    <para>The Deployment Admin service must publish several generic events to
    the Event Admin service in the course of a deployment operation. The
    purpose of these events is to allow, for example, a user interface to
    display the progress of a deployment operation to the user.</para>

    <para>The topics to which Deployment Admin publishes events are:</para>

    <itemizedlist>
      <listitem>
        <para><code>org/osgi/service/deployment/INSTALL</code> – The <phrase
        role="xref">installDeploymentPackage(InputStream)</phrase> method has
        been called.</para>
      </listitem>

      <listitem>
        <para><code>org/osgi/service/deployment/UNINSTALL</code> – The <phrase
        role="xref">uninstall()</phrase> or <phrase
        role="xref">uninstallForced()</phrase> method has been called..</para>
      </listitem>

      <listitem>
        <para><code>org/osgi/service/deployment/COMPLETE</code> – The
        deployment operation has completed.</para>
      </listitem>
    </itemizedlist>

    <para>The <code>INSTALL,</code> <code>UNINSTALL</code> and<code>
    COMPLETE</code> events have the following property:</para>

    <itemizedlist>
      <listitem>
        <para><phrase role="xref">EVENT_DEPLOYMENTPACKAGE_NAME</phrase> –
        (String) The name of the Deployment Package. This name is the same
        name as that specified in the DeploymentPackage-SymbolicName Manifest
        header.</para>
      </listitem>

      <listitem>
        <para><phrase
        role="xref">EVENT_DEPLOYMENTPACKAGE_READABLENAME</phrase> –
        (String)</para>
      </listitem>

      <listitem>
        <para><phrase
        role="xref">EVENT_DEPLOYMENTPACKAGE_CURRENTVERSION</phrase> –
        (Version) The currently installed version of the Deployment Packages.
        This attribute is only present when there is a version of the
        Deployment Package installed before the method that generated the
        event.</para>
      </listitem>

      <listitem>
        <para><phrase role="xref">EVENT_DEPLOYMENTPACKAGE_NEXTVERSION</phrase>
        – (Version) The version of Deployment Package after the successful
        completion of the install operation.</para>
      </listitem>
    </itemizedlist>

    <para>The <code>COMPLETE</code> event additionally has the following
    property:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>successful</emphasis> – (<code>Boolean</code>) Whether
        the deployment operation was successful or not.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="i1610495">
    <title>Threading</title>

    <para>The Deployment Admin service must be a singleton and must only
    process a single session at a time. When a client requests a new session
    with an install or uninstall operation, it must block that call until the
    earlier session is completed. The Deployment Admin service must throw a
    Deployment Exception when the session cannot be created after an
    appropriate time-out period. Resource Processor services can thus assume
    that all calls from <code>begin</code> to <code>commit</code> or
    <code>rollback</code> methods are called from the same thread.</para>

    <para>Special care should be taken with the <code>cancel</code> method
    that is usually called from another thread.</para>
  </section>

  <section>
    <title>Security</title>

    <section>
      <title>Deployment Admin Permission</title>

      <para>The Deployment Admin Permission is needed to access the methods of
      the Deployment Admin service. The target for a Deployment Admin
      Permission is the same Filter string as for an Admin Permission, see
      <phrase role="xref">Admin Permission on page 108</phrase> of <phrase
      role="xref"> <xref linkend="i1516004" xrefstyle="Reference"/></phrase>
      .</para>

      <para>The actions are:</para>

      <itemizedlist>
        <listitem>
          <para><phrase role="xref">LIST</phrase> – The permission to call the
          <phrase role="xref">listDeploymentPackages()</phrase> method and
          <phrase role="xref">getDeploymentPackage(String)</phrase> .</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">INSTALL</phrase> – Allowed to call the
          <phrase role="xref">installDeploymentPackage(InputStream)</phrase>
          method.</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">UNINSTALL</phrase> – Allowed to call the
          <phrase role="xref">uninstall()</phrase> method.</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">UNINSTALL_FORCED</phrase> – Allowed to
          call the <phrase role="xref">uninstallForced()</phrase>
          method.</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">CANCEL</phrase> – Allowed to cancel an
          ongoing session.</para>
        </listitem>

        <listitem>
          <para><phrase role="xref">METADATA</phrase> – Provide access to the
          Deployment Package meta data.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Deployment Customizer Permission</title>

      <para>The <phrase role="xref">DeploymentCustomizerPermission</phrase> is
      used by customizer bundles. The target is the same as the target of
      Admin Permission: a filter that selects bundles. It has the following
      action:</para>

      <itemizedlist>
        <listitem>
          <para><phrase role="xref">PRIVATEAREA</phrase> – Permits the use of
          the private area of the target bundles.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Permissions During an Install Session</title>

      <para>Unprotected, Resource Processor services can unwittingly disrupt
      the device by processing incorrect or malicious resources in a
      Deployment Package. In order to protect the device, Resource Processor
      service's capabilities must be limited by the permissions granted to the
      union of the permissions of the Deployment Package’s
      <emphasis>signers</emphasis>. This union is called the
      <emphasis>security scope</emphasis>. Given a signer, its security scope
      can be obtained from the <phrase role="xref">Conditional Permission
      Admin Service Specification on page 277</phrase> .</para>

      <para>The Deployment Admin service must execute all Resource Processor
      service calls inside a <code>doPrivileged</code> block. This privileged
      block must use an <code>AccessControlContext</code> object that limits
      the permissions to the security scope. Therefore, a Resource Processor
      service must assume that it is always running inside the correct
      security scope. A Resource Processor can, of course, use its own
      security scope by doing a local <code>doPrivileged</code> block.</para>

      <para>Bundle life cycle operations (install, uninstall, update) must be
      performed with the permissions granted to the Deployment Admin service
      implementation, they should not be further scoped because this could
      make it impossible to install unsigned Deployment Packages.</para>
    </section>

    <section>
      <title>Contained Bundle Permissions</title>

      <para>Bundles can be signed independently from the vehicle that deployed
      them. As a consequence, a bundle can be granted more permissions than
      its parent Deployment Package.</para>
    </section>

    <section>
      <title>Service Registry Security</title>

      <section>
        <title>Deployment Admin Service</title>

        <para>The Deployment Admin service is likely to require All
        Permission. This requirement is caused by the plugin model. Any
        permission required by any of the Resource Processor services must be
        granted to the Deployment Admin service as well. This set is large and
        difficult to define. The following list, however, shows the minimum
        permissions required if the permissions for the Resource Processor
        service permissions are ignored.</para>

        <programlisting>ServicePermission    ..DeploymentAdmin      REGISTER
ServicePermission    ..ResourceProcessor    GET
PackagePermission    ..deployment           EXPORTONLY</programlisting>
      </section>

      <section>
        <title>Resource Processor</title>

        <programlisting>ServicePermission    ..DeploymentAdmin      GET
ServicePermission    ..ResourceProcessor    REGISTER
PackagePermission    ..deployment           IMPORT</programlisting>
      </section>

      <section>
        <title>Client</title>

        <programlisting>ServicePermission    ..DeploymentAdmin      GET
PackagePermission    ..deployment           IMPORT</programlisting>
      </section>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.deploymentadmin.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.deploymentadmin.spi.xml"/>

  <section>
    <title>References</title>

    <para role="ExternalReference" xml:id="i1515091">JAR File
    Specification</para>

    <para
    role="ExternalReferenceCont">http://download.oracle.com/javase/1.4.2/docs/guide/jar/jar.html</para>

    <para role="ExternalReference" xml:id="i1516004">OSGi Service Platform
    Core Specification</para>

    <para
    role="ExternalReferenceCont">http://www.osgi.org/Download/Release4V43</para>
  </section>
</chapter>
