<?xml version="1.0" encoding="utf-8"?>
<chapter label="705"
         revision="$Id$"
         version="5" xml:id="util.pushstream"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Promises Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.util.pushstream-version"
    linkend="org.osgi.util.pushstream"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>In large-scale distributed systems <emphasis>events</emphasis> are
    a commonly used communication mechanism for passing data and triggering
    behaviours. Events are typically generated 
    <emphasis>asynchronously</emphasis> rather than at the request of the
    processing system, and once received an event usually undergoes some
    level of transformation before being stored, acted upon, or forwarded to
    another consumer.</para>
    
    <para>Pipelines and streams are a popular and effective model for consuming
    and processing events, with numerous APIs providing this sort of model.
    One of the most well-known processing pipeline APIs is the Java 8 Streams
    API, which provides a functional pipleline for operating on Collections. 
    The Streams API is inherently <emphasis>pull based</emphasis>‚Äù as it relies 
    on iterators and spliterators to <emphasis>pull</emphasis> the next entry 
    from the stream. This is the primary difference between synchronous and 
    asynchronous models. In an asynchronous world events are pushed into the 
    pipeline as they are received.</para>

    <para>This specification defines a PushStream API which can be used on
    devices which support the Java 8 compact1 profile. The PushStream API
    defined by this specification depends on OSGi Promises but is 
    independent of all other OSGi specifications, including the OSGi 
    Framework, and thus can be easily used outside of the OSGi environment.</para>

    <para>A PushStream object encapsulates a pipeline of a potentially 
    asynchronous tasks which will be performed when an event arrives. The 
    result of the processing pipeline is represented using a Promise object
    which will resolve when the result has been calculated.</para>

    <para>PushStream capture the effects of errors, finite streams and back 
    pressure by making these explicit in the API signatures. Errors and End 
    of Stream conditions are represented by specific events which are pushed 
    into the stream. Back pressure is represented by a delay value returned
    from the event pipeline stages.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Common concepts</emphasis> - The API is inspired by
          the Streams API in Java 8 and uses the same basic concepts.
          See ## TODO.</para>
        </listitem>

        <listitem>
          <para><emphasis>Independent</emphasis> - The design is independent
          of all other OSGi specifications (except for OSGi Promises) and 
          can be used outside of an OSGi environment.</para>
        </listitem>

        <listitem>
          <para><emphasis>Asynchronous</emphasis> - The design is built
          to handle asynchronously produced events.</para>
        </listitem>

        <listitem>
          <para><emphasis>Back Pressure</emphasis> - The design provides
          a means for event pipelines to communicate back-pressure to
          the Event Source.</para>
        </listitem>

        <listitem>
          <para><emphasis>Complete</emphasis> - The design provides a very
          complete set of operations for PushStreams which are primitives 
          that can be used to address most use cases.</para>
        </listitem>

        <listitem>
          <para><emphasis>Generified</emphasis> - Generics are used to promote
          type safety.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Push Event Source</emphasis> - A PushEventSource
          object represents a source of asynchronous events, and can
          be used to create a PushStream.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>Push Event Consumer</emphasis> - A Push Event Consumer
          object represents a sink for asynchronous events, and can be
          attached to a PushEventSource or a PushStream.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>Push Stream</emphasis> - A PushStream object 
          represents a pipeline for processing asynchronous events.</para>
        </listitem>

        <listitem>
          <para><emphasis>Terminal Operation</emphasis> - The final operation
          of a PushStream pipeline results in a Promise which represents the
          completion state of the pipeline. The operation also begins the
          processing of events.</para>
        </listitem>
      </itemizedlist>

    </section>
  </section>

  <section>
    <title>Asynchronous Eventing Streams</title>
    
    <para>The Push Stream API is built upon the principals of Asynchronous
    Event streams, and therefore requires three basic primitives:</para>
    
    <itemizedlist>
      <listitem><para>An event object</para></listitem>
      <listitem><para>A source of event objects</para></listitem>
      <listitem><para>A consumer of event objects</para></listitem>
    </itemizedlist>
  
    <section>
      <title>The Push Event</title>
      
      <para>The Push Event is an object representing an event. Every
      Push Event has an event type, which has one of three values:</para>
      
      <itemizedlist>
        <listitem>
          <para><code>DATA</code> - A data event encapsulates a
          typed object</para></listitem>
        <listitem>
          <para><code>ERROR</code> - An error event encapsulates
          an exception and indicates a failure in the event stream.</para>
        </listitem>
        <listitem>
          <para><code>CLOSE</code> - A close event represents
          the end of the stream of events.</para>
        </listitem>
      </itemizedlist>
      
      <para>An event stream consists of zero or more data events
      followed by a <emphasis>terminal event</emphasis>. A terminal
      event is either an error or a failure, and it indicates that
      there will be no more events in this stream. Depending on the
      reason for the terminal event it may be possible to re-attach
      to the event source and consume more events.</para>
    </section>
    
    <section>
      <title>The Push Event Source</title>
  
      <para>A Push Event Source object represents a source of asynchronous
      Push Events. The event source defines a single method <xref
      linkend="org.osgi.util.pushstream.PushEventSource.open--" 
      xrefstyle="hyperlink"/> which can be used to connect to the source
      and begin receiving a stream of events.</para>
      
      <para>The <code>open</code> method of the Push Event Source returns 
      an <code>AutoCloseable</code> which can be used to close the event 
      stream. If the <code>close</code> method is called on this object then 
      the stream is terminated by sending a close event. If additional calls 
      are made to the close method then they return without further action. 
      </para>
      
    </section>

    <section>
      <title>The Push Event Consumer</title>
  
      <para>A Push Event Consumer object represents a sink for 
      asynchronous Push Events. The event consumer defines a single method 
      <xref linkend="org.osgi.util.pushstream.PushEventConsumer.accept--" 
      xrefstyle="hyperlink"/> which can be used to receive a stream of 
      events.</para>
      
      <para>The <code>accept</code> method of the Push Event Consumer 
      returns a <code>long</code> representing 
      <emphasis>back pressure</emphasis>. Back pressure is described in
      detail in <xref linkend="util.pushstream.back-pressure" 
      xrefstyle="hyperlink"/>. If the returned long is negative then
      the event stream should be closed by the event source. 
      </para>
    </section>
    
    
    <section>
      <title>Closing the Event Stream</title>
      
      <para>There are three ways in which a stream can be closed:</para>
      
      <para>The Push Event Source may close the stream at any time by
      sending a terminal event to the consumer. Upon receiving a terminal
      event the consumer should clean up any resources and not expect
      to receive further messages. Note that in a multi-threaded system
      the consumer may receive events out of order, and in this case data 
      events may be received after a terminal event. Event processors 
      should be careful to ignore data events that occur after terminal
      events, and to ensure that any downstream consumers receive any
      pending data events before forwarding the terminal event.</para>
        
      <para>The <code>open</code> method of the Push Event Source returns 
      an <code>AutoCloseable</code> which can be used to close the event 
      stream. If the <code>close</code> method is called on this object then 
      the stream is terminated by sending a close event. If additional calls 
      are made to the close method then they return without action. If the 
      close method is called after a terminal event has been sent for any
      other reason then it should return without action.</para>
       
      <para>The <code>accept</code> method of the Push Event Consumer
      returns a long indicating back pressure. If the long is negative
      then the event source should immediately close the stream by sending
      a close event.</para>
    </section>
  </section>

  <section>
    <title>The Push Stream</title>
    
      <para>Simple event passing can be achieved by connecting a Push Event
      Consumer directly to a Push Event Source, however this model forces
      a large amount of flow-control and resource management into a single
      location. Furthermore it is difficult to reuse business logic across
      different event streams.</para>
    
      <para>The Push Stream provides a powerful, flexible pipeline for event
      processing. The Push Stream API shares many concepts with the Java 8 
      Streams API, in particular Push Streams are lazy, they may not consume
      the entire event stream, and they can be composed from functional steps.
      </para>
    
    <section>
      <title>Simple Pipelines</title>

      <para>A Push Stream can be created from a Push Event Source. A
      Push Stream represents a stage in an event processing pipeline. 
      The overall pipeline is constructed from zero or more 
      <code>intermediate operations</code>, and completed with a single 
      terminal operation.</para> 
      
      <para>Each intermediate operation returns a new Push Stream object
      chained to the previous pipeline step. Once a Push Stream object has 
      had an intermediate operation invoked on it then it may not have any 
      other operations chained to it. Terminal operations are either void, 
      or return a <code>Promise</code> representing the future result of 
      the pipeline. These API patterns allow Push Streams to be built using 
      a fluent API.</para>
      
      <para>Push Stream instances are lazy, and so the Push Stream will not be 
      connected to the Push Event Source until a <code>terminal operation</code> is
      invoked on the Push Stream. This means that a push stream object can
      be safely built without events being received when the pipeline is
      partially initialized.</para>
      
      <section>
        <title>Mapping, Flat Mapping and Filtering</title>
  
        <para>The simplest intermediate operations on a Push Stream are 
        <emphasis>mapping</emphasis> and <emphasis>filtering</emphasis>.
        These operations use stateless, non-interfering functions to
        alter the data receieved by the next stage in the pipeline.</para>
        
        <section>
          <title>Mapping</title>
          
          <para>Mapping is the act of transforming an event from one type into
          another. This may involve taking a field from the object, or performing
          some simple processing on it. When mapping there is an 
          <emphasis>one to one</emphasis> relationship between input and output
          events, i.e. each input event is mapped to exactly one output event.</para>
          
          <programlisting>
    PushStream&lt;String&gt; streamOfStrings = getStreamOfStrings();
    
    PushStream&lt;Integer&gt; streamOfLengths = 
            streamOfStrings.map(String::length);
          </programlisting>
          
          <para>If the mapping function throws an Exception then an Error Event
          is propagated down the stream to the next pipeline step. The failure
          in the error event is set to the Exception thrown by the mapping
          function. The current pipeline step is also closed, and the close
          operation is propagated back upstream to the event source by
          returning negative backpressure.</para>
        </section>
        
        <section>
          <title>Flat Mapping</title>
          
          <para>Flat Mapping is the act of transforming an event from one type into
          multiple events of another type. This may involve taking fields from an
          object, or performing some simple processing on it. When flat mapping there 
          is a <emphasis>one to many</emphasis> relationship between input and output
          events, i.e. each input event is mapped to zero or more output events.</para>
          
          <para>A flat mapping function should asynchronously consume the event data
          and return a Push Stream containing the flow of subsequent events.</para>
          
          <programlisting>
    PushStream&lt;String&gt; streamOfStrings = getStreamOfStrings();
    
    PushStream&lt;Character&gt; streamOfCharacters = 
            streamOfStrings.map(s -> {
                    SimplePushEventSource&lt;Character&gt; spes = 
                            getSimplePushEventSource();
                    
                    spes.connectPromise()
                        .onResolve(() ->
                            executor.execute(() -> {
                                    for(int i = 0; i &lt; s.length; i++) {
                                        spes.publish(s.charAt(i));
                                    }
                                });
                    return pushStreamProvider.createStream(spes);
                });
          </programlisting>
          
          <para>If the flat mapping function throws an Exception then an Error Event
          is propagated down the stream to the next pipeline step. The failure
          in the error event is set to the Exception thrown by the mapping
          function. The current pipeline step is also closed, and the close
          operation is propagated back upstream to the event source by
          returning negative backpressure.</para>
        </section>
        
        <section>
          <title>Filtering</title>
          
          <para>Filtering is the act of removing events from the stream based on
          some characteristic of the event data. This may involve inspecting the
          fields of the data object, or performing some simple processing on it. 
          If the filter function returns true for an event then it will be passed
          to the next stage of the pipeline. If the filter function returns false
          then it will be discarded, and not passed to the next pipeline stage.</para>
          
          <programlisting>
    PushStream&lt;String&gt; streamOfStrings = getStreamOfStrings();
    
    PushStream&lt;String&gt; filteredStrings = 
            streamOfStrings.map(s -> s.length() == 42);
          </programlisting>
          
          <para>If the filtering function throws an Exception then an Error Event
          is propagated down the stream to the next pipeline step. The failure
          in the error event is set to the Exception thrown by the filter
          function. The current pipeline step is also closed, and the close
          operation is propagated back upstream to the event source by
          returning negative backpressure.</para>
        </section>
      </section>
      
      <section>
        <title>Stateless and Stateful Operations</title>
        
        <para>Intermediate operations are either <emphasis>stateless</emphasis>
         or <emphasis>stateful</emphasis>. Stateless operations are ones
         where the pipeline stage does not need to remember the previous
         data from the stream. Mapping, Flat Mapping and Filtering are
         all stateless operations.</para>
         
         <para>Stateful operations differ from stateless operations in that
         they must remember items from the stream. Sometimes stateful operations
         must remember large numbers of events, or even the entire stream.
         For example the <code>distinct</code> operation remembers the identity
         of each entry in the stream, and filters out duplicate events.</para>
         
         <para>Care should be taken when using Stateful operations with large
         or infinite streams. Ror example the <code>sorted</code> operation
         must process the <emphasis>entire</emphasis> stream until it receives 
         a close event. At this point the events can be sorted and delivered 
         in order. It is usually a good idea to use the <code>limit</code>
         operation to restrict the length of the stream before performing
         a stateful operation.</para>
      </section>
      
      <section>
        <title>Terminal Operations</title>
  
        <para>Terminal operations mark the end of a processing pipeline. Invoking
        a terminal operation causes the PushStream to connect to its underlying
        event source and begin processing.</para>
        
        <para>The simplest terminal operation is the <code>count</code> 
        operation. This method returns a promise that will resolve when the stream
        finishes. If the stream finishes with a close event then the promise will
        resolve with a Long representing the number of events that reached the end 
        of the pipeline. If the stream finishes with an error then the promise will
        fail with that error.</para> 
        
        <para>Some terminal operations, like <code>count</code> require the full
        stream to be processed, others are are able to finish before the end of
        the stream. These are known as <code>short circuiting</code> operations.
        An example of a short-circuiting operation is <code>findFirst</code>. This
        operation resolves the promise with the first event that is received by
        the end of the pipeline. Once a short-circuiting operation has completed
        it propagates negative back-pressure through the pipeline to close the
        source of events.</para>
        
        <table>
          <title>Terminal Operations on the Push Stream</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth="1.6*"/>
        
        <colspec colnum="2" colwidth="0.8*"/>

        <colspec colnum="3" colwidth="4.0*"/>

        <thead>
          <row>
            <entry>Terminal Operation</entry>

            <entry>Short-circuiting</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>forEach()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Register a function to be called back with the data
            from each event in the stream</para></entry>
          </row>

          <row>
            <entry><code>forEachEvent()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Register a <code>PushEventConsumer</code> to be called 
            back with each event in the stream. If negative back-pressure is
            returned then the stream will be closed.</para></entry>
          </row>

          <row>
            <entry><code>toArray()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Collects together all of the event data in a
            single array which is used to resolve the returned promise.</para></entry>
          </row>

          <row>
            <entry><code>reduce()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Uses a Binary Operator function to combine event data
            into a single object. The promise is resolved with the final result
            when the stream finishes.</para></entry>
          </row>

          <row>
            <entry><code>collect()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Uses the Java Collector API to collect the data from
            events into a single Collection, Map, or other type.</para></entry>
          </row>
          
          <row>
            <entry><code>min()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Uses a Comparator to find the smallest data element in
            the stream of data. The promise is resolved with the final result
            when the stream finishes.</para></entry>
          </row>
          
          <row>
            <entry><code>max()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Uses a Comparator to find the largest data element in
            the stream of data. The promise is resolved with the final result
            when the stream finishes.</para></entry>
          </row>

          <row>
            <entry><code>count()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Counts the number of events that reach the end of
            the stream pipeline.</para></entry>
          </row>

          <row>
            <entry><code>anyMatch()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Resolves with <code>true</code> if any data event reaches
            the end of the stream pipeline and matches the supplied predicate.
            If the stream ends without any data matching the predicate then
            the promise resolves with <code>false</code></para></entry>
          </row>

          <row>
            <entry><code>allMatch()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Resolves with <code>false</code> if any event reaches
            the end of the stream pipeline that does not match the predicate.
            If the stream ends without any data matching the predicate then
            the promise resolves with <code>true</code></para></entry>
          </row>
          
          <row>
            <entry><code>anyMatch()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Resolves with <code>true</code> if any data event reaches
            the end of the stream pipeline and matches the supplied predicate.
            If the stream ends without any data matching the predicate then
            the promise resolves with <code>false</code></para></entry>
          </row>

          <row>
            <entry><code>findFirst()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Resolves with an Optional representing the data
            from the first event that reaches the end of the pipeline. 
            If the stream ends without any data reaching the end of the
            pipleine then the promise resolves with an empty Optional.</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
        
      </section>
    </section>
    
    <section>
      <title>Buffering, Back pressure and Circuit Breakers</title>
    
      <para>TODO</para>
    
      <section xml:id="util.pushstream.back-pressure">
        <title>Back pressure</title>
        <para>TODO</para>
      </section>
    
    </section>
    
    <section>
      <title>Coalescing and Windowing</title>
  
      <para>TODO</para>
    </section>

    <section>
      <title>Aggregating and Splitting</title>
  
      <para>TODO</para>
    </section>
    
    <section>
      <title>The Push Stream Provider</title>
    
      <para>TODO</para>
      
      <section>
        <title>Building Buffers</title>
  
        <para>TODO</para>
      </section>

      <section>
        <title>Simple Push Event Sources</title>
  
        <para>TODO</para>
      </section>
      
    </section>
    
    
    
  </section>


  <section>
    <title>Security</title>

    <para>The Push Stream API does not define any OSGi services nor does the 
    API perform any privileged actions. Therefore, it has no security
    considerations.</para>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.util.pushstream.xml"/>

  <section>
    <title>References</title>
      <para>TODO</para>

  </section>

</chapter>
