<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5" label="105" xml:id="i1495494" xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Metatype Service Specification</title>
<info xml:id="i1434957"><releaseinfo>Version 1.2</releaseinfo></info>
<section><title>Introduction</title>
<para>The Metatype specification defines interfaces that allow bundle
developers to describe attribute types in a computer readable form
using so-called <emphasis>metadata</emphasis>.</para>
<para>The purpose of this specification is to allow services to
specify the type information of data that they can use as arguments.
The data is based on <emphasis>attributes</emphasis>, which are
key/value pairs like properties.</para>
<para>A designer in a type-safe language like Java is often confronted
with the choice of using the language constructs to exchange data
or using a technique based on attributes/properties that are based
on key/value pairs. Attributes provide an escape from the rigid
type-safety requirements of modern programming languages. </para>
<para>Type-safety works very well for software development environments
in which multiple programmers work together on large applications
or systems, but often lacks the flexibility needed to receive structured
data from the outside world. </para>
<para>The attribute paradigm has several characteristics that make
this approach suitable when data needs to be communicated between
different entities which “speak” different languages. Attributes
are uncomplicated, resilient to change, and allow the receiver to
dynamically adapt to different types of data.</para>
<para>As an example, the OSGi framework Specifications define several
attribute types which are used in a Framework implementation, but
which are also used and referenced by other OSGi specifications such
as the 
<phrase role="xref">Configuration Admin Service Specification on
page 57</phrase>
. A Configuration Admin service implementation deploys attributes
(key/value pairs) as configuration properties.</para>
<para>The Meta Type Service provides a unified access point to the
Meta Type information that is associated with bundles. This Meta
Type information can be defined by an XML resource in a bundle (<code>OSGI-INF/metatype</code> directories
must be scanned for any XML resources), it can come from the Meta
Type Provider service, or it can be obtained from Managed Service
or Managed Service Factory services.</para>
<section><title>Essentials</title>
<itemizedlist><listitem><para><emphasis>Conceptual model</emphasis> –
The specification must have a conceptual model for how classes and
attributes are organized. </para></listitem>
<listitem><para><emphasis>Standards</emphasis> – The specification
should be aligned with appropriate standards, and explained in situations
where the specification is not aligned with, or cannot be mapped
to, standards.</para></listitem>
<listitem><para><emphasis>Remote Management</emphasis> – Remote
management should be taken into account.</para></listitem>
<listitem><para><emphasis>Size</emphasis> – Minimal overhead in
size for a bundle using this specification is required.</para></listitem>
<listitem><para><emphasis>Localization</emphasis> – It must be possible
to use this specification with different languages at the same time. This
ability allows servlets to serve information in the language selected
in the browser.</para></listitem>
<listitem><para><emphasis>Type information</emphasis> – The definition
of an attribute should contain the name (if it is required), the
cardinality, a label, a description, labels for enumerated values,
and the Java class that should be used for the values.</para></listitem>
<listitem><para><emphasis>Validation</emphasis> – It should be possible
to validate the values of the attributes.</para></listitem></itemizedlist></section>
<section xml:id="i1504332"><title>
Entities</title>
<itemizedlist><listitem><para><emphasis>Meta Type Service</emphasis> –
A service that provides a unified access point for meta type information.</para></listitem>
<listitem><para><emphasis>Attribute</emphasis> – A key/value pair.</para></listitem>
<listitem><para><emphasis>PID</emphasis> – A unique persistent ID,
defined in configuration management.</para></listitem>
<listitem><para><emphasis>Attribute Definition</emphasis> – Defines
a description, name, help text, and type information of an attribute.</para></listitem>
<listitem><para><emphasis>Object Class Definition</emphasis> – Defines
the type of a datum. It contains a description and name of the type plus
a set of <code>AttributeDefinition</code> objects.</para></listitem>
<listitem><para><emphasis>Meta Type Provider</emphasis> – Provides
access to the object classes that are available for this object.
Access uses the PID and a locale to find the best <code>ObjectClassDefinition</code> object.</para></listitem>
<listitem><para><emphasis>Meta Type Information</emphasis> – Provides
meta type information for a bundle.</para></listitem></itemizedlist>
<figure><title>, org.osgi.service.metatype</title><mediaobject><imageobject><imagedata fileref="GRAPHIC1" align="center" contentwidth="6.500in" contentdepth="2.098in"/></imageobject></mediaobject></figure></section>
<section><title>Operation</title>
<para>The Meta Type service defines a rich dynamic typing system
for properties. The purpose of the type system is to allow reasonable
User Interfaces to be constructed dynamically.</para>
<para>The type information is normally carried by the bundles themselves.
Either by implementing the <code>MetaTypeProvider</code> interface
on the Managed Service or Managed Service Factory, by carrying one
or more XML resources that define a number of Meta Types in the <code>OSGI-INF/metatype</code> directories,
or registering a Meta Type Provider as a service. Additionally,
a Meta Type service could have other sources that are not defined
in this specification.</para>
<para>The Meta Type Service provides unified access to Meta Types
that are carried by the resident bundles. The Meta Type Service
collects this information from the bundles and provides uniform
access to it. A client can requests the Meta Type Information associated
with a particular bundle. The <code>MetaTypeInformation</code> object
provides a list of <code>ObjectClassDefinition</code> objects for
a bundle. These objects define all the information for a specific 
<emphasis>object class</emphasis>. An object class is a some descriptive
information and a set of named attributes (which are key/value pairs). </para>
<para>Access to Object Class Definitions is qualified by a locale
and a Persistent IDentity (<?FM MARKER [Hypertext] PID?>
PID). This specification does not specify what the PID means. One
application is OSGi Configuration Management where a PID is used
by the Managed Service and Managed Service Factory services. In
general, a PID should be regarded as the name of a variable where
an Object Class Definition defines its type. </para></section></section>
<section><title>Attributes Model</title>
<para xml:id="i1279629">The Framework uses the 
LDAP filter syntax
for searching the Framework registry. The usage of the attributes
in this specification and the Framework specification closely resemble
the LDAP attribute model. Therefore, the names used in this specification
have been aligned with LDAP. Consequently, the interfaces which
are defined by this Specification are:</para>
<itemizedlist><listitem><para><code>AttributeDefinition</code></para></listitem>
<listitem><para><code>ObjectClassDefinition</code></para></listitem>
<listitem><para><code>MetaTypeProvider</code> </para></listitem></itemizedlist>
<para>These names correspond to the LDAP attribute model. For further
information on ASN.1-defined attributes and X.500 object classes
and attributes, see 
<phrase role="xref">
<xref xrefstyle="Reference" linkend="i1215870"/></phrase>
.</para>
<para>The LDAP attribute model assumes a global name-space for attributes,
and object classes consist of a number of attributes. So, if an
object class inherits the same attribute from different parents,
only one copy of the attribute must become part of the object class
definition. This name-space implies that a given attribute, for
example <code>cn</code>, should <emphasis>always</emphasis> be the
common name and the type must always be a <code>String</code>. An
attribute <code>cn</code> cannot be an <code>Integer</code> in another
object class definition. In this respect, the OSGi approach towards
attribute definitions is comparable with the LDAP attribute model.</para></section>
<section><title>Object Class Definition</title>
<para>The <code>ObjectClassDefinition</code> interface is used to
group the attributes which are defined in <code>AttributeDefinition</code> objects.</para>
<para xml:id="i1279638">An <code>ObjectClassDefinition</code> object
contains the information about the overall set of 
attributes and
has the following elements:</para>
<itemizedlist><listitem><para>A name which can be returned in different
locales.</para></listitem>
<listitem><para>	A global name-space in the registry, which is the
same condition as LDAP/X.500 object classes. In these standards
the OSI Object Identifier (OID) is used to uniquely identify object
classes. If such an OID exists, (which can be requested at several
standard organizations, and many companies already have a node in
the tree) it can be returned here. Otherwise, a unique id should
be returned. This id can be a Java class name (reverse domain name)
or can be generated with a GUID algorithm. All LDAP-defined object
classes already have an associated OID. It is strongly advised to
define the object classes from existing LDAP schemes which provide
many preexisting OIDs. Many such schemes exist ranging from postal
addresses to DHCP parameters.</para></listitem>
<listitem><para>A human-readable description of the class.</para></listitem>
<listitem><para>A list of attribute definitions which can be filtered
as required, or optional. Note that in X.500 the mandatory or required
status of an attribute is part of the object class definition and
not of the attribute definition.</para></listitem>
<listitem><para>An icon, in different sizes.</para></listitem></itemizedlist></section>
<section xml:id="i1504333"><title>
Attribute
Definition</title>
<para>The <code>AttributeDefinition</code> interface provides the
means to describe the data type of attributes.</para>
<para>The <code>AttributeDefinition</code> interface defines the
following elements:</para>
<itemizedlist><listitem><para>	Defined names (final ints) for the
data types as restricted in the Framework for the attributes, called the
syntax in OSI terms, which can be obtained with the <code>getType()</code> method.</para></listitem>
<listitem><para>	<code>AttributeDefinition</code> objects should
use an ID that is similar to the OID as described in the ID field
for <code>ObjectClassDefinition</code>.</para></listitem>
<listitem><para>	A localized name intended to be used in user interfaces.</para></listitem>
<listitem><para>	A localized description that defines the semantics
of the attribute and possible constraints, which should be usable
for tooltips.</para></listitem>
<listitem><para>	An indication if this attribute should be stored
as a unique value, a <code>Vector</code>, or an array of values,
as well as the maximum cardinality of the type.</para></listitem>
<listitem><para>	The data type, as limited by the Framework service
registry attribute types.</para></listitem>
<listitem><para>	A validation function to verify if a possible value
is correct.</para></listitem>
<listitem><para> 	A list of values and a list of localized labels.
Intended for popup menus in GUIs, allowing the user to choose from
a set. </para></listitem>
<listitem><para>	A default value (String[]). The return depends
on the following cases:</para>
<itemizedlist><listitem><para><emphasis>not specified</emphasis> –
Return <code>null</code> if this attribute is not specified.</para></listitem>
<listitem><para><emphasis>cardinality = 0</emphasis> – Return an
array with one element. </para></listitem>
<listitem><para><emphasis>otherwise</emphasis> – Return an array
with less or equal than the absolute value of cardinality, possibly
empty if the value is an empty string.</para></listitem></itemizedlist></listitem></itemizedlist></section>
<section xml:id="i1450077"><title>
Meta Type
Service</title>
<para>The Meta Type Service provides unified access to Meta Type
information that is associated with a Bundle. It can get this information
through the following means:</para>
<itemizedlist><listitem><para><emphasis>Meta Type Resource</emphasis> –
A bundle can provide one or more XML resources that are contained
in its JAR file. These resources contain an XML definition of meta
types as well as to what PIDs these Meta Types apply. These XML
resources must reside in the <code>OSGI-INF/metatype</code> directories
of the bundle (including any fragments).</para></listitem>
<listitem><para><emphasis>Managed Service [Factory] objects </emphasis>–
As defined in the configuration management specification, <code>ManagedService</code> and 
<code>ManagedServiceFactory</code> service objects can optionally
implement the <code>MetaTypeProvider</code> interface. The Meta
Type Service will only search for <code>MetaTypeProvider</code> objects
if no meta type resources are found in the bundle.</para></listitem>
<listitem><para><emphasis>Meta Type Provider service</emphasis> –
Bundles can register Meta Type Provider services to dynamically
provide meta types for PIDs and factory PIDs.</para></listitem></itemizedlist>
<figure xml:id="i1386202"><title>Sources for Meta Types</title><mediaobject><imageobject><imagedata fileref="GRAPHIC2" align="center" contentwidth="5.470in" contentdepth="1.619in"/></imageobject></mediaobject></figure>
<para>This model is depicted in 
<phrase role="xref">
<xref xrefstyle="FigureNumber" linkend="i1386202"/></phrase>
.</para>
<para>The Meta Type Service can therefore be used to retrieve meta
type information for bundles which contain Meta Type resources or
which provide their own <code>MetaTypeProvider</code> objects. The 
<code>MetaTypeService</code> interface has a single method:</para>
<itemizedlist><listitem><para><phrase role="xref">getMetaTypeInformation(Bundle)</phrase>
 – Given a bundle, it must return the Meta Type Information for
that bundle, even if there is no meta type information available
at the moment of the call.</para></listitem></itemizedlist>
<para>The returned <code>MetaTypeInformation</code> object maintains
a map of PID to <code>ObjectClassDefinition</code> objects. The
map is keyed by locale and PID. The list of maintained PIDs is available
from the <code>MetaTypeInformation</code> object with the following
methods:</para>
<itemizedlist><listitem><para><phrase role="xref">getPids()</phrase>
 – PIDs for which Meta Types are available. </para></listitem>
<listitem><para><phrase role="xref">getFactoryPids()</phrase>
 – PIDs associated with Managed Service Factory services.</para></listitem></itemizedlist>
<para>These methods and their interaction with the Meta Type resource
are described in 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1492258"/></phrase>
.</para>
<para>The <code>MetaTypeInformation</code> interface extends the <code>MetaTypeProvider</code> interface.
The <code>MetaTypeProvider</code> interface is used to access meta
type information. It supports locale dependent information so that
the text used in <code>AttributeDefinition</code> and <code>ObjectClassDefinition</code> objects
can be adapted to different locales.</para>
<para>Which locales are supported by the <code>MetaTypeProvider</code> object
are defined by the implementer or the meta type resources.The list
of available locales can be obtained from the <code>MetaTypeProvider</code> object.</para>
<para>The MetaTypeProvider interface provides the following methods:</para>
<itemizedlist><listitem><para><phrase role="xref">getObjectClassDefinition(String,String)</phrase>
 – Get access to an ObjectClassDefinition object for the given PID.
The second parameter defines the locale.</para></listitem>
<listitem><para><phrase role="xref">getLocales()</phrase>
 – List the locales that are available.</para></listitem></itemizedlist>
<para>Locale objects are represented in <code>String</code> objects
because not all profiles support Locale. The <code>String</code> holds the
standard Locale presentation of:</para>
<programlisting>locale = language ( ’_’ country ( ’_’ variation))
language ::= &lt; defined by ISO 3166 &gt;
country  ::= &lt; defined by ISO 639 &gt;</programlisting>
<para>For example, <code>en</code>, <code>nl_BE</code>, <code>en_CA_posix</code> are
valid locales. The use of <code>null</code> for locale indicates
that  <code>java.util.Locale.getDefault()</code> must be used.</para>
<para>The Meta Type Service implementation class is the main class.
It registers the <code>org.osgi.service.metatype.MetaTypeService</code> service
and has a method to get a <code>MetaTypeInformation</code> object
for a bundle.</para>
<para>Following is some sample code demonstrating how to print out
all the Object Class Definitions and Attribute Definitions contained
in a bundle:</para>
<programlisting>void printMetaTypes( MetaTypeService mts,Bundle b ) {
	MetaTypeInformation mti = 
		mts.getMetaTypeInformation(b);
	String [] pids = mti.getPids();
	String [] locales = mti.getLocales();

	for ( int locale = 0; locale&lt;locales.length; locale++) {
		System.out.println("Locale " + locales[locale] );
		for (int i=0; i&lt; pids.length; i++) {
   		  	ObjectClassDefinition ocd = 
				mti.getObjectClassDefinition(pids[i], null);
     			AttributeDefinition[] ads = 
				ocd.getAttributeDefinitions(
					ObjectClassDefinition.ALL);
     			for (int j=0; j&lt; ads.length; j++) {
          	System.out.println("OCD="+ocd.getName()
					+ "AD="+ads[j].getName());
     			}
		}
	}
}</programlisting></section>
<section xml:id="i1550143"><title>
Meta
Type Provider Service</title>
<para>A Meta Type Provider service allows third party contributions
to the internal Object Class Definition repository. A Meta Type
Provider can contribute multiple PIDs, both factory and singleton
PIDs. A Meta Type Provider service must register with both or one
of the following service properties:</para>
<itemizedlist><listitem><para><phrase role="xref">METATYPE_PID</phrase>
 – (<code>String+</code>) Provides a list of PIDs that this Meta
Type Provider can provide Object Class Definitions for. The listed
PIDs are intended to be used as normal singleton PIDs used by Managed
Services.</para></listitem>
<listitem><para><phrase role="xref">METATYPE_FACTORY_PID</phrase>
 – (<code>String+</code>) Provides a list of factory PIDs that this
Meta Type Provider can provide Object Class Definitions for. The
listed PIDs are intended to be used as factory PIDs used by Managed
Service Factories.</para></listitem></itemizedlist>
<para>The Object Class Definitions must originate from the bundle
that registered the Meta Type Provider service. Third party extenders
should therefore use the bundle of their extendee. A Meta Type Service must
report these Object Class Definitions on the Meta Type Information
of the registering bundle, merged with any other information from
that bundle.</para>
<para>The Meta Type Service must track these Meta Type Provider
services and make their Meta Types available as if they were provided
on the Managed Service (Factory) services. The Meta Types must become
unavailable when the Meta Type Provider service is unregistered.</para></section>
<section xml:id="i1504250"><title>
Using
the Meta Type Resources</title>
<para>A bundle that wants to provide meta type resources must place
these resources in the <code>OSGI-INF/metatype</code> directory.
The name of the resource must be a valid JAR path. All resources
in that directory must be meta type documents. Fragments can contain
additional meta type resources in the same directory and they must
be taken into account when the meta type resources are searched.
A meta type resource must be encoded in UTF-8. </para>
<para>The MetaType Service must support localization of the</para>
<itemizedlist><listitem><para>name</para></listitem>
<listitem><para>icon</para></listitem>
<listitem><para>description</para></listitem>
<listitem><para>label attributes</para></listitem></itemizedlist>
<para>The localization mechanism must be identical using the same
mechanism as described in the Core module layer, section 
<phrase role="xref">Localization on page 64</phrase>
, using the same property resource. However, it is possible to override
the property resource in the meta type definition resources with
the <code>localization</code> attribute of the <code>MetaData</code> element.</para>
<para>The Meta Type Service must examine the bundle and its fragments
to locate all localization resources for the localization base name.
From that list, the Meta Type Service derives the list of locales
which are available for the meta type information. This list can
then be returned by <code>MetaTypeInformation.getLocales</code> method.
This list can change at any time because the bundle could be refreshed.
Clients should be prepared that this list changes after they received
it.</para>
<section><title>XML Schema of a Meta Type Resource</title>
<para>This section describes the schema of the meta type resource.
This schema is not intended to be used during runtime for validating
meta type resources. The schema is intended to be used by tools
and external management systems.</para>
<para>The XML namespace for meta type documents must be:</para>
<programlisting>http://www.osgi.org/xmlns/metatype/v1.2.0</programlisting>
<para>The namespace abbreviation should be <code>metatype</code>.
I.e. the following header should be:</para>
<programlisting>&lt;metatype:MetaData 
	xmlns:metatype=
		"http://www.osgi.org/xmlns/metatype/v1.2.0" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	&gt;</programlisting>
<para>The file can be found in the osgi.jar file that can be downloaded
from the www.osgi.org web site.</para>
<figure><title>XML Schema Instance Structure (Type name = Element name)</title><mediaobject><imageobject><imagedata fileref="GRAPHIC3" align="center" contentwidth="4.280in" contentdepth="3.357in"/></imageobject></mediaobject></figure>
<para>The element structure of the XML file is:</para>
<programlisting>MetaData 				::= OCD* Designate*

OCD				::= AD+  Icon  
AD				::= Option*

Designate				::= Object  
Object				::= Attribute *

Attribute 				::= Value *</programlisting>
<para>The different elements are described in 
<phrase role="xref">Table 105.1</phrase>
.</para><table><title>
XML
Schema for Meta Type resources</title><tgroup cols="2"><thead><row><entry><para/></entry><entry><para>Attribute</para></entry><entry><para>Deflt</para></entry><entry><para>Type</para></entry><entry><para>Method</para></entry><entry><para>Description</para></entry></row></thead><tbody><row><entry><code>MetaData</code></entry><entry><para>Top Element</para></entry></row><row><entry/><entry><code>localization</code></entry><entry/><entry><code>string</code></entry><entry><para/></entry><entry><para>Points to the Properties file that can localize this
XML. See 
<phrase role="xref">Localization on page 64</phrase>
 of the Core book.</para></entry></row><row><entry><code>OCD</code></entry><entry><para>Object Class Definition</para></entry></row><row><entry/><entry><code>name</code></entry><entry><code>&lt;&gt;</code></entry><entry><code>string</code></entry><entry><para><phrase role="xref">getName()</phrase></para></entry><entry><para> A human readable name that can be localized.</para></entry></row><row><entry/><entry><code>description</code></entry><entry/><entry/><entry><para><phrase role="xref">getDescription()</phrase></para></entry><entry><para>A human readable description of the Object Class Definition
that can be localized. </para></entry></row><row><entry/><entry><code>id</code></entry><entry><code>&lt;&gt;</code></entry><entry/><entry><para><phrase role="xref">getID()</phrase></para></entry><entry><para>A unique id, cannot be localized.</para>
<para/></entry></row><row><entry><code>Designate</code></entry><entry><para>An association between one PID and an Object Class
Definition. This element <emphasis>designates</emphasis> a PID to
be of a certain <emphasis>type</emphasis>.</para></entry></row><row><entry/><entry><code>pid</code></entry><entry><code>&lt;&gt;</code></entry><entry><code>string</code></entry><entry><para/></entry><entry><para>The PID that is associated with an <code>OCD</code>. This
can be a reference to a factory or singleton configuration object.
Either <code>pid</code> or <code>factoryPid</code> must be specified.
See 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1492258"/></phrase>
.</para></entry></row><row><entry/><entry><code>factoryPid</code></entry><entry/><entry><code>string</code></entry><entry><para/></entry><entry><para>If the <code>factoryPid</code> attribute is set, this
Designate element defines a factory configuration for the given
factory, if it is not set or empty, it designates a singleton configuration.
Either <code>pid</code> or <code>factoryPid</code> must be specified.
See 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1492258"/></phrase>
.</para></entry></row><row><entry/><entry><code>bundle</code></entry><entry/><entry><code>string</code></entry><entry><para/></entry><entry><para>Location of the bundle that implements the PID. This
binds the PID to the bundle. I.e. no other bundle using the same PID
may use this designation. In a Meta Type resource this field may
be set to an wildcard (\u002A, <code>"*"</code>) to indicate the bundle
where the resource comes from. This is an optional attribute but
can be mandatory in certain usage schemes, for example the Autoconf
Resource Processor.</para></entry></row><row><entry/><entry><code>optional</code></entry><entry><code>false</code></entry><entry><code>boolean</code></entry><entry><para/></entry><entry><para>If <code>true</code>, then this Designate element is optional,
errors during processing must be ignored.</para></entry></row><row><entry/><entry><code>merge</code></entry><entry><code>false</code></entry><entry><code>boolean</code></entry><entry><para/></entry><entry><para>If the PID refers to an existing variable, then merge
the properties with the existing properties if this attribute is <code>true</code>.
Otherwise, replace the properties.</para></entry></row><row><entry><code>AD</code></entry><entry/><entry/><entry/><entry><para/></entry><entry><para>Attribute Definition</para></entry></row><row><entry/><entry><code>name</code></entry><entry/><entry><code>string</code></entry><entry><para><phrase role="xref">getName()</phrase></para></entry><entry><para>A localizable name for the Attribute Definition. <code>description</code></para></entry></row><row><entry/><entry><code>description</code></entry><entry/><entry><code>string</code></entry><entry><para><phrase role="xref">getDescription()</phrase></para></entry><entry><para>A localizable description for the Attribute Definition. </para></entry></row><row><entry/><entry><code>id</code></entry><entry/><entry/><entry><para><phrase role="xref">getID()</phrase></para></entry><entry><para> The unique ID of the Attribute Definition.</para></entry></row><row><entry/><entry><code>type</code></entry><entry/><entry><code>string</code></entry><entry><para><phrase role="xref">getType()</phrase></para></entry><entry><para>The type of an attribute is an enumeration of the different
scalar types. The string is mapped to one of the constants on the
AttributeDefinition interface. Valid values, which are defined in
the <code>Scalar</code> type, are:</para>
<programlisting>String			<symbol>↔</symbol>		<phrase role="xref">STRING</phrase>
Long			<symbol>↔</symbol>		<phrase role="xref">LONG</phrase>
Double			<symbol>↔</symbol>		<phrase role="xref">DOUBLE</phrase>
Float			<symbol>↔</symbol>		<phrase role="xref">FLOAT</phrase>
Integer			<symbol>↔</symbol>		<phrase role="xref">INTEGER</phrase>
Byte			<symbol>↔</symbol>		<phrase role="xref">BYTE</phrase>
Char			<symbol>↔</symbol>	 	<phrase role="xref">CHARACTER</phrase>
Boolean			<symbol>↔</symbol>		<phrase role="xref">BOOLEAN</phrase>
Short			<symbol>↔</symbol>		<phrase role="xref">SHORT</phrase>
Password <symbol>↔</symbol>	 				<phrase role="xref">PASSWORD</phrase></programlisting></entry></row><row><entry/><entry><code>cardinality</code></entry><entry><code>0</code></entry><entry/><entry><para><phrase role="xref">getCardinality()</phrase></para></entry><entry><para>The number of elements an instance can take. Positive
numbers describe an array (<code>[]</code>) and negative numbers describe
a <code>Vector</code> object.</para></entry></row><row><entry/><entry><code>min</code></entry><entry/><entry><code>string</code></entry><entry><para><phrase role="xref">validate(String)</phrase></para></entry><entry><para> A validation value. This value is not directly available
from the <code>AttributeDefinition</code> interface. However, the 
<phrase role="xref">validate(String)</phrase>
 method must verify this. The semantics of this field depend on
the type of this Attribute Definition.</para></entry></row><row><entry/><entry><code>max</code></entry><entry/><entry><code>string</code></entry><entry><para><phrase role="xref">validate(String)</phrase></para></entry><entry><para>A validation value. Similar to the <code>min</code> field.</para></entry></row><row><entry/><entry><code xml:id="i1366390">
default</code></entry><entry/><entry><code>string</code></entry><entry><para><phrase role="xref">getDefaultValue()</phrase></para></entry><entry><para>The default value. A default is an array of <code>String</code> objects.
The XML attribute must contain a comma delimited list. The default
value is trimmed and escaped in the same way as described in the <code>validate(String)</code> method.
The empty string is a valid value. If the empty string specifies
the default for an attribute with cardinality that is not equal to
zero then it must be seen as an empty Vector or array.</para></entry></row><row><entry/><entry><code>required</code></entry><entry><code>true</code></entry><entry><code>boolean</code></entry><entry><para/></entry><entry><para>Required attribute. The <code>required</code> attribute indicates
whether or not the attribute key must appear</para>
<para>within the configuration dictionary to be valid.</para></entry></row><row><entry><code>Option</code></entry><entry><para>One option label/value for the options in an <code>AD</code>.</para></entry></row><row><entry/><entry><code>label</code></entry><entry><code>&lt;&gt;</code></entry><entry><code>string</code></entry><entry><para><phrase role="xref">getOptionLabels()</phrase></para></entry><entry><para>The label</para></entry></row><row><entry/><entry><code>value</code></entry><entry><code>&lt;&gt;</code></entry><entry><code>string</code></entry><entry><para><phrase role="xref">getOptionValues()</phrase></para></entry><entry><para>The value</para></entry></row><row><entry><code>Icon</code></entry><entry><para>An icon definition. </para></entry></row><row><entry/><entry><code>resource</code></entry><entry><code>&lt;&gt;</code></entry><entry><code>string</code></entry><entry><para><phrase role="xref">getIcon(int)</phrase></para></entry><entry><para>The resource is a URL. The base URL is assumed to be
the XML file with the definition. I.e. if the XML is a resource in
the JAR file, then this URL can reference another resource in that
JAR file using a relative URL.</para></entry></row><row><entry/><entry><code>size</code></entry><entry><code>&lt;&gt;</code></entry><entry><code>string</code></entry><entry><para><phrase role="xref">getIcon(int)</phrase></para></entry><entry><para>The number of pixels of the icon, maps to the size
parameter of the 
<phrase role="xref">getIcon(int)</phrase>
 method.</para></entry></row><row><entry><code>Object</code></entry><entry><para>A definition of an instance.</para></entry></row><row><entry/><entry><code>ocdref</code></entry><entry><code>&lt;&gt;</code></entry><entry><code>string</code></entry><entry><para/></entry><entry><para>A reference to the id attribute of an OCD element.
I.e. this attribute defines the OCD type of this object.</para></entry></row><row><entry><code>Attribute</code></entry><entry><para>A value for an attribute of an object. </para></entry></row><row><entry/><entry><code>adref</code></entry><entry><code>&lt;&gt;</code></entry><entry><code>string</code></entry><entry><para/></entry><entry><para>A reference to the id of the <code>AD</code> in the <code>OCD</code> as
referenced by the parent <code>Object</code>. </para></entry></row><row><entry/><entry><code>content</code></entry><entry/><entry><code>string</code></entry><entry><para/></entry><entry><para>The content of the attributes. If this is an array,
the content must be separated by commas (<code>’,’ \u002C</code>).
Commas must be escaped as described at the 
<phrase role="xref">
<xref xrefstyle="HeadingOnly" linkend="i1366390"/></phrase>
 attribute of the <code>AD</code> element. See 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1366390"/></phrase>
.</para></entry></row><row><entry><code>Value</code></entry><entry><para>Holds a single value. This element can be repeated
multiple times under an Attribute </para></entry></row></tbody></tgroup></table></section>
<section xml:id="i1492258"><title>
Use
of the Designate Element</title>
<para>For the MetaType Service, the <code>Designate</code> definition
is used to declare the available PIDs and factory PIDs; the Attribute
elements are never used by the MetaType service.</para>
<para>The 
<phrase role="xref">getPids()</phrase>
 method returns an array of PIDs that were specified in the <code>pid</code> attribute
of the Object elements. The 
<phrase role="xref">getFactoryPids()</phrase>
 method returns an array of the <code>factoryPid</code> attributes.
For factories, the related <code>pid</code> attribute is ignored because
all instances of a factory must share the same meta type.</para>
<para>The following example shows a metatype reference to a singleton
configuration and a factory configuration.</para>
<programlisting>	&lt;Designate pid="com.acme.designate.1"&gt;
		&lt;Object ocdref="com.acme.designate"./&gt;
	&lt;/Designate&gt;
	&lt;Designate factoryPid="com.acme.designate.factory"
		bundle="*"&gt;
		&lt;Object ocdref="com.acme.designate"/&gt;
	&lt;/Designate&gt;</programlisting>
<para>Other schemes can embed the <code>Object</code> element in
the <code>Designate</code> element to define actual instances for
the Configuration Admin service. In that case the <code>pid</code> attribute
must be used together with the <code>factoryPid</code> attribute.
However, in that case an aliasing model is required because the
Configuration Admin service does not allow the creator to choose
the <code>Configuration</code> object’s PID.</para></section>
<section xml:id="i1504251"><title>
Example
Metadata File</title>
<para>This example defines a meta type file for a Person record,
based on ISO attribute types. The ids that are used are derived
from ISO attributes.</para>
<programlisting>&lt;xml version="1.0" encoding="UTF-8"&gt;
&lt;MetaData 
	xmlns=
		"http://www.osgi.org/xmlns/metatype/v1.2.0" 
	 localization="person"&gt;
  &lt;OCD name="%person" id="2.5.6.6"
		description="%Person Record"&gt;
    &lt;AD name="%sex" id="2.5.4.12" type="Integer"&gt;
       &lt;Option label="%male" 											value="1"/&gt;
       &lt;Option label="%Female"	 										value="0"/&gt;
    &lt;/AD&gt;
    &lt;AD name="%sn" 							id="2.5.4.4" type="String"/&gt;
    &lt;AD name="%cn" 	id="2.5.4.3" type="String"/&gt;
    &lt;AD name="%seeAlso" 	id="2.5.4.34" type="String"
 			cardinality="8" default="http://www.google.com,
					http://www.yahoo.com"/&gt;
    &lt;AD name="%telNumber" id="2.5.4.20" type="String"/&gt;
 &lt;/OCD&gt;

 &lt;Designate pid="com.acme.addressbook"&gt;
  &lt;Object ocdref="2.5.6.6"/&gt;
 &lt;/Designate&gt;
&lt;/MetaData&gt;</programlisting>
<para>Translations for this file, as indicated by the localization
attribute must be stored in the root directory (e.g. <code>person_du_NL.properties</code>).
The default localization base name for the properties is <code>OSGI-INF/l10n/bundle</code>, but
can be overridden by the manifest Bundle-Localization header and
the <code>localization</code> attribute of the Meta Data element.
The property files have the base name of <code>person</code>. The
Dutch, French and English translations could look like:</para>
<programlisting>person_du_NL.properties:
person=Persoon
person\ record=Persoons beschrijving
cn=Naam
sn=Voornaam
seeAlso=Zie ook
telNumber=Tel. Nummer
sex=Geslacht
male=Mannelijk
female=Vrouwelijk

person_fr.properties
person=Personne
person\ record=Description de la personne
cn=Nom
sn=Surnom
seeAlso=Reference
telNumber=Tel.
sex=Sexe
male=Homme
female=Femme

person_en_US.properties
person=Person
person\ record=Person Record
cn=Name
sn=Sur Name
seeAlso=See Also
telNumber=Tel.
sex=Sex
male=Male
female=Female</programlisting></section></section>
<section><title>Object</title>
<para>The <code>OCD</code> element can be used to describe the possible
contents of a <code>Dictionary</code> object. In this case, the attribute
name is the key. The <code>Object</code> element can be used to
assign a value to a Dictionary object. </para>
<para>For example:</para>
<programlisting>&lt;Designate pid="com.acme.b"&gt;
  	&lt;Object ocdref="b"&gt;
  		&lt;Attribute adref="foo" content="Zaphod Beeblebrox"/&gt;
  		&lt;Attribute adref="bar"&gt;
  			&lt;Value&gt;1&lt;/Value&gt;
  			&lt;Value&gt;2&lt;/Value&gt;
  			&lt;Value&gt;3&lt;/Value&gt;
  			&lt;Value&gt;4&lt;/Value&gt;
  			&lt;Value&gt;5&lt;/Value&gt;
  		&lt;/Attribute&gt;
  	&lt;/Object&gt;
  &lt;/Designate&gt;</programlisting></section>
<section xml:id="i1502383"><title>
XML
Schema</title>
<programlisting width="pgwide">&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
	xmlns:metatype="http://www.osgi.org/xmlns/metatype/v1.2.0"
	targetNamespace="http://www.osgi.org/xmlns/metatype/v1.2.0"
	version="1.2.0"&gt;

	&lt;element name="MetaData" type="metatype:Tmetadata" /&gt;

	&lt;complexType name="Tmetadata"&gt;
		&lt;sequence&gt;
			&lt;element name="OCD" type="metatype:Tocd" minOccurs="0"
				maxOccurs="unbounded" /&gt;
			&lt;element name="Designate" type="metatype:Tdesignate"
				minOccurs="0" maxOccurs="unbounded" /&gt;
			&lt;!-- It is non-deterministic, per W3C XML Schema 1.0:http://www.w3.org/TR/xmlschema-1/#cos-nonambig
				to use namespace="##any" below. --&gt;
			&lt;any namespace="##other" processContents="lax" minOccurs="0"
				maxOccurs="unbounded" /&gt;
		&lt;/sequence&gt;
		&lt;attribute name="localization" type="string" use="optional"/&gt;
		&lt;anyAttribute /&gt;
	&lt;/complexType&gt;

	&lt;complexType name="Tocd"&gt;
		&lt;sequence&gt;
			&lt;element name="AD" type="metatype:Tad" minOccurs="1"
				maxOccurs="unbounded" /&gt;
			&lt;element name="Icon" type="metatype:Ticon" minOccurs="0"
				maxOccurs="unbounded" /&gt;
			&lt;!-- It is non-deterministic, per W3C XML Schema 1.0:http://www.w3.org/TR/xmlschema-1/#cos-nonambig
				to use namespace="##any" below. --&gt;
			&lt;any namespace="##other" processContents="lax" minOccurs="0"
				maxOccurs="unbounded" /&gt;
		&lt;/sequence&gt;
		&lt;attribute name="name" type="string" use="required" /&gt;
		&lt;attribute name="description" type="string" use="optional"/&gt;
		&lt;attribute name="id" type="string" use="required" /&gt;
		&lt;anyAttribute /&gt;
	&lt;/complexType&gt;

	&lt;complexType name="Tad"&gt;
		&lt;sequence&gt;
			&lt;element name="Option" type="metatype:Toption" minOccurs="0"
				maxOccurs="unbounded" /&gt;
			&lt;!-- It is non-deterministic, per W3C XML Schema 1.0:http://www.w3.org/TR/xmlschema-1/#cos-nonambig
				to use namespace="##any" below. --&gt;
			&lt;any namespace="##other" processContents="lax" minOccurs="0"
				maxOccurs="unbounded" /&gt;
		&lt;/sequence&gt;
		&lt;attribute name="name" type="string" use="optional" /&gt;
		&lt;attribute name="description" type="string" use="optional"/&gt;
		&lt;attribute name="id" type="string" use="required" /&gt;
		&lt;attribute name="type" type="metatype:Tscalar" use="required"/&gt;
		&lt;attribute name="cardinality" type="int" use="optional"
			default="0" /&gt;
		&lt;attribute name="min" type="string" use="optional" /&gt;
		&lt;attribute name="max" type="string" use="optional" /&gt;
		&lt;attribute name="default" type="string" use="optional"/&gt;
		&lt;attribute name="required" type="boolean" use="optional"
			default="true" /&gt;
		&lt;anyAttribute /&gt;
	&lt;/complexType&gt;

	&lt;complexType name="Tobject"&gt;
		&lt;sequence&gt;
			&lt;element name="Attribute" type="metatype:Tattribute"
				minOccurs="0" maxOccurs="unbounded" /&gt;
			&lt;!-- It is non-deterministic, per W3C XML Schema 1.0:http://www.w3.org/TR/xmlschema-1/#cos-nonambig
				to use namespace="##any" below. --&gt;
			&lt;any namespace="##other" processContents="lax" minOccurs="0"
				maxOccurs="unbounded" /&gt;
		&lt;/sequence&gt;
		&lt;attribute name="ocdref" type="string" use="required"/&gt;
		&lt;anyAttribute /&gt;
	&lt;/complexType&gt;

	&lt;complexType name="Tattribute"&gt;
		&lt;sequence&gt;
			&lt;element name="Value" type="string" minOccurs="0"
				maxOccurs="unbounded" /&gt;
			&lt;!-- It is non-deterministic, per W3C XML Schema 1.0:http://www.w3.org/TR/xmlschema-1/#cos-nonambig
				to use namespace="##any" below. --&gt;
			&lt;any namespace="##other" processContents="lax" minOccurs="0"
				maxOccurs="unbounded" /&gt;
		&lt;/sequence&gt;
		&lt;attribute name="adref" type="string" use="required"/&gt;
		&lt;attribute name="content" type="string" use="optional"/&gt;
		&lt;anyAttribute /&gt;
	&lt;/complexType&gt;

	&lt;complexType name="Tdesignate"&gt;
		&lt;sequence&gt;
			&lt;element name="Object" type="metatype:Tobject" minOccurs="1"
				maxOccurs="1" /&gt;
			&lt;any namespace="##any" processContents="lax" minOccurs="0"
				maxOccurs="unbounded" /&gt;
		&lt;/sequence&gt;
		&lt;attribute name="pid" type="string" use="optional" /&gt;
		&lt;attribute name="factoryPid" type="string" use="optional"/&gt;
		&lt;attribute name="bundle" type="string" use="optional"/&gt;
		&lt;attribute name="optional" type="boolean" default="false"
			use="optional" /&gt;
		&lt;attribute name="merge" type="boolean" default="false"
			use="optional" /&gt;
		&lt;anyAttribute /&gt;
	&lt;/complexType&gt;

	&lt;simpleType name="Tscalar"&gt;
		&lt;restriction base="string"&gt;
			&lt;enumeration value="String" /&gt;
			&lt;enumeration value="Long" /&gt;
			&lt;enumeration value="Double" /&gt;
			&lt;enumeration value="Float" /&gt;
			&lt;enumeration value="Integer" /&gt;
			&lt;enumeration value="Byte" /&gt;
			&lt;enumeration value="Char" /&gt;
			&lt;enumeration value="Boolean" /&gt;
			&lt;enumeration value="Short" /&gt;
			&lt;enumeration value="Password" /&gt;
		&lt;/restriction&gt;
	&lt;/simpleType&gt;

	&lt;complexType name="Toption"&gt;
		&lt;sequence&gt;
			&lt;any namespace="##any" processContents="lax" minOccurs="0"
				maxOccurs="unbounded" /&gt;
		&lt;/sequence&gt;
		&lt;attribute name="label" type="string" use="required"/&gt;
		&lt;attribute name="value" type="string" use="required"/&gt;
		&lt;anyAttribute /&gt;
	&lt;/complexType&gt;

	&lt;complexType name="Ticon"&gt;
		&lt;sequence&gt;
			&lt;any namespace="##any" processContents="lax" minOccurs="0"
				maxOccurs="unbounded" /&gt;
		&lt;/sequence&gt;
		&lt;attribute name="resource" type="string" use="required"/&gt;
		&lt;attribute name="size" type="positiveInteger" use="required"/&gt;
		&lt;anyAttribute /&gt;
	&lt;/complexType&gt;

	&lt;attribute name="must-understand" type="boolean"&gt;
		&lt;annotation&gt;
			&lt;documentation xml:lang="en"&gt;
				This attribute should be used by extensions to documents
				to require that the document consumer understand the
				extension.
			&lt;/documentation&gt;
		&lt;/annotation&gt;
	&lt;/attribute&gt;
&lt;/schema&gt;</programlisting></section>
<section><title>Limitations</title>
<para>The OSGi MetaType specification is intended to be used for
simple applications. It does not, therefore, support recursive data
types, mixed types in arrays/vectors, or nested arrays/vectors.</para></section>
<section><title>Related Standards</title>
<para>One of the primary goals of this specification is to make
metatype information available at run-time with minimal overhead.
Many related standards are applicable to metatypes; except for Java
beans, however, all other metatype standards are based on document
formats (e.g. XML). In the OSGi framework, document format standards
are deemed unsuitable due to the overhead required in the execution
environment (they require a parser during run-time).</para>
<para>Another consideration is the applicability of these standards.
Most of these standards were developed for management systems on
platforms where resources are not necessarily a concern. In this
case, a metatype standard is normally used to describe the data
structures needed to control some other computer via a network.
This other computer, however, does not require the metatype information as
it is <emphasis>implementing</emphasis> this information.</para>
<para>In some traditional cases, a management system uses the metatype
information to control objects in an OSGi framework. Therefore,
the concepts and the <?FM MARKER [Hypertext] syntax?>
syntax of the metatype information must be mappable to these popular
standards. Clearly, then, these standards must be able to describe
objects in an OSGi framework. This ability is usually not a problem,
because the metatype languages used by current management systems
are very powerful. </para></section>
<section><title>Security Considerations</title>
<para>Special security issues are not applicable for this specification.</para></section>
<INSET xml:id="i1605072">org.osgi.service.metatype<?FM MARKER [Cross-Ref] org.osgi.service.metatype?>
<?FM MARKER [Index] org.osgi.service.metatype?>
<?FM MARKER [Cross-Ref] package:org.osgi.service.metatype?>

Metatype Package Version 1.2.  
Bundles wishing to use this package must list the package in the
Import-Package header of the bundle’s manifest. This package has
two types of users: the consumers that use the API in this package and
the providers that implement the API in this package. 
Example import for consumers using the API in this package: 
Import-Package: org.osgi.service.metatype; version=”[1.2,2.0)”
Example import for providers implementing the API in this package: 
Import-Package: org.osgi.service.metatype; version=”[1.2,1.3)”
Summary
AttributeDefinition –  An interface to describe an attribute. 
MetaTypeInformation –  A MetaType Information object is created
by the MetaTypeService to return meta type information for a specific
bundle. 
MetaTypeProvider –  Provides access to metatypes. 
MetaTypeService –  The MetaType Service can be used to obtain meta
type information for a bundle. 
ObjectClassDefinition –  Description for the data type information
of an objectclass. 
Permissions
<?FM MARKER [Cross-Ref] AttributeDefinition?>
<?FM MARKER [Index] AttributeDefinition?>
<?FM MARKER [Index] interface:AttributeDefinition?>
AttributeDefinition
public interface AttributeDefinition
An interface to describe an attribute.  
An AttributeDefinition object defines a description of the data
type of a property/attribute.
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] AttributeDefinition.BIGDECIMAL?>
<?FM MARKER [Index] AttributeDefinition:BIGDECIMAL?>
<?FM MARKER [Index] BIGDECIMAL?>
BIGDECIMAL
public static final int BIGDECIMAL = 10
The BIGDECIMAL (10) type.  Attributes of this type should be stored
as BigDecimal, Vector with BigDecimal or BigDecimal[] objects depending
on getCardinality(). 
	Deprecated	As of 1.1.
<?FM MARKER [Cross-Ref] AttributeDefinition.BIGINTEGER?>
<?FM MARKER [Index] AttributeDefinition:BIGINTEGER?>
<?FM MARKER [Index] BIGINTEGER?>
BIGINTEGER
public static final int BIGINTEGER = 9
The BIGINTEGER (9) type.  Attributes of this type should be stored
as BigInteger, Vector with BigInteger or BigInteger[] objects, depending
on the getCardinality() value. 
	Deprecated	As of 1.1.
<?FM MARKER [Cross-Ref] AttributeDefinition.BOOLEAN?>
<?FM MARKER [Index] AttributeDefinition:BOOLEAN?>
<?FM MARKER [Index] BOOLEAN?>
BOOLEAN
public static final int BOOLEAN = 11
The BOOLEAN (11) type.  Attributes of this type should be stored
as Boolean, Vector with Boolean or boolean[] objects depending on
getCardinality(). 
<?FM MARKER [Cross-Ref] AttributeDefinition.BYTE?>
<?FM MARKER [Index] AttributeDefinition:BYTE?>
<?FM MARKER [Index] BYTE?>
BYTE
public static final int BYTE = 6
The BYTE (6) type.  Attributes of this type should be stored as
Byte, Vector with Byte or byte[] objects, depending on the getCardinality()
value. 
<?FM MARKER [Cross-Ref] AttributeDefinition.CHARACTER?>
<?FM MARKER [Index] AttributeDefinition:CHARACTER?>
<?FM MARKER [Index] CHARACTER?>
CHARACTER
public static final int CHARACTER = 5
The CHARACTER (5) type.  Attributes of this type should be stored
as Character, Vector with Character or char[] objects, depending
on the getCardinality() value. 
<?FM MARKER [Cross-Ref] AttributeDefinition.DOUBLE?>
<?FM MARKER [Index] AttributeDefinition:DOUBLE?>
<?FM MARKER [Index] DOUBLE?>
DOUBLE
public static final int DOUBLE = 7
The DOUBLE (7) type.  Attributes of this type should be stored as
Double, Vector with Double or double[] objects, depending on the
getCardinality() value. 
<?FM MARKER [Cross-Ref] AttributeDefinition.FLOAT?>
<?FM MARKER [Index] AttributeDefinition:FLOAT?>
<?FM MARKER [Index] FLOAT?>
FLOAT
public static final int FLOAT = 8
The FLOAT (8) type.  Attributes of this type should be stored as
Float, Vector with Float or float[] objects, depending on the getCardinality()
value. 
<?FM MARKER [Cross-Ref] AttributeDefinition.INTEGER?>
<?FM MARKER [Index] AttributeDefinition:INTEGER?>
<?FM MARKER [Index] INTEGER?>
INTEGER
public static final int INTEGER = 3
The INTEGER (3) type.  Attributes of this type should be stored
as Integer, Vector with Integer or int[] objects, depending on the
getCardinality() value. 
<?FM MARKER [Cross-Ref] AttributeDefinition.LONG?>
<?FM MARKER [Index] AttributeDefinition:LONG?>
<?FM MARKER [Index] LONG?>
LONG
public static final int LONG = 2
The LONG (2) type.  Attributes of this type should be stored as
Long, Vector with Long or long[] objects, depending on the getCardinality()
value. 
<?FM MARKER [Cross-Ref] AttributeDefinition.PASSWORD?>
<?FM MARKER [Index] AttributeDefinition:PASSWORD?>
<?FM MARKER [Index] PASSWORD?>
PASSWORD
public static final int PASSWORD = 12
The PASSWORD (12) type.  Attributes of this type must be stored
as String, Vector with String or String[] objects depending on {link
getCardinality()}. A PASSWORD must be treated as a string but the
type can be used to disguise the information when displayed to a
user to prevent others from seeing it. 
	Since	1.2
<?FM MARKER [Cross-Ref] AttributeDefinition.SHORT?>
<?FM MARKER [Index] AttributeDefinition:SHORT?>
<?FM MARKER [Index] SHORT?>
SHORT
public static final int SHORT = 4
The SHORT (4) type.  Attributes of this type should be stored as
Short, Vector with Short or short[] objects, depending on the getCardinality()
value. 
<?FM MARKER [Cross-Ref] AttributeDefinition.STRING?>
<?FM MARKER [Index] AttributeDefinition:STRING?>
<?FM MARKER [Index] STRING?>
STRING
public static final int STRING = 1
The STRING (1) type.  
Attributes of this type should be stored as String, Vector with
String or String[] objects, depending on the getCardinality() value.
<?FM MARKER [Cross-Ref] AttributeDefinition.getCardinality()?>
<?FM MARKER [Index] AttributeDefinition:getCardinality?>
<?FM MARKER [Index] getCardinality?>
getCardinality()
public int getCardinality ( ) 
	
Return the cardinality of this attribute.  The OSGi environment
handles multi valued attributes in arrays ([]) or in Vector objects.
The return value is defined as follows:  
 
    x = Integer.MIN_VALUE    no limit, but use Vector
    x &lt; 0                    -x = max occurrences, store in Vector
    x &gt; 0                     x = max occurrences, store in array []
    x = Integer.MAX_VALUE    no limit, but use array []
    x = 0                     1 occurrence required
	Returns	The cardinality of this attribute.
<?FM MARKER [Cross-Ref] AttributeDefinition.getDefaultValue()?>
<?FM MARKER [Index] AttributeDefinition:getDefaultValue?>
<?FM MARKER [Index] getDefaultValue?>
getDefaultValue()
public String[] getDefaultValue (  ) 
	
Return a default for this attribute.  The object must be of the
appropriate type as defined by the cardinality and getType(). The
return type is a list of String objects that can be converted to
the appropriate type. The cardinality of the return array must follow
the absolute cardinality of this type. E.g. if the cardinality =
0, the array must contain 1 element. If the cardinality is 1, it
must contain 0 or 1 elements. If it is -5, it must contain from
0 to max 5 elements. Note that the special case of a 0 cardinality, meaning
a single value, does not allow arrays or vectors of 0 elements. 
	Returns	Return a default value or null if no default exists.
<?FM MARKER [Cross-Ref] AttributeDefinition.getDescription()?>
<?FM MARKER [Index] AttributeDefinition:getDescription?>
<?FM MARKER [Index] getDescription?>
getDescription()
public String getDescription ( ) 
	
Return a description of this attribute.  The description may be
localized and must describe the semantics of this type and any constraints. 
	Returns	The localized description of the definition.
<?FM MARKER [Cross-Ref] AttributeDefinition.getID()?>
<?FM MARKER [Index] AttributeDefinition:getID?>
<?FM MARKER [Index] getID?>
getID()
public String getID ( ) 
	
Unique identity for this attribute.  Attributes share a global namespace
in the registry. E.g. an attribute cn or commonName must always
be a String and the semantics are always a name of some object.
They share this aspect with LDAP/X.500 attributes. In these standards
the OSI Object Identifier (OID) is used to uniquely identify an
attribute. If such an OID exists, (which can be requested at several
standard organisations and many companies already have a node in
the tree) it can be returned here. Otherwise, a unique id should
be returned which can be a Java class name (reverse domain name)
or generated with a GUID algorithm. Note that all LDAP defined attributes
already have an OID. It is strongly advised to define the attributes
from existing LDAP schemes which will give the OID. Many such schemes
exist ranging from postal addresses to DHCP parameters. 
	Returns	The id or oid
<?FM MARKER [Cross-Ref] AttributeDefinition.getName()?>
<?FM MARKER [Index] AttributeDefinition:getName?>
<?FM MARKER [Index] getName?>
getName()
public String getName ( ) 
	
Get the name of the attribute. This name may be localized. 
	Returns	The localized name of the definition.
<?FM MARKER [Cross-Ref] AttributeDefinition.getOptionLabels()?>
<?FM MARKER [Index] AttributeDefinition:getOptionLabels?>
<?FM MARKER [Index] getOptionLabels?>
getOptionLabels()
public String[] getOptionLabels (  ) 
	
Return a list of labels of option values.  
The purpose of this method is to allow menus with localized labels.
It is associated with getOptionValues. The labels returned here
are ordered in the same way as the values in that method. 
If the function returns null, there are no option labels available. 
This list must be in the same sequence as the getOptionValues()
method. I.e. for each index i in getOptionLabels, i in getOptionValues()
should be the associated value.  
For example, if an attribute can have the value male, female, unknown,
this list can return (for dutch) new String[] { “Man”, “Vrouw”,
“Onbekend” }.
	Returns	A list values
<?FM MARKER [Cross-Ref] AttributeDefinition.getOptionValues()?>
<?FM MARKER [Index] AttributeDefinition:getOptionValues?>
<?FM MARKER [Index] getOptionValues?>
getOptionValues()
public String[] getOptionValues (  ) 
	
Return a list of option values that this attribute can take.  
If the function returns null, there are no option values available. 
Each value must be acceptable to validate() (return “”) and must
be a String object that can be converted to the data type defined
by getType() for this attribute. 
This list must be in the same sequence as getOptionLabels(). I.e.
for each index i in getOptionValues, i in getOptionLabels() should
be the label.  
For example, if an attribute can have the value male, female, unknown,
this list can return new String[] { “male”, “female”, “unknown”
}.
	Returns	A list values
<?FM MARKER [Cross-Ref] AttributeDefinition.getType()?>
<?FM MARKER [Index] AttributeDefinition:getType?>
<?FM MARKER [Index] getType?>
getType()
public int getType ( ) 
	
Return the type for this attribute.  
Defined in the following constants which map to the appropriate
Java type. STRING,LONG,INTEGER, CHAR, BYTE,DOUBLE,FLOAT, BOOLEAN.
	Returns	The type for this attribute.
<?FM MARKER [Cross-Ref] AttributeDefinition.validate(String)?>
<?FM MARKER [Index] AttributeDefinition:validate?>
<?FM MARKER [Index] validate?>
validate(String)
public String validate ( String value ) 
	value	The value before turning it into the basic data type. If
the cardinality indicates a multi-valued attribute then the given
string must be escaped.
	
Validate an attribute in String form.  An attribute might be further
constrained in value. This method will attempt to validate the attribute
according to these constraints. It can return three different values:
 
  null           No validation present
  “”             No problems detected
  “...”          A localized description of why the value is wrong
If the cardinality of this attribute is multi-valued then this string
must be interpreted as a comma delimited string. The complete value
must be trimmed from white space as well as spaces around commas.
Commas ( ‘,’ \u002C) and spaces (‘ ‘ \u0020) and backslashes (‘\’
\u005C) can be escaped with another backslash. Escaped spaces must
not be trimmed. For example: 
 value=”  a\,b,b\,c,\ c\\,d   “ =&gt; [ “a,b”, “b,c”, “ c\”, “d” ]
	Returns	null, “”, or another string
<?FM MARKER [Cross-Ref] MetaTypeInformation?>
<?FM MARKER [Index] MetaTypeInformation?>
<?FM MARKER [Index] interface:MetaTypeInformation?>
MetaTypeInformation
public interface MetaTypeInformation
	extends MetaTypeProvider
A MetaType Information object is created by the MetaTypeService
to return meta type information for a specific bundle. 
	Since	1.1
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] MetaTypeInformation.getBundle()?>
<?FM MARKER [Index] MetaTypeInformation:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle()
public Bundle getBundle ( ) 
	
Return the bundle for which this object provides meta type information. 
	Returns	Bundle for which this object provides meta type information.
<?FM MARKER [Cross-Ref] MetaTypeInformation.getFactoryPids()?>
<?FM MARKER [Index] MetaTypeInformation:getFactoryPids?>
<?FM MARKER [Index] getFactoryPids?>
getFactoryPids()
public String[] getFactoryPids (  ) 
	
Return the Factory PIDs (for ManagedServiceFactories) for which
ObjectClassDefinition information is available. 
	Returns	Array of Factory PIDs.
<?FM MARKER [Cross-Ref] MetaTypeInformation.getPids()?>
<?FM MARKER [Index] MetaTypeInformation:getPids?>
<?FM MARKER [Index] getPids?>
getPids()
public String[] getPids (  ) 
	
Return the PIDs (for ManagedServices) for which ObjectClassDefinition
information is available. 
	Returns	Array of PIDs.
<?FM MARKER [Cross-Ref] MetaTypeProvider?>
<?FM MARKER [Index] MetaTypeProvider?>
<?FM MARKER [Index] interface:MetaTypeProvider?>
MetaTypeProvider
public interface MetaTypeProvider
Provides access to metatypes. This interface can be implemented
on a Managed Service or Managed Service Factory as well as registered
as a service. When registered as a service, it must be registered with
a METATYPE_FACTORY_PID or METATYPE_PID service property (or both).
Any PID mentioned in either of these factories must be a valid argument
to the getObjectClassDefinition(String, String) method. 
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] MetaTypeProvider.METATYPE_FACTORY_PID?>
<?FM MARKER [Index] MetaTypeProvider:METATYPE_FACTORY_PID?>
<?FM MARKER [Index] METATYPE_FACTORY_PID?>
METATYPE_FACTORY_PID
public static final String METATYPE_FACTORY_PID = “metatype.factory.pid”<?FM MARKER [Index] metatype.factory.pid?>

Service property to signal that this service has ObjectClassDefinition
objects for the given factory PIDs. The type of this service property
is String+. 
	Since	1.2
<?FM MARKER [Cross-Ref] MetaTypeProvider.METATYPE_PID?>
<?FM MARKER [Index] MetaTypeProvider:METATYPE_PID?>
<?FM MARKER [Index] METATYPE_PID?>
METATYPE_PID
public static final String METATYPE_PID = “metatype.pid”<?FM MARKER [Index] metatype.pid?>

Service property to signal that this service has ObjectClassDefinition
objects for the given PIDs. The type of this service property is
String+. 
	Since	1.2
<?FM MARKER [Cross-Ref] MetaTypeProvider.getLocales()?>
<?FM MARKER [Index] MetaTypeProvider:getLocales?>
<?FM MARKER [Index] getLocales?>
getLocales()
public String[] getLocales (  ) 
	
Return a list of available locales.  The results must be names that
consists of language [ _ country [ _ variation ]] as is customary
in the Locale class. 
	Returns	An array of locale strings or null if there is no locale
specific localization can be found.
<?FM MARKER [Cross-Ref] MetaTypeProvider.getObjectClassDefinition(String,String)?>
<?FM MARKER [Index] MetaTypeProvider:getObjectClassDefinition?>
<?FM MARKER [Index] getObjectClassDefinition?>
getObjectClassDefinition(String,String)
public ObjectClassDefinition getObjectClassDefinition ( String id
, String locale ) 
	id	The ID of the requested object class. This can be a pid or factory
pid returned by getPids or getFactoryPids.
	locale	The locale of the definition or null for default locale.
	
Returns an object class definition for the specified id localized
to the specified locale. 
The locale parameter must be a name that consists of language[ “_”
country[ “_” variation] ] as is customary in the Locale class. This
Locale class is not used because certain profiles do not contain
it.
	Returns	A ObjectClassDefinition object.
	Throws	IllegalArgumentException –  If the id or locale arguments
are not valid 
<?FM MARKER [Cross-Ref] MetaTypeService?>
<?FM MARKER [Index] MetaTypeService?>
<?FM MARKER [Index] interface:MetaTypeService?>
MetaTypeService
public interface MetaTypeService
The MetaType Service can be used to obtain meta type information
for a bundle. The MetaType Service will examine the specified bundle
for meta type documents to create the returned MetaTypeInformation
object.  
If the specified bundle does not contain any meta type documents,
then a MetaTypeInformation object will be returned that wrappers
any ManagedService or ManagedServiceFactory services registered
by the specified bundle that implement MetaTypeProvider. Thus the
MetaType Service can be used to retrieve meta type information for
bundles which contain a meta type documents or which provide their
own MetaTypeProvider objects.
	Since	1.1
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] MetaTypeService.METATYPE_DOCUMENTS_LOCATION?>
<?FM MARKER [Index] MetaTypeService:METATYPE_DOCUMENTS_LOCATION?>
<?FM MARKER [Index] METATYPE_DOCUMENTS_LOCATION?>
METATYPE_DOCUMENTS_LOCATION
public static final String METATYPE_DOCUMENTS_LOCATION = “OSGI-INF/metatype”<?FM MARKER [Index] OSGI-INF/metatype?>

Location of meta type documents. The MetaType Service will process
each entry in the meta type documents directory. 
<?FM MARKER [Cross-Ref] MetaTypeService.getMetaTypeInformation(Bundle)?>
<?FM MARKER [Index] MetaTypeService:getMetaTypeInformation?>
<?FM MARKER [Index] getMetaTypeInformation?>
getMetaTypeInformation(Bundle)
public MetaTypeInformation getMetaTypeInformation ( Bundle bundle
) 
	bundle	The bundle for which meta type information is requested.
	
Return the MetaType information for the specified bundle. 
	Returns	A MetaTypeInformation object for the specified bundle.
<?FM MARKER [Cross-Ref] ObjectClassDefinition?>
<?FM MARKER [Index] ObjectClassDefinition?>
<?FM MARKER [Index] interface:ObjectClassDefinition?>
ObjectClassDefinition
public interface ObjectClassDefinition
Description for the data type information of an objectclass. 
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] ObjectClassDefinition.ALL?>
<?FM MARKER [Index] ObjectClassDefinition:ALL?>
<?FM MARKER [Index] ALL?>
ALL
public static final int ALL = -1
Argument for getAttributeDefinitions(int). 
ALL indicates that all the definitions are returned. The value is
-1.
<?FM MARKER [Cross-Ref] ObjectClassDefinition.OPTIONAL?>
<?FM MARKER [Index] ObjectClassDefinition:OPTIONAL?>
<?FM MARKER [Index] OPTIONAL?>
OPTIONAL
public static final int OPTIONAL = 2
Argument for getAttributeDefinitions(int). 
OPTIONAL indicates that only the optional definitions are returned.
The value is 2.
<?FM MARKER [Cross-Ref] ObjectClassDefinition.REQUIRED?>
<?FM MARKER [Index] ObjectClassDefinition:REQUIRED?>
<?FM MARKER [Index] REQUIRED?>
REQUIRED
public static final int REQUIRED = 1
Argument for getAttributeDefinitions(int). 
REQUIRED indicates that only the required definitions are returned.
The value is 1.
<?FM MARKER [Cross-Ref] ObjectClassDefinition.getAttributeDefinitions(int)?>
<?FM MARKER [Index] ObjectClassDefinition:getAttributeDefinitions?>
<?FM MARKER [Index] getAttributeDefinitions?>
getAttributeDefinitions(int)
public AttributeDefinition[] getAttributeDefinitions ( int filter
) 
	filter	ALL,REQUIRED,OPTIONAL
	
Return the attribute definitions for this object class.  
Return a set of attributes. The filter parameter can distinguish
between ALL,REQUIRED or the OPTIONAL attributes.
	Returns	An array of attribute definitions or null if no attributes
are selected
<?FM MARKER [Cross-Ref] ObjectClassDefinition.getDescription()?>
<?FM MARKER [Index] ObjectClassDefinition:getDescription?>
<?FM MARKER [Index] getDescription?>
getDescription()
public String getDescription ( ) 
	
Return a description of this object class.  The description may
be localized. 
	Returns	The description of this object class.
<?FM MARKER [Cross-Ref] ObjectClassDefinition.getIcon(int)?>
<?FM MARKER [Index] ObjectClassDefinition:getIcon?>
<?FM MARKER [Index] getIcon?>
getIcon(int)
public InputStream getIcon ( int size ) throws IOException
	size	Requested size of an icon, e.g. a 16x16 pixels icon then size
= 16
	
Return an InputStream object that can be used to create an icon
from. 
Indicate the size and return an InputStream object containing an
icon. The returned icon maybe larger or smaller than the indicated
size. 
The icon may depend on the localization.
	Returns	An InputStream representing an icon or null
	Throws	IOException –  If the InputStream cannot be returned. 
<?FM MARKER [Cross-Ref] ObjectClassDefinition.getID()?>
<?FM MARKER [Index] ObjectClassDefinition:getID?>
<?FM MARKER [Index] getID?>
getID()
public String getID ( ) 
	
Return the id of this object class.  
ObjectDefintion objects share a global namespace in the registry.
They share this aspect with LDAP/X.500 attributes. In these standards
the OSI Object Identifier (OID) is used to uniquely identify object classes.
If such an OID exists, (which can be requested at several standard
organisations and many companies already have a node in the tree)
it can be returned here. Otherwise, a unique id should be returned
which can be a java class name (reverse domain name) or generated
with a GUID algorithm. Note that all LDAP defined object classes
already have an OID associated. It is strongly advised to define
the object classes from existing LDAP schemes which will give the
OID for free. Many such schemes exist ranging from postal addresses
to DHCP parameters.
	Returns	The id of this object class.
<?FM MARKER [Cross-Ref] ObjectClassDefinition.getName()?>
<?FM MARKER [Index] ObjectClassDefinition:getName?>
<?FM MARKER [Index] getName?>
getName()
public String getName ( ) 
	
Return the name of this object class.  The name may be localized. 
	Returns	The name of this object class.

</INSET>
<section xml:id="i1215848"><title>
References</title>
<para role="ExternalReference" xml:id="i1215866">
LDAP. </para>
<para role="ExternalReferenceCont">http://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol</para>
<para role="ExternalReference" xml:id="i1215870">
Understanding
and Deploying LDAP Directory services</para>
<para role="ExternalReferenceCont">Timothy Howes et. al. ISBN
1-57870-070-1, MacMillan Technical publishing.</para></section>
</chapter>
