<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5" label="10" xml:id="i3564509" xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Framework API</title>
<INSET xml:id="i3902853">org.osgi.framework<?FM MARKER [Cross-Ref] org.osgi.framework?>
<?FM MARKER [Index] org.osgi.framework?>
<?FM MARKER [Cross-Ref] package:org.osgi.framework?>

Framework Package Version 1.7.  
Bundles wishing to use this package must list the package in the
Import-Package header of the bundle’s manifest. 
Example import for consumers using the API in this package: 
Import-Package: org.osgi.framework; version=”[1.7,2.0)”
Summary
AdaptPermission –  A bundle’s authority to adapt an object to a
type. 
AdminPermission –  A bundle’s authority to perform specific privileged
administrative operations on or to get sensitive information about
a bundle. 
AllServiceListener –  A ServiceEvent listener that does not filter
based upon package wiring. 
Bundle –  An installed bundle in the Framework. 
BundleActivator –  Customizes the starting and stopping of a bundle. 
BundleContext –  A bundle’s execution context within the Framework. 
BundleEvent –  An event from the Framework describing a bundle lifecycle
change. 
BundleException –  A Framework exception used to indicate that a
bundle lifecycle problem occurred. 
BundleListener –  A BundleEvent listener. 
BundlePermission –  A bundle’s authority to require or provide a
bundle or to receive or attach fragments. 
BundleReference –  A reference to a Bundle. 
CapabilityPermission –  A bundle’s authority to provide or require
a capability. 
Configurable –  Supports a configuration object. 
Constants –  Defines standard names for the OSGi environment system
properties, service properties, and Manifest header attribute keys. 
Filter –  An RFC 1960 ( http://www.ietf.org/rfc/rfc1960.txt ) -based
Filter. 
FrameworkEvent –  A general event from the Framework. 
FrameworkListener –  A FrameworkEvent listener. 
FrameworkUtil –  Framework Utility class. 
InvalidSyntaxException –  A Framework exception used to indicate
that a filter string has an invalid syntax. 
PackagePermission –  A bundle’s authority to import or export a
package. 
ServiceEvent –  An event from the Framework describing a service
lifecycle change. 
ServiceException –  A service exception used to indicate that a
service problem occurred. 
ServiceFactory –  Allows services to provide customized service
objects in the OSGi environment. 
ServiceListener –  A ServiceEvent listener. 
ServicePermission –  A bundle’s authority to register or get a service. 
ServiceReference –  A reference to a service. 
ServiceRegistration –  A registered service. 
SynchronousBundleListener –  A synchronous BundleEvent listener. 
UnfilteredServiceListener –  A ServiceEvent listener that does not
filter based upon any filter string specified to BundleContext.addServiceListener(ServiceListener,
String). 
Version –  Version identifier for capabilities such as bundles and
packages. 
VersionRange –  Version range. 
Permissions
<?FM MARKER [Cross-Ref] AdaptPermission?>
<?FM MARKER [Index] AdaptPermission?>
<?FM MARKER [Index] class:AdaptPermission?>
AdaptPermission
public final class AdaptPermission
	extends BasicPermission
A bundle’s authority to adapt an object to a type.  
AdaptPermission has one action: adapt.
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] AdaptPermission.ADAPT?>
<?FM MARKER [Index] AdaptPermission:ADAPT?>
<?FM MARKER [Index] ADAPT?>
ADAPT
public static final String ADAPT = “adapt”<?FM MARKER [Index] adapt?>

The action string initiate. 
<?FM MARKER [Cross-Ref] AdaptPermission.AdaptPermission(String,String)?>
<?FM MARKER [Index] AdaptPermission:AdaptPermission?>
<?FM MARKER [Index] AdaptPermission?>
AdaptPermission(String,String)
public AdaptPermission ( String filter , String actions ) 
	filter	A filter expression. Filter attribute names are processed
in a case sensitive manner. A special value of “*” can be used to
match all adaptations.
	actions	adapt.
	
Creates a new granted AdaptPermission object.  This constructor
must only be used to create a permission that is going to be checked. 
Examples:  
 (adaptClass=com.acme.*)
 (&amp;(signer=\*,o=ACME,c=US)(adaptClass=com.acme.*))
 (signer=\*,o=ACME,c=US)
When a signer key is used within the filter expression the signer
value must escape the special filter chars (’*’, ‘(’, ‘)’). 
The name is specified as a filter expression. The filter gives access
to the following attributes: 
signer - A Distinguished Name chain used to sign the exporting bundle.
Wildcards in a DN are not matched according to the filter string
rules, but according to the rules defined for a DN chain.
location - The location of the exporting bundle.
id - The bundle ID of the exporting bundle.
name - The symbolic name of the exporting bundle.
adaptClass - The name of the type to which an object can be adapted.
Filter attribute names are processed in a case sensitive manner. 
	Throws	IllegalArgumentException –  If the filter has an invalid
syntax. 
<?FM MARKER [Cross-Ref] AdaptPermission.AdaptPermission(String,Bundle,String)?>
<?FM MARKER [Index] AdaptPermission:AdaptPermission?>
<?FM MARKER [Index] AdaptPermission?>
AdaptPermission(String,Bundle,String)
public AdaptPermission ( String adaptClass , Bundle adaptableBundle
, String actions ) 
	adaptClass	The name of the type to which an object can be adapted.
	adaptableBundle	The bundle associated with the object being adapted.
	actions	adapt.
	
Creates a new requested AdaptPermission object to be used by the
code that must perform checkPermission. AdaptPermission objects
created with this constructor cannot be added to an AdaptPermission
permission collection. 
<?FM MARKER [Cross-Ref] AdaptPermission.equals(Object)?>
<?FM MARKER [Index] AdaptPermission:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to test for equality with this AdaptPermission object.
	
Determines the equality of two AdaptPermission objects.  This method
checks that specified permission has the same name and AdaptPermission
actions as this AdaptPermission object. 
	Returns	true if obj is a AdaptPermission, and has the same name
and actions as this AdaptPermission object; false otherwise.
<?FM MARKER [Cross-Ref] AdaptPermission.getActions()?>
<?FM MARKER [Index] AdaptPermission:getActions?>
<?FM MARKER [Index] getActions?>
getActions()
public String getActions ( ) 
	
Returns the canonical string representation of the AdaptPermission
actions.  
Always returns present AdaptPermission actions in the following
order: adapt.
	Returns	Canonical string representation of the AdaptPermission
actions.
<?FM MARKER [Cross-Ref] AdaptPermission.hashCode()?>
<?FM MARKER [Index] AdaptPermission:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hash code value for this object. 
	Returns	A hash code value for this object.
<?FM MARKER [Cross-Ref] AdaptPermission.implies(Permission)?>
<?FM MARKER [Index] AdaptPermission:implies?>
<?FM MARKER [Index] implies?>
implies(Permission)
public boolean implies ( Permission p ) 
	p	The requested permission.
	
Determines if the specified permission is implied by this object.
 
This method checks that the filter of the target is implied by the
adapt class name of this object. The list of AdaptPermission actions
must either match or allow for the list of the target object to
imply the target AdaptPermission action. 
	Returns	true if the specified permission is implied by this object;
false otherwise.
<?FM MARKER [Cross-Ref] AdaptPermission.newPermissionCollection()?>
<?FM MARKER [Index] AdaptPermission:newPermissionCollection?>
<?FM MARKER [Index] newPermissionCollection?>
newPermissionCollection()
public PermissionCollection newPermissionCollection ( ) 
	
Returns a new PermissionCollection object suitable for storing AdaptPermission
objects. 
	Returns	A new PermissionCollection object.
<?FM MARKER [Cross-Ref] AdminPermission?>
<?FM MARKER [Index] AdminPermission?>
<?FM MARKER [Index] class:AdminPermission?>
AdminPermission
public final class AdminPermission
	extends BasicPermission
A bundle’s authority to perform specific privileged administrative
operations on or to get sensitive information about a bundle. The
actions for this permission are:  
 Action             Methods
 class              Bundle.loadClass
 execute            Bundle.start
                    Bundle.stop
                    BundleStartLevel.setStartLevel
 extensionLifecycle BundleContext.installBundle for extension bundles
                    Bundle.update for extension bundles
                    Bundle.uninstall for extension bundles
 lifecycle          BundleContext.installBundle
                    Bundle.update
                    Bundle.uninstall
 listener           BundleContext.addBundleListener for SynchronousBundleListener
                    BundleContext.removeBundleListener for SynchronousBundleListener
 metadata           Bundle.getHeaders
                    Bundle.getLocation
 resolve            FrameworkWiring.refreshBundles
                    FrameworkWiring.resolveBundles
 resource           Bundle.getResource
                    Bundle.getResources
                    Bundle.getEntry
                    Bundle.getEntryPaths
                    Bundle.findEntries
                    Bundle resource/entry URL creation
 startlevel         FrameworkStartLevel.setStartLevel
                    FrameworkStartLevel.setInitialBundleStartLevel
 context            Bundle.getBundleContext
 weave              WovenClass.setBytes
                    WovenClass.getDynamicImports for modification
The special action “*” will represent all actions. The resolve action
is implied by the class, execute and resource actions. 
The name of this permission is a filter expression. The filter gives
access to the following attributes: 
signer - A Distinguished Name chain used to sign a bundle. Wildcards
in a DN are not matched according to the filter string rules, but
according to the rules defined for a DN chain.
location - The location of a bundle.
id - The bundle ID of the designated bundle.
name - The symbolic name of a bundle.
Filter attribute names are processed in a case sensitive manner. 
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] AdminPermission.CLASS?>
<?FM MARKER [Index] AdminPermission:CLASS?>
<?FM MARKER [Index] CLASS?>
CLASS
public static final String CLASS = “class”<?FM MARKER [Index] class?>

The action string class. The class action implies the resolve action. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.CONTEXT?>
<?FM MARKER [Index] AdminPermission:CONTEXT?>
<?FM MARKER [Index] CONTEXT?>
CONTEXT
public static final String CONTEXT = “context”<?FM MARKER [Index] context?>

The action string context. 
	Since	1.4
<?FM MARKER [Cross-Ref] AdminPermission.EXECUTE?>
<?FM MARKER [Index] AdminPermission:EXECUTE?>
<?FM MARKER [Index] EXECUTE?>
EXECUTE
public static final String EXECUTE = “execute”<?FM MARKER [Index] execute?>

The action string execute. The execute action implies the resolve
action. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.EXTENSIONLIFECYCLE?>
<?FM MARKER [Index] AdminPermission:EXTENSIONLIFECYCLE?>
<?FM MARKER [Index] EXTENSIONLIFECYCLE?>
EXTENSIONLIFECYCLE
public static final String EXTENSIONLIFECYCLE = “extensionLifecycle”<?FM MARKER [Index] extensionLifecycle?>

The action string extensionLifecycle. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.LIFECYCLE?>
<?FM MARKER [Index] AdminPermission:LIFECYCLE?>
<?FM MARKER [Index] LIFECYCLE?>
LIFECYCLE
public static final String LIFECYCLE = “lifecycle”<?FM MARKER [Index] lifecycle?>

The action string lifecycle. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.LISTENER?>
<?FM MARKER [Index] AdminPermission:LISTENER?>
<?FM MARKER [Index] LISTENER?>
LISTENER
public static final String LISTENER = “listener”<?FM MARKER [Index] listener?>

The action string listener. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.METADATA?>
<?FM MARKER [Index] AdminPermission:METADATA?>
<?FM MARKER [Index] METADATA?>
METADATA
public static final String METADATA = “metadata”<?FM MARKER [Index] metadata?>

The action string metadata. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.RESOLVE?>
<?FM MARKER [Index] AdminPermission:RESOLVE?>
<?FM MARKER [Index] RESOLVE?>
RESOLVE
public static final String RESOLVE = “resolve”<?FM MARKER [Index] resolve?>

The action string resolve. The resolve action is implied by the
class, execute and resource actions. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.RESOURCE?>
<?FM MARKER [Index] AdminPermission:RESOURCE?>
<?FM MARKER [Index] RESOURCE?>
RESOURCE
public static final String RESOURCE = “resource”<?FM MARKER [Index] resource?>

The action string resource. The resource action implies the resolve
action. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.STARTLEVEL?>
<?FM MARKER [Index] AdminPermission:STARTLEVEL?>
<?FM MARKER [Index] STARTLEVEL?>
STARTLEVEL
public static final String STARTLEVEL = “startlevel”<?FM MARKER [Index] startlevel?>

The action string startlevel. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.WEAVE?>
<?FM MARKER [Index] AdminPermission:WEAVE?>
<?FM MARKER [Index] WEAVE?>
WEAVE
public static final String WEAVE = “weave”<?FM MARKER [Index] weave?>

The action string weave. 
	Since	1.6
<?FM MARKER [Cross-Ref] AdminPermission.AdminPermission()?>
<?FM MARKER [Index] AdminPermission:AdminPermission?>
<?FM MARKER [Index] AdminPermission?>
AdminPermission()
public AdminPermission ( ) 
	
Creates a new AdminPermission object that matches all bundles and
has all actions. Equivalent to AdminPermission(”*”,”*”); 
<?FM MARKER [Cross-Ref] AdminPermission.AdminPermission(String,String)?>
<?FM MARKER [Index] AdminPermission:AdminPermission?>
<?FM MARKER [Index] AdminPermission?>
AdminPermission(String,String)
public AdminPermission ( String filter , String actions ) 
	filter	A filter expression that can use signer, location, id, and
name keys. A value of “*” or null matches all bundle. Filter attribute
names are processed in a case sensitive manner.
	actions	class, execute, extensionLifecycle , lifecycle, listener,
metadata, resolve , resource, startlevel, context or weave. A value
of “*” or null indicates all actions.
	
Create a new AdminPermission.  This constructor must only be used
to create a permission that is going to be checked. 
Examples: 
 (signer=\*,o=ACME,c=US)   
 (&amp;(signer=\*,o=ACME,c=US)(name=com.acme.*)(location=http://www.acme.com/bundles/*))
 (id&gt;=1)
When a signer key is used within the filter expression the signer
value must escape the special filter chars (’*’, ‘(’, ‘)’). 
Null arguments are equivalent to “*”.
	Throws	IllegalArgumentException –  If the filter has an invalid
syntax. 
<?FM MARKER [Cross-Ref] AdminPermission.AdminPermission(Bundle,String)?>
<?FM MARKER [Index] AdminPermission:AdminPermission?>
<?FM MARKER [Index] AdminPermission?>
AdminPermission(Bundle,String)
public AdminPermission ( Bundle bundle , String actions ) 
	bundle	A bundle.
	actions	class, execute, extensionLifecycle , lifecycle, listener,
metadata, resolve , resource, startlevel, context, weave. A value
of “*” or null indicates all actions.
	
Creates a new requested AdminPermission object to be used by the
code that must perform checkPermission. AdminPermission objects
created with this constructor cannot be added to an AdminPermission
permission collection. 
	Since	1.3
<?FM MARKER [Cross-Ref] AdminPermission.equals(Object)?>
<?FM MARKER [Index] AdminPermission:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object being compared for equality with this object.
	
Determines the equality of two AdminPermission objects. 
	Returns	true if obj is equivalent to this AdminPermission; false
otherwise.
<?FM MARKER [Cross-Ref] AdminPermission.getActions()?>
<?FM MARKER [Index] AdminPermission:getActions?>
<?FM MARKER [Index] getActions?>
getActions()
public String getActions ( ) 
	
Returns the canonical string representation of the AdminPermission
actions.  
Always returns present AdminPermission actions in the following
order: class, execute, extensionLifecycle, lifecycle, listener,
metadata, resolve, resource, startlevel, context, weave.
	Returns	Canonical string representation of the AdminPermission
actions.
<?FM MARKER [Cross-Ref] AdminPermission.hashCode()?>
<?FM MARKER [Index] AdminPermission:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hash code value for this object. 
	Returns	Hash code value for this object.
<?FM MARKER [Cross-Ref] AdminPermission.implies(Permission)?>
<?FM MARKER [Index] AdminPermission:implies?>
<?FM MARKER [Index] implies?>
implies(Permission)
public boolean implies ( Permission p ) 
	p	The requested permission.
	
Determines if the specified permission is implied by this object.
This method throws an exception if the specified permission was
not constructed with a bundle.  
This method returns true if the specified permission is an AdminPermission
AND 
this object’s filter matches the specified permission’s bundle ID,
bundle symbolic name, bundle location and bundle signer distinguished
name chain OR
this object’s filter is “*”
AND this object’s actions include all of the specified permission’s
actions. 
Special case: if the specified permission was constructed with “*”
filter, then this method returns true if this object’s filter is
“*” and this object’s actions include all of the specified permission’s
actions
	Returns	true if the specified permission is implied by this object;
false otherwise.
<?FM MARKER [Cross-Ref] AdminPermission.newPermissionCollection()?>
<?FM MARKER [Index] AdminPermission:newPermissionCollection?>
<?FM MARKER [Index] newPermissionCollection?>
newPermissionCollection()
public PermissionCollection newPermissionCollection ( ) 
	
Returns a new PermissionCollection object suitable for storing AdminPermissions. 
	Returns	A new PermissionCollection object.
<?FM MARKER [Cross-Ref] AllServiceListener?>
<?FM MARKER [Index] AllServiceListener?>
<?FM MARKER [Index] interface:AllServiceListener?>
AllServiceListener
public interface AllServiceListener
	extends ServiceListener
A ServiceEvent listener that does not filter based upon package
wiring. AllServiceListener is a listener interface that may be implemented
by a bundle developer. When a ServiceEvent is fired, it is synchronously
delivered to an AllServiceListener. The Framework may deliver ServiceEvent
objects to an AllServiceListener out of order and may concurrently
call and/or reenter an AllServiceListener. 
An AllServiceListener object is registered with the Framework using
the BundleContext.addServiceListener method. AllServiceListener
objects are called with a ServiceEvent object when a service is
registered, modified, or is in the process of unregistering. 
ServiceEvent object delivery to AllServiceListener objects is filtered
by the filter specified when the listener was registered. If the
Java Runtime Environment supports permissions, then additional filtering
is done. ServiceEvent objects are only delivered to the listener
if the bundle which defines the listener object’s class has the
appropriate ServicePermission to get the service using at least
one of the named classes under which the service was registered. 
Unlike normal ServiceListener objects, AllServiceListener objects
receive all ServiceEvent objects regardless of whether the package
source of the listening bundle is equal to the package source of
the bundle that registered the service. This means that the listener
may not be able to cast the service object to any of its corresponding
service interfaces if the service object is retrieved.
	See Also	ServiceEvent , ServicePermission
	Since	1.3
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] Bundle?>
<?FM MARKER [Index] Bundle?>
<?FM MARKER [Index] interface:Bundle?>
Bundle
public interface Bundle
	extends Comparable&lt;Bundle&gt;
An installed bundle in the Framework.  
A Bundle object is the access point to define the lifecycle of an
installed bundle. Each bundle installed in the OSGi environment
must have an associated Bundle object.  
A bundle must have a unique identity, a long, chosen by the Framework.
This identity must not change during the lifecycle of a bundle,
even when the bundle is updated. Uninstalling and then reinstalling
the bundle must create a new unique identity. 
A bundle can be in one of six states: 
UNINSTALLED
INSTALLED
RESOLVED
STARTING
STOPPING
ACTIVE
Values assigned to these states have no specified ordering; they
represent bit values that may be ORed together to determine if a
bundle is in one of the valid states.  
A bundle should only have active threads of execution when its state
is one of STARTING,ACTIVE, or STOPPING. An UNINSTALLED bundle can
not be set to another state; it is a zombie and can only be reached
because references are kept somewhere. 
The Framework is the only entity that is allowed to create Bundle
objects, and these objects are only valid within the Framework that
created them. 
Bundles have a natural ordering such that if two Bundles have the
same bundle id they are equal. A Bundle is less than another Bundle
if it has a lower bundle id and is greater if it has a higher bundle
id.
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] Bundle.ACTIVE?>
<?FM MARKER [Index] Bundle:ACTIVE?>
<?FM MARKER [Index] ACTIVE?>
ACTIVE
public static final int ACTIVE = 32
The bundle is now running.  
A bundle is in the ACTIVE state when it has been successfully started
and activated. 
The value of ACTIVE is 0x00000020.
<?FM MARKER [Cross-Ref] Bundle.INSTALLED?>
<?FM MARKER [Index] Bundle:INSTALLED?>
<?FM MARKER [Index] INSTALLED?>
INSTALLED
public static final int INSTALLED = 2
The bundle is installed but not yet resolved.  
A bundle is in the INSTALLED state when it has been installed in
the Framework but is not or cannot be resolved. 
This state is visible if the bundle’s code dependencies are not
resolved. The Framework may attempt to resolve an INSTALLED bundle’s
code dependencies and move the bundle to the RESOLVED state. 
The value of INSTALLED is 0x00000002.
<?FM MARKER [Cross-Ref] Bundle.RESOLVED?>
<?FM MARKER [Index] Bundle:RESOLVED?>
<?FM MARKER [Index] RESOLVED?>
RESOLVED
public static final int RESOLVED = 4
The bundle is resolved and is able to be started.  
A bundle is in the RESOLVED state when the Framework has successfully
resolved the bundle’s code dependencies. These dependencies include: 
The bundle’s class path from its Constants.BUNDLE_CLASSPATH Manifest
header. 
The bundle’s package dependencies from its Constants.EXPORT_PACKAGE
and Constants.IMPORT_PACKAGE Manifest headers. 
The bundle’s required bundle dependencies from its Constants.REQUIRE_BUNDLE
Manifest header. 
A fragment bundle’s host dependency from its Constants.FRAGMENT_HOST
Manifest header. 
Note that the bundle is not active yet. A bundle must be put in
the RESOLVED state before it can be started. The Framework may attempt
to resolve a bundle at any time. 
The value of RESOLVED is 0x00000004.
<?FM MARKER [Cross-Ref] Bundle.SIGNERS_ALL?>
<?FM MARKER [Index] Bundle:SIGNERS_ALL?>
<?FM MARKER [Index] SIGNERS_ALL?>
SIGNERS_ALL
public static final int SIGNERS_ALL = 1
Request that all certificates used to sign the bundle be returned. 
	See Also	getSignerCertificates(int)
	Since	1.5
<?FM MARKER [Cross-Ref] Bundle.SIGNERS_TRUSTED?>
<?FM MARKER [Index] Bundle:SIGNERS_TRUSTED?>
<?FM MARKER [Index] SIGNERS_TRUSTED?>
SIGNERS_TRUSTED
public static final int SIGNERS_TRUSTED = 2
Request that only certificates used to sign the bundle that are
trusted by the framework be returned. 
	See Also	getSignerCertificates(int)
	Since	1.5
<?FM MARKER [Cross-Ref] Bundle.START_ACTIVATION_POLICY?>
<?FM MARKER [Index] Bundle:START_ACTIVATION_POLICY?>
<?FM MARKER [Index] START_ACTIVATION_POLICY?>
START_ACTIVATION_POLICY
public static final int START_ACTIVATION_POLICY = 2
The bundle start operation must activate the bundle according to
the bundle’s declared activation policy.  
This bit may be set when calling start(int) to notify the framework
that the bundle must be activated using the bundle’s declared activation
policy.
	See Also	Constants.BUNDLE_ACTIVATIONPOLICY , start(int)
	Since	1.4
<?FM MARKER [Cross-Ref] Bundle.START_TRANSIENT?>
<?FM MARKER [Index] Bundle:START_TRANSIENT?>
<?FM MARKER [Index] START_TRANSIENT?>
START_TRANSIENT
public static final int START_TRANSIENT = 1
The bundle start operation is transient and the persistent autostart
setting of the bundle is not modified. 
This bit may be set when calling start(int) to notify the framework
that the autostart setting of the bundle must not be modified. If
this bit is not set, then the autostart setting of the bundle is
modified.
	See Also	start(int)
	Since	1.4
<?FM MARKER [Cross-Ref] Bundle.STARTING?>
<?FM MARKER [Index] Bundle:STARTING?>
<?FM MARKER [Index] STARTING?>
STARTING
public static final int STARTING = 8
The bundle is in the process of starting.  
A bundle is in the STARTING state when its start method is active.
A bundle must be in this state when the bundle’s BundleActivator.start(BundleContext)
is called. If the BundleActivator.start method completes without
exception, then the bundle has successfully started and must move
to the ACTIVE state. 
If the bundle has a lazy activation policy, then the bundle may
remain in this state for some time until the activation is triggered. 
The value of STARTING is 0x00000008.
<?FM MARKER [Cross-Ref] Bundle.STOP_TRANSIENT?>
<?FM MARKER [Index] Bundle:STOP_TRANSIENT?>
<?FM MARKER [Index] STOP_TRANSIENT?>
STOP_TRANSIENT
public static final int STOP_TRANSIENT = 1
The bundle stop is transient and the persistent autostart setting
of the bundle is not modified. 
This bit may be set when calling stop(int) to notify the framework
that the autostart setting of the bundle must not be modified. If
this bit is not set, then the autostart setting of the bundle is
modified.
	See Also	stop(int)
	Since	1.4
<?FM MARKER [Cross-Ref] Bundle.STOPPING?>
<?FM MARKER [Index] Bundle:STOPPING?>
<?FM MARKER [Index] STOPPING?>
STOPPING
public static final int STOPPING = 16
The bundle is in the process of stopping.  
A bundle is in the STOPPING state when its stop method is active.
A bundle must be in this state when the bundle’s BundleActivator.stop(BundleContext)
method is called. When the BundleActivator.stop method completes
the bundle is stopped and must move to the RESOLVED state. 
The value of STOPPING is 0x00000010.
<?FM MARKER [Cross-Ref] Bundle.UNINSTALLED?>
<?FM MARKER [Index] Bundle:UNINSTALLED?>
<?FM MARKER [Index] UNINSTALLED?>
UNINSTALLED
public static final int UNINSTALLED = 1
The bundle is uninstalled and may not be used.  
The UNINSTALLED state is only visible after a bundle is uninstalled;
the bundle is in an unusable state but references to the Bundle
object may still be available and used for introspection. 
The value of UNINSTALLED is 0x00000001.
<?FM MARKER [Cross-Ref] Bundle.adapt(Class)?>
<?FM MARKER [Index] Bundle:adapt?>
<?FM MARKER [Index] adapt?>
adapt(Class)
public A adapt ( Class&lt;A&gt; type ) 
	Type Arguments	&lt;A&gt;
	&lt;A&gt;	The type to which this bundle is to be adapted.
	type	Class object for the type to which this bundle is to be adapted.
	
Adapt this bundle to the specified type.  
Adapting this bundle to the specified type may require certain checks,
including security checks, to succeed. If a check does not succeed,
then this bundle cannot be adapted and null is returned.
	Returns	The object, of the specified type, to which this bundle
has been adapted or null if this bundle cannot be adapted to the
specified type.
	Throws	SecurityException –  If the caller does not have the appropriate
AdaptPermission[type,this,ADAPT], and the Java Runtime Environment
supports permissions. 
	Since	1.6
<?FM MARKER [Cross-Ref] Bundle.findEntries(String,String,boolean)?>
<?FM MARKER [Index] Bundle:findEntries?>
<?FM MARKER [Index] findEntries?>
findEntries(String,String,boolean)
public Enumeration&lt;URL&gt; findEntries ( String path , String filePattern
, boolean recurse ) 
	path	The path name in which to look. The path is always relative
to the root of this bundle and may begin with “/”. A path value
of “/” indicates the root of this bundle.
	filePattern	The file name pattern for selecting entries in the
specified path. The pattern is only matched against the last element
of the entry path. If the entry is a directory then the trailing
“/” is not used for pattern matching. Substring matching is supported,
as specified in the Filter specification, using the wildcard character
(”*”). If null is specified, this is equivalent to “*” and matches
all files.
	recurse	If true, recurse into subdirectories. Otherwise only return
entries from the specified path.
	
Returns entries in this bundle and its attached fragments. This
bundle’s class loader is not used to search for entries. Only the
contents of this bundle and its attached fragments are searched
for the specified entries.  If this bundle’s state is INSTALLED,
this method must attempt to resolve this bundle before attempting
to find entries. 
This method is intended to be used to obtain configuration, setup,
localization and other information from this bundle. This method
takes into account that the “contents” of this bundle can be extended with
fragments. This “bundle space” is not a namespace with unique members;
the same entry name can be present multiple times. This  method
therefore returns an enumeration of URL objects. These URLs can
come from different JARs but have the same path name. This method
can either return only entries in the specified path or recurse
into subdirectories returning entries in the directory tree beginning
at the specified path. Fragments can be attached after this bundle
is resolved, possibly changing the set of URLs returned by this
method. If this bundle is not resolved, only the entries in the
JAR file of this bundle are returned. 
Examples:  
 // List all XML files in the OSGI-INF directory and below
 Enumeration e = b.findEntries(”OSGI-INF”, “*.xml”, true);
   
 // Find a specific localization file
 Enumeration e = b.findEntries(”OSGI-INF/l10n”,
     “bundle_nl_DU.properties”, false);
 if (e.hasMoreElements())
     return (URL) e.nextElement();
URLs for directory entries must have their path end with “/”. 
Note: Jar and zip files are not required to include directory entries.
URLs to directory entries will not be returned if the bundle contents
do not contain directory entries.
	Returns	An enumeration of URL objects for each matching entry,
or null if no matching entry could be found or if the caller does
not have the appropriate AdminPermission[this,RESOURCE], and the
Java Runtime Environment supports permissions. The URLs are sorted
such that entries from this bundle are returned first followed by
the entries from attached fragments in attachment order. If this
bundle is a fragment, then only matching entries in this fragment
are returned.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
	Since	1.3
<?FM MARKER [Cross-Ref] Bundle.getBundleContext()?>
<?FM MARKER [Index] Bundle:getBundleContext?>
<?FM MARKER [Index] getBundleContext?>
getBundleContext()
public BundleContext getBundleContext ( ) 
	
Returns this bundle’s BundleContext. The returned BundleContext
can be used by the caller to act on behalf of this bundle. 
If this bundle is not in the STARTING, ACTIVE, or STOPPING states
or this bundle is a fragment bundle, then this bundle has no valid
BundleContext. This method will return null if this bundle has no valid
BundleContext.
	Returns	A BundleContext for this bundle or null if this bundle
has no valid BundleContext.
	Throws	SecurityException –  If the caller does not have the appropriate
AdminPermission[this,CONTEXT], and the Java Runtime Environment
supports permissions. 
	Since	1.4
<?FM MARKER [Cross-Ref] Bundle.getBundleId()?>
<?FM MARKER [Index] Bundle:getBundleId?>
<?FM MARKER [Index] getBundleId?>
getBundleId()
public long getBundleId ( ) 
	
Returns this bundle’s unique identifier. This bundle is assigned
a unique identifier by the Framework when it was installed in the
OSGi environment.  
A bundle’s unique identifier has the following attributes: 
Is unique and persistent. 
Is a long. 
Its value is not reused for another bundle, even after a bundle
is uninstalled. 
Does not change while a bundle remains installed. 
Does not change when a bundle is updated. 
This method must continue to return this bundle’s unique identifier
while this bundle is in the UNINSTALLED state.
	Returns	The unique identifier of this bundle.
<?FM MARKER [Cross-Ref] Bundle.getDataFile(String)?>
<?FM MARKER [Index] Bundle:getDataFile?>
<?FM MARKER [Index] getDataFile?>
getDataFile(String)
public File getDataFile ( String filename ) 
	filename	A relative name to the file to be accessed.
	
Creates a File object for a file in the persistent storage area
provided for this bundle by the Framework. This method will return
null if the platform does not have file system support or this bundle
is a fragment bundle. 
A File object for the base directory of the persistent storage area
provided for this bundle by the Framework can be obtained by calling
this method with an empty string as filename.  
If the Java Runtime Environment supports permissions, the Framework
will ensure that this bundle has the java.io.FilePermission with
actions read,write,delete for all files (recursively) in the persistent storage
area provided for this bundle.
	Returns	A File object that represents the requested file or null
if the platform does not have file system support or this bundle
is a fragment bundle.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
	Since	1.6
<?FM MARKER [Cross-Ref] Bundle.getEntry(String)?>
<?FM MARKER [Index] Bundle:getEntry?>
<?FM MARKER [Index] getEntry?>
getEntry(String)
public URL getEntry ( String path ) 
	path	The path name of the entry.
	
Returns a URL to the entry at the specified path in this bundle.
This bundle’s class loader is not used to search for the entry.
Only the contents of this bundle are searched for the entry. 
The specified path is always relative to the root of this bundle
and may begin with “/”. A path value of “/” indicates the root of
this bundle. 
Note: Jar and zip files are not required to include directory entries.
URLs to directory entries will not be returned if the bundle contents
do not contain directory entries.
	Returns	A URL to the entry, or null if no entry could be found
or if the caller does not have the appropriate AdminPermission[this,RESOURCE]
and the Java Runtime Environment supports permissions.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
	Since	1.3
<?FM MARKER [Cross-Ref] Bundle.getEntryPaths(String)?>
<?FM MARKER [Index] Bundle:getEntryPaths?>
<?FM MARKER [Index] getEntryPaths?>
getEntryPaths(String)
public Enumeration&lt;String&gt; getEntryPaths ( String path ) 
	path	The path name for which to return entry paths.
	
Returns an Enumeration of all the paths (String objects) to entries
within this bundle whose longest sub-path matches the specified
path. This bundle’s class loader is not used to search for entries.
Only the contents of this bundle are searched. 
The specified path is always relative to the root of this bundle
and may begin with a “/”. A path value of “/” indicates the root
of this bundle. 
Returned paths indicating subdirectory paths end with a “/”. The
returned paths are all relative to the root of this bundle and must
not begin with “/”. 
Note: Jar and zip files are not required to include directory entries.
Paths to directory entries will not be returned if the bundle contents
do not contain directory entries.
	Returns	An Enumeration of the entry paths (String objects) or null
if no entry could be found or if the caller does not have the appropriate
AdminPermission[this,RESOURCE] and the Java Runtime Environment
supports permissions.
	Throws	IllegalStateException –   If this bundle has been uninstalled. 
	Since	1.3
<?FM MARKER [Cross-Ref] Bundle.getHeaders()?>
<?FM MARKER [Index] Bundle:getHeaders?>
<?FM MARKER [Index] getHeaders?>
getHeaders()
public Dictionary&lt;String,String&gt; getHeaders ( ) 
	
Returns this bundle’s Manifest headers and values. This method returns
all the Manifest headers and values from the main section of this
bundle’s Manifest file; that is, all lines prior to the first blank line.
 
Manifest header names are case-insensitive. The methods of the returned
Dictionary object must operate on header names in a case-insensitive
manner. If a Manifest header value starts with “%”, it must be localized
according to the default locale. If no localization is found for
a header value, the header value without the leading “%” is returned.
 
For example, the following Manifest headers and values are included
if they are present in the Manifest file: 
     Bundle-Name
     Bundle-Vendor
     Bundle-Version
     Bundle-Description
     Bundle-DocURL
     Bundle-ContactAddress
This method must continue to return Manifest header information
while this bundle is in the UNINSTALLED state.
	Returns	An unmodifiable Dictionary object containing this bundle’s
Manifest headers and values.
	Throws	SecurityException –  If the caller does not have the appropriate
AdminPermission[this,METADATA], and the Java Runtime Environment
supports permissions. 
	See Also	Constants.BUNDLE_LOCALIZATION
<?FM MARKER [Cross-Ref] Bundle.getHeaders(String)?>
<?FM MARKER [Index] Bundle:getHeaders?>
<?FM MARKER [Index] getHeaders?>
getHeaders(String)
public Dictionary&lt;String,String&gt; getHeaders ( String locale ) 
	locale	The locale name into which the header values are to be localized.
If the specified locale is null then the locale returned by java.util.Locale.getDefault
is used. If the specified locale is the empty string, this method
will return the raw (unlocalized) manifest headers including any
leading “%”.
	
Returns this bundle’s Manifest headers and values localized to the
specified locale. 
This method performs the same function as Bundle.getHeaders() except
the manifest header values are localized to the specified locale.
 
If a Manifest header value starts with “%”, it must be localized
according to the specified locale. If a locale is specified and
cannot be found, then the header values must be returned using the
default locale. Localizations are searched for in the following
order: 
   bn + “_” + Ls + “_” + Cs + “_” + Vs
   bn + “_” + Ls + “_” + Cs
   bn + “_” + Ls
   bn + “_” + Ld + “_” + Cd + “_” + Vd
   bn + “_” + Ld + “_” + Cd
   bn + “_” + Ld
   bn
Where bn is this bundle’s localization basename, Ls, Cs and Vs are
the specified locale (language, country, variant) and Ld, Cd and
Vd are the default locale (language, country, variant). If null
is specified as the locale string, the header values must be localized
using the default locale. If the empty string (””) is specified
as the locale string, the header values must not be localized and
the raw (unlocalized) header values, including any leading “%”,
must be returned. If no localization is found for a header value,
the header value without the leading “%” is returned. 
This method must continue to return Manifest header information
while this bundle is in the UNINSTALLED state, however the header
values must only be available in the raw and default locale values.
	Returns	An unmodifiable Dictionary object containing this bundle’s
Manifest headers and values.
	Throws	SecurityException –  If the caller does not have the appropriate
AdminPermission[this,METADATA], and the Java Runtime Environment
supports permissions. 
	See Also	getHeaders() , Constants.BUNDLE_LOCALIZATION
	Since	1.3
<?FM MARKER [Cross-Ref] Bundle.getLastModified()?>
<?FM MARKER [Index] Bundle:getLastModified?>
<?FM MARKER [Index] getLastModified?>
getLastModified()
public long getLastModified ( ) 
	
Returns the time when this bundle was last modified. A bundle is
considered to be modified when it is installed, updated or uninstalled. 
The time value is the number of milliseconds since January 1, 1970,
00:00:00 UTC.
	Returns	The time when this bundle was last modified.
	Since	1.3
<?FM MARKER [Cross-Ref] Bundle.getLocation()?>
<?FM MARKER [Index] Bundle:getLocation?>
<?FM MARKER [Index] getLocation?>
getLocation()
public String getLocation ( ) 
	
Returns this bundle’s location identifier.  
The location identifier is the location passed to BundleContext.installBundle
when a bundle is installed. The location identifier does not change
while this bundle remains installed, even if this bundle is updated.
 
This method must continue to return this bundle’s location identifier
while this bundle is in the UNINSTALLED state.
	Returns	The string representation of this bundle’s location identifier.
	Throws	SecurityException –  If the caller does not have the appropriate
AdminPermission[this,METADATA], and the Java Runtime Environment
supports permissions. 
<?FM MARKER [Cross-Ref] Bundle.getRegisteredServices()?>
<?FM MARKER [Index] Bundle:getRegisteredServices?>
<?FM MARKER [Index] getRegisteredServices?>
getRegisteredServices()
public ServiceReference&lt;?&gt;[] getRegisteredServices (  ) 
	
Returns this bundle’s ServiceReference list for all services it
has registered or null if this bundle has no registered services.
 
If the Java runtime supports permissions, a ServiceReference object
to a service is included in the returned list only if the caller
has the ServicePermission to get the service using at least one
of the named classes the service was registered under. 
The list is valid at the time of the call to this method, however,
as the Framework is a very dynamic environment, services can be
modified or unregistered at anytime.
	Returns	An array of ServiceReference objects or null.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
	See Also	ServiceRegistration , ServiceReference , ServicePermission
<?FM MARKER [Cross-Ref] Bundle.getResource(String)?>
<?FM MARKER [Index] Bundle:getResource?>
<?FM MARKER [Index] getResource?>
getResource(String)
public URL getResource ( String name ) 
	name	The name of the resource. See ClassLoader.getResource for
a description of the format of a resource name.
	
Find the specified resource from this bundle’s class loader.  This
bundle’s class loader is called to search for the specified resource.
If this bundle’s state is INSTALLED, this method must attempt to resolve
this bundle before attempting to get the specified resource. If
this bundle cannot be resolved, then only this bundle must be searched
for the specified resource. Imported packages cannot be searched
when this bundle has not been resolved. If this bundle is a fragment
bundle then null is returned. 
Note: Jar and zip files are not required to include directory entries.
URLs to directory entries will not be returned if the bundle contents
do not contain directory entries.
	Returns	A URL to the named resource, or null if the resource could
not be found or if this bundle is a fragment bundle or if the caller
does not have the appropriate AdminPermission[this,RESOURCE], and
the Java Runtime Environment supports permissions.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
	See Also	getEntry(String) , findEntries(String, String, boolean)
	Since	1.1
<?FM MARKER [Cross-Ref] Bundle.getResources(String)?>
<?FM MARKER [Index] Bundle:getResources?>
<?FM MARKER [Index] getResources?>
getResources(String)
public Enumeration&lt;URL&gt; getResources ( String name ) throws IOException
	name	The name of the resource. See ClassLoader.getResources for
a description of the format of a resource name.
	
Find the specified resources from this bundle’s class loader.  This
bundle’s class loader is called to search for the specified resources.
If this bundle’s state is INSTALLED, this method must attempt to resolve
this bundle before attempting to get the specified resources. If
this bundle cannot be resolved, then only this bundle must be searched
for the specified resources. Imported packages cannot be searched
when a bundle has not been resolved. If this bundle is a fragment
bundle then null is returned. 
Note: Jar and zip files are not required to include directory entries.
URLs to directory entries will not be returned if the bundle contents
do not contain directory entries.
	Returns	An enumeration of URLs to the named resources, or null
if the resource could not be found or if this bundle is a fragment
bundle or if the caller does not have the appropriate AdminPermission[this,RESOURCE],
and the Java Runtime Environment supports permissions.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
		IOException –  If there is an I/O error. 
	Since	1.3
<?FM MARKER [Cross-Ref] Bundle.getServicesInUse()?>
<?FM MARKER [Index] Bundle:getServicesInUse?>
<?FM MARKER [Index] getServicesInUse?>
getServicesInUse()
public ServiceReference&lt;?&gt;[] getServicesInUse (  ) 
	
Returns this bundle’s ServiceReference list for all services it
is using or returns null if this bundle is not using any services.
A bundle is considered to be using a service if its use count for
that service is greater than zero.  
If the Java Runtime Environment supports permissions, a ServiceReference
object to a service is included in the returned list only if the
caller has the ServicePermission to get the service using at least
one of the named classes the service was registered under. 
The list is valid at the time of the call to this method, however,
as the Framework is a very dynamic environment, services can be
modified or unregistered at anytime.
	Returns	An array of ServiceReference objects or null.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
	See Also	ServiceReference , ServicePermission
<?FM MARKER [Cross-Ref] Bundle.getSignerCertificates(int)?>
<?FM MARKER [Index] Bundle:getSignerCertificates?>
<?FM MARKER [Index] getSignerCertificates?>
getSignerCertificates(int)
public Map&lt;X509Certificate,List&lt;X509Certificate&gt;&gt; getSignerCertificates
( int signersType ) 
	signersType	If SIGNERS_ALL is specified, then information on all
signers of this bundle is returned. If SIGNERS_TRUSTED is specified,
then only information on the signers of this bundle trusted by the
framework is returned.
	
Return the certificates for the signers of this bundle and the certificate
chains for those signers. 
	Returns	The X509Certificates for the signers of this bundle and
the X509Certificate chains for those signers. The keys of the Map
are the X509Certificates of the signers of this bundle. The value for
a key is a List containing the X509Certificate chain for the signer.
The first item in the List is the signer’s X509Certificate which
is then followed by the rest of the X509Certificate chain. The returned Map
will be empty if there are no signers. The returned Map is the property
of the caller who is free to modify it.
	Throws	IllegalArgumentException –  If the specified signersType
is not SIGNERS_ALL or SIGNERS_TRUSTED. 
	Since	1.5
<?FM MARKER [Cross-Ref] Bundle.getState()?>
<?FM MARKER [Index] Bundle:getState?>
<?FM MARKER [Index] getState?>
getState()
public int getState ( ) 
	
Returns this bundle’s current state.  
A bundle can be in only one state at any time.
	Returns	An element of UNINSTALLED,INSTALLED, RESOLVED, STARTING,
STOPPING, ACTIVE.
<?FM MARKER [Cross-Ref] Bundle.getSymbolicName()?>
<?FM MARKER [Index] Bundle:getSymbolicName?>
<?FM MARKER [Index] getSymbolicName?>
getSymbolicName()
public String getSymbolicName ( ) 
	
Returns the symbolic name of this bundle as specified by its Bundle-SymbolicName
manifest header. The bundle symbolic name should be based on the
reverse domain name naming convention like that used for java packages.
 
This method must continue to return this bundle’s symbolic name
while this bundle is in the UNINSTALLED state.
	Returns	The symbolic name of this bundle or null if this bundle
does not have a symbolic name.
	Since	1.3
<?FM MARKER [Cross-Ref] Bundle.getVersion()?>
<?FM MARKER [Index] Bundle:getVersion?>
<?FM MARKER [Index] getVersion?>
getVersion()
public Version getVersion ( ) 
	
Returns the version of this bundle as specified by its Bundle-Version
manifest header. If this bundle does not have a specified version
then Version.emptyVersion is returned.  
This method must continue to return this bundle’s version while
this bundle is in the UNINSTALLED state.
	Returns	The version of this bundle.
	Since	1.5
<?FM MARKER [Cross-Ref] Bundle.hasPermission(Object)?>
<?FM MARKER [Index] Bundle:hasPermission?>
<?FM MARKER [Index] hasPermission?>
hasPermission(Object)
public boolean hasPermission ( Object permission ) 
	permission	The permission to verify.
	
Determines if this bundle has the specified permissions.  
If the Java Runtime Environment does not support permissions, this
method always returns true. 
permission is of type Object to avoid referencing the java.security.Permission
class directly. This is to allow the Framework to be implemented
in Java environments which do not support permissions.  
If the Java Runtime Environment does support permissions, this bundle
and all its resources including embedded JAR files, belong to the
same java.security.ProtectionDomain; that is, they must share the
same set of permissions.
	Returns	true if this bundle has the specified permission or the
permissions possessed by this bundle imply the specified permission;
false if this bundle does not have the specified permission or permission
is not an instanceofjava.security.Permission.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
<?FM MARKER [Cross-Ref] Bundle.loadClass(String)?>
<?FM MARKER [Index] Bundle:loadClass?>
<?FM MARKER [Index] loadClass?>
loadClass(String)
public Class&lt;?&gt; loadClass ( String name ) throws ClassNotFoundException
	name	The name of the class to load.
	
Loads the specified class using this bundle’s class loader.  
If this bundle is a fragment bundle then this method must throw
a ClassNotFoundException.  
If this bundle’s state is INSTALLED, this method must attempt to
resolve this bundle before attempting to load the class. 
If this bundle cannot be resolved, a Framework event of type FrameworkEvent.ERROR
is fired containing a BundleException with details of the reason
this bundle could not be resolved. This method must then throw a
ClassNotFoundException.  
If this bundle’s state is UNINSTALLED, then an IllegalStateException
is thrown.
	Returns	The Class object for the requested class.
	Throws	ClassNotFoundException –  If no such class can be found
or if this bundle is a fragment bundle or if the caller does not
have the appropriate AdminPermission[this,CLASS], and the Java Runtime
Environment supports permissions. 
		IllegalStateException –  If this bundle has been uninstalled. 
	Since	1.3
<?FM MARKER [Cross-Ref] Bundle.start(int)?>
<?FM MARKER [Index] Bundle:start?>
<?FM MARKER [Index] start?>
start(int)
public void start ( int options ) throws BundleException
	options	The options for starting this bundle. See START_TRANSIENT
and START_ACTIVATION_POLICY. The Framework must ignore unrecognized
options.
	
Starts this bundle.  
If this bundle’s state is UNINSTALLED then an IllegalStateException
is thrown. 
If the current start level is less than this bundle’s start level: 
If the START_TRANSIENT option is set, then a BundleException is
thrown indicating this bundle cannot be started due to the Framework’s
current start level. 
Otherwise, the Framework must set this bundle’s persistent autostart
setting to Started with declared activation if the START_ACTIVATION_POLICY
option is set or Started with eager activation if not set. 
When the Framework’s current start level becomes equal to or more
than this bundle’s start level, this bundle will be started. 
Otherwise, the following steps are required to start this bundle: 
If this bundle is in the process of being activated or deactivated
then this method must wait for activation or deactivation to complete
before continuing. If this does not occur in a reasonable time,
a BundleException is thrown to indicate this bundle was unable to
be started. 
If this bundle’s state is ACTIVE then this method returns immediately. 
If the START_TRANSIENT option is not set then set this bundle’s
autostart setting to Started with declared activation if the START_ACTIVATION_POLICY
option is set or Started with eager activation if not set. When
the Framework is restarted and this bundle’s autostart setting is
not Stopped, this bundle must be automatically started. 
If this bundle’s state is not RESOLVED, an attempt is made to resolve
this bundle. If the Framework cannot resolve this bundle, a BundleException
is thrown.  
If the START_ACTIVATION_POLICY option is set and this bundle’s declared
activation policy is lazy then: 
If this bundle’s state is STARTING then this method returns immediately. 
This bundle’s state is set to STARTING. 
A bundle event of type BundleEvent.LAZY_ACTIVATION is fired. 
This method returns immediately and the remaining steps will be
followed when this bundle’s activation is later triggered. 
This bundle’s state is set to STARTING.  
A bundle event of type BundleEvent.STARTING is fired.  
The BundleActivator.start(BundleContext) method of this bundle’s
BundleActivator, if one is specified, is called. If the BundleActivator
is invalid or throws an exception then: 
This bundle’s state is set to STOPPING. 
A bundle event of type BundleEvent.STOPPING is fired. 
Any services registered by this bundle must be unregistered. 
Any services used by this bundle must be released. 
Any listeners registered by this bundle must be removed. 
This bundle’s state is set to RESOLVED. 
A bundle event of type BundleEvent.STOPPED is fired. 
A BundleException is then thrown. 
If this bundle’s state is UNINSTALLED, because this bundle was uninstalled
while the BundleActivator.start method was running, a BundleException
is thrown.  
This bundle’s state is set to ACTIVE.  
A bundle event of type BundleEvent.STARTED is fired. 
Preconditions 
getState() in { INSTALLED, RESOLVED } or { INSTALLED, RESOLVED,
STARTING } if this bundle has a lazy activation policy. 
Postconditions, no exceptions thrown 
Bundle autostart setting is modified unless the START_TRANSIENT
option was set. 
getState() in { ACTIVE } unless the lazy activation policy was used. 
BundleActivator.start() has been called and did not throw an exception
unless the lazy activation policy was used. 
Postconditions, when an exception is thrown 
Depending on when the exception occurred, bundle autostart setting
is modified unless the START_TRANSIENT option was set. 
getState() not in { STARTING, ACTIVE }. 
	Throws	BundleException –  If this bundle could not be started.
BundleException types thrown by this method include: BundleException.START_TRANSIENT_ERROR,
BundleException.NATIVECODE_ERROR, BundleException.RESOLVE_ERROR,
BundleException.STATECHANGE_ERROR, and BundleException.ACTIVATOR_ERROR. 
		IllegalStateException –  If this bundle has been uninstalled or
this bundle tries to change its own state. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,EXECUTE], and the Java Runtime Environment
supports permissions. 
	Since	1.4
<?FM MARKER [Cross-Ref] Bundle.start()?>
<?FM MARKER [Index] Bundle:start?>
<?FM MARKER [Index] start?>
start()
public void start ( ) throws BundleException
	
Starts this bundle with no options.  
This method performs the same function as calling start(0).
	Throws	BundleException –  If this bundle could not be started.
BundleException types thrown by this method include: BundleException.NATIVECODE_ERROR,
BundleException.RESOLVE_ERROR, BundleException.STATECHANGE_ERROR,
and BundleException.ACTIVATOR_ERROR. 
		IllegalStateException –  If this bundle has been uninstalled or
this bundle tries to change its own state. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,EXECUTE], and the Java Runtime Environment
supports permissions. 
	See Also	start(int)
<?FM MARKER [Cross-Ref] Bundle.stop(int)?>
<?FM MARKER [Index] Bundle:stop?>
<?FM MARKER [Index] stop?>
stop(int)
public void stop ( int options ) throws BundleException
	options	The options for stopping this bundle. See STOP_TRANSIENT.
The Framework must ignore unrecognized options.
	
Stops this bundle.  
The following steps are required to stop a bundle: 
If this bundle’s state is UNINSTALLED then an IllegalStateException
is thrown.  
If this bundle is in the process of being activated or deactivated
then this method must wait for activation or deactivation to complete
before continuing. If this does not occur in a reasonable time,
a BundleException is thrown to indicate this bundle was unable to
be stopped. 
If the STOP_TRANSIENT option is not set then then set this bundle’s
persistent autostart setting to to Stopped. When the Framework is
restarted and this bundle’s autostart setting is Stopped, this bundle must
not be automatically started.  
If this bundle’s state is not STARTING or ACTIVE then this method
returns immediately. 
This bundle’s state is set to STOPPING.  
A bundle event of type BundleEvent.STOPPING is fired.  
If this bundle’s state was ACTIVE prior to setting the state to
STOPPING, the BundleActivator.stop(BundleContext) method of this
bundle’s BundleActivator, if one is specified, is called. If that method
throws an exception, this method must continue to stop this bundle
and a BundleException must be thrown after completion of the remaining
steps. 
Any services registered by this bundle must be unregistered. 
Any services used by this bundle must be released. 
Any listeners registered by this bundle must be removed.  
If this bundle’s state is UNINSTALLED, because this bundle was uninstalled
while the BundleActivator.stop method was running, a BundleException
must be thrown.  
This bundle’s state is set to RESOLVED.  
A bundle event of type BundleEvent.STOPPED is fired. 
Preconditions 
getState() in { ACTIVE }. 
Postconditions, no exceptions thrown 
Bundle autostart setting is modified unless the STOP_TRANSIENT option
was set. 
getState() not in { ACTIVE, STOPPING }. 
BundleActivator.stop has been called and did not throw an exception. 
Postconditions, when an exception is thrown 
Bundle autostart setting is modified unless the STOP_TRANSIENT option
was set. 
	Throws	BundleException –  BundleException types thrown by this
method include: BundleException.STATECHANGE_ERROR and BundleException.ACTIVATOR_ERROR. 
		IllegalStateException –  If this bundle has been uninstalled or
this bundle tries to change its own state. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,EXECUTE], and the Java Runtime Environment
supports permissions. 
	Since	1.4
<?FM MARKER [Cross-Ref] Bundle.stop()?>
<?FM MARKER [Index] Bundle:stop?>
<?FM MARKER [Index] stop?>
stop()
public void stop ( ) throws BundleException
	
Stops this bundle with no options.  
This method performs the same function as calling stop(0).
	Throws	BundleException –  BundleException types thrown by this
method include: BundleException.STATECHANGE_ERROR and BundleException.ACTIVATOR_ERROR. 
		IllegalStateException –  If this bundle has been uninstalled or
this bundle tries to change its own state. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,EXECUTE], and the Java Runtime Environment
supports permissions. 
	See Also	start(int)
<?FM MARKER [Cross-Ref] Bundle.uninstall()?>
<?FM MARKER [Index] Bundle:uninstall?>
<?FM MARKER [Index] uninstall?>
uninstall()
public void uninstall ( ) throws BundleException
	
Uninstalls this bundle.  
This method causes the Framework to notify other bundles that this
bundle is being uninstalled, and then puts this bundle into the
UNINSTALLED state. The Framework must remove any resources related
to this bundle that it is able to remove. 
If this bundle has exported any packages, the Framework must continue
to make these packages available to their importing bundles until
the FrameworkWiring.refreshBundles method has been called or the
Framework is relaunched. 
The following steps are required to uninstall a bundle: 
If this bundle’s state is UNINSTALLED then an IllegalStateException
is thrown.  
If this bundle’s state is ACTIVE, STARTING or STOPPING, this bundle
is stopped as described in the Bundle.stop method. If Bundle.stop
throws an exception, a Framework event of type FrameworkEvent.ERROR
is fired containing the exception. 
This bundle’s state is set to UNINSTALLED.  
A bundle event of type BundleEvent.UNINSTALLED is fired.  
This bundle and any persistent storage area provided for this bundle
by the Framework are removed. 
Preconditions 
getState() not in { UNINSTALLED }. 
Postconditions, no exceptions thrown 
getState() in { UNINSTALLED }. 
This bundle has been uninstalled. 
Postconditions, when an exception is thrown 
getState() not in { UNINSTALLED }. 
This Bundle has not been uninstalled. 
	Throws	BundleException –  If the uninstall failed. This can occur
if another thread is attempting to change this bundle’s state and
does not complete in a timely manner. BundleException types thrown
by this method include: BundleException.STATECHANGE_ERROR
		IllegalStateException –  If this bundle has been uninstalled or
this bundle tries to change its own state. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,LIFECYCLE], and the Java Runtime Environment
supports permissions. 
	See Also	stop()
<?FM MARKER [Cross-Ref] Bundle.update(InputStream)?>
<?FM MARKER [Index] Bundle:update?>
<?FM MARKER [Index] update?>
update(InputStream)
public void update ( InputStream input ) throws BundleException
	input	The InputStream from which to read the new bundle or null
to indicate the Framework must create the input stream from this
bundle’s Bundle-UpdateLocation Manifest header, if present, or this
bundle’s original location. The input stream must always be closed
when this method completes, even if an exception is thrown.
	
Updates this bundle from an InputStream.  
If the specified InputStream is null, the Framework must create
the InputStream from which to read the updated bundle by interpreting,
in an implementation dependent manner, this bundle’s Bundle-UpdateLocation
Manifest header, if present, or this bundle’s original location. 
If this bundle’s state is ACTIVE, it must be stopped before the
update and started after the update successfully completes. 
If this bundle has exported any packages that are imported by another
bundle, these packages must remain exported until the FrameworkWiring.refreshBundles
method has been has been called or the Framework is relaunched. 
The following steps are required to update a bundle: 
If this bundle’s state is UNINSTALLED then an IllegalStateException
is thrown.  
If this bundle’s state is ACTIVE, STARTING or STOPPING, this bundle
is stopped as described in the Bundle.stop method. If Bundle.stop
throws an exception, the exception is rethrown terminating the update. 
The updated version of this bundle is read from the input stream
and installed. If the Framework is unable to install the updated
version of this bundle, the original version of this bundle must
be restored and a BundleException must be thrown after completion
of the remaining steps. 
This bundle’s state is set to INSTALLED.  
If the updated version of this bundle was successfully installed,
a bundle event of type BundleEvent.UPDATED is fired.  
If this bundle’s state was originally ACTIVE, the updated bundle
is started as described in the Bundle.start method. If Bundle.start
throws an exception, a Framework event of type FrameworkEvent.ERROR
is fired containing the exception. 
Preconditions 
getState() not in { UNINSTALLED }. 
Postconditions, no exceptions thrown 
getState() in { INSTALLED, RESOLVED, ACTIVE }. 
This bundle has been updated. 
Postconditions, when an exception is thrown 
getState() in { INSTALLED, RESOLVED, ACTIVE }. 
Original bundle is still used; no update occurred. 
	Throws	BundleException –  If this bundle could not be updated.
BundleException types thrown by this method include: BundleException.READ_ERROR,
BundleException.DUPLICATE_BUNDLE_ERROR, BundleException.MANIFEST_ERROR,
BundleException.NATIVECODE_ERROR, BundleException.RESOLVE_ERROR,
BundleException.STATECHANGE_ERROR, and BundleException.ACTIVATOR_ERROR. 
		IllegalStateException –  If this bundle has been uninstalled or
this bundle tries to change its own state. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,LIFECYCLE] for both the current bundle and
the updated bundle, and the Java Runtime Environment supports permissions. 
	See Also	stop() , start()
<?FM MARKER [Cross-Ref] Bundle.update()?>
<?FM MARKER [Index] Bundle:update?>
<?FM MARKER [Index] update?>
update()
public void update ( ) throws BundleException
	
Updates this bundle.  
This method performs the same function as calling update(InputStream)
with a null InputStream.
	Throws	BundleException –  If this bundle could not be updated.
BundleException types thrown by this method include: BundleException.READ_ERROR,
BundleException.DUPLICATE_BUNDLE_ERROR, BundleException.MANIFEST_ERROR,
BundleException.NATIVECODE_ERROR, BundleException.RESOLVE_ERROR,
BundleException.STATECHANGE_ERROR, and BundleException.ACTIVATOR_ERROR. 
		IllegalStateException –  If this bundle has been uninstalled or
this bundle tries to change its own state. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,LIFECYCLE] for both the current bundle and
the updated bundle, and the Java Runtime Environment supports permissions. 
	See Also	update(InputStream)
<?FM MARKER [Cross-Ref] BundleActivator?>
<?FM MARKER [Index] BundleActivator?>
<?FM MARKER [Index] interface:BundleActivator?>
BundleActivator
public interface BundleActivator
Customizes the starting and stopping of a bundle. 
BundleActivator is an interface that may be implemented when a bundle
is started or stopped. The Framework can create instances of a bundle’s
BundleActivator as required. If an instance’s BundleActivator.start
method executes successfully, it is guaranteed that the same instance’s
BundleActivator.stop method will be called when the bundle is to
be stopped. The Framework must not concurrently call a BundleActivator
object.  
BundleActivator is specified through the Bundle-Activator Manifest
header. A bundle can only specify a single BundleActivator in the
Manifest file. Fragment bundles must not have a BundleActivator. The
form of the Manifest header is:  
Bundle-Activator: &lt;i&gt;class-name&lt;/i&gt;
where &lt;i&gt;class-name&lt;/i&gt; is a fully qualified Java classname. 
The specified BundleActivator class must have a public constructor
that takes no parameters so that a BundleActivator object can be
created by Class.newInstance().
	Concurrency	Not Thread-safe 
<?FM MARKER [Cross-Ref] BundleActivator.start(BundleContext)?>
<?FM MARKER [Index] BundleActivator:start?>
<?FM MARKER [Index] start?>
start(BundleContext)
public void start ( BundleContext context ) throws Exception
	context	The execution context of the bundle being started.
	
Called when this bundle is started so the Framework can perform
the bundle-specific activities necessary to start this bundle. This
method can be used to register services or to allocate any resources
that this bundle needs. 
This method must complete and return to its caller in a timely manner.
	Throws	Exception –  If this method throws an exception, this bundle
is marked as stopped and the Framework will remove this bundle’s
listeners, unregister all services registered by this bundle, and
release all services used by this bundle. 
<?FM MARKER [Cross-Ref] BundleActivator.stop(BundleContext)?>
<?FM MARKER [Index] BundleActivator:stop?>
<?FM MARKER [Index] stop?>
stop(BundleContext)
public void stop ( BundleContext context ) throws Exception
	context	The execution context of the bundle being stopped.
	
Called when this bundle is stopped so the Framework can perform
the bundle-specific activities necessary to stop the bundle. In
general, this method should undo the work that the BundleActivator.start
method started. There should be no active threads that were started
by this bundle when this bundle returns. A stopped bundle must not
call any Framework objects. 
This method must complete and return to its caller in a timely manner.
	Throws	Exception –  If this method throws an exception, the bundle
is still marked as stopped, and the Framework will remove the bundle’s
listeners, unregister all services registered by the bundle, and
release all services used by the bundle. 
<?FM MARKER [Cross-Ref] BundleContext?>
<?FM MARKER [Index] BundleContext?>
<?FM MARKER [Index] interface:BundleContext?>
BundleContext
public interface BundleContext
	extends BundleReference
A bundle’s execution context within the Framework. The context is
used to grant access to other methods so that this bundle can interact
with the Framework.  
BundleContext methods allow a bundle to: 
Subscribe to events published by the Framework. 
Register service objects with the Framework service registry. 
Retrieve ServiceReferences from the Framework service registry. 
Get and release service objects for a referenced service. 
Install new bundles in the Framework. 
Get the list of bundles installed in the Framework. 
Get the Bundle object for a bundle. 
Create File objects for files in a persistent storage area provided
for the bundle by the Framework. 
A BundleContext object will be created for a bundle when the bundle
is started. The Bundle object associated with a BundleContext object
is called the context bundle.  
The BundleContext object will be passed to the BundleActivator.start(BundleContext)
method during activation of the context bundle. The same BundleContext
object will be passed to the BundleActivator.stop(BundleContext)
method when the context bundle is stopped. A BundleContext object is
generally for the private use of its associated bundle and is not
meant to be shared with other bundles in the OSGi environment.  
The BundleContext object is only valid during the execution of its
context bundle; that is, during the period from when the context
bundle is in the STARTING, STOPPING, and ACTIVE bundle states. If the
BundleContext object is used subsequently, an IllegalStateException
must be thrown. The BundleContext object must never be reused after
its context bundle is stopped.  
Two BundleContext objects are equal if they both refer to the same
execution context of a bundle. The Framework is the only entity
that can create BundleContext objects and they are only valid within
the Framework that created them. 
A Bundle can be adapted to its BundleContext. In order for this
to succeed, the caller must have the appropriate AdminPermission[bundle,CONTEXT]
if the Java Runtime Environment supports permissions.
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleContext.addBundleListener(BundleListener)?>
<?FM MARKER [Index] BundleContext:addBundleListener?>
<?FM MARKER [Index] addBundleListener?>
addBundleListener(BundleListener)
public void addBundleListener ( BundleListener listener ) 
	listener	The BundleListener to be added.
	
Adds the specified BundleListener object to the context bundle’s
list of listeners if not already present. BundleListener objects
are notified when a bundle has a lifecycle state change.  
If the context bundle’s list of listeners already contains a listener
l such that (l==listener), this method does nothing.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
		SecurityException –  If listener is a SynchronousBundleListener
and the caller does not have the appropriate AdminPermission[context
bundle,LISTENER], and the Java Runtime Environment supports permissions. 
	See Also	BundleEvent , BundleListener
<?FM MARKER [Cross-Ref] BundleContext.addFrameworkListener(FrameworkListener)?>
<?FM MARKER [Index] BundleContext:addFrameworkListener?>
<?FM MARKER [Index] addFrameworkListener?>
addFrameworkListener(FrameworkListener)
public void addFrameworkListener ( FrameworkListener listener ) 
	listener	The FrameworkListener object to be added.
	
Adds the specified FrameworkListener object to the context bundle’s
list of listeners if not already present. FrameworkListeners are
notified of general Framework events.  
If the context bundle’s list of listeners already contains a listener
l such that (l==listener), this method does nothing.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
	See Also	FrameworkEvent , FrameworkListener
<?FM MARKER [Cross-Ref] BundleContext.addServiceListener(ServiceListener,String)?>
<?FM MARKER [Index] BundleContext:addServiceListener?>
<?FM MARKER [Index] addServiceListener?>
addServiceListener(ServiceListener,String)
public void addServiceListener ( ServiceListener listener , String
filter ) throws InvalidSyntaxException
	listener	The ServiceListener object to be added.
	filter	The filter criteria.
	
Adds the specified ServiceListener object with the specified filter
to the context bundle’s list of listeners. See Filter for a description
of the filter syntax. ServiceListener objects are notified when
a service has a lifecycle state change. 
If the context bundle’s list of listeners already contains a listener
l such that (l==listener), then this method replaces that listener’s
filter (which may be null) with the specified one (which may be
null).  
The listener is called if the filter criteria is met. To filter
based upon the class of the service, the filter should reference
the Constants.OBJECTCLASS property. If filter is null , all services
are considered to match the filter.  
When using a filter, it is possible that the ServiceEvent s for
the complete lifecycle of a service will not be delivered to the
listener. For example, if the filter only matches when the property
x has the value 1, the listener will not be called if the service
is registered with the property x not set to the value 1. Subsequently,
when the service is modified setting property x to the value 1,
the filter will match and the listener will be called with a ServiceEvent
of type MODIFIED. Thus, the listener will not be called with a ServiceEvent
of type REGISTERED.  
If the Java Runtime Environment supports permissions, the ServiceListener
object will be notified of a service event only if the bundle that
is registering it has the ServicePermission to get the service using
at least one of the named classes the service was registered under.
	Throws	InvalidSyntaxException –  If filter contains an invalid
filter string that cannot be parsed. 
		IllegalStateException –  If this BundleContext is no longer valid. 
	See Also	ServiceEvent , ServiceListener , ServicePermission
<?FM MARKER [Cross-Ref] BundleContext.addServiceListener(ServiceListener)?>
<?FM MARKER [Index] BundleContext:addServiceListener?>
<?FM MARKER [Index] addServiceListener?>
addServiceListener(ServiceListener)
public void addServiceListener ( ServiceListener listener ) 
	listener	The ServiceListener object to be added.
	
Adds the specified ServiceListener object to the context bundle’s
list of listeners. 
This method is the same as calling BundleContext.addServiceListener(ServiceListener
listener, String filter) with filter set to null.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
	See Also	addServiceListener(ServiceListener, String)
<?FM MARKER [Cross-Ref] BundleContext.createFilter(String)?>
<?FM MARKER [Index] BundleContext:createFilter?>
<?FM MARKER [Index] createFilter?>
createFilter(String)
public Filter createFilter ( String filter ) throws InvalidSyntaxException
	filter	The filter string.
	
Creates a Filter object. This Filter object may be used to match
a ServiceReference object or a Dictionary object. 
If the filter cannot be parsed, an InvalidSyntaxException will be
thrown with a human readable message where the filter became unparsable.
	Returns	A Filter object encapsulating the filter string.
	Throws	InvalidSyntaxException –  If filter contains an invalid
filter string that cannot be parsed. 
		NullPointerException –  If filter is null. 
		IllegalStateException –  If this BundleContext is no longer valid. 
	See Also	Framework specification for a description of the filter
string syntax. , FrameworkUtil.createFilter(String)
	Since	1.1
<?FM MARKER [Cross-Ref] BundleContext.getAllServiceReferences(String,String)?>
<?FM MARKER [Index] BundleContext:getAllServiceReferences?>
<?FM MARKER [Index] getAllServiceReferences?>
getAllServiceReferences(String,String)
public ServiceReference&lt;?&gt;[] getAllServiceReferences ( String
clazz , String filter )  throws InvalidSyntaxException
	clazz	The class name with which the service was registered or null
for all services.
	filter	The filter expression or null for all services.
	
Returns an array of ServiceReference objects. The returned array
of ServiceReference objects contains services that were registered
under the specified class and match the specified filter expression.
 
The list is valid at the time of the call to this method. However
since the Framework is a very dynamic environment, services can
be modified or unregistered at any time.  
The specified filter expression is used to select the registered
services whose service properties contain keys and values which
satisfy the filter expression. See Filter for a description of the
filter syntax. If the specified filter is null, all registered services
are considered to match the filter. If the specified filter expression
cannot be parsed, an InvalidSyntaxException will be thrown with
a human readable message where the filter became unparsable. 
The result is an array of ServiceReference objects for all services
that meet all of the following conditions: 
If the specified class name, clazz, is not null, the service must
have been registered with the specified class name. The complete
list of class names with which a service was registered is available
from the service’s objectClass property. 
If the specified filter is not null, the filter expression must
match the service. 
If the Java Runtime Environment supports permissions, the caller
must have ServicePermission with the GET action for at least one
of the class names under which the service was registered. 
	Returns	An array of ServiceReference objects or null if no services
are registered which satisfy the search.
	Throws	InvalidSyntaxException –  If the specified filter contains
an invalid filter expression that cannot be parsed. 
		IllegalStateException –  If this BundleContext is no longer valid. 
	Since	1.3
<?FM MARKER [Cross-Ref] BundleContext.getBundle()?>
<?FM MARKER [Index] BundleContext:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle()
public Bundle getBundle ( ) 
	
Returns the Bundle object associated with this BundleContext. This
bundle is called the context bundle. 
	Returns	The Bundle object associated with this BundleContext.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
<?FM MARKER [Cross-Ref] BundleContext.getBundle(long)?>
<?FM MARKER [Index] BundleContext:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle(long)
public Bundle getBundle ( long id ) 
	id	The identifier of the bundle to retrieve.
	
Returns the bundle with the specified identifier. 
	Returns	A Bundle object or null if the identifier does not match
any installed bundle.
<?FM MARKER [Cross-Ref] BundleContext.getBundle(String)?>
<?FM MARKER [Index] BundleContext:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle(String)
public Bundle getBundle ( String location ) 
	location	The location of the bundle to retrieve.
	
Returns the bundle with the specified location. 
	Returns	A Bundle object or null if the location does not match
any installed bundle.
	Since	1.6
<?FM MARKER [Cross-Ref] BundleContext.getBundles()?>
<?FM MARKER [Index] BundleContext:getBundles?>
<?FM MARKER [Index] getBundles?>
getBundles()
public Bundle[] getBundles (  ) 
	
Returns a list of all installed bundles. 
This method returns a list of all bundles installed in the OSGi
environment at the time of the call to this method. However, since
the Framework is a very dynamic environment, bundles can be installed or
uninstalled at anytime.
	Returns	An array of Bundle objects, one object per installed bundle.
<?FM MARKER [Cross-Ref] BundleContext.getDataFile(String)?>
<?FM MARKER [Index] BundleContext:getDataFile?>
<?FM MARKER [Index] getDataFile?>
getDataFile(String)
public File getDataFile ( String filename ) 
	filename	A relative name to the file to be accessed.
	
Creates a File object for a file in the persistent storage area
provided for the bundle by the Framework. This method will return
null if the platform does not have file system support.  
A File object for the base directory of the persistent storage area
provided for the context bundle by the Framework can be obtained
by calling this method with an empty string as filename.  
If the Java Runtime Environment supports permissions, the Framework
will ensure that the bundle has the java.io.FilePermission with
actions read,write,delete for all files (recursively) in the persistent storage
area provided for the context bundle.
	Returns	A File object that represents the requested file or null
if the platform does not have file system support.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
<?FM MARKER [Cross-Ref] BundleContext.getProperty(String)?>
<?FM MARKER [Index] BundleContext:getProperty?>
<?FM MARKER [Index] getProperty?>
getProperty(String)
public String getProperty ( String key ) 
	key	The name of the requested property.
	
Returns the value of the specified property. If the key is not found
in the Framework properties, the system properties are then searched.
The method returns null if the property is not found.  
All bundles must have permission to read properties whose names
start with “org.osgi.”.
	Returns	The value of the requested property, or null if the property
is undefined.
	Throws	SecurityException –  If the caller does not have the appropriate
PropertyPermission to read the property, and the Java Runtime Environment
supports permissions. 
<?FM MARKER [Cross-Ref] BundleContext.getService(ServiceReference)?>
<?FM MARKER [Index] BundleContext:getService?>
<?FM MARKER [Index] getService?>
getService(ServiceReference)
public S getService ( ServiceReference&lt;S&gt; reference ) 
	Type Arguments	&lt;S&gt;
	&lt;S&gt;	Type of Service.
	reference	A reference to the service.
	
Returns the service object referenced by the specified ServiceReference
object. 
A bundle’s use of a service is tracked by the bundle’s use count
of that service. Each time a service’s service object is returned
by getService(ServiceReference) the context bundle’s use count for
that service is incremented by one. Each time the service is released
by ungetService(ServiceReference) the context bundle’s use count
for that service is decremented by one. 
When a bundle’s use count for a service drops to zero, the bundle
should no longer use that service. 
This method will always return null when the service associated
with this reference has been unregistered.  
The following steps are required to get the service object: 
If the service has been unregistered, null is returned. 
If the context bundle’s use count for the service is currently zero
and the service was registered with an object implementing the ServiceFactory
interface, the ServiceFactory.getService(Bundle, ServiceRegistration)
method is called to create a service object for the context bundle.
If the service object returned by the ServiceFactory object is null,
not an instanceof all the classes named when the service was registered
or the ServiceFactory object throws an exception or will be recursively
called for the context bundle, null is returned and a Framework
event of type FrameworkEvent.ERROR containing a ServiceException
describing the error is fired. 
 This service object is cached by the Framework. While the context
bundle’s use count for the service is greater than zero, subsequent
calls to get the services’s service object for the context bundle
will return the cached service object. 
The context bundle’s use count for this service is incremented by
one. 
The service object for the service is returned. 
	Returns	A service object for the service associated with reference
or null if the service is not registered, the service object returned
by a ServiceFactory does not implement the classes under which it
was registered or the ServiceFactory threw an exception.
	Throws	SecurityException –  If the caller does not have the ServicePermission
to get the service using at least one of the named classes the service
was registered under and the Java Runtime Environment supports permissions. 
		IllegalStateException –  If this BundleContext is no longer valid. 
		IllegalArgumentException –  If the specified ServiceReference
was not created by the same framework instance as this BundleContext. 
	See Also	ungetService(ServiceReference) , ServiceFactory
<?FM MARKER [Cross-Ref] BundleContext.getServiceReference(String)?>
<?FM MARKER [Index] BundleContext:getServiceReference?>
<?FM MARKER [Index] getServiceReference?>
getServiceReference(String)
public ServiceReference&lt;?&gt; getServiceReference ( String clazz
) 
	clazz	The class name with which the service was registered.
	
Returns a ServiceReference object for a service that implements
and was registered under the specified class. 
The returned ServiceReference object is valid at the time of the
call to this method. However as the Framework is a very dynamic
environment, services can be modified or unregistered at any time.
 
This method is the same as calling getServiceReferences(String,
String) with a null filter expression and then finding the reference
with the highest priority. It is provided as a convenience for when
the caller is interested in any service that implements the specified
class. 
If multiple such services exist, the service with the highest priority
is selected. This priority is defined as the service reference with
the highest ranking (as specified in its Constants.SERVICE_RANKING property)
is returned. 
If there is a tie in ranking, the service with the lowest service
ID (as specified in its Constants.SERVICE_ID property); that is,
the service that was registered first is returned.
	Returns	A ServiceReference object, or null if no services are registered
which implement the named class.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
	See Also	getServiceReferences(String, String)
<?FM MARKER [Cross-Ref] BundleContext.getServiceReference(Class)?>
<?FM MARKER [Index] BundleContext:getServiceReference?>
<?FM MARKER [Index] getServiceReference?>
getServiceReference(Class)
public ServiceReference&lt;S&gt; getServiceReference ( Class&lt;S&gt;
clazz ) 
	Type Arguments	&lt;S&gt;
	&lt;S&gt;	Type of Service.
	clazz	The class under whose name the service was registered. Must
not be null.
	
Returns a ServiceReference object for a service that implements
and was registered under the name of the specified class. 
The returned ServiceReference object is valid at the time of the
call to this method. However as the Framework is a very dynamic
environment, services can be modified or unregistered at any time.
 
This method is the same as calling getServiceReferences(Class, String)
with a null filter expression. It is provided as a convenience for
when the caller is interested in any service that implements the
specified class. 
If multiple such services exist, the service with the highest ranking
(as specified in its Constants.SERVICE_RANKING property) is returned. 
If there is a tie in ranking, the service with the lowest service
ID (as specified in its Constants.SERVICE_ID property); that is,
the service that was registered first is returned.
	Returns	A ServiceReference object, or null if no services are registered
which implement the specified class.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
	See Also	getServiceReferences(Class, String)
	Since	1.6
<?FM MARKER [Cross-Ref] BundleContext.getServiceReferences(String,String)?>
<?FM MARKER [Index] BundleContext:getServiceReferences?>
<?FM MARKER [Index] getServiceReferences?>
getServiceReferences(String,String)
public ServiceReference&lt;?&gt;[] getServiceReferences ( String clazz
, String filter )  throws InvalidSyntaxException
	clazz	The class name with which the service was registered or null
for all services.
	filter	The filter expression or null for all services.
	
Returns an array of ServiceReference objects. The returned array
of ServiceReference objects contains services that were registered
under the specified class, match the specified filter expression,
and the packages for the class names under which the services were
registered match the context bundle’s packages as defined in ServiceReference.isAssignableTo(Bundle,
String).  
The list is valid at the time of the call to this method. However
since the Framework is a very dynamic environment, services can
be modified or unregistered at any time.  
The specified filter expression is used to select the registered
services whose service properties contain keys and values which
satisfy the filter expression. See Filter for a description of the
filter syntax. If the specified filter is null, all registered services
are considered to match the filter. If the specified filter expression
cannot be parsed, an InvalidSyntaxException will be thrown with
a human readable message where the filter became unparsable. 
The result is an array of ServiceReference objects for all services
that meet all of the following conditions: 
If the specified class name, clazz, is not null, the service must
have been registered with the specified class name. The complete
list of class names with which a service was registered is available
from the service’s objectClass property. 
If the specified filter is not null, the filter expression must
match the service. 
If the Java Runtime Environment supports permissions, the caller
must have ServicePermission with the GET action for at least one
of the class names under which the service was registered. 
For each class name with which the service was registered, calling
ServiceReference.isAssignableTo(Bundle, String) with the context
bundle and the class name on the service’s ServiceReference object
must return true
	Returns	An array of ServiceReference objects or null if no services
are registered which satisfy the search.
	Throws	InvalidSyntaxException –  If the specified filter contains
an invalid filter expression that cannot be parsed. 
		IllegalStateException –  If this BundleContext is no longer valid. 
<?FM MARKER [Cross-Ref] BundleContext.getServiceReferences(Class,String)?>
<?FM MARKER [Index] BundleContext:getServiceReferences?>
<?FM MARKER [Index] getServiceReferences?>
getServiceReferences(Class,String)
public Collection&lt;ServiceReference&lt;S&gt;&gt; getServiceReferences
( Class&lt;S&gt; clazz , String filter ) throws InvalidSyntaxException
	Type Arguments	&lt;S&gt;
	&lt;S&gt;	Type of Service
	clazz	The class under whose name the service was registered. Must
not be null.
	filter	The filter expression or null for all services.
	
Returns a collection of ServiceReference objects. The returned collection
of ServiceReference objects contains services that were registered
under the name of the specified class, match the specified filter expression,
and the packages for the class names under which the services were
registered match the context bundle’s packages as defined in ServiceReference.isAssignableTo(Bundle,
String).  
The collection is valid at the time of the call to this method.
However since the Framework is a very dynamic environment, services
can be modified or unregistered at any time.  
The specified filter expression is used to select the registered
services whose service properties contain keys and values which
satisfy the filter expression. See Filter for a description of the
filter syntax. If the specified filter is null, all registered services
are considered to match the filter. If the specified filter expression
cannot be parsed, an InvalidSyntaxException will be thrown with
a human readable message where the filter became unparsable. 
The result is a collection of ServiceReference objects for all services
that meet all of the following conditions: 
The service must have been registered with the name of the specified
class. The complete list of class names with which a service was
registered is available from the service’s objectClass property. 
If the specified filter is not null, the filter expression must
match the service. 
If the Java Runtime Environment supports permissions, the caller
must have ServicePermission with the GET action for at least one
of the class names under which the service was registered. 
For each class name with which the service was registered, calling
ServiceReference.isAssignableTo(Bundle, String) with the context
bundle and the class name on the service’s ServiceReference object
must return true
	Returns	A collection of ServiceReference objects. May be empty
if no services are registered which satisfy the search.
	Throws	InvalidSyntaxException –  If the specified filter contains
an invalid filter expression that cannot be parsed. 
		IllegalStateException –  If this BundleContext is no longer valid. 
	Since	1.6
<?FM MARKER [Cross-Ref] BundleContext.installBundle(String,InputStream)?>
<?FM MARKER [Index] BundleContext:installBundle?>
<?FM MARKER [Index] installBundle?>
installBundle(String,InputStream)
public Bundle installBundle ( String location , InputStream input
) throws BundleException
	location	The location identifier of the bundle to install.
	input	The InputStream object from which this bundle will be read
or null to indicate the Framework must create the input stream from
the specified location identifier. The input stream must always
be closed when this method completes, even if an exception is thrown.
	
Installs a bundle from the specified InputStream object.  
If the specified InputStream is null, the Framework must create
the InputStream from which to read the bundle by interpreting, in
an implementation dependent manner, the specified location.  
The specified location identifier will be used as the identity of
the bundle. Every installed bundle is uniquely identified by its
location identifier which is typically in the form of a URL.  
The following steps are required to install a bundle: 
If a bundle containing the same location identifier is already installed,
the Bundle object for that bundle is returned.  
The bundle’s content is read from the input stream. If this fails,
a BundleException is thrown.  
The bundle’s associated resources are allocated. The associated
resources minimally consist of a unique identifier and a persistent
storage area if the platform has file system support. If this step
fails, a BundleException is thrown.  
The bundle’s state is set to INSTALLED.  
A bundle event of type BundleEvent.INSTALLED is fired.  
The Bundle object for the newly or previously installed bundle is
returned. 
Postconditions, no exceptions thrown 
getState() in { INSTALLED, RESOLVED }. 
Bundle has a unique ID. 
Postconditions, when an exception is thrown 
Bundle is not installed. If there was an existing bundle for the
specified location, then that bundle must still be in the state
it was prior to calling this method.
	Returns	The Bundle object of the installed bundle.
	Throws	BundleException –  If the installation failed. BundleException
types thrown by this method include: BundleException.READ_ERROR
, BundleException.DUPLICATE_BUNDLE_ERROR, BundleException.MANIFEST_ERROR,
and BundleException.REJECTED_BY_HOOK. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[installed bundle,LIFECYCLE], and the Java Runtime
Environment supports permissions. 
		IllegalStateException –  If this BundleContext is no longer valid. 
<?FM MARKER [Cross-Ref] BundleContext.installBundle(String)?>
<?FM MARKER [Index] BundleContext:installBundle?>
<?FM MARKER [Index] installBundle?>
installBundle(String)
public Bundle installBundle ( String location ) throws BundleException
	location	The location identifier of the bundle to install.
	
Installs a bundle from the specified location identifier.  
This method performs the same function as calling installBundle(String,InputStream)
with the specified location identifier and a null InputStream.
	Returns	The Bundle object of the installed bundle.
	Throws	BundleException –  If the installation failed. BundleException
types thrown by this method include: BundleException.READ_ERROR
, BundleException.DUPLICATE_BUNDLE_ERROR, BundleException.MANIFEST_ERROR,
and BundleException.REJECTED_BY_HOOK. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[installed bundle,LIFECYCLE], and the Java Runtime
Environment supports permissions. 
		IllegalStateException –  If this BundleContext is no longer valid. 
	See Also	installBundle(String, InputStream)
<?FM MARKER [Cross-Ref] BundleContext.registerService(String[],Object,Dictionary)?>
<?FM MARKER [Index] BundleContext:registerService?>
<?FM MARKER [Index] registerService?>
registerService(String[],Object,Dictionary)
public ServiceRegistration&lt;?&gt; registerService ( String[] clazzes
, Object service , Dictionary&lt;String,?&gt; properties ) 
	clazzes	The class names under which the service can be located.
The class names in this array will be stored in the service’s properties
under the key Constants.OBJECTCLASS.
	service	The service object or a ServiceFactory object.
	properties	The properties for this service. The keys in the properties
object must all be String objects. See Constants for a list of standard
service property keys. Changes should not be made to this object
after calling this method. To update the service’s properties the
ServiceRegistration.setProperties(Dictionary) method must be called.
The set of properties may be null if the service has no properties.
	
Registers the specified service object with the specified properties
under the specified class names into the Framework. A ServiceRegistration
object is returned. The ServiceRegistration object is for the private
use of the bundle registering the service and should not be shared
with other bundles. The registering bundle is defined to be the
context bundle. Other bundles can locate the service by using one
of the getServiceReferences(Class, String), getServiceReferences(String,
String), getServiceReference(Class) or getServiceReference(String)
methods.  
A bundle can register a service object that implements the ServiceFactory
interface to have more flexibility in providing service objects
to other bundles. 
The following steps are required to register a service: 
If service is not a ServiceFactory, an IllegalArgumentException
is thrown if service is not an instanceof all the specified class
names. 
The Framework adds the following service properties to the service
properties from the specified Dictionary (which may be null): 
 A property named Constants.SERVICE_ID identifying the registration
number of the service 
 A property named Constants.OBJECTCLASS containing all the specified
classes. 
 Properties with these names in the specified Dictionary will be
ignored. 
The service is added to the Framework service registry and may now
be used by other bundles. 
A service event of type ServiceEvent.REGISTERED is fired. 
A ServiceRegistration object for this registration is returned. 
	Returns	A ServiceRegistration object for use by the bundle registering
the service to update the service’s properties or to unregister
the service.
	Throws	IllegalArgumentException –  If one of the following is true: 
service is null. 
service is not a ServiceFactory object and is not an instance of
all the named classes in clazzes. 
properties contains case variants of the same key name. 
		SecurityException –  If the caller does not have the ServicePermission
to register the service for all the named classes and the Java Runtime
Environment supports permissions. 
		IllegalStateException –  If this BundleContext is no longer valid. 
	See Also	ServiceRegistration , ServiceFactory
<?FM MARKER [Cross-Ref] BundleContext.registerService(String,Object,Dictionary)?>
<?FM MARKER [Index] BundleContext:registerService?>
<?FM MARKER [Index] registerService?>
registerService(String,Object,Dictionary)
public ServiceRegistration&lt;?&gt; registerService ( String clazz
, Object service , Dictionary&lt;String,?&gt; properties ) 
	clazz	The class name under which the service can be located.
	service	The service object or a ServiceFactory object.
	properties	The properties for this service.
	
Registers the specified service object with the specified properties
under the specified class name with the Framework. 
This method is otherwise identical to registerService(String[],
Object, Dictionary) and is provided as a convenience when service
will only be registered under a single class name. Note that even
in this case the value of the service’s Constants.OBJECTCLASS property
will be an array of string, rather than just a single string.
	Returns	A ServiceRegistration object for use by the bundle registering
the service to update the service’s properties or to unregister
the service.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
	See Also	registerService(String[], Object, Dictionary)
<?FM MARKER [Cross-Ref] BundleContext.registerService(Class,S,Dictionary)?>
<?FM MARKER [Index] BundleContext:registerService?>
<?FM MARKER [Index] registerService?>
registerService(Class,S,Dictionary)
public ServiceRegistration&lt;S&gt; registerService ( Class&lt;S&gt; clazz
, S service , Dictionary&lt;String,?&gt; properties ) 
	Type Arguments	&lt;S&gt;
	&lt;S&gt;	Type of Service.
	clazz	The class under whose name the service can be located.
	service	The service object or a ServiceFactory object.
	properties	The properties for this service.
	
Registers the specified service object with the specified properties
under the name of the specified class with the Framework. 
This method is otherwise identical to registerService(String, Object,
Dictionary) and is provided to return a type safe ServiceRegistration.
	Returns	A ServiceRegistration object for use by the bundle registering
the service to update the service’s properties or to unregister
the service.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
	See Also	registerService(String, Object, Dictionary)
	Since	1.6
<?FM MARKER [Cross-Ref] BundleContext.removeBundleListener(BundleListener)?>
<?FM MARKER [Index] BundleContext:removeBundleListener?>
<?FM MARKER [Index] removeBundleListener?>
removeBundleListener(BundleListener)
public void removeBundleListener ( BundleListener listener ) 
	listener	The BundleListener object to be removed.
	
Removes the specified BundleListener object from the context bundle’s
list of listeners. 
If listener is not contained in the context bundle’s list of listeners,
this method does nothing.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
		SecurityException –  If listener is a SynchronousBundleListener
and the caller does not have the appropriate AdminPermission[context
bundle,LISTENER], and the Java Runtime Environment supports permissions. 
<?FM MARKER [Cross-Ref] BundleContext.removeFrameworkListener(FrameworkListener)?>
<?FM MARKER [Index] BundleContext:removeFrameworkListener?>
<?FM MARKER [Index] removeFrameworkListener?>
removeFrameworkListener(FrameworkListener)
public void removeFrameworkListener ( FrameworkListener listener
) 
	listener	The FrameworkListener object to be removed.
	
Removes the specified FrameworkListener object from the context
bundle’s list of listeners. 
If listener is not contained in the context bundle’s list of listeners,
this method does nothing.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
<?FM MARKER [Cross-Ref] BundleContext.removeServiceListener(ServiceListener)?>
<?FM MARKER [Index] BundleContext:removeServiceListener?>
<?FM MARKER [Index] removeServiceListener?>
removeServiceListener(ServiceListener)
public void removeServiceListener ( ServiceListener listener ) 
	listener	The ServiceListener to be removed.
	
Removes the specified ServiceListener object from the context bundle’s
list of listeners. 
If listener is not contained in this context bundle’s list of listeners,
this method does nothing.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
<?FM MARKER [Cross-Ref] BundleContext.ungetService(ServiceReference)?>
<?FM MARKER [Index] BundleContext:ungetService?>
<?FM MARKER [Index] ungetService?>
ungetService(ServiceReference)
public boolean ungetService ( ServiceReference&lt;?&gt; reference ) 
	reference	A reference to the service to be released.
	
Releases the service object referenced by the specified ServiceReference
object. If the context bundle’s use count for the service is zero,
this method returns false. Otherwise, the context bundle’s use count for
the service is decremented by one. 
The service’s service object should no longer be used and all references
to it should be destroyed when a bundle’s use count for the service
drops to zero.  
The following steps are required to unget the service object: 
If the context bundle’s use count for the service is zero or the
service has been unregistered, false is returned. 
The context bundle’s use count for this service is decremented by
one. 
If the context bundle’s use count for the service is currently zero
and the service was registered with a ServiceFactory object, the
ServiceFactory.ungetService(Bundle, ServiceRegistration, Object)
method is called to release the service object for the context bundle. 
true is returned. 
	Returns	false if the context bundle’s use count for the service
is zero or if the service has been unregistered; true otherwise.
	Throws	IllegalStateException –  If this BundleContext is no longer
valid. 
		IllegalArgumentException –  If the specified ServiceReference
was not created by the same framework instance as this BundleContext. 
	See Also	getService(ServiceReference) , ServiceFactory
<?FM MARKER [Cross-Ref] BundleEvent?>
<?FM MARKER [Index] BundleEvent?>
<?FM MARKER [Index] class:BundleEvent?>
BundleEvent
public class BundleEvent
	extends EventObject
An event from the Framework describing a bundle lifecycle change. 
BundleEvent objects are delivered to SynchronousBundleListeners
and BundleListeners when a change occurs in a bundle’s lifecycle.
A type code is used to identify the event type for future extendability.
 
OSGi Alliance reserves the right to extend the set of types.
	See Also	BundleListener , SynchronousBundleListener
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] BundleEvent.INSTALLED?>
<?FM MARKER [Index] BundleEvent:INSTALLED?>
<?FM MARKER [Index] INSTALLED?>
INSTALLED
public static final int INSTALLED = 1
The bundle has been installed. 
	See Also	BundleContext.installBundle(String)
<?FM MARKER [Cross-Ref] BundleEvent.LAZY_ACTIVATION?>
<?FM MARKER [Index] BundleEvent:LAZY_ACTIVATION?>
<?FM MARKER [Index] LAZY_ACTIVATION?>
LAZY_ACTIVATION
public static final int LAZY_ACTIVATION = 512
The bundle will be lazily activated. 
The bundle has a lazy activation policy and is waiting to be activated.
It is now in the STARTING state and has a valid BundleContext. This
event is only delivered to SynchronousBundleListeners. It is not delivered
to BundleListeners.
	Since	1.4
<?FM MARKER [Cross-Ref] BundleEvent.RESOLVED?>
<?FM MARKER [Index] BundleEvent:RESOLVED?>
<?FM MARKER [Index] RESOLVED?>
RESOLVED
public static final int RESOLVED = 32
The bundle has been resolved. 
	See Also	Bundle.RESOLVED
	Since	1.3
<?FM MARKER [Cross-Ref] BundleEvent.STARTED?>
<?FM MARKER [Index] BundleEvent:STARTED?>
<?FM MARKER [Index] STARTED?>
STARTED
public static final int STARTED = 2
The bundle has been started. 
The bundle’s BundleActivator start method has been executed if the
bundle has a bundle activator class.
	See Also	Bundle.start()
<?FM MARKER [Cross-Ref] BundleEvent.STARTING?>
<?FM MARKER [Index] BundleEvent:STARTING?>
<?FM MARKER [Index] STARTING?>
STARTING
public static final int STARTING = 128
The bundle is about to be activated. 
The bundle’s BundleActivator start method is about to be called
if the bundle has a bundle activator class. This event is only delivered
to SynchronousBundleListener s. It is not delivered to BundleListeners.
	See Also	Bundle.start()
	Since	1.3
<?FM MARKER [Cross-Ref] BundleEvent.STOPPED?>
<?FM MARKER [Index] BundleEvent:STOPPED?>
<?FM MARKER [Index] STOPPED?>
STOPPED
public static final int STOPPED = 4
The bundle has been stopped. 
The bundle’s BundleActivator stop method has been executed if the
bundle has a bundle activator class.
	See Also	Bundle.stop()
<?FM MARKER [Cross-Ref] BundleEvent.STOPPING?>
<?FM MARKER [Index] BundleEvent:STOPPING?>
<?FM MARKER [Index] STOPPING?>
STOPPING
public static final int STOPPING = 256
The bundle is about to deactivated. 
The bundle’s BundleActivator stop method is about to be called if
the bundle has a bundle activator class. This event is only delivered
to SynchronousBundleListener s. It is not delivered to BundleListeners.
	See Also	Bundle.stop()
	Since	1.3
<?FM MARKER [Cross-Ref] BundleEvent.UNINSTALLED?>
<?FM MARKER [Index] BundleEvent:UNINSTALLED?>
<?FM MARKER [Index] UNINSTALLED?>
UNINSTALLED
public static final int UNINSTALLED = 16
The bundle has been uninstalled. 
	See Also	Bundle.uninstall()
<?FM MARKER [Cross-Ref] BundleEvent.UNRESOLVED?>
<?FM MARKER [Index] BundleEvent:UNRESOLVED?>
<?FM MARKER [Index] UNRESOLVED?>
UNRESOLVED
public static final int UNRESOLVED = 64
The bundle has been unresolved. 
	See Also	Bundle.INSTALLED
	Since	1.3
<?FM MARKER [Cross-Ref] BundleEvent.UPDATED?>
<?FM MARKER [Index] BundleEvent:UPDATED?>
<?FM MARKER [Index] UPDATED?>
UPDATED
public static final int UPDATED = 8
The bundle has been updated. 
	See Also	Bundle.update()
<?FM MARKER [Cross-Ref] BundleEvent.BundleEvent(int,Bundle,Bundle)?>
<?FM MARKER [Index] BundleEvent:BundleEvent?>
<?FM MARKER [Index] BundleEvent?>
BundleEvent(int,Bundle,Bundle)
public BundleEvent ( int type , Bundle bundle , Bundle origin ) 
	type	The event type.
	bundle	The bundle which had a lifecycle change.
	origin	The bundle which is the origin of the event. For the event
type INSTALLED, this is the bundle whose context was used to install
the bundle. Otherwise it is the bundle itself.
	
Creates a bundle event of the specified type. 
	Since	1.6
<?FM MARKER [Cross-Ref] BundleEvent.BundleEvent(int,Bundle)?>
<?FM MARKER [Index] BundleEvent:BundleEvent?>
<?FM MARKER [Index] BundleEvent?>
BundleEvent(int,Bundle)
public BundleEvent ( int type , Bundle bundle ) 
	type	The event type.
	bundle	The bundle which had a lifecycle change. This bundle is
used as the origin of the event.
	
Creates a bundle event of the specified type. 
<?FM MARKER [Cross-Ref] BundleEvent.getBundle()?>
<?FM MARKER [Index] BundleEvent:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle()
public Bundle getBundle ( ) 
	
Returns the bundle which had a lifecycle change. This bundle is
the source of the event. 
	Returns	The bundle that had a change occur in its lifecycle.
<?FM MARKER [Cross-Ref] BundleEvent.getOrigin()?>
<?FM MARKER [Index] BundleEvent:getOrigin?>
<?FM MARKER [Index] getOrigin?>
getOrigin()
public Bundle getOrigin ( ) 
	
Returns the bundle that was the origin of the event.  
For the event type INSTALLED, this is the bundle whose context was
used to install the bundle. Otherwise it is the bundle itself.
	Returns	The bundle that was the origin of the event.
	Since	1.6
<?FM MARKER [Cross-Ref] BundleEvent.getType()?>
<?FM MARKER [Index] BundleEvent:getType?>
<?FM MARKER [Index] getType?>
getType()
public int getType ( ) 
	
Returns the type of lifecyle event. The type values are: 
INSTALLED
RESOLVED
LAZY_ACTIVATION
STARTING
STARTED
STOPPING
STOPPED
UPDATED
UNRESOLVED
UNINSTALLED
	Returns	The type of lifecycle event.
<?FM MARKER [Cross-Ref] BundleException?>
<?FM MARKER [Index] BundleException?>
<?FM MARKER [Index] class:BundleException?>
BundleException
public class BundleException
	extends Exception
A Framework exception used to indicate that a bundle lifecycle problem
occurred. 
A BundleException object is created by the Framework to denote an
exception condition in the lifecycle of a bundle. BundleExceptions
should not be created by bundle developers. A type code is used to
identify the exception type for future extendability.  
OSGi Alliance reserves the right to extend the set of types.  
This exception conforms to the general purpose exception chaining
mechanism.
<?FM MARKER [Cross-Ref] BundleException.ACTIVATOR_ERROR?>
<?FM MARKER [Index] BundleException:ACTIVATOR_ERROR?>
<?FM MARKER [Index] ACTIVATOR_ERROR?>
ACTIVATOR_ERROR
public static final int ACTIVATOR_ERROR = 5
The bundle activator was in error. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.DUPLICATE_BUNDLE_ERROR?>
<?FM MARKER [Index] BundleException:DUPLICATE_BUNDLE_ERROR?>
<?FM MARKER [Index] DUPLICATE_BUNDLE_ERROR?>
DUPLICATE_BUNDLE_ERROR
public static final int DUPLICATE_BUNDLE_ERROR = 9
The install or update operation failed because another already installed
bundle has the same symbolic name and version. This exception type
will only occur if the framework is configured to only allow a single
bundle to be installed for a given symbolic name and version. 
	See Also	Constants.FRAMEWORK_BSNVERSION
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.INVALID_OPERATION?>
<?FM MARKER [Index] BundleException:INVALID_OPERATION?>
<?FM MARKER [Index] INVALID_OPERATION?>
INVALID_OPERATION
public static final int INVALID_OPERATION = 2
The operation was invalid. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.MANIFEST_ERROR?>
<?FM MARKER [Index] BundleException:MANIFEST_ERROR?>
<?FM MARKER [Index] MANIFEST_ERROR?>
MANIFEST_ERROR
public static final int MANIFEST_ERROR = 3
The bundle manifest was in error. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.NATIVECODE_ERROR?>
<?FM MARKER [Index] BundleException:NATIVECODE_ERROR?>
<?FM MARKER [Index] NATIVECODE_ERROR?>
NATIVECODE_ERROR
public static final int NATIVECODE_ERROR = 8
The bundle could not be resolved due to an error with the Bundle-NativeCode
header. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.READ_ERROR?>
<?FM MARKER [Index] BundleException:READ_ERROR?>
<?FM MARKER [Index] READ_ERROR?>
READ_ERROR
public static final int READ_ERROR = 11
The framework received an error while reading the input stream for
a bundle. 
	Since	1.6
<?FM MARKER [Cross-Ref] BundleException.REJECTED_BY_HOOK?>
<?FM MARKER [Index] BundleException:REJECTED_BY_HOOK?>
<?FM MARKER [Index] REJECTED_BY_HOOK?>
REJECTED_BY_HOOK
public static final int REJECTED_BY_HOOK = 12
A framework hook rejected the operation. 
	Since	1.6
<?FM MARKER [Cross-Ref] BundleException.RESOLVE_ERROR?>
<?FM MARKER [Index] BundleException:RESOLVE_ERROR?>
<?FM MARKER [Index] RESOLVE_ERROR?>
RESOLVE_ERROR
public static final int RESOLVE_ERROR = 4
The bundle was not resolved. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.SECURITY_ERROR?>
<?FM MARKER [Index] BundleException:SECURITY_ERROR?>
<?FM MARKER [Index] SECURITY_ERROR?>
SECURITY_ERROR
public static final int SECURITY_ERROR = 6
The operation failed due to insufficient permissions. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.START_TRANSIENT_ERROR?>
<?FM MARKER [Index] BundleException:START_TRANSIENT_ERROR?>
<?FM MARKER [Index] START_TRANSIENT_ERROR?>
START_TRANSIENT_ERROR
public static final int START_TRANSIENT_ERROR = 10
The start transient operation failed because the start level of
the bundle is greater than the current framework start level 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.STATECHANGE_ERROR?>
<?FM MARKER [Index] BundleException:STATECHANGE_ERROR?>
<?FM MARKER [Index] STATECHANGE_ERROR?>
STATECHANGE_ERROR
public static final int STATECHANGE_ERROR = 7
The operation failed to complete the requested lifecycle state change. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.UNSPECIFIED?>
<?FM MARKER [Index] BundleException:UNSPECIFIED?>
<?FM MARKER [Index] UNSPECIFIED?>
UNSPECIFIED
public static final int UNSPECIFIED = 0
No exception type is specified. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.UNSUPPORTED_OPERATION?>
<?FM MARKER [Index] BundleException:UNSUPPORTED_OPERATION?>
<?FM MARKER [Index] UNSUPPORTED_OPERATION?>
UNSUPPORTED_OPERATION
public static final int UNSUPPORTED_OPERATION = 1
The operation was unsupported. This type can be used anywhere a
BundleException can be thrown. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.BundleException(String,Throwable)?>
<?FM MARKER [Index] BundleException:BundleException?>
<?FM MARKER [Index] BundleException?>
BundleException(String,Throwable)
public BundleException ( String msg , Throwable cause ) 
	msg	The associated message.
	cause	The cause of this exception.
	
Creates a BundleException with the specified message and exception
cause. 
<?FM MARKER [Cross-Ref] BundleException.BundleException(String)?>
<?FM MARKER [Index] BundleException:BundleException?>
<?FM MARKER [Index] BundleException?>
BundleException(String)
public BundleException ( String msg ) 
	msg	The message.
	
Creates a BundleException with the specified message. 
<?FM MARKER [Cross-Ref] BundleException.BundleException(String,int,Throwable)?>
<?FM MARKER [Index] BundleException:BundleException?>
<?FM MARKER [Index] BundleException?>
BundleException(String,int,Throwable)
public BundleException ( String msg , int type , Throwable cause
) 
	msg	The associated message.
	type	The type for this exception.
	cause	The cause of this exception.
	
Creates a BundleException with the specified message, type and exception
cause. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.BundleException(String,int)?>
<?FM MARKER [Index] BundleException:BundleException?>
<?FM MARKER [Index] BundleException?>
BundleException(String,int)
public BundleException ( String msg , int type ) 
	msg	The message.
	type	The type for this exception.
	
Creates a BundleException with the specified message and type. 
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.getCause()?>
<?FM MARKER [Index] BundleException:getCause?>
<?FM MARKER [Index] getCause?>
getCause()
public Throwable getCause ( ) 
	
Returns the cause of this exception or null if no cause was set. 
	Returns	The cause of this exception or null if no cause was set.
	Since	1.3
<?FM MARKER [Cross-Ref] BundleException.getNestedException()?>
<?FM MARKER [Index] BundleException:getNestedException?>
<?FM MARKER [Index] getNestedException?>
getNestedException()
public Throwable getNestedException ( ) 
	
Returns the cause of this exception or null if no cause was specified
when this exception was created. 
This method predates the general purpose exception chaining mechanism.
The getCause() method is now the preferred means of obtaining this
information.
	Returns	The result of calling getCause().
<?FM MARKER [Cross-Ref] BundleException.getType()?>
<?FM MARKER [Index] BundleException:getType?>
<?FM MARKER [Index] getType?>
getType()
public int getType ( ) 
	
Returns the type for this exception or UNSPECIFIED if the type was
unspecified or unknown. 
	Returns	The type of this exception.
	Since	1.5
<?FM MARKER [Cross-Ref] BundleException.initCause(Throwable)?>
<?FM MARKER [Index] BundleException:initCause?>
<?FM MARKER [Index] initCause?>
initCause(Throwable)
public Throwable initCause ( Throwable cause ) 
	cause	The cause of this exception.
	
Initializes the cause of this exception to the specified value. 
	Returns	This exception.
	Throws	IllegalArgumentException –  If the specified cause is this
exception. 
		IllegalStateException –  If the cause of this exception has already
been set. 
	Since	1.3
<?FM MARKER [Cross-Ref] BundleListener?>
<?FM MARKER [Index] BundleListener?>
<?FM MARKER [Index] interface:BundleListener?>
BundleListener
public interface BundleListener
	extends EventListener
A BundleEvent listener. BundleListener is a listener interface that
may be implemented by a bundle developer. When a BundleEvent is
fired, it is asynchronously delivered to a BundleListener. The Framework
delivers BundleEvent objects to a BundleListener in order and must
not concurrently call a BundleListener. 
A BundleListener object is registered with the Framework using the
BundleContext.addBundleListener(BundleListener) method. BundleListeners
are called with a BundleEvent object when a bundle has been installed,
resolved, started, stopped, updated, unresolved, or uninstalled.
	See Also	BundleEvent
	Concurrency	Not Thread-safe 
<?FM MARKER [Cross-Ref] BundleListener.bundleChanged(BundleEvent)?>
<?FM MARKER [Index] BundleListener:bundleChanged?>
<?FM MARKER [Index] bundleChanged?>
bundleChanged(BundleEvent)
public void bundleChanged ( BundleEvent event ) 
	event	The BundleEvent.
	
Receives notification that a bundle has had a lifecycle change. 
<?FM MARKER [Cross-Ref] BundlePermission?>
<?FM MARKER [Index] BundlePermission?>
<?FM MARKER [Index] class:BundlePermission?>
BundlePermission
public final class BundlePermission
	extends BasicPermission
A bundle’s authority to require or provide a bundle or to receive
or attach fragments. 
A bundle symbolic name defines a unique fully qualified name. Wildcards
may be used. 
 name ::= &lt;symbolic name&gt; | &lt;symbolic name ending in “.*”&gt; | *
Examples: 
 org.osgi.example.bundle
 org.osgi.example.*
 *
BundlePermission has four actions: provide, require, host, and fragment.
The provide action implies the require action.
	Since	1.3
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] BundlePermission.FRAGMENT?>
<?FM MARKER [Index] BundlePermission:FRAGMENT?>
<?FM MARKER [Index] FRAGMENT?>
FRAGMENT
public static final String FRAGMENT = “fragment”<?FM MARKER [Index] fragment?>

The action string fragment. 
<?FM MARKER [Cross-Ref] BundlePermission.HOST?>
<?FM MARKER [Index] BundlePermission:HOST?>
<?FM MARKER [Index] HOST?>
HOST
public static final String HOST = “host”<?FM MARKER [Index] host?>

The action string host. 
<?FM MARKER [Cross-Ref] BundlePermission.PROVIDE?>
<?FM MARKER [Index] BundlePermission:PROVIDE?>
<?FM MARKER [Index] PROVIDE?>
PROVIDE
public static final String PROVIDE = “provide”<?FM MARKER [Index] provide?>

The action string provide. The provide action implies the require
action. 
<?FM MARKER [Cross-Ref] BundlePermission.REQUIRE?>
<?FM MARKER [Index] BundlePermission:REQUIRE?>
<?FM MARKER [Index] REQUIRE?>
REQUIRE
public static final String REQUIRE = “require”<?FM MARKER [Index] require?>

The action string require. The require action is implied by the
provide action. 
<?FM MARKER [Cross-Ref] BundlePermission.BundlePermission(String,String)?>
<?FM MARKER [Index] BundlePermission:BundlePermission?>
<?FM MARKER [Index] BundlePermission?>
BundlePermission(String,String)
public BundlePermission ( String symbolicName , String actions ) 
	symbolicName	The bundle symbolic name.
	actions	provide,require, host, fragment (canonical order).
	
Defines the authority to provide and/or require and or specify a
host fragment symbolic name within the OSGi environment. 
Bundle Permissions are granted over all possible versions of a bundle.
 A bundle that needs to provide a bundle must have the appropriate
BundlePermission for the symbolic name; a bundle that requires a
bundle must have the appropriate BundlePermssion for that symbolic
name; a bundle that specifies a fragment host must have the appropriate
BundlePermission for that symbolic name.
<?FM MARKER [Cross-Ref] BundlePermission.equals(Object)?>
<?FM MARKER [Index] BundlePermission:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to test for equality with this BundlePermission
object.
	
Determines the equality of two BundlePermission objects.  This method
checks that specified bundle has the same bundle symbolic name and
BundlePermission actions as this BundlePermission object. 
	Returns	true if obj is a BundlePermission, and has the same bundle
symbolic name and actions as this BundlePermission object; false
otherwise.
<?FM MARKER [Cross-Ref] BundlePermission.getActions()?>
<?FM MARKER [Index] BundlePermission:getActions?>
<?FM MARKER [Index] getActions?>
getActions()
public String getActions ( ) 
	
Returns the canonical string representation of the BundlePermission
actions.  
Always returns present BundlePermission actions in the following
order: provide, require, host, fragment.
	Returns	Canonical string representation of the BundlePermission
actions.
<?FM MARKER [Cross-Ref] BundlePermission.hashCode()?>
<?FM MARKER [Index] BundlePermission:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hash code value for this object. 
	Returns	A hash code value for this object.
<?FM MARKER [Cross-Ref] BundlePermission.implies(Permission)?>
<?FM MARKER [Index] BundlePermission:implies?>
<?FM MARKER [Index] implies?>
implies(Permission)
public boolean implies ( Permission p ) 
	p	The requested permission.
	
Determines if the specified permission is implied by this object.
 
This method checks that the symbolic name of the target is implied
by the symbolic name of this object. The list of BundlePermission
actions must either match or allow for the list of the target object to
imply the target BundlePermission action. 
The permission to provide a bundle implies the permission to require
the named symbolic name. 
       x.y.*,”provide” -&gt; x.y.z,”provide” is true
       *,”require” -&gt; x.y, “require”      is true
       *,”provide” -&gt; x.y, “require”      is true
       x.y,”provide” -&gt; x.y.z, “provide”  is false
	Returns	true if the specified BundlePermission action is implied
by this object; false otherwise.
<?FM MARKER [Cross-Ref] BundlePermission.newPermissionCollection()?>
<?FM MARKER [Index] BundlePermission:newPermissionCollection?>
<?FM MARKER [Index] newPermissionCollection?>
newPermissionCollection()
public PermissionCollection newPermissionCollection ( ) 
	
Returns a new PermissionCollection object suitable for storing BundlePermission
objects. 
	Returns	A new PermissionCollection object.
<?FM MARKER [Cross-Ref] BundleReference?>
<?FM MARKER [Index] BundleReference?>
<?FM MARKER [Index] interface:BundleReference?>
BundleReference
public interface BundleReference
A reference to a Bundle. 
	Since	1.5
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleReference.getBundle()?>
<?FM MARKER [Index] BundleReference:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle()
public Bundle getBundle ( ) 
	
Returns the Bundle object associated with this BundleReference. 
	Returns	The Bundle object associated with this BundleReference.
<?FM MARKER [Cross-Ref] CapabilityPermission?>
<?FM MARKER [Index] CapabilityPermission?>
<?FM MARKER [Index] class:CapabilityPermission?>
CapabilityPermission
public final class CapabilityPermission
	extends BasicPermission
A bundle’s authority to provide or require a capability. 
The provide action allows a bundle to provide a capability matching
the specified filter.
The require action allows a bundle to require a capability matching
the specified filter.
	Since	1.6
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] CapabilityPermission.PROVIDE?>
<?FM MARKER [Index] CapabilityPermission:PROVIDE?>
<?FM MARKER [Index] PROVIDE?>
PROVIDE
public static final String PROVIDE = “provide”<?FM MARKER [Index] provide?>

The action string provide. 
<?FM MARKER [Cross-Ref] CapabilityPermission.REQUIRE?>
<?FM MARKER [Index] CapabilityPermission:REQUIRE?>
<?FM MARKER [Index] REQUIRE?>
REQUIRE
public static final String REQUIRE = “require”<?FM MARKER [Index] require?>

The action string require. 
<?FM MARKER [Cross-Ref] CapabilityPermission.CapabilityPermission(String,String)?>
<?FM MARKER [Index] CapabilityPermission:CapabilityPermission?>
<?FM MARKER [Index] CapabilityPermission?>
CapabilityPermission(String,String)
public CapabilityPermission ( String name , String actions ) 
	name	The capability namespace or a filter over the attributes.
	actions	require,provide (canonical order)
	
Create a new CapabilityPermission.  
The name is specified as a dot-separated string. Wildcards may be
used.  
 name ::= &lt;namespace&gt; | &lt;namespace ending in “.*”&gt; | *
Examples: 
 com.acme.capability.*
 org.foo.capability
 *
For the require action, the name can also be a filter expression.
The filter gives access to the capability attributes as well as
the following attributes: 
signer - A Distinguished Name chain used to sign the bundle providing
the capability. Wildcards in a DN are not matched according to the
filter string rules, but according to the rules defined for a DN chain.
location - The location of the bundle providing the capability.
id - The bundle ID of the bundle providing the capability.
name - The symbolic name of the bundle providing the capability.
capability.namespace - The namespace of the required capability.
Since the above attribute names may conflict with attribute names
of a capability, you can prefix an attribute name with ‘@’ in the
filter expression to match against the capability attributes and
not one of the above attributes. Filter attribute names are processed
in a case sensitive manner.  
There are two possible actions: require and provide. The require
permission allows the owner of this permission to require a capability
matching the attributes. The provide permission allows the bundle to
provide a capability in the specified capability namespace.
	Throws	IllegalArgumentException –  If the specified name is a filter
expression and either the specified action is not require or the
filter has an invalid syntax. 
<?FM MARKER [Cross-Ref] CapabilityPermission.CapabilityPermission(String,Map,Bundle,String)?>
<?FM MARKER [Index] CapabilityPermission:CapabilityPermission?>
<?FM MARKER [Index] CapabilityPermission?>
CapabilityPermission(String,Map,Bundle,String)
public CapabilityPermission ( String namespace , Map&lt;String,?&gt;
attributes , Bundle providingBundle , String actions ) 
	namespace	The requested capability namespace.
	attributes	The requested capability attributes.
	providingBundle	The bundle providing the requested capability.
	actions	The action require.
	
Creates a new requested CapabilityPermission object to be used by
code that must perform checkPermission for the require action. CapabilityPermission
objects created with this constructor cannot be added to a CapabilityPermission
permission collection. 
	Throws	IllegalArgumentException –  If the specified action is not
require or attributes or providingBundle are null . 
<?FM MARKER [Cross-Ref] CapabilityPermission.equals(Object)?>
<?FM MARKER [Index] CapabilityPermission:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to test for equality.
	
Determines the equality of two CapabilityPermission objects.  Checks
that specified object has the same name and action as this CapabilityPermission. 
	Returns	true if obj is a CapabilityPermission, and has the same
name and actions as this CapabilityPermission object; false otherwise.
<?FM MARKER [Cross-Ref] CapabilityPermission.getActions()?>
<?FM MARKER [Index] CapabilityPermission:getActions?>
<?FM MARKER [Index] getActions?>
getActions()
public String getActions ( ) 
	
Returns the canonical string representation of the actions. Always
returns present actions in the following order: require, provide. 
	Returns	The canonical string representation of the actions.
<?FM MARKER [Cross-Ref] CapabilityPermission.hashCode()?>
<?FM MARKER [Index] CapabilityPermission:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hash code value for this object. 
	Returns	Hash code value for this object.
<?FM MARKER [Cross-Ref] CapabilityPermission.implies(Permission)?>
<?FM MARKER [Index] CapabilityPermission:implies?>
<?FM MARKER [Index] implies?>
implies(Permission)
public boolean implies ( Permission p ) 
	p	The target permission to check.
	
Determines if a CapabilityPermission object “implies” the specified
permission. 
	Returns	true if the specified permission is implied by this object;
false otherwise.
<?FM MARKER [Cross-Ref] CapabilityPermission.newPermissionCollection()?>
<?FM MARKER [Index] CapabilityPermission:newPermissionCollection?>
<?FM MARKER [Index] newPermissionCollection?>
newPermissionCollection()
public PermissionCollection newPermissionCollection ( ) 
	
Returns a new PermissionCollection object for storing CapabilityPermission
objects. 
	Returns	A new PermissionCollection object suitable for storing
CapabilityPermission objects.
<?FM MARKER [Cross-Ref] Configurable?>
<?FM MARKER [Index] Configurable?>
<?FM MARKER [Index] interface:Configurable?>
Configurable
public interface Configurable
Supports a configuration object.  
Configurable is an interface that should be used by a bundle developer
in support of a configurable service. Bundles that need to configure
a service may test to determine if the service object is an instanceof
Configurable.
	Deprecated	As of 1.2. Please use Configuration Admin service.
<?FM MARKER [Cross-Ref] Configurable.getConfigurationObject()?>
<?FM MARKER [Index] Configurable:getConfigurationObject?>
<?FM MARKER [Index] getConfigurationObject?>
getConfigurationObject()
public Object getConfigurationObject ( ) 
	
Returns this service’s configuration object.  
Services implementing Configurable should take care when returning
a service configuration object since this object is probably sensitive. 
If the Java Runtime Environment supports permissions, it is recommended
that the caller is checked for some appropriate permission before
returning the configuration object.
	Returns	The configuration object for this service.
	Throws	SecurityException –  If the caller does not have an appropriate
permission and the Java Runtime Environment supports permissions. 
	Deprecated	As of 1.2. Please use Configuration Admin service.
<?FM MARKER [Cross-Ref] Constants?>
<?FM MARKER [Index] Constants?>
<?FM MARKER [Index] interface:Constants?>
Constants
public interface Constants
Defines standard names for the OSGi environment system properties,
service properties, and Manifest header attribute keys. 
The values associated with these keys are of type String, unless
otherwise indicated.
	Since	1.1
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] Constants.ACTIVATION_LAZY?>
<?FM MARKER [Index] Constants:ACTIVATION_LAZY?>
<?FM MARKER [Index] ACTIVATION_LAZY?>
ACTIVATION_LAZY
public static final String ACTIVATION_LAZY = “lazy”<?FM MARKER [Index] lazy?>

Bundle activation policy declaring the bundle must be activated
when the first class load is made from the bundle. 
A bundle with the lazy activation policy that is started with the
START_ACTIVATION_POLICY option will wait in the STARTING state until
the first class load from the bundle occurs. The bundle will then
be activated before the class is returned to the requester. 
The activation policy value is specified as in the Bundle-ActivationPolicy
manifest header like: 
       Bundle-ActivationPolicy: lazy
	See Also	BUNDLE_ACTIVATIONPOLICY , Bundle.start(int) , Bundle.START_ACTIVATION_POLICY
	Since	1.4
<?FM MARKER [Cross-Ref] Constants.BUNDLE_ACTIVATIONPOLICY?>
<?FM MARKER [Index] Constants:BUNDLE_ACTIVATIONPOLICY?>
<?FM MARKER [Index] BUNDLE_ACTIVATIONPOLICY?>
BUNDLE_ACTIVATIONPOLICY
public static final String BUNDLE_ACTIVATIONPOLICY = “Bundle-ActivationPolicy”<?FM MARKER [Index] Bundle-ActivationPolicy?>

Manifest header identifying the bundle’s activation policy. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	See Also	ACTIVATION_LAZY , INCLUDE_DIRECTIVE , EXCLUDE_DIRECTIVE
	Since	1.4
<?FM MARKER [Cross-Ref] Constants.BUNDLE_ACTIVATOR?>
<?FM MARKER [Index] Constants:BUNDLE_ACTIVATOR?>
<?FM MARKER [Index] BUNDLE_ACTIVATOR?>
BUNDLE_ACTIVATOR
public static final String BUNDLE_ACTIVATOR = “Bundle-Activator”<?FM MARKER [Index] Bundle-Activator?>

Manifest header attribute identifying the bundle’s activator class.
 
If present, this header specifies the name of the bundle resource
class that implements the BundleActivator interface and whose start
and stop methods are called by the Framework when the bundle is started
and stopped, respectively. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_CATEGORY?>
<?FM MARKER [Index] Constants:BUNDLE_CATEGORY?>
<?FM MARKER [Index] BUNDLE_CATEGORY?>
BUNDLE_CATEGORY
public static final String BUNDLE_CATEGORY = “Bundle-Category”<?FM MARKER [Index] Bundle-Category?>

Manifest header identifying the bundle’s category. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_CLASSPATH?>
<?FM MARKER [Index] Constants:BUNDLE_CLASSPATH?>
<?FM MARKER [Index] BUNDLE_CLASSPATH?>
BUNDLE_CLASSPATH
public static final String BUNDLE_CLASSPATH = “Bundle-ClassPath”<?FM MARKER [Index] Bundle-ClassPath?>

Manifest header identifying a list of directories and embedded JAR
files, which are bundle resources used to extend the bundle’s classpath. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_CONTACTADDRESS?>
<?FM MARKER [Index] Constants:BUNDLE_CONTACTADDRESS?>
<?FM MARKER [Index] BUNDLE_CONTACTADDRESS?>
BUNDLE_CONTACTADDRESS
public static final String BUNDLE_CONTACTADDRESS = “Bundle-ContactAddress”<?FM MARKER [Index] Bundle-ContactAddress?>

Manifest header identifying the contact address where problems with
the bundle may be reported; for example, an email address. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_COPYRIGHT?>
<?FM MARKER [Index] Constants:BUNDLE_COPYRIGHT?>
<?FM MARKER [Index] BUNDLE_COPYRIGHT?>
BUNDLE_COPYRIGHT
public static final String BUNDLE_COPYRIGHT = “Bundle-Copyright”<?FM MARKER [Index] Bundle-Copyright?>

Manifest header identifying the bundle’s copyright information. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_DESCRIPTION?>
<?FM MARKER [Index] Constants:BUNDLE_DESCRIPTION?>
<?FM MARKER [Index] BUNDLE_DESCRIPTION?>
BUNDLE_DESCRIPTION
public static final String BUNDLE_DESCRIPTION = “Bundle-Description”<?FM MARKER [Index] Bundle-Description?>

Manifest header containing a brief description of the bundle’s functionality. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_DOCURL?>
<?FM MARKER [Index] Constants:BUNDLE_DOCURL?>
<?FM MARKER [Index] BUNDLE_DOCURL?>
BUNDLE_DOCURL
public static final String BUNDLE_DOCURL = “Bundle-DocURL”<?FM MARKER [Index] Bundle-DocURL?>

Manifest header identifying the bundle’s documentation URL, from
which further information about the bundle may be obtained. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_LOCALIZATION?>
<?FM MARKER [Index] Constants:BUNDLE_LOCALIZATION?>
<?FM MARKER [Index] BUNDLE_LOCALIZATION?>
BUNDLE_LOCALIZATION
public static final String BUNDLE_LOCALIZATION = “Bundle-Localization”<?FM MARKER [Index] Bundle-Localization?>

Manifest header identifying the base name of the bundle’s localization
entries. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	See Also	BUNDLE_LOCALIZATION_DEFAULT_BASENAME
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.BUNDLE_LOCALIZATION_DEFAULT_BASENAME?>
<?FM MARKER [Index] Constants:BUNDLE_LOCALIZATION_DEFAULT_BASENAME?>
<?FM MARKER [Index] BUNDLE_LOCALIZATION_DEFAULT_BASENAME?>
BUNDLE_LOCALIZATION_DEFAULT_BASENAME
public static final String BUNDLE_LOCALIZATION_DEFAULT_BASENAME
= “OSGI-INF/l10n/bundle”<?FM MARKER [Index] OSGI-INF/l10n/bundle?>

Default value for the Bundle-Localization manifest header. 
	See Also	BUNDLE_LOCALIZATION
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.BUNDLE_MANIFESTVERSION?>
<?FM MARKER [Index] Constants:BUNDLE_MANIFESTVERSION?>
<?FM MARKER [Index] BUNDLE_MANIFESTVERSION?>
BUNDLE_MANIFESTVERSION
public static final String BUNDLE_MANIFESTVERSION = “Bundle-ManifestVersion”<?FM MARKER [Index] Bundle-ManifestVersion?>

Manifest header identifying the bundle manifest version. A bundle
manifest may express the version of the syntax in which it is written
by specifying a bundle manifest version. Bundles exploiting OSGi Release
4, or later, syntax must specify a bundle manifest version. 
The bundle manifest version defined by OSGi Release 4 or, more specifically,
by version 1.3 of the OSGi Core Specification is “2”. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.BUNDLE_NAME?>
<?FM MARKER [Index] Constants:BUNDLE_NAME?>
<?FM MARKER [Index] BUNDLE_NAME?>
BUNDLE_NAME
public static final String BUNDLE_NAME = “Bundle-Name”<?FM MARKER [Index] Bundle-Name?>

Manifest header identifying the bundle’s name. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_NATIVECODE?>
<?FM MARKER [Index] Constants:BUNDLE_NATIVECODE?>
<?FM MARKER [Index] BUNDLE_NATIVECODE?>
BUNDLE_NATIVECODE
public static final String BUNDLE_NATIVECODE = “Bundle-NativeCode”<?FM MARKER [Index] Bundle-NativeCode?>

Manifest header identifying a number of hardware environments and
the native language code libraries that the bundle is carrying for
each of these environments.  
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_NATIVECODE_LANGUAGE?>
<?FM MARKER [Index] Constants:BUNDLE_NATIVECODE_LANGUAGE?>
<?FM MARKER [Index] BUNDLE_NATIVECODE_LANGUAGE?>
BUNDLE_NATIVECODE_LANGUAGE
public static final String BUNDLE_NATIVECODE_LANGUAGE = “language”<?FM MARKER [Index] language?>

Manifest header attribute identifying the language in which the
native bundle code is written specified in the Bundle-NativeCode
manifest header. See ISO 639 for possible values. 
The attribute value is encoded in the Bundle-NativeCode manifest
header like: 
     Bundle-NativeCode: http.so ; language=nl_be ...
	See Also	BUNDLE_NATIVECODE
<?FM MARKER [Cross-Ref] Constants.BUNDLE_NATIVECODE_OSNAME?>
<?FM MARKER [Index] Constants:BUNDLE_NATIVECODE_OSNAME?>
<?FM MARKER [Index] BUNDLE_NATIVECODE_OSNAME?>
BUNDLE_NATIVECODE_OSNAME
public static final String BUNDLE_NATIVECODE_OSNAME = “osname”<?FM MARKER [Index] osname?>

Manifest header attribute identifying the operating system required
to run native bundle code specified in the Bundle-NativeCode manifest
header). 
The attribute value is encoded in the Bundle-NativeCode manifest
header like: 
     Bundle-NativeCode: http.so ; osname=Linux ...
	See Also	BUNDLE_NATIVECODE
<?FM MARKER [Cross-Ref] Constants.BUNDLE_NATIVECODE_OSVERSION?>
<?FM MARKER [Index] Constants:BUNDLE_NATIVECODE_OSVERSION?>
<?FM MARKER [Index] BUNDLE_NATIVECODE_OSVERSION?>
BUNDLE_NATIVECODE_OSVERSION
public static final String BUNDLE_NATIVECODE_OSVERSION = “osversion”<?FM MARKER [Index] osversion?>

Manifest header attribute identifying the operating system version
required to run native bundle code specified in the Bundle-NativeCode
manifest header). 
The attribute value is encoded in the Bundle-NativeCode manifest
header like: 
     Bundle-NativeCode: http.so ; osversion=”2.34” ...
	See Also	BUNDLE_NATIVECODE
<?FM MARKER [Cross-Ref] Constants.BUNDLE_NATIVECODE_PROCESSOR?>
<?FM MARKER [Index] Constants:BUNDLE_NATIVECODE_PROCESSOR?>
<?FM MARKER [Index] BUNDLE_NATIVECODE_PROCESSOR?>
BUNDLE_NATIVECODE_PROCESSOR
public static final String BUNDLE_NATIVECODE_PROCESSOR = “processor”<?FM MARKER [Index] processor?>

Manifest header attribute identifying the processor required to
run native bundle code specified in the Bundle-NativeCode manifest
header). 
The attribute value is encoded in the Bundle-NativeCode manifest
header like: 
     Bundle-NativeCode: http.so ; processor=x86 ...
	See Also	BUNDLE_NATIVECODE
<?FM MARKER [Cross-Ref] Constants.BUNDLE_REQUIREDEXECUTIONENVIRONMENT?>
<?FM MARKER [Index] Constants:BUNDLE_REQUIREDEXECUTIONENVIRONMENT?>
<?FM MARKER [Index] BUNDLE_REQUIREDEXECUTIONENVIRONMENT?>
BUNDLE_REQUIREDEXECUTIONENVIRONMENT
public static final String BUNDLE_REQUIREDEXECUTIONENVIRONMENT =
“Bundle-RequiredExecutionEnvironment”<?FM MARKER [Index] Bundle-RequiredExecutionEnvironment?>

Manifest header identifying the required execution environment for
the bundle. The service platform may run this bundle if any of the
execution environments named in this header matches one of the execution
environments it implements. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Since	1.2
	Deprecated	As of 1.6. Replaced by the osgi.ee capability.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_SYMBOLICNAME?>
<?FM MARKER [Index] Constants:BUNDLE_SYMBOLICNAME?>
<?FM MARKER [Index] BUNDLE_SYMBOLICNAME?>
BUNDLE_SYMBOLICNAME
public static final String BUNDLE_SYMBOLICNAME = “Bundle-SymbolicName”<?FM MARKER [Index] Bundle-SymbolicName?>

Manifest header identifying the bundle’s symbolic name.  
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE?>
<?FM MARKER [Index] Constants:BUNDLE_SYMBOLICNAME_ATTRIBUTE?>
<?FM MARKER [Index] BUNDLE_SYMBOLICNAME_ATTRIBUTE?>
BUNDLE_SYMBOLICNAME_ATTRIBUTE
public static final String BUNDLE_SYMBOLICNAME_ATTRIBUTE = “bundle-symbolic-name”<?FM MARKER [Index] bundle-symbolic-name?>

Manifest header attribute identifying the symbolic name of a bundle
that exports a package specified in the Import-Package manifest
header. 
The attribute value is encoded in the Import-Package manifest header
like: 
     Import-Package: org.osgi.framework; bundle-symbolic-name=”com.acme.module.test”
	See Also	IMPORT_PACKAGE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.BUNDLE_UPDATELOCATION?>
<?FM MARKER [Index] Constants:BUNDLE_UPDATELOCATION?>
<?FM MARKER [Index] BUNDLE_UPDATELOCATION?>
BUNDLE_UPDATELOCATION
public static final String BUNDLE_UPDATELOCATION = “Bundle-UpdateLocation”<?FM MARKER [Index] Bundle-UpdateLocation?>

Manifest header identifying the location from which a new bundle
version is obtained during a bundle update operation. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_VENDOR?>
<?FM MARKER [Index] Constants:BUNDLE_VENDOR?>
<?FM MARKER [Index] BUNDLE_VENDOR?>
BUNDLE_VENDOR
public static final String BUNDLE_VENDOR = “Bundle-Vendor”<?FM MARKER [Index] Bundle-Vendor?>

Manifest header identifying the bundle’s vendor.  
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_VERSION?>
<?FM MARKER [Index] Constants:BUNDLE_VERSION?>
<?FM MARKER [Index] BUNDLE_VERSION?>
BUNDLE_VERSION
public static final String BUNDLE_VERSION = “Bundle-Version”<?FM MARKER [Index] Bundle-Version?>

Manifest header identifying the bundle’s version.  
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.BUNDLE_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] Constants:BUNDLE_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] BUNDLE_VERSION_ATTRIBUTE?>
BUNDLE_VERSION_ATTRIBUTE
public static final String BUNDLE_VERSION_ATTRIBUTE = “bundle-version”<?FM MARKER [Index] bundle-version?>

Manifest header attribute identifying a range of versions for a
bundle specified in the Require-Bundle or Fragment-Host manifest
headers. The default value is 0.0.0.  
The attribute value is encoded in the Require-Bundle manifest header
like: 
     Require-Bundle: com.acme.module.test; bundle-version=”1.1”
     Require-Bundle: com.acme.module.test; bundle-version=”[1.0,2.0)”
The bundle-version attribute value uses a mathematical interval
notation to specify a range of bundle versions. A bundle-version
attribute value specified as a single version means a version range
that includes any bundle version greater than or equal to the specified
version.
	See Also	REQUIRE_BUNDLE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.DYNAMICIMPORT_PACKAGE?>
<?FM MARKER [Index] Constants:DYNAMICIMPORT_PACKAGE?>
<?FM MARKER [Index] DYNAMICIMPORT_PACKAGE?>
DYNAMICIMPORT_PACKAGE
public static final String DYNAMICIMPORT_PACKAGE = “DynamicImport-Package”<?FM MARKER [Index] DynamicImport-Package?>

Manifest header identifying the packages that the bundle may dynamically
import during execution. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Since	1.2
<?FM MARKER [Cross-Ref] Constants.EFFECTIVE_ACTIVE?>
<?FM MARKER [Index] Constants:EFFECTIVE_ACTIVE?>
<?FM MARKER [Index] EFFECTIVE_ACTIVE?>
EFFECTIVE_ACTIVE
public static final String EFFECTIVE_ACTIVE = “active”<?FM MARKER [Index] active?>

Manifest header directive value identifying a capability that is
effective at active time. Capabilities with an effective time of
active are ignored by the resolver.  
The directive value is encoded in the Provide-Capability manifest
header like: 
     Provide-Capability: com.acme.capability; effective:=”active”
	See Also	EFFECTIVE_DIRECTIVE
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.EFFECTIVE_DIRECTIVE?>
<?FM MARKER [Index] Constants:EFFECTIVE_DIRECTIVE?>
<?FM MARKER [Index] EFFECTIVE_DIRECTIVE?>
EFFECTIVE_DIRECTIVE
public static final String EFFECTIVE_DIRECTIVE = “effective”<?FM MARKER [Index] effective?>

Manifest header directive identifying the effective time of the
provided capability. The default value is resolve.  
The directive value is encoded in the Provide-Capability manifest
header like: 
     Provide-Capability: com.acme.capability; effective:=”resolve”
	See Also	PROVIDE_CAPABILITY , EFFECTIVE_RESOLVE , EFFECTIVE_ACTIVE
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.EFFECTIVE_RESOLVE?>
<?FM MARKER [Index] Constants:EFFECTIVE_RESOLVE?>
<?FM MARKER [Index] EFFECTIVE_RESOLVE?>
EFFECTIVE_RESOLVE
public static final String EFFECTIVE_RESOLVE = “resolve”<?FM MARKER [Index] resolve?>

Manifest header directive value identifying a capability that is
effective at resolve time. Capabilities with an effective time of
resolve are the only capabilities which are processed by the resolver.
 
The directive value is encoded in the Provide-Capability manifest
header like: 
     Provide-Capability: com.acme.capability; effective:=”resolve”
	See Also	EFFECTIVE_DIRECTIVE
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.EXCLUDE_DIRECTIVE?>
<?FM MARKER [Index] Constants:EXCLUDE_DIRECTIVE?>
<?FM MARKER [Index] EXCLUDE_DIRECTIVE?>
EXCLUDE_DIRECTIVE
public static final String EXCLUDE_DIRECTIVE = “exclude”<?FM MARKER [Index] exclude?>

Manifest header directive identifying a list of classes to exclude
in the exported package.. 
This directive is used by the Export-Package manifest header to
identify a list of classes of the specified package which must not
be allowed to be exported. The directive value is encoded in the
Export-Package manifest header like: 
     Export-Package: org.osgi.framework; exclude:=”*Impl”
This directive is also used by the Bundle-ActivationPolicy manifest
header to identify the packages from which class loads will not
trigger lazy activation. The directive value is encoded in the Bundle-ActivationPolicy
manifest header like: 
     Bundle-ActivationPolicy: lazy; exclude:=”org.osgi.framework”
	See Also	EXPORT_PACKAGE , BUNDLE_ACTIVATIONPOLICY
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.EXPORT_PACKAGE?>
<?FM MARKER [Index] Constants:EXPORT_PACKAGE?>
<?FM MARKER [Index] EXPORT_PACKAGE?>
EXPORT_PACKAGE
public static final String EXPORT_PACKAGE = “Export-Package”<?FM MARKER [Index] Export-Package?>

Manifest header identifying the packages that the bundle offers
to the Framework for export. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.EXPORT_SERVICE?>
<?FM MARKER [Index] Constants:EXPORT_SERVICE?>
<?FM MARKER [Index] EXPORT_SERVICE?>
EXPORT_SERVICE
public static final String EXPORT_SERVICE = “Export-Service”<?FM MARKER [Index] Export-Service?>

Manifest header identifying the fully qualified class names of the
services that the bundle may register (used for informational purposes
only).  
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Deprecated	As of 1.2.
<?FM MARKER [Cross-Ref] Constants.EXTENSION_BOOTCLASSPATH?>
<?FM MARKER [Index] Constants:EXTENSION_BOOTCLASSPATH?>
<?FM MARKER [Index] EXTENSION_BOOTCLASSPATH?>
EXTENSION_BOOTCLASSPATH
public static final String EXTENSION_BOOTCLASSPATH = “bootclasspath”<?FM MARKER [Index] bootclasspath?>

Manifest header directive value identifying the type of extension
fragment. An extension fragment type of bootclasspath indicates
that the extension fragment is to be loaded by the boot class loader.
 
The directive value is encoded in the Fragment-Host manifest header
like:  
     Fragment-Host: system.bundle; extension:=”bootclasspath”
	See Also	EXTENSION_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.EXTENSION_DIRECTIVE?>
<?FM MARKER [Index] Constants:EXTENSION_DIRECTIVE?>
<?FM MARKER [Index] EXTENSION_DIRECTIVE?>
EXTENSION_DIRECTIVE
public static final String EXTENSION_DIRECTIVE = “extension”<?FM MARKER [Index] extension?>

Manifest header directive identifying the type of the extension
fragment.  
The directive value is encoded in the Fragment-Host manifest header
like:  
     Fragment-Host: system.bundle; extension:=”framework”
	See Also	FRAGMENT_HOST , EXTENSION_FRAMEWORK , EXTENSION_BOOTCLASSPATH
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.EXTENSION_FRAMEWORK?>
<?FM MARKER [Index] Constants:EXTENSION_FRAMEWORK?>
<?FM MARKER [Index] EXTENSION_FRAMEWORK?>
EXTENSION_FRAMEWORK
public static final String EXTENSION_FRAMEWORK = “framework”<?FM MARKER [Index] framework?>

Manifest header directive value identifying the type of extension
fragment. An extension fragment type of framework indicates that
the extension fragment is to be loaded by the framework’s class loader.
 
The directive value is encoded in the Fragment-Host manifest header
like:  
     Fragment-Host: system.bundle; extension:=”framework”
	See Also	EXTENSION_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.FILTER_DIRECTIVE?>
<?FM MARKER [Index] Constants:FILTER_DIRECTIVE?>
<?FM MARKER [Index] FILTER_DIRECTIVE?>
FILTER_DIRECTIVE
public static final String FILTER_DIRECTIVE = “filter”<?FM MARKER [Index] filter?>

Manifest header directive identifying the capability filter specified
in the Require-Capability manifest header. 
The directive value is encoded in the Require-Capability manifest
header like: 
     Require-Capability: com.acme.capability; filter:=”(someattr=somevalue)”
	See Also	REQUIRE_CAPABILITY
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.FRAGMENT_ATTACHMENT_ALWAYS?>
<?FM MARKER [Index] Constants:FRAGMENT_ATTACHMENT_ALWAYS?>
<?FM MARKER [Index] FRAGMENT_ATTACHMENT_ALWAYS?>
FRAGMENT_ATTACHMENT_ALWAYS
public static final String FRAGMENT_ATTACHMENT_ALWAYS = “always”<?FM MARKER [Index] always?>

Manifest header directive value identifying a fragment attachment
type of always. A fragment attachment type of always indicates that
fragments are allowed to attach to the host bundle at any time (while
the host is resolved or during the process of resolving the host
bundle). 
The directive value is encoded in the Bundle-SymbolicName manifest
header like: 
     Bundle-SymbolicName: com.acme.module.test; fragment-attachment:=”always”
	See Also	FRAGMENT_ATTACHMENT_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.FRAGMENT_ATTACHMENT_DIRECTIVE?>
<?FM MARKER [Index] Constants:FRAGMENT_ATTACHMENT_DIRECTIVE?>
<?FM MARKER [Index] FRAGMENT_ATTACHMENT_DIRECTIVE?>
FRAGMENT_ATTACHMENT_DIRECTIVE
public static final String FRAGMENT_ATTACHMENT_DIRECTIVE = “fragment-attachment”<?FM MARKER [Index] fragment-attachment?>

Manifest header directive identifying if and when a fragment may
attach to a host bundle. The default value is always.  
The directive value is encoded in the Bundle-SymbolicName manifest
header like: 
     Bundle-SymbolicName: com.acme.module.test; fragment-attachment:=”never”
	See Also	BUNDLE_SYMBOLICNAME , FRAGMENT_ATTACHMENT_ALWAYS , FRAGMENT_ATTACHMENT_RESOLVETIME
, FRAGMENT_ATTACHMENT_NEVER
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.FRAGMENT_ATTACHMENT_NEVER?>
<?FM MARKER [Index] Constants:FRAGMENT_ATTACHMENT_NEVER?>
<?FM MARKER [Index] FRAGMENT_ATTACHMENT_NEVER?>
FRAGMENT_ATTACHMENT_NEVER
public static final String FRAGMENT_ATTACHMENT_NEVER = “never”<?FM MARKER [Index] never?>

Manifest header directive value identifying a fragment attachment
type of never. A fragment attachment type of never indicates that
no fragments are allowed to attach to the host bundle at any time.
 
The directive value is encoded in the Bundle-SymbolicName manifest
header like: 
     Bundle-SymbolicName: com.acme.module.test; fragment-attachment:=”never”
	See Also	FRAGMENT_ATTACHMENT_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.FRAGMENT_ATTACHMENT_RESOLVETIME?>
<?FM MARKER [Index] Constants:FRAGMENT_ATTACHMENT_RESOLVETIME?>
<?FM MARKER [Index] FRAGMENT_ATTACHMENT_RESOLVETIME?>
FRAGMENT_ATTACHMENT_RESOLVETIME
public static final String FRAGMENT_ATTACHMENT_RESOLVETIME = “resolve-time”<?FM MARKER [Index] resolve-time?>

Manifest header directive value identifying a fragment attachment
type of resolve-time. A fragment attachment type of resolve-time
indicates that fragments are allowed to attach to the host bundle only
during the process of resolving the host bundle. 
The directive value is encoded in the Bundle-SymbolicName manifest
header like: 
     Bundle-SymbolicName: com.acme.module.test; fragment-attachment:=”resolve-time”
	See Also	FRAGMENT_ATTACHMENT_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.FRAGMENT_HOST?>
<?FM MARKER [Index] Constants:FRAGMENT_HOST?>
<?FM MARKER [Index] FRAGMENT_HOST?>
FRAGMENT_HOST
public static final String FRAGMENT_HOST = “Fragment-Host”<?FM MARKER [Index] Fragment-Host?>

Manifest header identifying the symbolic name of another bundle
for which that the bundle is a fragment. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BEGINNING_STARTLEVEL?>
<?FM MARKER [Index] Constants:FRAMEWORK_BEGINNING_STARTLEVEL?>
<?FM MARKER [Index] FRAMEWORK_BEGINNING_STARTLEVEL?>
FRAMEWORK_BEGINNING_STARTLEVEL
public static final String FRAMEWORK_BEGINNING_STARTLEVEL = “org.osgi.framework.startlevel.beginning”<?FM MARKER [Index] org.osgi.framework.startlevel.beginning?>

Framework launching property specifying the beginning start level
of the framework. 
	See Also	Core Specification, Starting the Framework.
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BOOTDELEGATION?>
<?FM MARKER [Index] Constants:FRAMEWORK_BOOTDELEGATION?>
<?FM MARKER [Index] FRAMEWORK_BOOTDELEGATION?>
FRAMEWORK_BOOTDELEGATION
public static final String FRAMEWORK_BOOTDELEGATION = “org.osgi.framework.bootdelegation”<?FM MARKER [Index] org.osgi.framework.bootdelegation?>

Framework launching property identifying packages for which the
Framework must delegate class loading to the parent class loader
of the bundle. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	See Also	FRAMEWORK_BUNDLE_PARENT
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BSNVERSION?>
<?FM MARKER [Index] Constants:FRAMEWORK_BSNVERSION?>
<?FM MARKER [Index] FRAMEWORK_BSNVERSION?>
FRAMEWORK_BSNVERSION
public static final String FRAMEWORK_BSNVERSION = “org.osgi.framework.bsnversion”<?FM MARKER [Index] org.osgi.framework.bsnversion?>

Framework launching property specifying whether multiple bundles
having the same symbolic name and version may be installed.  
Default value is managed in this release of the specification. This
default may change in a future specification release. Therefore,
code must not assume the default behavior is managed and should
interrogate the value of this property to determine the behavior. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	See Also	FRAMEWORK_BSNVERSION_MULTIPLE , FRAMEWORK_BSNVERSION_SINGLE
, FRAMEWORK_BSNVERSION_MANAGED
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BSNVERSION_MANAGED?>
<?FM MARKER [Index] Constants:FRAMEWORK_BSNVERSION_MANAGED?>
<?FM MARKER [Index] FRAMEWORK_BSNVERSION_MANAGED?>
FRAMEWORK_BSNVERSION_MANAGED
public static final String FRAMEWORK_BSNVERSION_MANAGED = “managed”<?FM MARKER [Index] managed?>

Specifies the framework must consult the bundle collision hook services
to determine if it will be an error to install a bundle or update
a bundle to have the same symbolic name and version as another installed
bundle. If no bundle collision hook services are registered, then
it will be an error to install a bundle or update a bundle to have
the same symbolic name and version as another installed bundle. 
	See Also	FRAMEWORK_BSNVERSION , BundleException.DUPLICATE_BUNDLE_ERROR
	Since	1.7
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BSNVERSION_MULTIPLE?>
<?FM MARKER [Index] Constants:FRAMEWORK_BSNVERSION_MULTIPLE?>
<?FM MARKER [Index] FRAMEWORK_BSNVERSION_MULTIPLE?>
FRAMEWORK_BSNVERSION_MULTIPLE
public static final String FRAMEWORK_BSNVERSION_MULTIPLE = “multiple”<?FM MARKER [Index] multiple?>

Specifies the framework will allow multiple bundles to be installed
having the same symbolic name and version. 
	See Also	FRAMEWORK_BSNVERSION
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BSNVERSION_SINGLE?>
<?FM MARKER [Index] Constants:FRAMEWORK_BSNVERSION_SINGLE?>
<?FM MARKER [Index] FRAMEWORK_BSNVERSION_SINGLE?>
FRAMEWORK_BSNVERSION_SINGLE
public static final String FRAMEWORK_BSNVERSION_SINGLE = “single”<?FM MARKER [Index] single?>

Specifies the framework will only allow a single bundle to be installed
for a given symbolic name and version. It will be an error to install
a bundle or update a bundle to have the same symbolic name and version
as another installed bundle. 
	See Also	FRAMEWORK_BSNVERSION , BundleException.DUPLICATE_BUNDLE_ERROR
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BUNDLE_PARENT?>
<?FM MARKER [Index] Constants:FRAMEWORK_BUNDLE_PARENT?>
<?FM MARKER [Index] FRAMEWORK_BUNDLE_PARENT?>
FRAMEWORK_BUNDLE_PARENT
public static final String FRAMEWORK_BUNDLE_PARENT = “org.osgi.framework.bundle.parent”<?FM MARKER [Index] org.osgi.framework.bundle.parent?>

Framework launching property specifying the parent class loader
type for all bundle class loaders. Default value is boot. 
	See Also	FRAMEWORK_BUNDLE_PARENT_BOOT , FRAMEWORK_BUNDLE_PARENT_EXT
, FRAMEWORK_BUNDLE_PARENT_APP , FRAMEWORK_BUNDLE_PARENT_FRAMEWORK
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BUNDLE_PARENT_APP?>
<?FM MARKER [Index] Constants:FRAMEWORK_BUNDLE_PARENT_APP?>
<?FM MARKER [Index] FRAMEWORK_BUNDLE_PARENT_APP?>
FRAMEWORK_BUNDLE_PARENT_APP
public static final String FRAMEWORK_BUNDLE_PARENT_APP = “app”<?FM MARKER [Index] app?>

Specifies to use the application class loader as the parent class
loader for all bundle class loaders. Depending on how the framework
is launched, this may refer to the same class loader as FRAMEWORK_BUNDLE_PARENT_FRAMEWORK. 
	See Also	FRAMEWORK_BUNDLE_PARENT
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BUNDLE_PARENT_BOOT?>
<?FM MARKER [Index] Constants:FRAMEWORK_BUNDLE_PARENT_BOOT?>
<?FM MARKER [Index] FRAMEWORK_BUNDLE_PARENT_BOOT?>
FRAMEWORK_BUNDLE_PARENT_BOOT
public static final String FRAMEWORK_BUNDLE_PARENT_BOOT = “boot”<?FM MARKER [Index] boot?>

Specifies to use of the boot class loader as the parent class loader
for all bundle class loaders. 
	See Also	FRAMEWORK_BUNDLE_PARENT
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BUNDLE_PARENT_EXT?>
<?FM MARKER [Index] Constants:FRAMEWORK_BUNDLE_PARENT_EXT?>
<?FM MARKER [Index] FRAMEWORK_BUNDLE_PARENT_EXT?>
FRAMEWORK_BUNDLE_PARENT_EXT
public static final String FRAMEWORK_BUNDLE_PARENT_EXT = “ext”<?FM MARKER [Index] ext?>

Specifies to use the extension class loader as the parent class
loader for all bundle class loaders. 
	See Also	FRAMEWORK_BUNDLE_PARENT
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_BUNDLE_PARENT_FRAMEWORK?>
<?FM MARKER [Index] Constants:FRAMEWORK_BUNDLE_PARENT_FRAMEWORK?>
<?FM MARKER [Index] FRAMEWORK_BUNDLE_PARENT_FRAMEWORK?>
FRAMEWORK_BUNDLE_PARENT_FRAMEWORK
public static final String FRAMEWORK_BUNDLE_PARENT_FRAMEWORK = “framework”<?FM MARKER [Index] framework?>

Specifies to use the framework class loader as the parent class
loader for all bundle class loaders. The framework class loader
is the class loader used to load the framework implementation. Depending
on how the framework is launched, this may refer to the same class
loader as FRAMEWORK_BUNDLE_PARENT_APP. 
	See Also	FRAMEWORK_BUNDLE_PARENT
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_COMMAND_ABSPATH?>
<?FM MARKER [Index] Constants:FRAMEWORK_COMMAND_ABSPATH?>
<?FM MARKER [Index] FRAMEWORK_COMMAND_ABSPATH?>
FRAMEWORK_COMMAND_ABSPATH
public static final String FRAMEWORK_COMMAND_ABSPATH = “abspath”<?FM MARKER [Index] abspath?>

Specified the substitution string for the absolute path of a file. 
	See Also	FRAMEWORK_EXECPERMISSION
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_EXECPERMISSION?>
<?FM MARKER [Index] Constants:FRAMEWORK_EXECPERMISSION?>
<?FM MARKER [Index] FRAMEWORK_EXECPERMISSION?>
FRAMEWORK_EXECPERMISSION
public static final String FRAMEWORK_EXECPERMISSION = “org.osgi.framework.command.execpermission”<?FM MARKER [Index] org.osgi.framework.command.execpermission?>

Framework launching property specifying an optional OS specific
command to set file permissions on extracted native code. On some
operating systems, it is required that native libraries be set to
executable. This optional property allows you to specify the command.
For example, on a UNIX style OS, this property could have the following
value.  
 chmod +rx ${abspath}
The ${abspath} is used by the framework to substitute the actual
absolute file path. 
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_EXECUTIONENVIRONMENT?>
<?FM MARKER [Index] Constants:FRAMEWORK_EXECUTIONENVIRONMENT?>
<?FM MARKER [Index] FRAMEWORK_EXECUTIONENVIRONMENT?>
FRAMEWORK_EXECUTIONENVIRONMENT
public static final String FRAMEWORK_EXECUTIONENVIRONMENT = “org.osgi.framework.executionenvironment”<?FM MARKER [Index] org.osgi.framework.executionenvironment?>

Framework launching property identifying execution environments
provided by the Framework. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	Since	1.2
	Deprecated	As of 1.6. Replaced by the osgi.ee capability.
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_LANGUAGE?>
<?FM MARKER [Index] Constants:FRAMEWORK_LANGUAGE?>
<?FM MARKER [Index] FRAMEWORK_LANGUAGE?>
FRAMEWORK_LANGUAGE
public static final String FRAMEWORK_LANGUAGE = “org.osgi.framework.language”<?FM MARKER [Index] org.osgi.framework.language?>

Framework launching property identifying the Framework implementation
language (see ISO 639 for possible values). 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_LIBRARY_EXTENSIONS?>
<?FM MARKER [Index] Constants:FRAMEWORK_LIBRARY_EXTENSIONS?>
<?FM MARKER [Index] FRAMEWORK_LIBRARY_EXTENSIONS?>
FRAMEWORK_LIBRARY_EXTENSIONS
public static final String FRAMEWORK_LIBRARY_EXTENSIONS = “org.osgi.framework.library.extensions”<?FM MARKER [Index] org.osgi.framework.library.extensions?>

Framework launching property specifying a comma separated list of
additional library file extensions that must be used when a bundle’s
class loader is searching for native libraries. If this property is
not set, then only the library name returned by System.mapLibraryName(String)
will be used to search. This is needed for certain operating systems
which allow more than one extension for a library. For example,
AIX allows library extensions of .a and .so, but System.mapLibraryName(String) will
only return names with the .a extension. 
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_OS_NAME?>
<?FM MARKER [Index] Constants:FRAMEWORK_OS_NAME?>
<?FM MARKER [Index] FRAMEWORK_OS_NAME?>
FRAMEWORK_OS_NAME
public static final String FRAMEWORK_OS_NAME = “org.osgi.framework.os.name”<?FM MARKER [Index] org.osgi.framework.os.name?>

Framework launching property identifying the Framework host-computer’s
operating system. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_OS_VERSION?>
<?FM MARKER [Index] Constants:FRAMEWORK_OS_VERSION?>
<?FM MARKER [Index] FRAMEWORK_OS_VERSION?>
FRAMEWORK_OS_VERSION
public static final String FRAMEWORK_OS_VERSION = “org.osgi.framework.os.version”<?FM MARKER [Index] org.osgi.framework.os.version?>

Framework launching property identifying the Framework host-computer’s
operating system version number. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_PROCESSOR?>
<?FM MARKER [Index] Constants:FRAMEWORK_PROCESSOR?>
<?FM MARKER [Index] FRAMEWORK_PROCESSOR?>
FRAMEWORK_PROCESSOR
public static final String FRAMEWORK_PROCESSOR = “org.osgi.framework.processor”<?FM MARKER [Index] org.osgi.framework.processor?>

Framework launching property identifying the Framework host-computer’s
processor name. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_SECURITY?>
<?FM MARKER [Index] Constants:FRAMEWORK_SECURITY?>
<?FM MARKER [Index] FRAMEWORK_SECURITY?>
FRAMEWORK_SECURITY
public static final String FRAMEWORK_SECURITY = “org.osgi.framework.security”<?FM MARKER [Index] org.osgi.framework.security?>

Framework launching property specifying the type of security manager
the framework must use. If not specified then the framework will
not set the VM security manager. 
	See Also	FRAMEWORK_SECURITY_OSGI
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_SECURITY_OSGI?>
<?FM MARKER [Index] Constants:FRAMEWORK_SECURITY_OSGI?>
<?FM MARKER [Index] FRAMEWORK_SECURITY_OSGI?>
FRAMEWORK_SECURITY_OSGI
public static final String FRAMEWORK_SECURITY_OSGI = “osgi”<?FM MARKER [Index] osgi?>

Specifies that a security manager that supports all security aspects
of the OSGi core specification including postponed conditions must
be installed.  
If this value is specified and there is a security manager already
installed, then a SecurityException must be thrown when the Framework
is initialized.
	See Also	FRAMEWORK_SECURITY
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_STORAGE?>
<?FM MARKER [Index] Constants:FRAMEWORK_STORAGE?>
<?FM MARKER [Index] FRAMEWORK_STORAGE?>
FRAMEWORK_STORAGE
public static final String FRAMEWORK_STORAGE = “org.osgi.framework.storage”<?FM MARKER [Index] org.osgi.framework.storage?>

Framework launching property specifying the persistent storage area
used by the framework. The value of this property must be a valid
file path in the file system to a directory. If the specified directory
does not exist then the framework will create the directory. If
the specified path exists but is not a directory or if the framework
fails to create the storage directory, then framework initialization must
fail. The framework is free to use this directory as it sees fit.
This area can not be shared with anything else. 
If this property is not set, the framework should use a reasonable
platform default for the persistent storage area.
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_STORAGE_CLEAN?>
<?FM MARKER [Index] Constants:FRAMEWORK_STORAGE_CLEAN?>
<?FM MARKER [Index] FRAMEWORK_STORAGE_CLEAN?>
FRAMEWORK_STORAGE_CLEAN
public static final String FRAMEWORK_STORAGE_CLEAN = “org.osgi.framework.storage.clean”<?FM MARKER [Index] org.osgi.framework.storage.clean?>

Framework launching property specifying if and when the persistent
storage area for the framework should be cleaned. If this property
is not set, then the framework storage area must not be cleaned. 
	See Also	FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT?>
<?FM MARKER [Index] Constants:FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT?>
<?FM MARKER [Index] FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT?>
FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT
public static final String FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT =
“onFirstInit”<?FM MARKER [Index] onFirstInit?>

Specifies that the framework storage area must be cleaned before
the framework is initialized for the first time. Subsequent inits,
starts or updates of the framework will not result in cleaning the
framework storage area. 
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_SYSTEMCAPABILITIES?>
<?FM MARKER [Index] Constants:FRAMEWORK_SYSTEMCAPABILITIES?>
<?FM MARKER [Index] FRAMEWORK_SYSTEMCAPABILITIES?>
FRAMEWORK_SYSTEMCAPABILITIES
public static final String FRAMEWORK_SYSTEMCAPABILITIES = “org.osgi.framework.system.capabilities”<?FM MARKER [Index] org.osgi.framework.system.capabilities?>

Framework launching property identifying capabilities which the
system bundle must provide. 
If this property is not specified then the framework must calculate
a reasonable default value for the current execution environment. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_SYSTEMCAPABILITIES_EXTRA?>
<?FM MARKER [Index] Constants:FRAMEWORK_SYSTEMCAPABILITIES_EXTRA?>
<?FM MARKER [Index] FRAMEWORK_SYSTEMCAPABILITIES_EXTRA?>
FRAMEWORK_SYSTEMCAPABILITIES_EXTRA
public static final String FRAMEWORK_SYSTEMCAPABILITIES_EXTRA =
“org.osgi.framework.system.capabilities.extra”<?FM MARKER [Index] org.osgi.framework.system.capabilities.extra?>

Framework launching property identifying extra capabilities which
the system bundle must additionally provide. 
This property is useful for configuring extra system capabilities
in addition to the system capabilities calculated by the framework. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	See Also	FRAMEWORK_SYSTEMCAPABILITIES
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_SYSTEMPACKAGES?>
<?FM MARKER [Index] Constants:FRAMEWORK_SYSTEMPACKAGES?>
<?FM MARKER [Index] FRAMEWORK_SYSTEMPACKAGES?>
FRAMEWORK_SYSTEMPACKAGES
public static final String FRAMEWORK_SYSTEMPACKAGES = “org.osgi.framework.system.packages”<?FM MARKER [Index] org.osgi.framework.system.packages?>

Framework launching property identifying packages which the system
bundle must export. 
If this property is not specified then the framework must calculate
a reasonable default value for the current execution environment. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA?>
<?FM MARKER [Index] Constants:FRAMEWORK_SYSTEMPACKAGES_EXTRA?>
<?FM MARKER [Index] FRAMEWORK_SYSTEMPACKAGES_EXTRA?>
FRAMEWORK_SYSTEMPACKAGES_EXTRA
public static final String FRAMEWORK_SYSTEMPACKAGES_EXTRA = “org.osgi.framework.system.packages.extra”<?FM MARKER [Index] org.osgi.framework.system.packages.extra?>

Framework launching property identifying extra packages which the
system bundle must export from the current execution environment. 
This property is useful for configuring extra system packages in
addition to the system packages calculated by the framework. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	See Also	FRAMEWORK_SYSTEMPACKAGES
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_TRUST_REPOSITORIES?>
<?FM MARKER [Index] Constants:FRAMEWORK_TRUST_REPOSITORIES?>
<?FM MARKER [Index] FRAMEWORK_TRUST_REPOSITORIES?>
FRAMEWORK_TRUST_REPOSITORIES
public static final String FRAMEWORK_TRUST_REPOSITORIES = “org.osgi.framework.trust.repositories”<?FM MARKER [Index] org.osgi.framework.trust.repositories?>

Framework launching property specifying the trust repositories used
by the framework. The value is a java.io.File.pathSeparator separated
list of valid file paths to files that contain key stores. Key stores of
type JKS must be supported and other key store types may be supported.
The framework will use the key stores as trust repositories to authenticate
certificates of trusted signers. The key stores are only used as
read-only trust repositories to access public keys. No passwords
are required to access the key stores’ public keys. 
Note that framework implementations are allowed to use other trust
repositories in addition to the trust repositories specified by
this property. How these other trust repositories are configured
and populated is implementation specific.
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_UUID?>
<?FM MARKER [Index] Constants:FRAMEWORK_UUID?>
<?FM MARKER [Index] FRAMEWORK_UUID?>
FRAMEWORK_UUID
public static final String FRAMEWORK_UUID = “org.osgi.framework.uuid”<?FM MARKER [Index] org.osgi.framework.uuid?>

Framework environment property identifying the Framework’s universally
unique identifier (UUID). A UUID represents a 128-bit value. A new
UUID is generated by the Framework.init() method each time a framework
is initialized. The value of this property must conform to the UUID string
representation specified in RFC 4122 ( http://www.ietf.org/rfc/rfc4122.txt
) .  
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_VENDOR?>
<?FM MARKER [Index] Constants:FRAMEWORK_VENDOR?>
<?FM MARKER [Index] FRAMEWORK_VENDOR?>
FRAMEWORK_VENDOR
public static final String FRAMEWORK_VENDOR = “org.osgi.framework.vendor”<?FM MARKER [Index] org.osgi.framework.vendor?>

Framework environment property identifying the Framework implementation
vendor. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_VERSION?>
<?FM MARKER [Index] Constants:FRAMEWORK_VERSION?>
<?FM MARKER [Index] FRAMEWORK_VERSION?>
FRAMEWORK_VERSION
public static final String FRAMEWORK_VERSION = “org.osgi.framework.version”<?FM MARKER [Index] org.osgi.framework.version?>

Framework environment property identifying the Framework version.
 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
<?FM MARKER [Cross-Ref] Constants.FRAMEWORK_WINDOWSYSTEM?>
<?FM MARKER [Index] Constants:FRAMEWORK_WINDOWSYSTEM?>
<?FM MARKER [Index] FRAMEWORK_WINDOWSYSTEM?>
FRAMEWORK_WINDOWSYSTEM
public static final String FRAMEWORK_WINDOWSYSTEM = “org.osgi.framework.windowsystem”<?FM MARKER [Index] org.osgi.framework.windowsystem?>

Framework launching property specifying the current windowing system.
The framework should provide a reasonable default if this is not
set. 
	Since	1.5
<?FM MARKER [Cross-Ref] Constants.IMPORT_PACKAGE?>
<?FM MARKER [Index] Constants:IMPORT_PACKAGE?>
<?FM MARKER [Index] IMPORT_PACKAGE?>
IMPORT_PACKAGE
public static final String IMPORT_PACKAGE = “Import-Package”<?FM MARKER [Index] Import-Package?>

Manifest header identifying the packages on which the bundle depends.
 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
<?FM MARKER [Cross-Ref] Constants.IMPORT_SERVICE?>
<?FM MARKER [Index] Constants:IMPORT_SERVICE?>
<?FM MARKER [Index] IMPORT_SERVICE?>
IMPORT_SERVICE
public static final String IMPORT_SERVICE = “Import-Service”<?FM MARKER [Index] Import-Service?>

Manifest header identifying the fully qualified class names of the
services that the bundle requires (used for informational purposes
only). 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Deprecated	As of 1.2.
<?FM MARKER [Cross-Ref] Constants.INCLUDE_DIRECTIVE?>
<?FM MARKER [Index] Constants:INCLUDE_DIRECTIVE?>
<?FM MARKER [Index] INCLUDE_DIRECTIVE?>
INCLUDE_DIRECTIVE
public static final String INCLUDE_DIRECTIVE = “include”<?FM MARKER [Index] include?>

Manifest header directive identifying a list of classes to include
in the exported package. 
This directive is used by the Export-Package manifest header to
identify a list of classes of the specified package which must be
allowed to be exported. The directive value is encoded in the Export-Package
manifest header like: 
     Export-Package: org.osgi.framework; include:=”MyClass*”
This directive is also used by the Bundle-ActivationPolicy manifest
header to identify the packages from which class loads will trigger
lazy activation. The directive value is encoded in the Bundle-ActivationPolicy
manifest header like: 
     Bundle-ActivationPolicy: lazy; include:=”org.osgi.framework”
	See Also	EXPORT_PACKAGE , BUNDLE_ACTIVATIONPOLICY
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.MANDATORY_DIRECTIVE?>
<?FM MARKER [Index] Constants:MANDATORY_DIRECTIVE?>
<?FM MARKER [Index] MANDATORY_DIRECTIVE?>
MANDATORY_DIRECTIVE
public static final String MANDATORY_DIRECTIVE = “mandatory”<?FM MARKER [Index] mandatory?>

Manifest header directive identifying names of matching attributes
which must be specified by matching Import-Package statements in
the Export-Package manifest header.  
The directive value is encoded in the Export-Package manifest header
like: 
     Export-Package: org.osgi.framework; mandatory:=”bundle-symbolic-name”
	See Also	EXPORT_PACKAGE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.OBJECTCLASS?>
<?FM MARKER [Index] Constants:OBJECTCLASS?>
<?FM MARKER [Index] OBJECTCLASS?>
OBJECTCLASS
public static final String OBJECTCLASS = “objectClass”<?FM MARKER [Index] objectClass?>

Service property identifying all of the class names under which
a service was registered in the Framework. The value of this property
must be of type String[].  
This property is set by the Framework when a service is registered.
<?FM MARKER [Cross-Ref] Constants.PACKAGE_SPECIFICATION_VERSION?>
<?FM MARKER [Index] Constants:PACKAGE_SPECIFICATION_VERSION?>
<?FM MARKER [Index] PACKAGE_SPECIFICATION_VERSION?>
PACKAGE_SPECIFICATION_VERSION
public static final String PACKAGE_SPECIFICATION_VERSION = “specification-version”<?FM MARKER [Index] specification-version?>

Manifest header attribute identifying the version of a package specified
in the Export-Package or Import-Package manifest header. 
	Deprecated	As of 1.3. This has been replaced by VERSION_ATTRIBUTE.
<?FM MARKER [Cross-Ref] Constants.PROVIDE_CAPABILITY?>
<?FM MARKER [Index] Constants:PROVIDE_CAPABILITY?>
<?FM MARKER [Index] PROVIDE_CAPABILITY?>
PROVIDE_CAPABILITY
public static final String PROVIDE_CAPABILITY = “Provide-Capability”<?FM MARKER [Index] Provide-Capability?>

Manifest header identifying the capabilities that the bundle offers
to provide to other bundles. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.REMOTE_CONFIGS_SUPPORTED?>
<?FM MARKER [Index] Constants:REMOTE_CONFIGS_SUPPORTED?>
<?FM MARKER [Index] REMOTE_CONFIGS_SUPPORTED?>
REMOTE_CONFIGS_SUPPORTED
public static final String REMOTE_CONFIGS_SUPPORTED = “remote.configs.supported”<?FM MARKER [Index] remote.configs.supported?>

Service property identifying the configuration types supported by
a distribution provider. Registered by the distribution provider
on one of its services to indicate the supported configuration types.
 
The value of this property must be of type String, String[], or
Collection of String.
	See Also	Remote Services Specification
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.REMOTE_INTENTS_SUPPORTED?>
<?FM MARKER [Index] Constants:REMOTE_INTENTS_SUPPORTED?>
<?FM MARKER [Index] REMOTE_INTENTS_SUPPORTED?>
REMOTE_INTENTS_SUPPORTED
public static final String REMOTE_INTENTS_SUPPORTED = “remote.intents.supported”<?FM MARKER [Index] remote.intents.supported?>

Service property identifying the intents supported by a distribution
provider. Registered by the distribution provider on one of its
services to indicate the vocabulary of implemented intents.  
The value of this property must be of type String, String[], or
Collection of String.
	See Also	Remote Services Specification
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.REQUIRE_BUNDLE?>
<?FM MARKER [Index] Constants:REQUIRE_BUNDLE?>
<?FM MARKER [Index] REQUIRE_BUNDLE?>
REQUIRE_BUNDLE
public static final String REQUIRE_BUNDLE = “Require-Bundle”<?FM MARKER [Index] Require-Bundle?>

Manifest header identifying the symbolic names of other bundles
required by the bundle. 
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.REQUIRE_CAPABILITY?>
<?FM MARKER [Index] Constants:REQUIRE_CAPABILITY?>
<?FM MARKER [Index] REQUIRE_CAPABILITY?>
REQUIRE_CAPABILITY
public static final String REQUIRE_CAPABILITY = “Require-Capability”<?FM MARKER [Index] Require-Capability?>

Manifest header identifying the capabilities on which the bundle
depends.  
The header value may be retrieved from the Dictionary object returned
by the Bundle.getHeaders method.
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.RESOLUTION_DIRECTIVE?>
<?FM MARKER [Index] Constants:RESOLUTION_DIRECTIVE?>
<?FM MARKER [Index] RESOLUTION_DIRECTIVE?>
RESOLUTION_DIRECTIVE
public static final String RESOLUTION_DIRECTIVE = “resolution”<?FM MARKER [Index] resolution?>

Manifest header directive identifying the resolution type in the
Import-Package, Require-Bundle or Require-Capability manifest header.
The default value is mandatory.  
The directive value is encoded in the Import-Package, Require-Bundle
or Require-Capability manifest header like: 
     Import-Package: org.osgi.framework; resolution:=”optional”
     Require-Bundle: com.acme.module.test; resolution:=”optional”
     Require-Capability: com.acme.capability; resolution:=”optional”
	See Also	IMPORT_PACKAGE , REQUIRE_BUNDLE , REQUIRE_CAPABILITY ,
RESOLUTION_MANDATORY , RESOLUTION_OPTIONAL
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.RESOLUTION_MANDATORY?>
<?FM MARKER [Index] Constants:RESOLUTION_MANDATORY?>
<?FM MARKER [Index] RESOLUTION_MANDATORY?>
RESOLUTION_MANDATORY
public static final String RESOLUTION_MANDATORY = “mandatory”<?FM MARKER [Index] mandatory?>

Manifest header directive value identifying a mandatory resolution
type. A mandatory resolution type indicates that the import package,
require bundle or require capability must be resolved when the bundle
is resolved. If such an import, require bundle or require capability
cannot be resolved, the module fails to resolve.  
The directive value is encoded in the Import-Package, Require-Bundle
or Require-Capability manifest header like: 
     Import-Package: org.osgi.framework; resolution:=”mandatory”
     Require-Bundle: com.acme.module.test; resolution:=”mandatory”
     Require-Capability: com.acme.capability; resolution:=”mandatory”
	See Also	RESOLUTION_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.RESOLUTION_OPTIONAL?>
<?FM MARKER [Index] Constants:RESOLUTION_OPTIONAL?>
<?FM MARKER [Index] RESOLUTION_OPTIONAL?>
RESOLUTION_OPTIONAL
public static final String RESOLUTION_OPTIONAL = “optional”<?FM MARKER [Index] optional?>

Manifest header directive value identifying an optional resolution
type. An optional resolution type indicates that the import, require
bundle or require capability is optional and the bundle may be resolved
without the import, require bundle or require capability being resolved.
If the import, require bundle or require capability is not resolved
when the bundle is resolved, the import, require bundle or require
capability may not be resolved until the bundle is refreshed.  
The directive value is encoded in the Import-Package, Require-Bundle
or Require-Capability manifest header like: 
     Import-Package: org.osgi.framework; resolution:=”optional”
     Require-Bundle: com.acme.module.test; resolution:=”optional”
     Require-Capability: com.acme.capability; resolution:=”optional”
	See Also	RESOLUTION_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.SELECTION_FILTER_ATTRIBUTE?>
<?FM MARKER [Index] Constants:SELECTION_FILTER_ATTRIBUTE?>
<?FM MARKER [Index] SELECTION_FILTER_ATTRIBUTE?>
SELECTION_FILTER_ATTRIBUTE
public static final String SELECTION_FILTER_ATTRIBUTE = “selection-filter”<?FM MARKER [Index] selection-filter?>

Manifest header attribute is used for selection by filtering based
upon system properties. 
The attribute value is encoded in manifest headers like:  
     Bundle-NativeCode: libgtk.so; selection-filter=”(ws=gtk)”; ...
	See Also	BUNDLE_NATIVECODE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.SERVICE_DESCRIPTION?>
<?FM MARKER [Index] Constants:SERVICE_DESCRIPTION?>
<?FM MARKER [Index] SERVICE_DESCRIPTION?>
SERVICE_DESCRIPTION
public static final String SERVICE_DESCRIPTION = “service.description”<?FM MARKER [Index] service.description?>

Service property identifying a service’s description.  
This property may be supplied in the properties Dictionary object
passed to the BundleContext.registerService method.
<?FM MARKER [Cross-Ref] Constants.SERVICE_EXPORTED_CONFIGS?>
<?FM MARKER [Index] Constants:SERVICE_EXPORTED_CONFIGS?>
<?FM MARKER [Index] SERVICE_EXPORTED_CONFIGS?>
SERVICE_EXPORTED_CONFIGS
public static final String SERVICE_EXPORTED_CONFIGS = “service.exported.configs”<?FM MARKER [Index] service.exported.configs?>

Service property identifying the configuration types that should
be used to export the service. Each configuration type represents
the configuration parameters for an endpoint. A distribution provider should
create an endpoint for each configuration type that it supports. 
This property may be supplied in the propertiesDictionary object
passed to the BundleContext.registerService method. The value of
this property must be of type String, String[], or Collection of
String.
	See Also	Remote Services Specification
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.SERVICE_EXPORTED_INTENTS?>
<?FM MARKER [Index] Constants:SERVICE_EXPORTED_INTENTS?>
<?FM MARKER [Index] SERVICE_EXPORTED_INTENTS?>
SERVICE_EXPORTED_INTENTS
public static final String SERVICE_EXPORTED_INTENTS = “service.exported.intents”<?FM MARKER [Index] service.exported.intents?>

Service property identifying the intents that the distribution provider
must implement to distribute the service. Intents listed in this
property are reserved for intents that are critical for the code
to function correctly, for example, ordering of messages. These
intents should not be configurable.  
This property may be supplied in the propertiesDictionary object
passed to the BundleContext.registerService method. The value of
this property must be of type String, String[], or Collection of
String.
	See Also	Remote Services Specification
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.SERVICE_EXPORTED_INTENTS_EXTRA?>
<?FM MARKER [Index] Constants:SERVICE_EXPORTED_INTENTS_EXTRA?>
<?FM MARKER [Index] SERVICE_EXPORTED_INTENTS_EXTRA?>
SERVICE_EXPORTED_INTENTS_EXTRA
public static final String SERVICE_EXPORTED_INTENTS_EXTRA = “service.exported.intents.extra”<?FM MARKER [Index] service.exported.intents.extra?>

Service property identifying the extra intents that the distribution
provider must implement to distribute the service. This property
is merged with the service.exported.intents property before the
distribution provider interprets the listed intents; it has therefore
the same semantics but the property should be configurable so the
administrator can choose the intents based on the topology. Bundles should
therefore make this property configurable, for example through the
Configuration Admin service.  
This property may be supplied in the propertiesDictionary object
passed to the BundleContext.registerService method. The value of
this property must be of type String, String[], or Collection of
String.
	See Also	Remote Services Specification
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.SERVICE_EXPORTED_INTERFACES?>
<?FM MARKER [Index] Constants:SERVICE_EXPORTED_INTERFACES?>
<?FM MARKER [Index] SERVICE_EXPORTED_INTERFACES?>
SERVICE_EXPORTED_INTERFACES
public static final String SERVICE_EXPORTED_INTERFACES = “service.exported.interfaces”<?FM MARKER [Index] service.exported.interfaces?>

Service property marking the service for export. It defines the
interfaces under which this service can be exported. This list must
be a subset of the types under which the service was registered.
The single value of an asterisk (‘*’ \u002A) indicates all the interface
types under which the service was registered excluding the non-interface
types. It is strongly recommended to only export interface types and
not concrete classes due to the complexity of creating proxies for
some type of concrete classes.  
This property may be supplied in the propertiesDictionary object
passed to the BundleContext.registerService method. The value of
this property must be of type String, String[], or Collection of
String.
	See Also	Remote Services Specification
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.SERVICE_ID?>
<?FM MARKER [Index] Constants:SERVICE_ID?>
<?FM MARKER [Index] SERVICE_ID?>
SERVICE_ID
public static final String SERVICE_ID = “service.id”<?FM MARKER [Index] service.id?>

Service property identifying a service’s registration number. The
value of this property must be of type Long.  
The value of this property is assigned by the Framework when a service
is registered. The Framework assigns a unique value that is larger
than all previously assigned values since the Framework was started.
These values are NOT persistent across restarts of the Framework.
<?FM MARKER [Cross-Ref] Constants.SERVICE_IMPORTED?>
<?FM MARKER [Index] Constants:SERVICE_IMPORTED?>
<?FM MARKER [Index] SERVICE_IMPORTED?>
SERVICE_IMPORTED
public static final String SERVICE_IMPORTED = “service.imported”<?FM MARKER [Index] service.imported?>

Service property identifying the service as imported. This service
property must be set by a distribution provider to any value when
it registers the endpoint proxy as an imported service. A bundle
can use this property to filter out imported services.  
The value of this property may be of any type.
	See Also	Remote Services Specification
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.SERVICE_IMPORTED_CONFIGS?>
<?FM MARKER [Index] Constants:SERVICE_IMPORTED_CONFIGS?>
<?FM MARKER [Index] SERVICE_IMPORTED_CONFIGS?>
SERVICE_IMPORTED_CONFIGS
public static final String SERVICE_IMPORTED_CONFIGS = “service.imported.configs”<?FM MARKER [Index] service.imported.configs?>

Service property identifying the configuration types used to import
the service. Any associated properties for this configuration types
must be properly mapped to the importing system. For example, a URL
in these properties must point to a valid resource when used in
the importing framework. If multiple configuration types are listed
in this property, then they must be synonyms for exactly the same
remote endpoint that is used to export this service.  
The value of this property must be of type String, String[], or
Collection of String.
	See Also	Remote Services Specification , SERVICE_EXPORTED_CONFIGS
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.SERVICE_INTENTS?>
<?FM MARKER [Index] Constants:SERVICE_INTENTS?>
<?FM MARKER [Index] SERVICE_INTENTS?>
SERVICE_INTENTS
public static final String SERVICE_INTENTS = “service.intents”<?FM MARKER [Index] service.intents?>

Service property identifying the intents that this service implement.
This property has a dual purpose: 
A bundle can use this service property to notify the distribution
provider that these intents are already implemented by the exported
service object.
A distribution provider must use this property to convey the combined
intents of: the exporting service, the intents that the exporting
distribution provider adds, and the intents that the importing distribution
provider adds.
To export a service, a distribution provider must expand any qualified
intents. Both the exporting and importing distribution providers
must recognize all intents before a service can be distributed. 
The value of this property must be of type String, String[], or
Collection of String.
	See Also	Remote Services Specification
	Since	1.6
<?FM MARKER [Cross-Ref] Constants.SERVICE_PID?>
<?FM MARKER [Index] Constants:SERVICE_PID?>
<?FM MARKER [Index] SERVICE_PID?>
SERVICE_PID
public static final String SERVICE_PID = “service.pid”<?FM MARKER [Index] service.pid?>

Service property identifying a service’s persistent identifier.
 
This property may be supplied in the propertiesDictionary object
passed to the BundleContext.registerService method. The value of
this property must be of type String, String[], or Collection of
String.  
A service’s persistent identifier uniquely identifies the service
and persists across multiple Framework invocations. 
By convention, every bundle has its own unique namespace, starting
with the bundle’s identifier (see Bundle.getBundleId()) and followed
by a dot (.). A bundle may use this as the prefix of the persistent identifiers
for the services it registers.
<?FM MARKER [Cross-Ref] Constants.SERVICE_RANKING?>
<?FM MARKER [Index] Constants:SERVICE_RANKING?>
<?FM MARKER [Index] SERVICE_RANKING?>
SERVICE_RANKING
public static final String SERVICE_RANKING = “service.ranking”<?FM MARKER [Index] service.ranking?>

Service property identifying a service’s ranking number.  
This property may be supplied in the properties Dictionary object
passed to the BundleContext.registerService method. The value of
this property must be of type Integer.  
The service ranking is used by the Framework to determine the natural
order of services, see ServiceReference.compareTo(Object), and the
default service to be returned from a call to the BundleContext.getServiceReference(Class)
or BundleContext.getServiceReference(String) method.  
The default ranking is zero (0). A service with a ranking of Integer.MAX_VALUE
is very likely to be returned as the default service, whereas a
service with a ranking of Integer.MIN_VALUE is very unlikely to
be returned. 
If the supplied property value is not of type Integer, it is deemed
to have a ranking value of zero.
<?FM MARKER [Cross-Ref] Constants.SERVICE_VENDOR?>
<?FM MARKER [Index] Constants:SERVICE_VENDOR?>
<?FM MARKER [Index] SERVICE_VENDOR?>
SERVICE_VENDOR
public static final String SERVICE_VENDOR = “service.vendor”<?FM MARKER [Index] service.vendor?>

Service property identifying a service’s vendor.  
This property may be supplied in the properties Dictionary object
passed to the BundleContext.registerService method.
<?FM MARKER [Cross-Ref] Constants.SINGLETON_DIRECTIVE?>
<?FM MARKER [Index] Constants:SINGLETON_DIRECTIVE?>
<?FM MARKER [Index] SINGLETON_DIRECTIVE?>
SINGLETON_DIRECTIVE
public static final String SINGLETON_DIRECTIVE = “singleton”<?FM MARKER [Index] singleton?>

Manifest header directive identifying whether a bundle is a singleton.
The default value is false.  
The directive value is encoded in the Bundle-SymbolicName manifest
header like: 
     Bundle-SymbolicName: com.acme.module.test; singleton:=true
	See Also	BUNDLE_SYMBOLICNAME
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.SUPPORTS_BOOTCLASSPATH_EXTENSION?>
<?FM MARKER [Index] Constants:SUPPORTS_BOOTCLASSPATH_EXTENSION?>
<?FM MARKER [Index] SUPPORTS_BOOTCLASSPATH_EXTENSION?>
SUPPORTS_BOOTCLASSPATH_EXTENSION
public static final String SUPPORTS_BOOTCLASSPATH_EXTENSION = “org.osgi.supports.bootclasspath.extension”<?FM MARKER [Index] org.osgi.supports.bootclasspath.extension?>

Framework environment property identifying whether the Framework
supports bootclasspath extension bundles. 
If the value of this property is true, then the Framework supports
bootclasspath extension bundles. The default value is false. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.SUPPORTS_FRAMEWORK_EXTENSION?>
<?FM MARKER [Index] Constants:SUPPORTS_FRAMEWORK_EXTENSION?>
<?FM MARKER [Index] SUPPORTS_FRAMEWORK_EXTENSION?>
SUPPORTS_FRAMEWORK_EXTENSION
public static final String SUPPORTS_FRAMEWORK_EXTENSION = “org.osgi.supports.framework.extension”<?FM MARKER [Index] org.osgi.supports.framework.extension?>

Framework environment property identifying whether the Framework
supports framework extension bundles. 
As of version 1.4, the value of this property must be true. The
Framework must support framework extension bundles. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.SUPPORTS_FRAMEWORK_FRAGMENT?>
<?FM MARKER [Index] Constants:SUPPORTS_FRAMEWORK_FRAGMENT?>
<?FM MARKER [Index] SUPPORTS_FRAMEWORK_FRAGMENT?>
SUPPORTS_FRAMEWORK_FRAGMENT
public static final String SUPPORTS_FRAMEWORK_FRAGMENT = “org.osgi.supports.framework.fragment”<?FM MARKER [Index] org.osgi.supports.framework.fragment?>

Framework environment property identifying whether the Framework
supports fragment bundles. 
As of version 1.4, the value of this property must be true. The
Framework must support fragment bundles. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.SUPPORTS_FRAMEWORK_REQUIREBUNDLE?>
<?FM MARKER [Index] Constants:SUPPORTS_FRAMEWORK_REQUIREBUNDLE?>
<?FM MARKER [Index] SUPPORTS_FRAMEWORK_REQUIREBUNDLE?>
SUPPORTS_FRAMEWORK_REQUIREBUNDLE
public static final String SUPPORTS_FRAMEWORK_REQUIREBUNDLE = “org.osgi.supports.framework.requirebundle”<?FM MARKER [Index] org.osgi.supports.framework.requirebundle?>

Framework environment property identifying whether the Framework
supports the Require-Bundle manifest header.  
As of version 1.4, the value of this property must be true. The
Framework must support the Require-Bundle manifest header. 
The value of this property may be retrieved by calling the BundleContext.getProperty
method.
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.SYSTEM_BUNDLE_LOCATION?>
<?FM MARKER [Index] Constants:SYSTEM_BUNDLE_LOCATION?>
<?FM MARKER [Index] SYSTEM_BUNDLE_LOCATION?>
SYSTEM_BUNDLE_LOCATION
public static final String SYSTEM_BUNDLE_LOCATION = “System Bundle”<?FM MARKER [Index] `System Bundle'?>

Location identifier of the OSGi system bundle , which is defined
to be “System Bundle”. 
<?FM MARKER [Cross-Ref] Constants.SYSTEM_BUNDLE_SYMBOLICNAME?>
<?FM MARKER [Index] Constants:SYSTEM_BUNDLE_SYMBOLICNAME?>
<?FM MARKER [Index] SYSTEM_BUNDLE_SYMBOLICNAME?>
SYSTEM_BUNDLE_SYMBOLICNAME
public static final String SYSTEM_BUNDLE_SYMBOLICNAME = “system.bundle”<?FM MARKER [Index] system.bundle?>

Alias for the symbolic name of the OSGi system bundle . It is defined
to be “system.bundle”. 
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.USES_DIRECTIVE?>
<?FM MARKER [Index] Constants:USES_DIRECTIVE?>
<?FM MARKER [Index] USES_DIRECTIVE?>
USES_DIRECTIVE
public static final String USES_DIRECTIVE = “uses”<?FM MARKER [Index] uses?>

Manifest header directive identifying a list of packages that an
exported package or provided capability uses. 
The directive value is encoded in the Export-Package or Provide-Capability
manifest header like: 
     Export-Package: org.osgi.util.tracker; uses:=”org.osgi.framework”
     Provide-Capability: com.acme.capability; uses:=”com.acme.service”
	See Also	EXPORT_PACKAGE , PROVIDE_CAPABILITY
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.VERSION_ATTRIBUTE?>
<?FM MARKER [Index] Constants:VERSION_ATTRIBUTE?>
<?FM MARKER [Index] VERSION_ATTRIBUTE?>
VERSION_ATTRIBUTE
public static final String VERSION_ATTRIBUTE = “version”<?FM MARKER [Index] version?>

Manifest header attribute identifying the version of a package specified
in the Export-Package or Import-Package manifest header. 
The attribute value is encoded in the Export-Package or Import-Package
manifest header like: 
     Export-Package: org.osgi.framework; version=”1.1”
	See Also	EXPORT_PACKAGE , IMPORT_PACKAGE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.VISIBILITY_DIRECTIVE?>
<?FM MARKER [Index] Constants:VISIBILITY_DIRECTIVE?>
<?FM MARKER [Index] VISIBILITY_DIRECTIVE?>
VISIBILITY_DIRECTIVE
public static final String VISIBILITY_DIRECTIVE = “visibility”<?FM MARKER [Index] visibility?>

Manifest header directive identifying the visibility of a required
bundle in the Require-Bundle manifest header. The default value
is private.  
The directive value is encoded in the Require-Bundle manifest header
like: 
     Require-Bundle: com.acme.module.test; visibility:=”reexport”
	See Also	REQUIRE_BUNDLE , VISIBILITY_PRIVATE , VISIBILITY_REEXPORT
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.VISIBILITY_PRIVATE?>
<?FM MARKER [Index] Constants:VISIBILITY_PRIVATE?>
<?FM MARKER [Index] VISIBILITY_PRIVATE?>
VISIBILITY_PRIVATE
public static final String VISIBILITY_PRIVATE = “private”<?FM MARKER [Index] private?>

Manifest header directive value identifying a private visibility
type. A private visibility type indicates that any packages that
are exported by the required bundle are not made visible on the
export signature of the requiring bundle. 
The directive value is encoded in the Require-Bundle manifest header
like: 
     Require-Bundle: com.acme.module.test; visibility:=”private”
	See Also	VISIBILITY_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Constants.VISIBILITY_REEXPORT?>
<?FM MARKER [Index] Constants:VISIBILITY_REEXPORT?>
<?FM MARKER [Index] VISIBILITY_REEXPORT?>
VISIBILITY_REEXPORT
public static final String VISIBILITY_REEXPORT = “reexport”<?FM MARKER [Index] reexport?>

Manifest header directive value identifying a reexport visibility
type. A reexport visibility type indicates any packages that are
exported by the required bundle are re-exported by the requiring
bundle. Any arbitrary arbitrary matching attributes with which they
were exported by the required bundle are deleted.  
The directive value is encoded in the Require-Bundle manifest header
like:  
     Require-Bundle: com.acme.module.test; visibility:=”reexport”
	See Also	VISIBILITY_DIRECTIVE
	Since	1.3
<?FM MARKER [Cross-Ref] Filter?>
<?FM MARKER [Index] Filter?>
<?FM MARKER [Index] interface:Filter?>
Filter
public interface Filter
An RFC 1960 ( http://www.ietf.org/rfc/rfc1960.txt ) -based Filter. 
Filters can be created by calling BundleContext.createFilter(String)
or FrameworkUtil.createFilter(String) with a filter string. 
A Filter can be used numerous times to determine if the match argument
matches the filter string that was used to create the Filter. 
Some examples of LDAP filters are:  
  “(cn=Babs Jensen)”
  “(!(cn=Tim Howes))”
  “(&amp;(” + Constants.OBJECTCLASS + “=Person)(|(sn=Jensen)(cn=Babs J*)))”
  “(o=univ*of*mich*)”
	See Also	Core Specification, Filters, for a description of the
filter string syntax.
	Since	1.1
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] Filter.equals(Object)?>
<?FM MARKER [Index] Filter:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to compare against this Filter.
	
Compares this Filter to another Filter.  
This implementation returns the result of calling this.toString().equals(obj.toString()).
	Returns	If the other object is a Filter object, then returns the
result of calling this.toString().equals(obj.toString()); false
otherwise.
<?FM MARKER [Cross-Ref] Filter.hashCode()?>
<?FM MARKER [Index] Filter:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hashCode for this Filter.  
This implementation returns the result of calling this.toString().hashCode().
	Returns	The hashCode of this Filter.
<?FM MARKER [Cross-Ref] Filter.match(ServiceReference)?>
<?FM MARKER [Index] Filter:match?>
<?FM MARKER [Index] match?>
match(ServiceReference)
public boolean match ( ServiceReference&lt;?&gt; reference ) 
	reference	The reference to the service whose properties are used
in the match.
	
Filter using a service’s properties. 
This Filter is executed using the keys and values of the referenced
service’s properties. The keys are looked up in a case insensitive
manner.
	Returns	true if the service’s properties match this Filter; false
otherwise.
<?FM MARKER [Cross-Ref] Filter.match(Dictionary)?>
<?FM MARKER [Index] Filter:match?>
<?FM MARKER [Index] match?>
match(Dictionary)
public boolean match ( Dictionary&lt;String,?&gt; dictionary ) 
	dictionary	The Dictionary whose key/value pairs are used in the
match.
	
Filter using a Dictionary with case insensitive key lookup. This
Filter is executed using the specified Dictionary‘s keys and values.
The keys are looked up in a case insensitive manner. 
	Returns	true if the Dictionary‘s values match this filter; false
otherwise.
	Throws	IllegalArgumentException –  If dictionary contains case
variants of the same key name. 
<?FM MARKER [Cross-Ref] Filter.matchCase(Dictionary)?>
<?FM MARKER [Index] Filter:matchCase?>
<?FM MARKER [Index] matchCase?>
matchCase(Dictionary)
public boolean matchCase ( Dictionary&lt;String,?&gt; dictionary ) 
	dictionary	The Dictionary whose key/value pairs are used in the
match.
	
Filter using a Dictionary. This Filter is executed using the specified
Dictionary‘s keys and values. The keys are looked up in a normal
manner respecting case. 
	Returns	true if the Dictionary‘s values match this filter; false
otherwise.
	Since	1.3
<?FM MARKER [Cross-Ref] Filter.matches(Map)?>
<?FM MARKER [Index] Filter:matches?>
<?FM MARKER [Index] matches?>
matches(Map)
public boolean matches ( Map&lt;String,?&gt; map ) 
	map	The Map whose key/value pairs are used in the match. Maps with
null key or values are not supported. A null value is considered
not present to the filter.
	
Filter using a Map. This Filter is executed using the specified
Map‘s keys and values. The keys are looked up in a normal manner
respecting case. 
	Returns	true if the Map‘s values match this filter; false otherwise.
	Since	1.6
<?FM MARKER [Cross-Ref] Filter.toString()?>
<?FM MARKER [Index] Filter:toString?>
<?FM MARKER [Index] toString?>
toString()
public String toString ( ) 
	
Returns this Filter‘s filter string. 
The filter string is normalized by removing whitespace which does
not affect the meaning of the filter.
	Returns	This Filter‘s filter string.
<?FM MARKER [Cross-Ref] FrameworkEvent?>
<?FM MARKER [Index] FrameworkEvent?>
<?FM MARKER [Index] class:FrameworkEvent?>
FrameworkEvent
public class FrameworkEvent
	extends EventObject
A general event from the Framework.  
FrameworkEvent objects are delivered to FrameworkListeners when
a general event occurs within the OSGi environment. A type code
is used to identify the event type for future extendability.  
OSGi Alliance reserves the right to extend the set of event types.
	See Also	FrameworkListener
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] FrameworkEvent.ERROR?>
<?FM MARKER [Index] FrameworkEvent:ERROR?>
<?FM MARKER [Index] ERROR?>
ERROR
public static final int ERROR = 2
An error has occurred.  
There was an error associated with a bundle.
<?FM MARKER [Cross-Ref] FrameworkEvent.INFO?>
<?FM MARKER [Index] FrameworkEvent:INFO?>
<?FM MARKER [Index] INFO?>
INFO
public static final int INFO = 32
An informational event has occurred.  
There was an informational event associated with a bundle.
	Since	1.3
<?FM MARKER [Cross-Ref] FrameworkEvent.PACKAGES_REFRESHED?>
<?FM MARKER [Index] FrameworkEvent:PACKAGES_REFRESHED?>
<?FM MARKER [Index] PACKAGES_REFRESHED?>
PACKAGES_REFRESHED
public static final int PACKAGES_REFRESHED = 4
A FrameworkWiring.refreshBundles operation has completed.  
This event is fired when the Framework has completed the refresh
bundles operation initiated by a call to the FrameworkWiring.refreshBundles
method. The source of this event is the System Bundle.
	See Also	FrameworkWiring.refreshBundles(java.util.Collection, FrameworkListener...)
	Since	1.2
<?FM MARKER [Cross-Ref] FrameworkEvent.STARTED?>
<?FM MARKER [Index] FrameworkEvent:STARTED?>
<?FM MARKER [Index] STARTED?>
STARTED
public static final int STARTED = 1
The Framework has started.  
This event is fired when the Framework has started after all installed
bundles that are marked to be started have been started and the
Framework has reached the initial start level. The source of this event
is the System Bundle.
	See Also	The Start Level Specification
<?FM MARKER [Cross-Ref] FrameworkEvent.STARTLEVEL_CHANGED?>
<?FM MARKER [Index] FrameworkEvent:STARTLEVEL_CHANGED?>
<?FM MARKER [Index] STARTLEVEL_CHANGED?>
STARTLEVEL_CHANGED
public static final int STARTLEVEL_CHANGED = 8
A FrameworkStartLevel.setStartLevel operation has completed.  
This event is fired when the Framework has completed changing the
active start level initiated by a call to the StartLevel.setStartLevel
method. The source of this event is the System Bundle.
	See Also	FrameworkStartLevel.setStartLevel(int, FrameworkListener...)
	Since	1.2
<?FM MARKER [Cross-Ref] FrameworkEvent.STOPPED?>
<?FM MARKER [Index] FrameworkEvent:STOPPED?>
<?FM MARKER [Index] STOPPED?>
STOPPED
public static final int STOPPED = 64
The Framework has stopped.  
This event is fired when the Framework has been stopped because
of a stop operation on the system bundle. The source of this event
is the System Bundle.
	Since	1.5
<?FM MARKER [Cross-Ref] FrameworkEvent.STOPPED_BOOTCLASSPATH_MODIFIED?>
<?FM MARKER [Index] FrameworkEvent:STOPPED_BOOTCLASSPATH_MODIFIED?>
<?FM MARKER [Index] STOPPED_BOOTCLASSPATH_MODIFIED?>
STOPPED_BOOTCLASSPATH_MODIFIED
public static final int STOPPED_BOOTCLASSPATH_MODIFIED = 256
The Framework has stopped and the boot class path has changed.  
This event is fired when the Framework has been stopped because
of a stop operation on the system bundle and a bootclasspath extension
bundle has been installed or updated. The source of this event is
the System Bundle.
	Since	1.5
<?FM MARKER [Cross-Ref] FrameworkEvent.STOPPED_UPDATE?>
<?FM MARKER [Index] FrameworkEvent:STOPPED_UPDATE?>
<?FM MARKER [Index] STOPPED_UPDATE?>
STOPPED_UPDATE
public static final int STOPPED_UPDATE = 128
The Framework has stopped during update.  
This event is fired when the Framework has been stopped because
of an update operation on the system bundle. The Framework will
be restarted after this event is fired. The source of this event
is the System Bundle.
	Since	1.5
<?FM MARKER [Cross-Ref] FrameworkEvent.WAIT_TIMEDOUT?>
<?FM MARKER [Index] FrameworkEvent:WAIT_TIMEDOUT?>
<?FM MARKER [Index] WAIT_TIMEDOUT?>
WAIT_TIMEDOUT
public static final int WAIT_TIMEDOUT = 512
The Framework did not stop before the wait timeout expired.  
This event is fired when the Framework did not stop before the wait
timeout expired. The source of this event is the System Bundle.
	Since	1.5
<?FM MARKER [Cross-Ref] FrameworkEvent.WARNING?>
<?FM MARKER [Index] FrameworkEvent:WARNING?>
<?FM MARKER [Index] WARNING?>
WARNING
public static final int WARNING = 16
A warning has occurred.  
There was a warning associated with a bundle.
	Since	1.3
<?FM MARKER [Cross-Ref] FrameworkEvent.FrameworkEvent(int,Object)?>
<?FM MARKER [Index] FrameworkEvent:FrameworkEvent?>
<?FM MARKER [Index] FrameworkEvent?>
FrameworkEvent(int,Object)
public FrameworkEvent ( int type , Object source ) 
	type	The event type.
	source	The event source object. This may not be null.
	
Creates a Framework event. 
	Deprecated	As of 1.2. This constructor is deprecated in favor of
using the other constructor with the System Bundle as the event
source.
<?FM MARKER [Cross-Ref] FrameworkEvent.FrameworkEvent(int,Bundle,Throwable)?>
<?FM MARKER [Index] FrameworkEvent:FrameworkEvent?>
<?FM MARKER [Index] FrameworkEvent?>
FrameworkEvent(int,Bundle,Throwable)
public FrameworkEvent ( int type , Bundle bundle , Throwable throwable
) 
	type	The event type.
	bundle	The event source.
	throwable	The related exception. This argument may be null if there
is no related exception.
	
Creates a Framework event regarding the specified bundle. 
<?FM MARKER [Cross-Ref] FrameworkEvent.getBundle()?>
<?FM MARKER [Index] FrameworkEvent:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle()
public Bundle getBundle ( ) 
	
Returns the bundle associated with the event. This bundle is also
the source of the event. 
	Returns	The bundle associated with the event.
<?FM MARKER [Cross-Ref] FrameworkEvent.getThrowable()?>
<?FM MARKER [Index] FrameworkEvent:getThrowable?>
<?FM MARKER [Index] getThrowable?>
getThrowable()
public Throwable getThrowable ( ) 
	
Returns the exception related to this event. 
	Returns	The related exception or null if none.
<?FM MARKER [Cross-Ref] FrameworkEvent.getType()?>
<?FM MARKER [Index] FrameworkEvent:getType?>
<?FM MARKER [Index] getType?>
getType()
public int getType ( ) 
	
Returns the type of framework event. 
The type values are: 
STARTED
ERROR
WARNING
INFO
PACKAGES_REFRESHED
STARTLEVEL_CHANGED
STOPPED
STOPPED_BOOTCLASSPATH_MODIFIED
STOPPED_UPDATE
WAIT_TIMEDOUT
	Returns	The type of state change.
<?FM MARKER [Cross-Ref] FrameworkListener?>
<?FM MARKER [Index] FrameworkListener?>
<?FM MARKER [Index] interface:FrameworkListener?>
FrameworkListener
public interface FrameworkListener
	extends EventListener
A FrameworkEvent listener. FrameworkListener is a listener interface
that may be implemented by a bundle developer. When a FrameworkEvent
is fired, it is asynchronously delivered to a FrameworkListener.
The Framework delivers FrameworkEvent objects to a FrameworkListener
in order and must not concurrently call a FrameworkListener.  
A FrameworkListener object is registered with the Framework using
the BundleContext.addFrameworkListener(FrameworkListener) method.
FrameworkListener objects are called with a FrameworkEvent objects
when the Framework starts and when asynchronous errors occur.
	See Also	FrameworkEvent
	Concurrency	Not Thread-safe 
<?FM MARKER [Cross-Ref] FrameworkListener.frameworkEvent(FrameworkEvent)?>
<?FM MARKER [Index] FrameworkListener:frameworkEvent?>
<?FM MARKER [Index] frameworkEvent?>
frameworkEvent(FrameworkEvent)
public void frameworkEvent ( FrameworkEvent event ) 
	event	The FrameworkEvent object.
	
Receives notification of a general FrameworkEvent object. 
<?FM MARKER [Cross-Ref] FrameworkUtil?>
<?FM MARKER [Index] FrameworkUtil?>
<?FM MARKER [Index] class:FrameworkUtil?>
FrameworkUtil
public class FrameworkUtil
Framework Utility class.  
This class contains utility methods which access Framework functions
that may be useful to bundles.
	Since	1.3
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] FrameworkUtil.createFilter(String)?>
<?FM MARKER [Index] FrameworkUtil:createFilter?>
<?FM MARKER [Index] createFilter?>
createFilter(String)
public static Filter createFilter ( String filter ) throws InvalidSyntaxException
	filter	The filter string.
	
Creates a Filter object. This Filter object may be used to match
a ServiceReference object or a Dictionary object.  
If the filter cannot be parsed, an InvalidSyntaxException will be
thrown with a human readable message where the filter became unparsable. 
This method returns a Filter implementation which may not perform
as well as the framework implementation-specific Filter implementation
returned by BundleContext.createFilter(String).
	Returns	A Filter object encapsulating the filter string.
	Throws	InvalidSyntaxException –  If filter contains an invalid
filter string that cannot be parsed. 
		NullPointerException –  If filter is null. 
	See Also	Filter
<?FM MARKER [Cross-Ref] FrameworkUtil.getBundle(Class)?>
<?FM MARKER [Index] FrameworkUtil:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle(Class)
public static Bundle getBundle ( Class&lt;?&gt; classFromBundle ) 
	classFromBundle	A class defined by a bundle class loader.
	
Return a Bundle for the specified bundle class. The returned Bundle
is the bundle associated with the bundle class loader which defined
the specified class. 
	Returns	A Bundle for the specified bundle class or null if the
specified class was not defined by a bundle class loader.
	Since	1.5
<?FM MARKER [Cross-Ref] FrameworkUtil.matchDistinguishedNameChain(String,List)?>
<?FM MARKER [Index] FrameworkUtil:matchDistinguishedNameChain?>
<?FM MARKER [Index] matchDistinguishedNameChain?>
matchDistinguishedNameChain(String,List)
public static boolean matchDistinguishedNameChain ( String matchPattern
, List&lt;String&gt; dnChain ) 
	matchPattern	The pattern against which to match the DN chain.
	dnChain	The DN chain to match against the specified pattern. Each
element of the chain must be of type String and use the format defined
in RFC 2253 ( http://www.ietf.org/rfc/rfc2253.txt ) .
	
Match a Distinguished Name (DN) chain against a pattern. DNs can
be matched using wildcards. A wildcard (‘*’ \u002A) replaces all
possible values. Due to the structure of the DN, the comparison
is more complicated than string-based wildcard matching. 
A wildcard can stand for zero or more DNs in a chain, a number of
relative distinguished names (RDNs) within a DN, or the value of
a single RDN. The DNs in the chain and the matching pattern are canonicalized
before processing. This means, among other things, that spaces must
be ignored, except in values. 
The format of a wildcard match pattern is:  
 matchPattern ::= dn-match ( ‘;’ dn-match ) *
 dn-match     ::= ( ‘*’ | rdn-match ) ( ‘,’ rdn-match ) * | ‘-’
 rdn-match    ::= name ‘=’ value-match
 value-match  ::= ‘*’ | value-star
 value-star   ::= &lt; value, requires escaped ‘*’ and ‘-’ &gt;
The most simple case is a single wildcard; it must match any DN.
A wildcard can also replace the first list of RDNs of a DN. The
first RDNs are the least significant. Such lists of matched RDNs
can be empty. 
For example, a match pattern with a wildcard that matches all DNs
that end with RDNs of o=ACME and c=US would look like this: 
 *, o=ACME, c=US
This match pattern would match the following DNs: 
 cn = Bugs Bunny, o = ACME, c = US
 ou = Carrots, cn=Daffy Duck, o=ACME, c=US
 street = 9C\, Avenue St. Dré zé ry, o=ACME, c=US
 dc=www, dc=acme, dc=com, o=ACME, c=US
 o=ACME, c=US
The following DNs would not match: 
 street = 9C\, Avenue St. Dré zé ry, o=ACME, c=FR
 dc=www, dc=acme, dc=com, c=US
If a wildcard is used for a value of an RDN, the value must be exactly
*. The wildcard must match any value, and no substring matching
must be done. For example: 
 cn=*,o=ACME,c=*
This match pattern with wildcard must match the following DNs: 
 cn=Bugs Bunny,o=ACME,c=US
 cn = Daffy Duck , o = ACME , c = US
 cn=Road Runner, o=ACME, c=NL
But not: 
 o=ACME, c=NL
 dc=acme.com, cn=Bugs Bunny, o=ACME, c=US
A match pattern may contain a chain of DN match patterns. The semicolon(
‘;’ \u003B) must be used to separate DN match patterns in a chain.
Wildcards can also be used to match against a complete DN within
a chain. 
The following example matches a certificate signed by Tweety Inc.
in the US. 
 * ; ou=S &amp; V, o=Tweety Inc., c=US
The wildcard (’*’) matches zero or one DN in the chain, however,
sometimes it is necessary to match a longer chain. The minus sign
( ‘-’ \u002D) represents zero or more DNs, whereas the asterisk
only represents a single DN. For example, to match a DN where the
Tweety Inc. is in the DN chain, use the following expression: 
 - ; *, o=Tweety Inc., c=US
	Returns	true If the pattern matches the DN chain; otherwise false
is returned.
	Throws	IllegalArgumentException –  If the specified match pattern
or DN chain is invalid. 
	Since	1.5
<?FM MARKER [Cross-Ref] InvalidSyntaxException?>
<?FM MARKER [Index] InvalidSyntaxException?>
<?FM MARKER [Index] class:InvalidSyntaxException?>
InvalidSyntaxException
public class InvalidSyntaxException
	extends Exception
A Framework exception used to indicate that a filter string has
an invalid syntax. 
An InvalidSyntaxException object indicates that a filter string
parameter has an invalid syntax and cannot be parsed. See Filter
for a description of the filter string syntax. 
This exception conforms to the general purpose exception chaining
mechanism.
<?FM MARKER [Cross-Ref] InvalidSyntaxException.InvalidSyntaxException(String,String)?>
<?FM MARKER [Index] InvalidSyntaxException:InvalidSyntaxException?>
<?FM MARKER [Index] InvalidSyntaxException?>
InvalidSyntaxException(String,String)
public InvalidSyntaxException ( String msg , String filter ) 
	msg	The message.
	filter	The invalid filter string.
	
Creates an exception of type InvalidSyntaxException.  
This method creates an InvalidSyntaxException object with the specified
message and the filter string which generated the exception.
<?FM MARKER [Cross-Ref] InvalidSyntaxException.InvalidSyntaxException(String,String,Throwable)?>
<?FM MARKER [Index] InvalidSyntaxException:InvalidSyntaxException?>
<?FM MARKER [Index] InvalidSyntaxException?>
InvalidSyntaxException(String,String,Throwable)
public InvalidSyntaxException ( String msg , String filter , Throwable
cause ) 
	msg	The message.
	filter	The invalid filter string.
	cause	The cause of this exception.
	
Creates an exception of type InvalidSyntaxException.  
This method creates an InvalidSyntaxException object with the specified
message and the filter string which generated the exception.
	Since	1.3
<?FM MARKER [Cross-Ref] InvalidSyntaxException.getCause()?>
<?FM MARKER [Index] InvalidSyntaxException:getCause?>
<?FM MARKER [Index] getCause?>
getCause()
public Throwable getCause ( ) 
	
Returns the cause of this exception or null if no cause was set. 
	Returns	The cause of this exception or null if no cause was set.
	Since	1.3
<?FM MARKER [Cross-Ref] InvalidSyntaxException.getFilter()?>
<?FM MARKER [Index] InvalidSyntaxException:getFilter?>
<?FM MARKER [Index] getFilter?>
getFilter()
public String getFilter ( ) 
	
Returns the filter string that generated the InvalidSyntaxException
object. 
	Returns	The invalid filter string.
	See Also	BundleContext.getServiceReferences(Class, String) , BundleContext.getServiceReferences(String,
String) , BundleContext.addServiceListener(ServiceListener,String)
<?FM MARKER [Cross-Ref] InvalidSyntaxException.initCause(Throwable)?>
<?FM MARKER [Index] InvalidSyntaxException:initCause?>
<?FM MARKER [Index] initCause?>
initCause(Throwable)
public Throwable initCause ( Throwable cause ) 
	cause	The cause of this exception.
	
Initializes the cause of this exception to the specified value. 
	Returns	This exception.
	Throws	IllegalArgumentException –  If the specified cause is this
exception. 
		IllegalStateException –  If the cause of this exception has already
been set. 
	Since	1.3
<?FM MARKER [Cross-Ref] PackagePermission?>
<?FM MARKER [Index] PackagePermission?>
<?FM MARKER [Index] class:PackagePermission?>
PackagePermission
public final class PackagePermission
	extends BasicPermission
A bundle’s authority to import or export a package.  
A package is a dot-separated string that defines a fully qualified
Java package. 
For example:  
 org.osgi.service.http
PackagePermission has three actions: exportonly, import and export.
The export action, which is deprecated, implies the import action.
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] PackagePermission.EXPORT?>
<?FM MARKER [Index] PackagePermission:EXPORT?>
<?FM MARKER [Index] EXPORT?>
EXPORT
public static final String EXPORT = “export”<?FM MARKER [Index] export?>

The action string export. The export action implies the import action. 
	Deprecated	Since 1.5. Use exportonly instead.
<?FM MARKER [Cross-Ref] PackagePermission.EXPORTONLY?>
<?FM MARKER [Index] PackagePermission:EXPORTONLY?>
<?FM MARKER [Index] EXPORTONLY?>
EXPORTONLY
public static final String EXPORTONLY = “exportonly”<?FM MARKER [Index] exportonly?>

The action string exportonly. The exportonly action does not imply
the import action. 
	Since	1.5
<?FM MARKER [Cross-Ref] PackagePermission.IMPORT?>
<?FM MARKER [Index] PackagePermission:IMPORT?>
<?FM MARKER [Index] IMPORT?>
IMPORT
public static final String IMPORT = “import”<?FM MARKER [Index] import?>

The action string import. 
<?FM MARKER [Cross-Ref] PackagePermission.PackagePermission(String,String)?>
<?FM MARKER [Index] PackagePermission:PackagePermission?>
<?FM MARKER [Index] PackagePermission?>
PackagePermission(String,String)
public PackagePermission ( String name , String actions ) 
	name	Package name or filter expression. A filter expression can
only be specified if the specified action is import.
	actions	exportonly,import (canonical order).
	
Creates a new PackagePermission object.  
The name is specified as a normal Java package name: a dot-separated
string. Wildcards may be used. 
 name ::= &lt;package name&gt; | &lt;package name ending in “.*”&gt; | *
Examples: 
 org.osgi.service.http
 javax.servlet.*
 *
For the import action, the name can also be a filter expression.
The filter gives access to the following attributes: 
signer - A Distinguished Name chain used to sign the exporting bundle.
Wildcards in a DN are not matched according to the filter string
rules, but according to the rules defined for a DN chain.
location - The location of the exporting bundle.
id - The bundle ID of the exporting bundle.
name - The symbolic name of the exporting bundle.
package.name - The name of the requested package.
Filter attribute names are processed in a case sensitive manner.
 
Package Permissions are granted over all possible versions of a
package.  A bundle that needs to export a package must have the
appropriate PackagePermission for that package; similarly, a bundle that
needs to import a package must have the appropriate PackagePermssion
for that package. 
Permission is granted for both classes and resources.
	Throws	IllegalArgumentException –  If the specified name is a filter
expression and either the specified action is not import or the
filter has an invalid syntax. 
<?FM MARKER [Cross-Ref] PackagePermission.PackagePermission(String,Bundle,String)?>
<?FM MARKER [Index] PackagePermission:PackagePermission?>
<?FM MARKER [Index] PackagePermission?>
PackagePermission(String,Bundle,String)
public PackagePermission ( String name , Bundle exportingBundle
, String actions ) 
	name	The name of the requested package to import.
	exportingBundle	The bundle exporting the requested package.
	actions	The action import.
	
Creates a new requested PackagePermission object to be used by code
that must perform checkPermission for the import action. PackagePermission
objects created with this constructor cannot be added to a PackagePermission
permission collection. 
	Throws	IllegalArgumentException –  If the specified action is not
import or the name is a filter expression. 
	Since	1.5
<?FM MARKER [Cross-Ref] PackagePermission.equals(Object)?>
<?FM MARKER [Index] PackagePermission:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to test for equality with this PackagePermission
object.
	
Determines the equality of two PackagePermission objects.  This
method checks that specified package has the same package name and
PackagePermission actions as this PackagePermission object. 
	Returns	true if obj is a PackagePermission, and has the same package
name and actions as this PackagePermission object; false otherwise.
<?FM MARKER [Cross-Ref] PackagePermission.getActions()?>
<?FM MARKER [Index] PackagePermission:getActions?>
<?FM MARKER [Index] getActions?>
getActions()
public String getActions ( ) 
	
Returns the canonical string representation of the PackagePermission
actions.  
Always returns present PackagePermission actions in the following
order: EXPORTONLY,IMPORT.
	Returns	Canonical string representation of the PackagePermission
actions.
<?FM MARKER [Cross-Ref] PackagePermission.hashCode()?>
<?FM MARKER [Index] PackagePermission:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hash code value for this object. 
	Returns	A hash code value for this object.
<?FM MARKER [Cross-Ref] PackagePermission.implies(Permission)?>
<?FM MARKER [Index] PackagePermission:implies?>
<?FM MARKER [Index] implies?>
implies(Permission)
public boolean implies ( Permission p ) 
	p	The requested permission.
	
Determines if the specified permission is implied by this object.
 
This method checks that the package name of the target is implied
by the package name of this object. The list of PackagePermission
actions must either match or allow for the list of the target object
to imply the target PackagePermission action. 
The permission to export a package implies the permission to import
the named package. 
 x.y.*,”export” -&gt; x.y.z,”export” is true
 *,”import” -&gt; x.y, “import”      is true
 *,”export” -&gt; x.y, “import”      is true
 x.y,”export” -&gt; x.y.z, “export”  is false
	Returns	true if the specified permission is implied by this object;
false otherwise.
<?FM MARKER [Cross-Ref] PackagePermission.newPermissionCollection()?>
<?FM MARKER [Index] PackagePermission:newPermissionCollection?>
<?FM MARKER [Index] newPermissionCollection?>
newPermissionCollection()
public PermissionCollection newPermissionCollection ( ) 
	
Returns a new PermissionCollection object suitable for storing PackagePermission
objects. 
	Returns	A new PermissionCollection object.
<?FM MARKER [Cross-Ref] ServiceEvent?>
<?FM MARKER [Index] ServiceEvent?>
<?FM MARKER [Index] class:ServiceEvent?>
ServiceEvent
public class ServiceEvent
	extends EventObject
An event from the Framework describing a service lifecycle change. 
ServiceEvent objects are delivered to ServiceListeners and AllServiceListeners
when a change occurs in this service’s lifecycle. A type code is
used to identify the event type for future extendability.  
OSGi Alliance reserves the right to extend the set of types.
	See Also	ServiceListener , AllServiceListener
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] ServiceEvent.MODIFIED?>
<?FM MARKER [Index] ServiceEvent:MODIFIED?>
<?FM MARKER [Index] MODIFIED?>
MODIFIED
public static final int MODIFIED = 2
The properties of a registered service have been modified. 
This event is synchronously delivered after the service properties
have been modified.
	See Also	ServiceRegistration.setProperties(Dictionary)
<?FM MARKER [Cross-Ref] ServiceEvent.MODIFIED_ENDMATCH?>
<?FM MARKER [Index] ServiceEvent:MODIFIED_ENDMATCH?>
<?FM MARKER [Index] MODIFIED_ENDMATCH?>
MODIFIED_ENDMATCH
public static final int MODIFIED_ENDMATCH = 8
The properties of a registered service have been modified and the
new properties no longer match the listener’s filter. 
This event is synchronously delivered after the service properties
have been modified. This event is only delivered to listeners which
were added with a non-null filter where the filter matched the service
properties prior to the modification but the filter does not match
the modified service properties.
	See Also	ServiceRegistration.setProperties(Dictionary)
	Since	1.5
<?FM MARKER [Cross-Ref] ServiceEvent.REGISTERED?>
<?FM MARKER [Index] ServiceEvent:REGISTERED?>
<?FM MARKER [Index] REGISTERED?>
REGISTERED
public static final int REGISTERED = 1
This service has been registered. 
This event is synchronously delivered after the service has been
registered with the Framework.
	See Also	BundleContext.registerService(String[],Object,Dictionary)
<?FM MARKER [Cross-Ref] ServiceEvent.UNREGISTERING?>
<?FM MARKER [Index] ServiceEvent:UNREGISTERING?>
<?FM MARKER [Index] UNREGISTERING?>
UNREGISTERING
public static final int UNREGISTERING = 4
This service is in the process of being unregistered. 
This event is synchronously delivered before the service has completed
unregistering. 
If a bundle is using a service that is UNREGISTERING, the bundle
should release its use of the service when it receives this event.
If the bundle does not release its use of the service when it receives
this event, the Framework will automatically release the bundle’s
use of the service while completing the service unregistration operation.
	See Also	ServiceRegistration.unregister() , BundleContext.ungetService(ServiceReference)
<?FM MARKER [Cross-Ref] ServiceEvent.ServiceEvent(int,ServiceReference)?>
<?FM MARKER [Index] ServiceEvent:ServiceEvent?>
<?FM MARKER [Index] ServiceEvent?>
ServiceEvent(int,ServiceReference)
public ServiceEvent ( int type , ServiceReference&lt;?&gt; reference
) 
	type	The event type.
	reference	A ServiceReference object to the service that had a lifecycle
change.
	
Creates a new service event object. 
<?FM MARKER [Cross-Ref] ServiceEvent.getServiceReference()?>
<?FM MARKER [Index] ServiceEvent:getServiceReference?>
<?FM MARKER [Index] getServiceReference?>
getServiceReference()
public ServiceReference&lt;?&gt; getServiceReference ( ) 
	
Returns a reference to the service that had a change occur in its
lifecycle. 
This reference is the source of the event.
	Returns	Reference to the service that had a lifecycle change.
<?FM MARKER [Cross-Ref] ServiceEvent.getType()?>
<?FM MARKER [Index] ServiceEvent:getType?>
<?FM MARKER [Index] getType?>
getType()
public int getType ( ) 
	
Returns the type of event. The event type values are: 
REGISTERED
MODIFIED
MODIFIED_ENDMATCH
UNREGISTERING
	Returns	Type of service lifecycle change.
<?FM MARKER [Cross-Ref] ServiceException?>
<?FM MARKER [Index] ServiceException?>
<?FM MARKER [Index] class:ServiceException?>
ServiceException
public class ServiceException
	extends RuntimeException
A service exception used to indicate that a service problem occurred.
 
A ServiceException object is created by the Framework or service
implementation to denote an exception condition in the service.
A type code is used to identify the exception type for future extendability.
Service implementations may also create subclasses of ServiceException.
When subclassing, the subclass should set the type to SUBCLASSED
to indicate that ServiceException has been subclassed.  
This exception conforms to the general purpose exception chaining
mechanism.
	Since	1.5
<?FM MARKER [Cross-Ref] ServiceException.FACTORY_ERROR?>
<?FM MARKER [Index] ServiceException:FACTORY_ERROR?>
<?FM MARKER [Index] FACTORY_ERROR?>
FACTORY_ERROR
public static final int FACTORY_ERROR = 2
The service factory produced an invalid service object. 
<?FM MARKER [Cross-Ref] ServiceException.FACTORY_EXCEPTION?>
<?FM MARKER [Index] ServiceException:FACTORY_EXCEPTION?>
<?FM MARKER [Index] FACTORY_EXCEPTION?>
FACTORY_EXCEPTION
public static final int FACTORY_EXCEPTION = 3
The service factory threw an exception. 
<?FM MARKER [Cross-Ref] ServiceException.FACTORY_RECURSION?>
<?FM MARKER [Index] ServiceException:FACTORY_RECURSION?>
<?FM MARKER [Index] FACTORY_RECURSION?>
FACTORY_RECURSION
public static final int FACTORY_RECURSION = 6
The service factory resulted in a recursive call to itself for the
requesting bundle. 
	Since	1.6
<?FM MARKER [Cross-Ref] ServiceException.REMOTE?>
<?FM MARKER [Index] ServiceException:REMOTE?>
<?FM MARKER [Index] REMOTE?>
REMOTE
public static final int REMOTE = 5
An error occurred invoking a remote service. 
<?FM MARKER [Cross-Ref] ServiceException.SUBCLASSED?>
<?FM MARKER [Index] ServiceException:SUBCLASSED?>
<?FM MARKER [Index] SUBCLASSED?>
SUBCLASSED
public static final int SUBCLASSED = 4
The exception is a subclass of ServiceException. The subclass should
be examined for the type of the exception. 
<?FM MARKER [Cross-Ref] ServiceException.UNREGISTERED?>
<?FM MARKER [Index] ServiceException:UNREGISTERED?>
<?FM MARKER [Index] UNREGISTERED?>
UNREGISTERED
public static final int UNREGISTERED = 1
The service has been unregistered. 
<?FM MARKER [Cross-Ref] ServiceException.UNSPECIFIED?>
<?FM MARKER [Index] ServiceException:UNSPECIFIED?>
<?FM MARKER [Index] UNSPECIFIED?>
UNSPECIFIED
public static final int UNSPECIFIED = 0
No exception type is unspecified. 
<?FM MARKER [Cross-Ref] ServiceException.ServiceException(String,Throwable)?>
<?FM MARKER [Index] ServiceException:ServiceException?>
<?FM MARKER [Index] ServiceException?>
ServiceException(String,Throwable)
public ServiceException ( String msg , Throwable cause ) 
	msg	The associated message.
	cause	The cause of this exception.
	
Creates a ServiceException with the specified message and exception
cause. 
<?FM MARKER [Cross-Ref] ServiceException.ServiceException(String)?>
<?FM MARKER [Index] ServiceException:ServiceException?>
<?FM MARKER [Index] ServiceException?>
ServiceException(String)
public ServiceException ( String msg ) 
	msg	The message.
	
Creates a ServiceException with the specified message. 
<?FM MARKER [Cross-Ref] ServiceException.ServiceException(String,int,Throwable)?>
<?FM MARKER [Index] ServiceException:ServiceException?>
<?FM MARKER [Index] ServiceException?>
ServiceException(String,int,Throwable)
public ServiceException ( String msg , int type , Throwable cause
) 
	msg	The associated message.
	type	The type for this exception.
	cause	The cause of this exception.
	
Creates a ServiceException with the specified message, type and
exception cause. 
<?FM MARKER [Cross-Ref] ServiceException.ServiceException(String,int)?>
<?FM MARKER [Index] ServiceException:ServiceException?>
<?FM MARKER [Index] ServiceException?>
ServiceException(String,int)
public ServiceException ( String msg , int type ) 
	msg	The message.
	type	The type for this exception.
	
Creates a ServiceException with the specified message and type. 
<?FM MARKER [Cross-Ref] ServiceException.getType()?>
<?FM MARKER [Index] ServiceException:getType?>
<?FM MARKER [Index] getType?>
getType()
public int getType ( ) 
	
Returns the type for this exception or UNSPECIFIED if the type was
unspecified or unknown. 
	Returns	The type of this exception.
<?FM MARKER [Cross-Ref] ServiceFactory?>
<?FM MARKER [Index] ServiceFactory?>
<?FM MARKER [Index] interface:ServiceFactory?>
ServiceFactory
public interface ServiceFactory&lt;S&gt;
	&lt;S&gt;	Type of Service
Allows services to provide customized service objects in the OSGi
environment. 
When registering a service, a ServiceFactory object can be used
instead of a service object, so that the bundle developer can gain
control of the specific service object granted to a bundle that
is using the service.  
When this happens, the BundleContext.getService(ServiceReference)
method calls the ServiceFactory.getService method to create a service
object specifically for the requesting bundle. The service object
returned by the ServiceFactory is cached by the Framework until
the bundle releases its use of the service. 
When the bundle’s use count for the service is decremented to zero
(including the bundle stopping or the service being unregistered),
the ServiceFactory.ungetService method is called.  
ServiceFactory objects are only used by the Framework and are not
made available to other bundles in the OSGi environment. The Framework
may concurrently call a ServiceFactory.
	See Also	BundleContext.getService(ServiceReference)
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] ServiceFactory.getService(Bundle,ServiceRegistration)?>
<?FM MARKER [Index] ServiceFactory:getService?>
<?FM MARKER [Index] getService?>
getService(Bundle,ServiceRegistration)
public S getService ( Bundle bundle , ServiceRegistration&lt;S&gt;
registration ) 
	bundle	The bundle requesting the service.
	registration	The ServiceRegistration object for the requested service.
	
Creates a new service object.  
The Framework invokes this method the first time the specified bundle
requests a service object using the BundleContext.getService(ServiceReference)
method. The service factory can then return a specific service object
for each bundle. 
The Framework must check that the returned service object is valid.
If the returned service object is null or is not an instanceof all
the classes named when the service was registered, a framework event of
type FrameworkEvent.ERROR is fired containing a service exception
of type ServiceException.FACTORY_ERROR and null is returned to the
bundle. If this method throws an exception, a framework event of
type FrameworkEvent.ERROR is fired containing a service exception
of type ServiceException.FACTORY_EXCEPTION with the thrown exception
as the cause and null is returned to the bundle. If this method
is recursively called for the specified bundle, a framework event
of type FrameworkEvent.ERROR is fired containing a service exception
of type ServiceException.FACTORY_RECURSION and null is returned
to the bundle. 
The Framework caches the valid service object and will return the
same service object on any future call to BundleContext.getService
for the specified bundle. This means the Framework must not allow this
method to be concurrently called for the specified bundle.
	Returns	A service object that must be an instance of all the classes
named when the service was registered.
	See Also	BundleContext.getService(ServiceReference)
<?FM MARKER [Cross-Ref] ServiceFactory.ungetService(Bundle,ServiceRegistration,S)?>
<?FM MARKER [Index] ServiceFactory:ungetService?>
<?FM MARKER [Index] ungetService?>
ungetService(Bundle,ServiceRegistration,S)
public void ungetService ( Bundle bundle , ServiceRegistration&lt;S&gt;
registration , S service ) 
	bundle	The bundle releasing the service.
	registration	The ServiceRegistration object for the service being
released.
	service	The service object returned by a previous call to the getService
method.
	
Releases a service object.  
The Framework invokes this method when a service has been released
by a bundle. The service object may then be destroyed. 
If this method throws an exception, a framework event of type FrameworkEvent.ERROR
is fired containing a service exception of type ServiceException.FACTORY_EXCEPTION
with the thrown exception as the cause.
	See Also	BundleContext.ungetService(ServiceReference)
<?FM MARKER [Cross-Ref] ServiceListener?>
<?FM MARKER [Index] ServiceListener?>
<?FM MARKER [Index] interface:ServiceListener?>
ServiceListener
public interface ServiceListener
	extends EventListener
A ServiceEvent listener. ServiceListener is a listener interface
that may be implemented by a bundle developer. When a ServiceEvent
is fired, it is synchronously delivered to a ServiceListener. The Framework
may deliver ServiceEvent objects to a ServiceListener out of order
and may concurrently call and/or reenter a ServiceListener.  
A ServiceListener object is registered with the Framework using
the BundleContext.addServiceListener method. ServiceListener objects
are called with a ServiceEvent object when a service is registered,
modified, or is in the process of unregistering. 
ServiceEvent object delivery to ServiceListener objects is filtered
by the filter specified when the listener was registered. If the
Java Runtime Environment supports permissions, then additional filtering
is done. ServiceEvent objects are only delivered to the listener
if the bundle which defines the listener object’s class has the
appropriate ServicePermission to get the service using at least
one of the named classes under which the service was registered. 
ServiceEvent object delivery to ServiceListener objects is further
filtered according to package sources as defined in ServiceReference.isAssignableTo(Bundle,
String).
	See Also	ServiceEvent , ServicePermission
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] ServiceListener.serviceChanged(ServiceEvent)?>
<?FM MARKER [Index] ServiceListener:serviceChanged?>
<?FM MARKER [Index] serviceChanged?>
serviceChanged(ServiceEvent)
public void serviceChanged ( ServiceEvent event ) 
	event	The ServiceEvent object.
	
Receives notification that a service has had a lifecycle change. 
<?FM MARKER [Cross-Ref] ServicePermission?>
<?FM MARKER [Index] ServicePermission?>
<?FM MARKER [Index] class:ServicePermission?>
ServicePermission
public final class ServicePermission
	extends BasicPermission
A bundle’s authority to register or get a service. 
The register action allows a bundle to register a service on the
specified names.
The get action allows a bundle to detect a service and get it.
Permission to get a service is required in order to detect events
regarding the service. Untrusted bundles should not be able to detect
the presence of certain services unless they have the appropriate
ServicePermission to get the specific service. 
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] ServicePermission.GET?>
<?FM MARKER [Index] ServicePermission:GET?>
<?FM MARKER [Index] GET?>
GET
public static final String GET = “get”<?FM MARKER [Index] get?>

The action string get. 
<?FM MARKER [Cross-Ref] ServicePermission.REGISTER?>
<?FM MARKER [Index] ServicePermission:REGISTER?>
<?FM MARKER [Index] REGISTER?>
REGISTER
public static final String REGISTER = “register”<?FM MARKER [Index] register?>

The action string register. 
<?FM MARKER [Cross-Ref] ServicePermission.ServicePermission(String,String)?>
<?FM MARKER [Index] ServicePermission:ServicePermission?>
<?FM MARKER [Index] ServicePermission?>
ServicePermission(String,String)
public ServicePermission ( String name , String actions ) 
	name	The service class name
	actions	get,register (canonical order)
	
Create a new ServicePermission.  
The name of the service is specified as a fully qualified class
name. Wildcards may be used. 
 name ::= &lt;class name&gt; | &lt;class name ending in “.*”&gt; | *
Examples: 
 org.osgi.service.http.HttpService
 org.osgi.service.http.*
 *
For the get action, the name can also be a filter expression. The
filter gives access to the service properties as well as the following
attributes: 
signer - A Distinguished Name chain used to sign the bundle publishing
the service. Wildcards in a DN are not matched according to the
filter string rules, but according to the rules defined for a DN chain.
location - The location of the bundle publishing the service.
id - The bundle ID of the bundle publishing the service.
name - The symbolic name of the bundle publishing the service.
Since the above attribute names may conflict with service property
names used by a service, you can prefix an attribute name with ‘@’
in the filter expression to match against the service property and not
one of the above attributes. Filter attribute names are processed
in a case sensitive manner unless the attribute references a service
property. Service properties names are case insensitive. 
There are two possible actions: get and register. The get permission
allows the owner of this permission to obtain a service with this
name. The register permission allows the bundle to register a service under
that name.
	Throws	IllegalArgumentException –  If the specified name is a filter
expression and either the specified action is not get or the filter
has an invalid syntax. 
<?FM MARKER [Cross-Ref] ServicePermission.ServicePermission(ServiceReference,String)?>
<?FM MARKER [Index] ServicePermission:ServicePermission?>
<?FM MARKER [Index] ServicePermission?>
ServicePermission(ServiceReference,String)
public ServicePermission ( ServiceReference&lt;?&gt; reference , String
actions ) 
	reference	The requested service.
	actions	The action get.
	
Creates a new requested ServicePermission object to be used by code
that must perform checkPermission for the get action. ServicePermission
objects created with this constructor cannot be added to a ServicePermission
permission collection. 
	Throws	IllegalArgumentException –  If the specified action is not
get or reference is null. 
	Since	1.5
<?FM MARKER [Cross-Ref] ServicePermission.equals(Object)?>
<?FM MARKER [Index] ServicePermission:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to test for equality.
	
Determines the equality of two ServicePermission objects.  Checks
that specified object has the same class name and action as this
ServicePermission. 
	Returns	true if obj is a ServicePermission, and has the same class
name and actions as this ServicePermission object; false otherwise.
<?FM MARKER [Cross-Ref] ServicePermission.getActions()?>
<?FM MARKER [Index] ServicePermission:getActions?>
<?FM MARKER [Index] getActions?>
getActions()
public String getActions ( ) 
	
Returns the canonical string representation of the actions. Always
returns present actions in the following order: get, register. 
	Returns	The canonical string representation of the actions.
<?FM MARKER [Cross-Ref] ServicePermission.hashCode()?>
<?FM MARKER [Index] ServicePermission:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hash code value for this object. 
	Returns	Hash code value for this object.
<?FM MARKER [Cross-Ref] ServicePermission.implies(Permission)?>
<?FM MARKER [Index] ServicePermission:implies?>
<?FM MARKER [Index] implies?>
implies(Permission)
public boolean implies ( Permission p ) 
	p	The target permission to check.
	
Determines if a ServicePermission object “implies” the specified
permission. 
	Returns	true if the specified permission is implied by this object;
false otherwise.
<?FM MARKER [Cross-Ref] ServicePermission.newPermissionCollection()?>
<?FM MARKER [Index] ServicePermission:newPermissionCollection?>
<?FM MARKER [Index] newPermissionCollection?>
newPermissionCollection()
public PermissionCollection newPermissionCollection ( ) 
	
Returns a new PermissionCollection object for storing ServicePermission
objects. 
	Returns	A new PermissionCollection object suitable for storing
ServicePermission objects.
<?FM MARKER [Cross-Ref] ServiceReference?>
<?FM MARKER [Index] ServiceReference?>
<?FM MARKER [Index] interface:ServiceReference?>
ServiceReference
public interface ServiceReference&lt;S&gt;
	extends Comparable&lt;Object&gt;
	&lt;S&gt;	Type of Service.
A reference to a service.  
The Framework returns ServiceReference objects from the BundleContext.getServiceReference
and BundleContext.getServiceReferences methods. 
A ServiceReference object may be shared between bundles and can
be used to examine the properties of the service and to get the
service object. 
Every service registered in the Framework has a unique ServiceRegistration
object and may have multiple, distinct ServiceReference objects
referring to it. ServiceReference objects associated with a ServiceRegistration
object have the same hashCode and are considered equal (more specifically,
their equals() method will return true when compared). 
If the same service object is registered multiple times, ServiceReference
objects associated with different ServiceRegistration objects are
not equal.
	See Also	BundleContext.getServiceReference(Class) , BundleContext.getServiceReference(String)
, BundleContext.getServiceReferences(Class, String) , BundleContext.getServiceReferences(String,
String) , BundleContext.getService(ServiceReference)
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] ServiceReference.compareTo(Object)?>
<?FM MARKER [Index] ServiceReference:compareTo?>
<?FM MARKER [Index] compareTo?>
compareTo(Object)
public int compareTo ( Object reference ) 
	reference	The ServiceReference to be compared.
	
Compares this ServiceReference with the specified ServiceReference
for order.  
If this ServiceReference and the specified ServiceReference have
the same service id they are equal. This ServiceReference is less
than the specified ServiceReference if it has a lower service ranking
and greater if it has a higher service ranking. Otherwise, if this
ServiceReference and the specified ServiceReference have the same
service ranking, this ServiceReference is less than the specified
ServiceReference if it has a higher service id and greater if it
has a lower service id.
	Returns	Returns a negative integer, zero, or a positive integer
if this ServiceReference is less than, equal to, or greater than
the specified ServiceReference.
	Throws	IllegalArgumentException –  If the specified ServiceReference
was not created by the same framework instance as this ServiceReference. 
	Since	1.4
<?FM MARKER [Cross-Ref] ServiceReference.getBundle()?>
<?FM MARKER [Index] ServiceReference:getBundle?>
<?FM MARKER [Index] getBundle?>
getBundle()
public Bundle getBundle ( ) 
	
Returns the bundle that registered the service referenced by this
ServiceReference object.  
This method must return null when the service has been unregistered.
This can be used to determine if the service has been unregistered.
	Returns	The bundle that registered the service referenced by this
ServiceReference object; null if that service has already been unregistered.
	See Also	BundleContext.registerService(String[],Object,Dictionary)
<?FM MARKER [Cross-Ref] ServiceReference.getProperty(String)?>
<?FM MARKER [Index] ServiceReference:getProperty?>
<?FM MARKER [Index] getProperty?>
getProperty(String)
public Object getProperty ( String key ) 
	key	The property key.
	
Returns the property value to which the specified property key is
mapped in the properties Dictionary object of the service referenced
by this ServiceReference object.  
Property keys are case-insensitive.  
This method must continue to return property values after the service
has been unregistered. This is so references to unregistered services
(for example, ServiceReference objects stored in the log) can still
be interrogated.
	Returns	The property value to which the key is mapped; null if
there is no property named after the key.
<?FM MARKER [Cross-Ref] ServiceReference.getPropertyKeys()?>
<?FM MARKER [Index] ServiceReference:getPropertyKeys?>
<?FM MARKER [Index] getPropertyKeys?>
getPropertyKeys()
public String[] getPropertyKeys (  ) 
	
Returns an array of the keys in the properties Dictionary object
of the service referenced by this ServiceReference object.  
This method will continue to return the keys after the service has
been unregistered. This is so references to unregistered services
(for example, ServiceReference objects stored in the log) can still
be interrogated. 
This method is case-preserving ; this means that every key in the
returned array must have the same case as the corresponding key
in the properties Dictionary that was passed to the BundleContext.registerService(String[],Object,Dictionary)
or ServiceRegistration.setProperties(Dictionary) methods.
	Returns	An array of property keys.
<?FM MARKER [Cross-Ref] ServiceReference.getUsingBundles()?>
<?FM MARKER [Index] ServiceReference:getUsingBundles?>
<?FM MARKER [Index] getUsingBundles?>
getUsingBundles()
public Bundle[] getUsingBundles (  ) 
	
Returns the bundles that are using the service referenced by this
ServiceReference object. Specifically, this method returns the bundles
whose usage count for that service is greater than zero. 
	Returns	An array of bundles whose usage count for the service referenced
by this ServiceReference object is greater than zero; null if no
bundles are currently using that service.
	Since	1.1
<?FM MARKER [Cross-Ref] ServiceReference.isAssignableTo(Bundle,String)?>
<?FM MARKER [Index] ServiceReference:isAssignableTo?>
<?FM MARKER [Index] isAssignableTo?>
isAssignableTo(Bundle,String)
public boolean isAssignableTo ( Bundle bundle , String className
) 
	bundle	The Bundle object to check.
	className	The class name to check.
	
Tests if the bundle that registered the service referenced by this
ServiceReference and the specified bundle use the same source for
the package of the specified class name. 
This method performs the following checks: 
Get the package name from the specified class name.
For the bundle that registered the service referenced by this ServiceReference
(registrant bundle); find the source for the package. If no source
is found then return true if the registrant bundle is equal to the
specified bundle; otherwise return false.
If the package source of the registrant bundle is equal to the package
source of the specified bundle then return true; otherwise return
false.
	Returns	true if the bundle which registered the service referenced
by this ServiceReference and the specified bundle use the same source
for the package of the specified class name. Otherwise false is
returned.
	Throws	IllegalArgumentException –  If the specified Bundle was
not created by the same framework instance as this ServiceReference. 
	Since	1.3
<?FM MARKER [Cross-Ref] ServiceRegistration?>
<?FM MARKER [Index] ServiceRegistration?>
<?FM MARKER [Index] interface:ServiceRegistration?>
ServiceRegistration
public interface ServiceRegistration&lt;S&gt;
	&lt;S&gt;	Type of Service.
A registered service.  
The Framework returns a ServiceRegistration object when a BundleContext.registerService
method invocation is successful. The ServiceRegistration object
is for the private use of the registering bundle and should not
be shared with other bundles. 
The ServiceRegistration object may be used to update the properties
of the service or to unregister the service.
	See Also	BundleContext.registerService(String[],Object,Dictionary)
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] ServiceRegistration.getReference()?>
<?FM MARKER [Index] ServiceRegistration:getReference?>
<?FM MARKER [Index] getReference?>
getReference()
public ServiceReference&lt;S&gt; getReference ( ) 
	
Returns a ServiceReference object for a service being registered. 
The ServiceReference object may be shared with other bundles.
	Returns	ServiceReference object.
	Throws	IllegalStateException –  If this ServiceRegistration object
has already been unregistered. 
<?FM MARKER [Cross-Ref] ServiceRegistration.setProperties(Dictionary)?>
<?FM MARKER [Index] ServiceRegistration:setProperties?>
<?FM MARKER [Index] setProperties?>
setProperties(Dictionary)
public void setProperties ( Dictionary&lt;String,?&gt; properties ) 
	properties	The properties for this service. See Constants for a
list of standard service property keys. Changes should not be made
to this object after calling this method. To update the service’s properties
this method should be called again.
	
Updates the properties associated with a service.  
The Constants.OBJECTCLASS and Constants.SERVICE_ID keys cannot be
modified by this method. These values are set by the Framework when
the service is registered in the OSGi environment.  
The following steps are required to modify service properties: 
The service’s properties are replaced with the provided properties. 
A service event of type ServiceEvent.MODIFIED is fired. 
	Throws	IllegalStateException –  If this ServiceRegistration object
has already been unregistered. 
		IllegalArgumentException –  If properties contains case variants
of the same key name. 
<?FM MARKER [Cross-Ref] ServiceRegistration.unregister()?>
<?FM MARKER [Index] ServiceRegistration:unregister?>
<?FM MARKER [Index] unregister?>
unregister()
public void unregister ( ) 
	
Unregisters a service. Remove a ServiceRegistration object from
the Framework service registry. All ServiceReference objects associated
with this ServiceRegistration object can no longer be used to interact
with the service once unregistration is complete. 
The following steps are required to unregister a service: 
The service is removed from the Framework service registry so that
it can no longer be obtained. 
A service event of type ServiceEvent.UNREGISTERING is fired so that
bundles using this service can release their use of the service.
Once delivery of the service event is complete, the ServiceReference objects
for the service may no longer be used to get a service object for
the service. 
For each bundle whose use count for this service is greater than
zero: 
 The bundle’s use count for this service is set to zero. 
 If the service was registered with a ServiceFactory object, the
ServiceFactory.ungetService method is called to release the service
object for the bundle. 
	Throws	IllegalStateException –  If this ServiceRegistration object
has already been unregistered. 
	See Also	BundleContext.ungetService(ServiceReference) , ServiceFactory.ungetService(Bundle,
ServiceRegistration, Object)
<?FM MARKER [Cross-Ref] SynchronousBundleListener?>
<?FM MARKER [Index] SynchronousBundleListener?>
<?FM MARKER [Index] interface:SynchronousBundleListener?>
SynchronousBundleListener
public interface SynchronousBundleListener
	extends BundleListener
A synchronous BundleEvent listener. SynchronousBundleListener is
a listener interface that may be implemented by a bundle developer.
When a BundleEvent is fired, it is synchronously delivered to a SynchronousBundleListener.
The Framework may deliver BundleEvent objects to a SynchronousBundleListener
out of order and may concurrently call and/or reenter a SynchronousBundleListener.
 
For BundleEvent types STARTED and LAZY_ACTIVATION, the Framework
must not hold the referenced bundle’s “state change” lock when the
BundleEvent is delivered to a SynchronousBundleListener. For the
other BundleEvent types, the Framework must hold the referenced
bundle’s “state change” lock when the BundleEvent is delivered to
a SynchronousBundleListener. A SynchronousBundleListener cannot
directly call life cycle methods on the referenced bundle when the
Framework is holding the referenced bundle’s “state change” lock.
 
A SynchronousBundleListener object is registered with the Framework
using the BundleContext.addBundleListener(BundleListener) method.
SynchronousBundleListener objects are called with a BundleEvent
object when a bundle has been installed, resolved, starting, started,
stopping, stopped, updated, unresolved, or uninstalled. 
Unlike normal BundleListener objects, SynchronousBundleListeners
are synchronously called during bundle lifecycle processing. The
bundle lifecycle processing will not proceed until all SynchronousBundleListeners
have completed. SynchronousBundleListener objects will be called
prior to BundleListener objects. 
AdminPermission[bundle,LISTENER] is required to add or remove a
SynchronousBundleListener object.
	See Also	BundleEvent
	Since	1.1
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] UnfilteredServiceListener?>
<?FM MARKER [Index] UnfilteredServiceListener?>
<?FM MARKER [Index] interface:UnfilteredServiceListener?>
UnfilteredServiceListener
public interface UnfilteredServiceListener
	extends ServiceListener
A ServiceEvent listener that does not filter based upon any filter
string specified to BundleContext.addServiceListener(ServiceListener,
String). Using an UnfilteredServiceListener and specifying a filter
string to BundleContext.addServiceListener(ServiceListener, String)
allows the listener to receive all ServiceEvent objects while still
advising ListenerHook implementation of the service interests in
the filter string. For example, an implementation of Declarative
Services would add an UnfilteredServiceListener with a filter string
listing all the services referenced by all the service components.
The Declarative Services implementation would receive all ServiceEvent
objects for internal processing and a Remote Services discovery
service implementation can observe the service interests of the
service components using a ListenerHook. When the set of service
components being processed changes, the Declarative Services implementation
would re-add the UnfilteredServiceListener with an updated filter
string.  
When a ServiceEvent is fired, it is synchronously delivered to an
UnfilteredServiceListener. The Framework may deliver ServiceEvent
objects to an UnfilteredServiceListener out of order and may concurrently
call and/or reenter an UnfilteredServiceListener.  
An UnfilteredServiceListener object is registered with the Framework
using the BundleContext.addServiceListener method. UnfilteredServiceListener
objects are called with a ServiceEvent object when a service is
registered, modified, or is in the process of unregistering. 
ServiceEvent object delivery to UnfilteredServiceListener objects
are not filtered by the filter specified when the listener was registered.
If the Java Runtime Environment supports permissions, then some
filtering is done. ServiceEvent objects are only delivered to the
listener if the bundle which defines the listener object’s class
has the appropriate ServicePermission to get the service using at least
one of the named classes under which the service was registered.
	See Also	ServiceEvent , ServicePermission
	Since	1.7
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] Version?>
<?FM MARKER [Index] Version?>
<?FM MARKER [Index] class:Version?>
Version
public class Version
	implements Comparable&lt;Version&gt;
Version identifier for capabilities such as bundles and packages.
 
Version identifiers have four components. 
Major version. A non-negative integer.
Minor version. A non-negative integer.
Micro version. A non-negative integer.
Qualifier. A text string. See Version(String) for the format of
the qualifier string.
Version objects are immutable.
	Since	1.3
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] Version.emptyVersion?>
<?FM MARKER [Index] Version:emptyVersion?>
<?FM MARKER [Index] emptyVersion?>
emptyVersion
public static final Version emptyVersion
The empty version “0.0.0”. 
<?FM MARKER [Cross-Ref] Version.Version(int,int,int)?>
<?FM MARKER [Index] Version:Version?>
<?FM MARKER [Index] Version?>
Version(int,int,int)
public Version ( int major , int minor , int micro ) 
	major	Major component of the version identifier.
	minor	Minor component of the version identifier.
	micro	Micro component of the version identifier.
	
Creates a version identifier from the specified numerical components.
 
The qualifier is set to the empty string.
	Throws	IllegalArgumentException –  If the numerical components
are negative. 
<?FM MARKER [Cross-Ref] Version.Version(int,int,int,String)?>
<?FM MARKER [Index] Version:Version?>
<?FM MARKER [Index] Version?>
Version(int,int,int,String)
public Version ( int major , int minor , int micro , String qualifier
) 
	major	Major component of the version identifier.
	minor	Minor component of the version identifier.
	micro	Micro component of the version identifier.
	qualifier	Qualifier component of the version identifier. If null
is specified, then the qualifier will be set to the empty string.
	
Creates a version identifier from the specified components. 
	Throws	IllegalArgumentException –  If the numerical components
are negative or the qualifier string is invalid. 
<?FM MARKER [Cross-Ref] Version.Version(String)?>
<?FM MARKER [Index] Version:Version?>
<?FM MARKER [Index] Version?>
Version(String)
public Version ( String version ) 
	version	String representation of the version identifier. There
must be no whitespace in the argument.
	
Creates a version identifier from the specified string.  
Version string grammar:  
 version ::= major(’.’minor(’.’micro(’.’qualifier)?)?)?
 major ::= digit+
 minor ::= digit+
 micro ::= digit+
 qualifier ::= (alpha|digit|’_’|’-’)+
 digit ::= [0..9]
 alpha ::= [a..zA..Z]
	Throws	IllegalArgumentException –  If version is improperly formatted. 
<?FM MARKER [Cross-Ref] Version.compareTo(Version)?>
<?FM MARKER [Index] Version:compareTo?>
<?FM MARKER [Index] compareTo?>
compareTo(Version)
public int compareTo ( Version other ) 
	other	The Version object to be compared.
	
Compares this Version object to another Version.  
A version is considered to be less than another version if its major
component is less than the other version’s major component, or the
major components are equal and its minor component is less than the
other version’s minor component, or the major and minor components
are equal and its micro component is less than the other version’s
micro component, or the major, minor and micro components are equal
and it’s qualifier component is less than the other version’s qualifier
component (using String.compareTo).  
A version is considered to be equal to another version if the major,
minor and micro components are equal and the qualifier component
is equal (using String.compareTo).
	Returns	A negative integer, zero, or a positive integer if this
version is less than, equal to, or greater than the specified Version
object.
	Throws	ClassCastException –  If the specified object is not a Version
object. 
<?FM MARKER [Cross-Ref] Version.equals(Object)?>
<?FM MARKER [Index] Version:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object object ) 
	object	The Version object to be compared.
	
Compares this Version object to another object.  
A version is considered to be equal to  another version if the major,
minor and micro components are equal and the qualifier component
is equal (using String.equals).
	Returns	true if object is a Version and is equal to this object;
false otherwise.
<?FM MARKER [Cross-Ref] Version.getMajor()?>
<?FM MARKER [Index] Version:getMajor?>
<?FM MARKER [Index] getMajor?>
getMajor()
public int getMajor ( ) 
	
Returns the major component of this version identifier. 
	Returns	The major component.
<?FM MARKER [Cross-Ref] Version.getMicro()?>
<?FM MARKER [Index] Version:getMicro?>
<?FM MARKER [Index] getMicro?>
getMicro()
public int getMicro ( ) 
	
Returns the micro component of this version identifier. 
	Returns	The micro component.
<?FM MARKER [Cross-Ref] Version.getMinor()?>
<?FM MARKER [Index] Version:getMinor?>
<?FM MARKER [Index] getMinor?>
getMinor()
public int getMinor ( ) 
	
Returns the minor component of this version identifier. 
	Returns	The minor component.
<?FM MARKER [Cross-Ref] Version.getQualifier()?>
<?FM MARKER [Index] Version:getQualifier?>
<?FM MARKER [Index] getQualifier?>
getQualifier()
public String getQualifier ( ) 
	
Returns the qualifier component of this version identifier. 
	Returns	The qualifier component.
<?FM MARKER [Cross-Ref] Version.hashCode()?>
<?FM MARKER [Index] Version:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns a hash code value for the object. 
	Returns	An integer which is a hash code value for this object.
<?FM MARKER [Cross-Ref] Version.parseVersion(String)?>
<?FM MARKER [Index] Version:parseVersion?>
<?FM MARKER [Index] parseVersion?>
parseVersion(String)
public static Version parseVersion ( String version ) 
	version	String representation of the version identifier. Leading
and trailing whitespace will be ignored.
	
Parses a version identifier from the specified string.  
See Version(String) for the format of the version string.
	Returns	A Version object representing the version identifier. If
version is null or the empty string then emptyVersion will be returned.
	Throws	IllegalArgumentException –  If version is improperly formatted. 
<?FM MARKER [Cross-Ref] Version.toString()?>
<?FM MARKER [Index] Version:toString?>
<?FM MARKER [Index] toString?>
toString()
public String toString ( ) 
	
Returns the string representation of this version identifier.  
The format of the version string will be major.minor.micro if qualifier
is the empty string or major.minor.micro.qualifier otherwise.
	Returns	The string representation of this version identifier.
<?FM MARKER [Cross-Ref] VersionRange?>
<?FM MARKER [Index] VersionRange?>
<?FM MARKER [Index] class:VersionRange?>
VersionRange
public class VersionRange
Version range. A version range is an interval describing a set of
versions.  
A range has a left (lower) endpoint and a right (upper) endpoint.
Each endpoint can be open (excluded from the set) or closed (included
in the set). 
VersionRange objects are immutable.
	Since	1.7
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] VersionRange.LEFT_CLOSED?>
<?FM MARKER [Index] VersionRange:LEFT_CLOSED?>
<?FM MARKER [Index] LEFT_CLOSED?>
LEFT_CLOSED
public static final char LEFT_CLOSED = 91
The left endpoint is closed and is included in the range. 
The value of LEFT_CLOSED is ‘[’.
<?FM MARKER [Cross-Ref] VersionRange.LEFT_OPEN?>
<?FM MARKER [Index] VersionRange:LEFT_OPEN?>
<?FM MARKER [Index] LEFT_OPEN?>
LEFT_OPEN
public static final char LEFT_OPEN = 40
The left endpoint is open and is excluded from the range. 
The value of LEFT_OPEN is ‘(’.
<?FM MARKER [Cross-Ref] VersionRange.RIGHT_CLOSED?>
<?FM MARKER [Index] VersionRange:RIGHT_CLOSED?>
<?FM MARKER [Index] RIGHT_CLOSED?>
RIGHT_CLOSED
public static final char RIGHT_CLOSED = 93
The right endpoint is closed and is included in the range. 
The value of RIGHT_CLOSED is ‘]’.
<?FM MARKER [Cross-Ref] VersionRange.RIGHT_OPEN?>
<?FM MARKER [Index] VersionRange:RIGHT_OPEN?>
<?FM MARKER [Index] RIGHT_OPEN?>
RIGHT_OPEN
public static final char RIGHT_OPEN = 41
The right endpoint is open and is excluded from the range. 
The value of RIGHT_OPEN is ‘)’.
<?FM MARKER [Cross-Ref] VersionRange.VersionRange(char,Version,Version,char)?>
<?FM MARKER [Index] VersionRange:VersionRange?>
<?FM MARKER [Index] VersionRange?>
VersionRange(char,Version,Version,char)
public VersionRange ( char leftType , Version leftEndpoint , Version
rightEndpoint , char rightType ) 
	leftType	Must be either LEFT_CLOSED or LEFT_OPEN .
	leftEndpoint	Left endpoint of range. Must not be null.
	rightEndpoint	Right endpoint of range. May be null to indicate
the right endpoint is Infinity.
	rightType	Must be either RIGHT_CLOSED or RIGHT_OPEN.
	
Creates a version range from the specified versions. 
	Throws	IllegalArgumentException –  If the arguments are invalid. 
<?FM MARKER [Cross-Ref] VersionRange.VersionRange(String)?>
<?FM MARKER [Index] VersionRange:VersionRange?>
<?FM MARKER [Index] VersionRange?>
VersionRange(String)
public VersionRange ( String range ) 
	range	String representation of the version range. The versions
in the range must contain no whitespace. Other whitespace in the
range string is ignored.
	
Creates a version range from the specified string.  
Version range string grammar:  
 range ::= interval | atleast
 interval ::= ( ‘[’ | ‘(’ ) left ‘,’ right ( ‘]’ | ‘)’ )
 left ::= version
 right ::= version
 atleast ::= version
	Throws	IllegalArgumentException –  If range is improperly formatted. 
<?FM MARKER [Cross-Ref] VersionRange.equals(Object)?>
<?FM MARKER [Index] VersionRange:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object object ) 
	object	The VersionRange object to be compared.
	
Compares this VersionRange object to another object.  
A version range is considered to be equal to  another version range
if both the endpoints and their types are equal or if both version
ranges are empty.
	Returns	true if object is a VersionRange and is equal to this object;
false otherwise.
<?FM MARKER [Cross-Ref] VersionRange.getLeft()?>
<?FM MARKER [Index] VersionRange:getLeft?>
<?FM MARKER [Index] getLeft?>
getLeft()
public Version getLeft ( ) 
	
Returns the left endpoint of this version range. 
	Returns	The left endpoint.
<?FM MARKER [Cross-Ref] VersionRange.getLeftType()?>
<?FM MARKER [Index] VersionRange:getLeftType?>
<?FM MARKER [Index] getLeftType?>
getLeftType()
public char getLeftType ( ) 
	
Returns the type of the left endpoint of this version range. 
	Returns	LEFT_CLOSED if the left endpoint is closed or LEFT_OPEN
if the left endpoint is open.
<?FM MARKER [Cross-Ref] VersionRange.getRight()?>
<?FM MARKER [Index] VersionRange:getRight?>
<?FM MARKER [Index] getRight?>
getRight()
public Version getRight ( ) 
	
Returns the right endpoint of this version range. 
	Returns	The right endpoint. May be null which indicates the right
endpoint is Infinity.
<?FM MARKER [Cross-Ref] VersionRange.getRightType()?>
<?FM MARKER [Index] VersionRange:getRightType?>
<?FM MARKER [Index] getRightType?>
getRightType()
public char getRightType ( ) 
	
Returns the type of the right endpoint of this version range. 
	Returns	RIGHT_CLOSED if the right endpoint is closed or RIGHT_OPEN
if the right endpoint is open.
<?FM MARKER [Cross-Ref] VersionRange.hashCode()?>
<?FM MARKER [Index] VersionRange:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns a hash code value for the object. 
	Returns	An integer which is a hash code value for this object.
<?FM MARKER [Cross-Ref] VersionRange.includes(Version)?>
<?FM MARKER [Index] VersionRange:includes?>
<?FM MARKER [Index] includes?>
includes(Version)
public boolean includes ( Version version ) 
	version	The version to test for inclusion in this version range.
	
Returns whether this version range includes the specified version. 
	Returns	true if the specified version is included in this version
range; false otherwise.
<?FM MARKER [Cross-Ref] VersionRange.intersection(VersionRange...)?>
<?FM MARKER [Index] VersionRange:intersection?>
<?FM MARKER [Index] intersection?>
intersection(VersionRange...)
public VersionRange intersection ( VersionRange ... ranges ) 
	ranges	The version ranges to intersect with this version range.
	
Returns the intersection of this version range with the specified
version ranges. 
	Returns	A version range representing the intersection of this version
range and the specified version ranges. If no version ranges are
specified, then this version range is returned.
<?FM MARKER [Cross-Ref] VersionRange.isEmpty()?>
<?FM MARKER [Index] VersionRange:isEmpty?>
<?FM MARKER [Index] isEmpty?>
isEmpty()
public boolean isEmpty ( ) 
	
Returns whether this version range is empty. A version range is
empty if the set of versions defined by the interval is empty. 
	Returns	true if this version range is empty; false otherwise.
<?FM MARKER [Cross-Ref] VersionRange.isExact()?>
<?FM MARKER [Index] VersionRange:isExact?>
<?FM MARKER [Index] isExact?>
isExact()
public boolean isExact ( ) 
	
Returns whether this version range contains only a single version. 
	Returns	true if this version range contains only a single version;
false otherwise.
<?FM MARKER [Cross-Ref] VersionRange.toFilterString(String)?>
<?FM MARKER [Index] VersionRange:toFilterString?>
<?FM MARKER [Index] toFilterString?>
toFilterString(String)
public String toFilterString ( String attributeName ) 
	attributeName	The attribute name to use in the returned filter
string.
	
Returns the filter string for this version range using the specified
attribute name. 
	Returns	A filter string for this version range using the specified
attribute name.
	Throws	IllegalArgumentException –  If the specified attribute name
is not a valid attribute name. 
	See Also	Core Specification, Filters, for a description of the
filter string syntax.
<?FM MARKER [Cross-Ref] VersionRange.toString()?>
<?FM MARKER [Index] VersionRange:toString?>
<?FM MARKER [Index] toString?>
toString()
public String toString ( ) 
	
Returns the string representation of this version range.  
The format of the version range string will be a version string
if the right end point is Infinity (null) or an interval string.
	Returns	The string representation of this version range.

</INSET><INSET xml:id="i3907115">org.osgi.framework.launch<?FM MARKER [Cross-Ref] org.osgi.framework.launch?>
<?FM MARKER [Index] org.osgi.framework.launch?>
<?FM MARKER [Cross-Ref] package:org.osgi.framework.launch?>

Framework Launch Package Version 1.1. 
Bundles wishing to use this package must list the package in the
Import-Package header of the bundle’s manifest. 
Example import for consumers using the API in this package: 
Import-Package: org.osgi.framework.launch; version=”[1.1,2.0)”
Summary
Framework –  A Framework instance. 
FrameworkFactory –  A factory for creating Framework instances. 
Permissions
<?FM MARKER [Cross-Ref] Framework?>
<?FM MARKER [Index] Framework?>
<?FM MARKER [Index] interface:Framework?>
Framework
public interface Framework
	extends Bundle
A Framework instance. A Framework is also known as a System Bundle.
 
Framework instances are created using a FrameworkFactory. The methods
of this interface can be used to manage and control the created
framework instance.
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] Framework.adapt(Class)?>
<?FM MARKER [Index] Framework:adapt?>
<?FM MARKER [Index] adapt?>
adapt(Class)
public A adapt ( Class&lt;A&gt; type ) 
	Type Arguments	&lt;A&gt;
	&lt;A&gt;	The type to which this Framework is to be adapted.
	type	Class object for the type to which this Framework is to be
adapted.
	
Adapt this Framework to the specified type.  
Adapting this Framework to the specified type may require certain
checks, including security checks, to succeed. If a check does not
succeed, then this Framework cannot be adapted and null is returned. If
this Framework is not initialized, then null is returned if the
specified type is one of the OSGi defined types to which a system
bundle can be adapted.
	Returns	The object, of the specified type, to which this Framework
has been adapted or null if this Framework cannot be adapted
<?FM MARKER [Cross-Ref] Framework.findEntries(String,String,boolean)?>
<?FM MARKER [Index] Framework:findEntries?>
<?FM MARKER [Index] findEntries?>
findEntries(String,String,boolean)
public Enumeration&lt;URL&gt; findEntries ( String path , String filePattern
, boolean recurse ) 
	path	Ignored.
	filePattern	Ignored.
	recurse	Ignored.
	
Returns null as a framework implementation does not have a proper
bundle from which to return entries. 
	Returns	null as a framework implementation does not have a proper
bundle from which to return entries.
<?FM MARKER [Cross-Ref] Framework.getBundleId()?>
<?FM MARKER [Index] Framework:getBundleId?>
<?FM MARKER [Index] getBundleId?>
getBundleId()
public long getBundleId ( ) 
	
Returns the Framework unique identifier. This Framework is assigned
the unique identifier zero (0) since this Framework is also a System
Bundle. 
	Returns	0.
	See Also	Bundle.getBundleId()
<?FM MARKER [Cross-Ref] Framework.getEntry(String)?>
<?FM MARKER [Index] Framework:getEntry?>
<?FM MARKER [Index] getEntry?>
getEntry(String)
public URL getEntry ( String path ) 
	path	Ignored.
	
Returns null as a framework implementation does not have a proper
bundle from which to return an entry. 
	Returns	null as a framework implementation does not have a proper
bundle from which to return an entry.
<?FM MARKER [Cross-Ref] Framework.getEntryPaths(String)?>
<?FM MARKER [Index] Framework:getEntryPaths?>
<?FM MARKER [Index] getEntryPaths?>
getEntryPaths(String)
public Enumeration&lt;String&gt; getEntryPaths ( String path ) 
	path	Ignored.
	
Returns null as a framework implementation does not have a proper
bundle from which to return entry paths. 
	Returns	null as a framework implementation does not have a proper
bundle from which to return entry paths.
<?FM MARKER [Cross-Ref] Framework.getLocation()?>
<?FM MARKER [Index] Framework:getLocation?>
<?FM MARKER [Index] getLocation?>
getLocation()
public String getLocation ( ) 
	
Returns the Framework location identifier. This Framework is assigned
the unique location “System Bundle“ since this Framework is also
a System Bundle. 
	Returns	The string “System Bundle“.
	Throws	SecurityException –  If the caller does not have the appropriate
AdminPermission[this,METADATA], and the Java Runtime Environment
supports permissions. 
	See Also	Bundle.getLocation() , Constants.SYSTEM_BUNDLE_LOCATION
<?FM MARKER [Cross-Ref] Framework.getSymbolicName()?>
<?FM MARKER [Index] Framework:getSymbolicName?>
<?FM MARKER [Index] getSymbolicName?>
getSymbolicName()
public String getSymbolicName ( ) 
	
Returns the symbolic name of this Framework. The symbolic name is
unique for the implementation of the framework. However, the symbolic
name “system.bundle“ must be recognized as an alias to the implementation-defined
symbolic name since this Framework is also a System Bundle. 
	Returns	The symbolic name of this Framework.
	See Also	Bundle.getSymbolicName() , Constants.SYSTEM_BUNDLE_SYMBOLICNAME
<?FM MARKER [Cross-Ref] Framework.init()?>
<?FM MARKER [Index] Framework:init?>
<?FM MARKER [Index] init?>
init()
public void init ( ) throws BundleException
	
Initialize this Framework. After calling this method, this Framework
must: 
Have generated a new framework UUID. 
Be in the STARTING state.
Have a valid Bundle Context.
Be at start level 0.
Have event handling enabled.
Have reified Bundle objects for all installed bundles.
Have registered any framework services. For example, ConditionalPermissionAdmin.
Be adaptable to the OSGi defined types to which a system bundle
can be adapted.
This Framework will not actually be started until start is called.
 
This method does nothing if called when this Framework is in the
STARTING, ACTIVE or STOPPING states.
	Throws	BundleException –  If this Framework could not be initialized. 
		SecurityException –  If the Java Runtime Environment supports
permissions and the caller does not have the appropriate AdminPermission[this,EXECUTE]
or if there is a security manager already installed and the Constants.FRAMEWORK_SECURITY
configuration property is set. 
<?FM MARKER [Cross-Ref] Framework.start()?>
<?FM MARKER [Index] Framework:start?>
<?FM MARKER [Index] start?>
start()
public void start ( ) throws BundleException
	
Start this Framework.  
The following steps are taken to start this Framework: 
If this Framework is not in the STARTING state, initialize this
Framework.
All installed bundles must be started in accordance with each bundle’s
persistent autostart setting. This means some bundles will not be
started, some will be started with eager activation and some will
be started with their declared activation policy. The start level
of this Framework is moved to the start level specified by the beginning
start level framework property, as described in the Start Level
Specification. If this framework property is not specified, then
the start level of this Framework is moved to start level one (1).
Any exceptions that occur during bundle starting must be wrapped
in a BundleException and then published as a framework event of
type FrameworkEvent.ERROR
This Framework’s state is set to ACTIVE.
A framework event of type FrameworkEvent.STARTED is fired
	Throws	BundleException –  If this Framework could not be started. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,EXECUTE], and the Java Runtime Environment
supports permissions. 
	See Also	Start Level Specification
<?FM MARKER [Cross-Ref] Framework.start(int)?>
<?FM MARKER [Index] Framework:start?>
<?FM MARKER [Index] start?>
start(int)
public void start ( int options )  throws BundleException
	options	Ignored. There are no start options for the Framework.
	
Start this Framework.  
Calling this method is the same as calling start(). There are no
start options for the Framework.
	Throws	BundleException –  If this Framework could not be started. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,EXECUTE], and the Java Runtime Environment
supports permissions. 
	See Also	start()
<?FM MARKER [Cross-Ref] Framework.stop()?>
<?FM MARKER [Index] Framework:stop?>
<?FM MARKER [Index] stop?>
stop()
public void stop ( ) throws BundleException
	
Stop this Framework.  
The method returns immediately to the caller after initiating the
following steps to be taken on another thread. 
This Framework’s state is set to STOPPING.
All installed bundles must be stopped without changing each bundle’s
persistent autostart setting. The start level of this Framework
is moved to start level zero (0), as described in the Start Level
Specification. Any exceptions that occur during bundle stopping
must be wrapped in a BundleException and then published as a framework
event of type FrameworkEvent.ERROR
Unregister all services registered by this Framework.
Event handling is disabled.
This Framework’s state is set to RESOLVED.
All resources held by this Framework are released. This includes
threads, bundle class loaders, open files, etc.
Notify all threads that are waiting at waitForStop that the stop
operation has completed.
After being stopped, this Framework may be discarded, initialized
or started.
	Throws	BundleException –  If stopping this Framework could not
be initiated. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,EXECUTE], and the Java Runtime Environment
supports permissions. 
	See Also	Start Level Specification
<?FM MARKER [Cross-Ref] Framework.stop(int)?>
<?FM MARKER [Index] Framework:stop?>
<?FM MARKER [Index] stop?>
stop(int)
public void stop ( int options ) throws BundleException
	options	Ignored. There are no stop options for the Framework.
	
Stop this Framework.  
Calling this method is the same as calling stop(). There are no
stop options for the Framework.
	Throws	BundleException –  If stopping this Framework could not
be initiated. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,EXECUTE], and the Java Runtime Environment
supports permissions. 
	See Also	stop()
<?FM MARKER [Cross-Ref] Framework.uninstall()?>
<?FM MARKER [Index] Framework:uninstall?>
<?FM MARKER [Index] uninstall?>
uninstall()
public void uninstall ( ) throws BundleException
	
The Framework cannot be uninstalled.  
This method always throws a BundleException.
	Throws	BundleException –  This Framework cannot be uninstalled. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,LIFECYCLE], and the Java Runtime Environment
supports permissions. 
<?FM MARKER [Cross-Ref] Framework.update()?>
<?FM MARKER [Index] Framework:update?>
<?FM MARKER [Index] update?>
update()
public void update ( ) throws BundleException
	
Stop and restart this Framework.  
The method returns immediately to the caller after initiating the
following steps to be taken on another thread. 
Perform the steps in the stop() method to stop this Framework.
Perform the steps in the start() method to start this Framework.
	Throws	BundleException –  If stopping and restarting this Framework
could not be initiated. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,LIFECYCLE], and the Java Runtime Environment
supports permissions. 
<?FM MARKER [Cross-Ref] Framework.update(InputStream)?>
<?FM MARKER [Index] Framework:update?>
<?FM MARKER [Index] update?>
update(InputStream)
public void update ( InputStream in ) throws BundleException
	in	Any provided InputStream is immediately closed before returning
from this method and otherwise ignored.
	
Stop and restart this Framework.  
Calling this method is the same as calling update() except that
any provided InputStream is immediately closed.
	Throws	BundleException –  If stopping and restarting this Framework
could not be initiated. 
		SecurityException –  If the caller does not have the appropriate
AdminPermission[this,LIFECYCLE], and the Java Runtime Environment
supports permissions. 
<?FM MARKER [Cross-Ref] Framework.waitForStop(long)?>
<?FM MARKER [Index] Framework:waitForStop?>
<?FM MARKER [Index] waitForStop?>
waitForStop(long)
public FrameworkEvent waitForStop ( long timeout ) throws InterruptedException
	timeout	Maximum number of milliseconds to wait until this Framework
has completely stopped. A value of zero will wait indefinitely.
	
Wait until this Framework has completely stopped. The stop and update
methods on a Framework performs an asynchronous stop of the Framework.
This method can be used to wait until the asynchronous stop of this
Framework has completed. This method will only wait if called when
this Framework is in the STARTING, ACTIVE, or STOPPING states. Otherwise
it will return immediately. 
A Framework Event is returned to indicate why this Framework has
stopped.
	Returns	A Framework Event indicating the reason this method returned.
The following FrameworkEvent types may be returned by this method. 
STOPPED - This Framework has been stopped. 
STOPPED_UPDATE - This Framework has been updated which has shutdown
and will now restart.
STOPPED_BOOTCLASSPATH_MODIFIED - This Framework has been stopped
and a bootclasspath extension bundle has been installed or updated.
The VM must be restarted in order for the changed boot class path
to take effect. 
ERROR - The Framework encountered an error while shutting down or
an error has occurred which forced the framework to shutdown. 
WAIT_TIMEDOUT - This method has timed out and returned before this
Framework has stopped.
	Throws	InterruptedException –  If another thread interrupted the
current thread before or while the current thread was waiting for
this Framework to completely stop. The interrupted status of the
current thread is cleared when this exception is thrown. 
		IllegalArgumentException –  If the value of timeout is negative. 
<?FM MARKER [Cross-Ref] FrameworkFactory?>
<?FM MARKER [Index] FrameworkFactory?>
<?FM MARKER [Index] interface:FrameworkFactory?>
FrameworkFactory
public interface FrameworkFactory
A factory for creating Framework instances.  
A framework implementation jar must contain the following resource:
 
 /META-INF/services/org.osgi.framework.launch.FrameworkFactory
This UTF-8 encoded resource must contain the name of the framework
implementation’s FrameworkFactory implementation class. Space and
tab characters, including blank lines, in the resource must be ignored.
The number sign (‘#’ \u0023) and all characters following it on
each line are a comment and must be ignored. 
Launchers can find the name of the FrameworkFactory implementation
class in the resource and then load and construct a FrameworkFactory
object for the framework implementation. The FrameworkFactory implementation
class must have a public, no-argument constructor. Java™  SE 6 introduced
the ServiceLoader class which can create a FrameworkFactory instance
from the resource.
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] FrameworkFactory.newFramework(Map)?>
<?FM MARKER [Index] FrameworkFactory:newFramework?>
<?FM MARKER [Index] newFramework?>
newFramework(Map)
public Framework newFramework ( Map&lt;String,String&gt; configuration
) 
	configuration	The framework properties to configure the new framework
instance. If framework properties are not provided by the configuration
argument, the created framework instance must use some reasonable default
configuration appropriate for the current VM. For example, the system
packages for the current execution environment should be properly
exported. The specified configuration argument may be null. The
created framework instance must copy any information needed from
the specified configuration argument since the configuration argument
can be changed after the framework instance has been created.
	
Create a new Framework instance. 
	Returns	A new, configured Framework instance. The framework instance
must be in the Bundle.INSTALLED state.
	Throws	SecurityException –  If the caller does not have AllPermission,
and the Java Runtime Environment supports permissions. 

</INSET><INSET xml:id="i3907356"><phrase role="body">org.osgi.resource<?FM MARKER [Cross-Ref] org.osgi.resource?>
<?FM MARKER [Index] org.osgi.resource?>
<?FM MARKER [Cross-Ref] package:org.osgi.resource?>

Resource Package Version 1.0.  
Bundles wishing to use this package must list the package in the
Import-Package header of the bundle’s manifest. For example: 
 Import-Package: org.osgi.resource; version=”[1.0,2.0)”
Summary
Capability –  A capability that has been declared from a Resource. 
Namespace –  Capability and Requirement Namespaces base class. 
Requirement –  A requirement that has been declared from a Resource
. 
Resource –  A resource is the representation of a uniquely identified
and typed data. 
Wire –  A wire connecting a Capability to a Requirement. 
Wiring –  A wiring for a resource. 
Permissions
<?FM MARKER [Cross-Ref] Capability?>
<?FM MARKER [Index] Capability?>
<?FM MARKER [Index] interface:Capability?>
Capability
public interface Capability
A capability that has been declared from a Resource.  
Instances of this type must be effectively immutable. That is, for
a given instance of this interface, the methods defined by this
interface must always return the same result.
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] Capability.equals(Object)?>
<?FM MARKER [Index] Capability:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to compare against this Capability.
	
Compares this Capability to another Capability.  
This Capability is equal to another Capability if they have the
same namespace, directives and attributes and are declared by the
same resource.
	Returns	true if this Capability is equal to the other object; false
otherwise.
<?FM MARKER [Cross-Ref] Capability.getAttributes()?>
<?FM MARKER [Index] Capability:getAttributes?>
<?FM MARKER [Index] getAttributes?>
getAttributes()
public Map&lt;String,Object&gt; getAttributes ( ) 
	
Returns the attributes of this capability. 
	Returns	An unmodifiable map of attribute names to attribute values
for this capability, or an empty map if this capability has no attributes.
<?FM MARKER [Cross-Ref] Capability.getDirectives()?>
<?FM MARKER [Index] Capability:getDirectives?>
<?FM MARKER [Index] getDirectives?>
getDirectives()
public Map&lt;String,String&gt; getDirectives ( ) 
	
Returns the directives of this capability. 
	Returns	An unmodifiable map of directive names to directive values
for this capability, or an empty map if this capability has no directives.
<?FM MARKER [Cross-Ref] Capability.getNamespace()?>
<?FM MARKER [Index] Capability:getNamespace?>
<?FM MARKER [Index] getNamespace?>
getNamespace()
public String getNamespace ( ) 
	
Returns the namespace of this capability. 
	Returns	The namespace of this capability.
<?FM MARKER [Cross-Ref] Capability.getResource()?>
<?FM MARKER [Index] Capability:getResource?>
<?FM MARKER [Index] getResource?>
getResource()
public Resource getResource ( ) 
	
Returns the resource declaring this capability. 
	Returns	The resource declaring this capability.
<?FM MARKER [Cross-Ref] Capability.hashCode()?>
<?FM MARKER [Index] Capability:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hashCode of this Capability. 
	Returns	The hashCode of this Capability.
<?FM MARKER [Cross-Ref] Namespace?>
<?FM MARKER [Index] Namespace?>
<?FM MARKER [Index] class:Namespace?>
Namespace
public abstract class Namespace
Capability and Requirement Namespaces base class.  
This class is the common class shared by all OSGi defined namespaces.
It defines the names for the common attributes and directives for
the OSGi specified namespaces.  
The OSGi Alliance reserves the right to extend the set of directives
and attributes which have specified semantics for all of the specified
namespaces. 
The values associated with these keys are of type String, unless
otherwise indicated.
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] Namespace.CAPABILITY_EFFECTIVE_DIRECTIVE?>
<?FM MARKER [Index] Namespace:CAPABILITY_EFFECTIVE_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_EFFECTIVE_DIRECTIVE?>
CAPABILITY_EFFECTIVE_DIRECTIVE
public static final String CAPABILITY_EFFECTIVE_DIRECTIVE = “effective”<?FM MARKER [Index] effective?>

The capability directive used to specify the effective time for
the capability. The default value is resolve. 
	See Also	resolve , active
<?FM MARKER [Cross-Ref] Namespace.CAPABILITY_USES_DIRECTIVE?>
<?FM MARKER [Index] Namespace:CAPABILITY_USES_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_USES_DIRECTIVE?>
CAPABILITY_USES_DIRECTIVE
public static final String CAPABILITY_USES_DIRECTIVE = “uses”<?FM MARKER [Index] uses?>

The capability directive used to specify the comma separated list
of package names used by a capability. 
<?FM MARKER [Cross-Ref] Namespace.CARDINALITY_MULTIPLE?>
<?FM MARKER [Index] Namespace:CARDINALITY_MULTIPLE?>
<?FM MARKER [Index] CARDINALITY_MULTIPLE?>
CARDINALITY_MULTIPLE
public static final String CARDINALITY_MULTIPLE = “multiple”<?FM MARKER [Index] multiple?>

The directive value identifying a multiple cardinality type. 
	See Also	REQUIREMENT_CARDINALITY_DIRECTIVE
<?FM MARKER [Cross-Ref] Namespace.CARDINALITY_SINGLE?>
<?FM MARKER [Index] Namespace:CARDINALITY_SINGLE?>
<?FM MARKER [Index] CARDINALITY_SINGLE?>
CARDINALITY_SINGLE
public static final String CARDINALITY_SINGLE = “single”<?FM MARKER [Index] single?>

The directive value identifying a cardinality type of single. 
	See Also	REQUIREMENT_CARDINALITY_DIRECTIVE
<?FM MARKER [Cross-Ref] Namespace.EFFECTIVE_ACTIVE?>
<?FM MARKER [Index] Namespace:EFFECTIVE_ACTIVE?>
<?FM MARKER [Index] EFFECTIVE_ACTIVE?>
EFFECTIVE_ACTIVE
public static final String EFFECTIVE_ACTIVE = “active”<?FM MARKER [Index] active?>

The directive value identifying a capability or requirement that
is effective at active time. Capabilities and requirements with
an effective time of active are ignored while resolving a resource. 
	See Also	REQUIREMENT_EFFECTIVE_DIRECTIVE , CAPABILITY_EFFECTIVE_DIRECTIVE
<?FM MARKER [Cross-Ref] Namespace.EFFECTIVE_RESOLVE?>
<?FM MARKER [Index] Namespace:EFFECTIVE_RESOLVE?>
<?FM MARKER [Index] EFFECTIVE_RESOLVE?>
EFFECTIVE_RESOLVE
public static final String EFFECTIVE_RESOLVE = “resolve”<?FM MARKER [Index] resolve?>

The directive value identifying a capability or requirement that
is effective at resolve time. Capabilities and requirements with
an effective time of resolve are the only capabilities which are
processed while resolving a resource. 
	See Also	REQUIREMENT_EFFECTIVE_DIRECTIVE , CAPABILITY_EFFECTIVE_DIRECTIVE
<?FM MARKER [Cross-Ref] Namespace.REQUIREMENT_CARDINALITY_DIRECTIVE?>
<?FM MARKER [Index] Namespace:REQUIREMENT_CARDINALITY_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_CARDINALITY_DIRECTIVE?>
REQUIREMENT_CARDINALITY_DIRECTIVE
public static final String REQUIREMENT_CARDINALITY_DIRECTIVE = “cardinality”<?FM MARKER [Index] cardinality?>

The requirement directive used to specify the cardinality for a
requirement. The default value is single. 
	See Also	multiple , single
<?FM MARKER [Cross-Ref] Namespace.REQUIREMENT_EFFECTIVE_DIRECTIVE?>
<?FM MARKER [Index] Namespace:REQUIREMENT_EFFECTIVE_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_EFFECTIVE_DIRECTIVE?>
REQUIREMENT_EFFECTIVE_DIRECTIVE
public static final String REQUIREMENT_EFFECTIVE_DIRECTIVE = “effective”<?FM MARKER [Index] effective?>

The requirement directive used to specify the effective time for
the requirement. The default value is resolve. 
	See Also	resolve , active
<?FM MARKER [Cross-Ref] Namespace.REQUIREMENT_FILTER_DIRECTIVE?>
<?FM MARKER [Index] Namespace:REQUIREMENT_FILTER_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_FILTER_DIRECTIVE?>
REQUIREMENT_FILTER_DIRECTIVE
public static final String REQUIREMENT_FILTER_DIRECTIVE = “filter”<?FM MARKER [Index] filter?>

The requirement directive used to specify a capability filter. This
filter is used to match against a capability’s attributes. 
<?FM MARKER [Cross-Ref] Namespace.REQUIREMENT_RESOLUTION_DIRECTIVE?>
<?FM MARKER [Index] Namespace:REQUIREMENT_RESOLUTION_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_RESOLUTION_DIRECTIVE?>
REQUIREMENT_RESOLUTION_DIRECTIVE
public static final String REQUIREMENT_RESOLUTION_DIRECTIVE = “resolution”<?FM MARKER [Index] resolution?>

The requirement directive used to specify the resolution type for
a requirement. The default value is mandatory . 
	See Also	mandatory , optional
<?FM MARKER [Cross-Ref] Namespace.RESOLUTION_MANDATORY?>
<?FM MARKER [Index] Namespace:RESOLUTION_MANDATORY?>
<?FM MARKER [Index] RESOLUTION_MANDATORY?>
RESOLUTION_MANDATORY
public static final String RESOLUTION_MANDATORY = “mandatory”<?FM MARKER [Index] mandatory?>

The directive value identifying a mandatory requirement resolution
type. A mandatory resolution type indicates that the requirement
must be resolved when the resource is resolved. If such a requirement
cannot be resolved, the resource fails to resolve. 
	See Also	REQUIREMENT_RESOLUTION_DIRECTIVE
<?FM MARKER [Cross-Ref] Namespace.RESOLUTION_OPTIONAL?>
<?FM MARKER [Index] Namespace:RESOLUTION_OPTIONAL?>
<?FM MARKER [Index] RESOLUTION_OPTIONAL?>
RESOLUTION_OPTIONAL
public static final String RESOLUTION_OPTIONAL = “optional”<?FM MARKER [Index] optional?>

The directive value identifying an optional requirement resolution
type. An optional resolution type indicates that the requirement
is optional and the resource may be resolved without the requirement being
resolved. 
	See Also	REQUIREMENT_RESOLUTION_DIRECTIVE
<?FM MARKER [Cross-Ref] Namespace.Namespace()?>
<?FM MARKER [Index] Namespace:Namespace?>
<?FM MARKER [Index] Namespace?>
Namespace()
protected Namespace ( ) 
	
Protected constructor for Namespace sub-types. 
<?FM MARKER [Cross-Ref] Requirement?>
<?FM MARKER [Index] Requirement?>
<?FM MARKER [Index] interface:Requirement?>
Requirement
public interface Requirement
A requirement that has been declared from a Resource .  
Instances of this type must be effectively immutable. That is, for
a given instance of this interface, the methods defined by this
interface must always return the same result.
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] Requirement.equals(Object)?>
<?FM MARKER [Index] Requirement:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to compare against this Requirement.
	
Compares this Requirement to another Requirement.  
This Requirement is equal to another Requirement if they have the
same namespace, directives and attributes and are declared by the
same resource.
	Returns	true if this Requirement is equal to the other object;
false otherwise.
<?FM MARKER [Cross-Ref] Requirement.getAttributes()?>
<?FM MARKER [Index] Requirement:getAttributes?>
<?FM MARKER [Index] getAttributes?>
getAttributes()
public Map&lt;String,Object&gt; getAttributes ( ) 
	
Returns the attributes of this requirement.  
Requirement attributes have no specified semantics and are considered
extra user defined information.
	Returns	An unmodifiable map of attribute names to attribute values
for this requirement, or an empty map if this requirement has no
attributes.
<?FM MARKER [Cross-Ref] Requirement.getDirectives()?>
<?FM MARKER [Index] Requirement:getDirectives?>
<?FM MARKER [Index] getDirectives?>
getDirectives()
public Map&lt;String,String&gt; getDirectives ( ) 
	
Returns the directives of this requirement. 
	Returns	An unmodifiable map of directive names to directive values
for this requirement, or an empty map if this requirement has no
directives.
<?FM MARKER [Cross-Ref] Requirement.getNamespace()?>
<?FM MARKER [Index] Requirement:getNamespace?>
<?FM MARKER [Index] getNamespace?>
getNamespace()
public String getNamespace ( ) 
	
Returns the namespace of this requirement. 
	Returns	The namespace of this requirement.
<?FM MARKER [Cross-Ref] Requirement.getResource()?>
<?FM MARKER [Index] Requirement:getResource?>
<?FM MARKER [Index] getResource?>
getResource()
public Resource getResource ( ) 
	
Returns the resource declaring this requirement. 
	Returns	The resource declaring this requirement. This can be null
if this requirement is synthesized.
<?FM MARKER [Cross-Ref] Requirement.hashCode()?>
<?FM MARKER [Index] Requirement:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hashCode of this Requirement. 
	Returns	The hashCode of this Requirement.
<?FM MARKER [Cross-Ref] Resource?>
<?FM MARKER [Index] Resource?>
<?FM MARKER [Index] interface:Resource?>
Resource
public interface Resource
A resource is the representation of a uniquely identified and typed
data. A resource declares requirements that need to be satisfied
by capabilities before it can provide its capabilities.  
Instances of this type must be effectively immutable. That is, for
a given instance of this interface, the methods defined by this
interface must always return the same result.
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] Resource.equals(Object)?>
<?FM MARKER [Index] Resource:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to compare against this Resource.
	
Compares this Resource to another Resource.  
This Resource is equal to another Resource if both have the same
content and come from the same location. Location may be defined
as the bundle location if the resource is an installed bundle or
the repository location if the resource is in a repository.
	Returns	true if this Resource is equal to the other object; false
otherwise.
<?FM MARKER [Cross-Ref] Resource.getCapabilities(String)?>
<?FM MARKER [Index] Resource:getCapabilities?>
<?FM MARKER [Index] getCapabilities?>
getCapabilities(String)
public List&lt;Capability&gt; getCapabilities ( String namespace ) 
	namespace	The namespace of the declared capabilities to return
or null to return the declared capabilities from all namespaces.
	
Returns the capabilities declared by this resource. 
	Returns	An unmodifiable list containing the declared Capabilitys
from the specified namespace. The returned list will be empty if
this resource declares no capabilities in the specified namespace.
<?FM MARKER [Cross-Ref] Resource.getRequirements(String)?>
<?FM MARKER [Index] Resource:getRequirements?>
<?FM MARKER [Index] getRequirements?>
getRequirements(String)
public List&lt;Requirement&gt; getRequirements ( String namespace ) 
	namespace	The namespace of the declared requirements to return
or null to return the declared requirements from all namespaces.
	
Returns the requirements declared by this bundle resource. 
	Returns	An unmodifiable list containing the declared Requirement
s from the specified namespace. The returned list will be empty
if this resource declares no requirements in the specified namespace.
<?FM MARKER [Cross-Ref] Resource.hashCode()?>
<?FM MARKER [Index] Resource:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hashCode of this Resource. 
	Returns	The hashCode of this Resource.
<?FM MARKER [Cross-Ref] Wire?>
<?FM MARKER [Index] Wire?>
<?FM MARKER [Index] interface:Wire?>
Wire
public interface Wire
A wire connecting a Capability to a Requirement.  
Instances of this type must be effectively immutable. That is, for
a given instance of this interface, the methods defined by this
interface must always return the same result.
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] Wire.equals(Object)?>
<?FM MARKER [Index] Wire:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object to compare against this Wire.
	
Compares this Wire to another Wire.  
This Wire is equal to another Wire if they have the same capability,
requirement, provider and requirer.
	Returns	true if this Wire is equal to the other object; false otherwise.
<?FM MARKER [Cross-Ref] Wire.getCapability()?>
<?FM MARKER [Index] Wire:getCapability?>
<?FM MARKER [Index] getCapability?>
getCapability()
public Capability getCapability ( ) 
	
Returns the Capability for this wire. 
	Returns	The Capability for this wire.
<?FM MARKER [Cross-Ref] Wire.getProvider()?>
<?FM MARKER [Index] Wire:getProvider?>
<?FM MARKER [Index] getProvider?>
getProvider()
public Resource getProvider ( ) 
	
Returns the resource providing the capability.  
The returned resource may differ from the resource referenced by
the capability.
	Returns	The resource providing the capability.
<?FM MARKER [Cross-Ref] Wire.getRequirement()?>
<?FM MARKER [Index] Wire:getRequirement?>
<?FM MARKER [Index] getRequirement?>
getRequirement()
public Requirement getRequirement ( ) 
	
Returns the Requirement for this wire. 
	Returns	The Requirement for this wire.
<?FM MARKER [Cross-Ref] Wire.getRequirer()?>
<?FM MARKER [Index] Wire:getRequirer?>
<?FM MARKER [Index] getRequirer?>
getRequirer()
public Resource getRequirer ( ) 
	
Returns the resource who requires the capability.  
The returned resource may differ from the resource referenced by
the requirement.
	Returns	The resource who requires the capability.
<?FM MARKER [Cross-Ref] Wire.hashCode()?>
<?FM MARKER [Index] Wire:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hashCode of this Wire. 
	Returns	The hashCode of this Wire.
<?FM MARKER [Cross-Ref] Wiring?>
<?FM MARKER [Index] Wiring?>
<?FM MARKER [Index] interface:Wiring?>
Wiring
public interface Wiring
A wiring for a resource. A wiring is associated with a resource
and represents the dependencies with other wirings. 
Instances of this type must be effectively immutable. That is, for
a given instance of this interface, the methods defined by this
interface must always return the same result.
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] Wiring.getProvidedResourceWires(String)?>
<?FM MARKER [Index] Wiring:getProvidedResourceWires?>
<?FM MARKER [Index] getProvidedResourceWires?>
getProvidedResourceWires(String)
public List&lt;Wire&gt; getProvidedResourceWires ( String namespace
) 
	namespace	The namespace of the capabilities for which to return
wires or null to return the wires for the capabilities in all namespaces.
	
Returns the Wires to the provided capabilities of this wiring. 
	Returns	A list containing a snapshot of the Wires for the capabilities
of this wiring, or an empty list if this wiring has no capabilities
in the specified namespace. For a given namespace, the list contains
the wires in the order the capabilities were specified in the manifests
of the resource and the attached fragment resources of this wiring.
There is no ordering defined between capabilities in different namespaces.
<?FM MARKER [Cross-Ref] Wiring.getRequiredResourceWires(String)?>
<?FM MARKER [Index] Wiring:getRequiredResourceWires?>
<?FM MARKER [Index] getRequiredResourceWires?>
getRequiredResourceWires(String)
public List&lt;Wire&gt; getRequiredResourceWires ( String namespace
) 
	namespace	The namespace of the requirements for which to return
wires or null to return the wires for the requirements in all namespaces.
	
Returns the Wires to the requirements in use by this wiring. 
	Returns	A list containing a snapshot of the Wires for the requirements
of this wiring, or an empty list if this wiring has no requirements
in the specified namespace. For a given namespace, the list contains
the wires in the order the requirements were specified in the manifests
of the resource and the attached fragment resources of this wiring.
There is no ordering defined between requirements in different namespaces.
<?FM MARKER [Cross-Ref] Wiring.getResource()?>
<?FM MARKER [Index] Wiring:getResource?>
<?FM MARKER [Index] getResource?>
getResource()
public Resource getResource ( ) 
	
Returns the resource associated with this wiring. 
	Returns	The resource associated with this wiring.
<?FM MARKER [Cross-Ref] Wiring.getResourceCapabilities(String)?>
<?FM MARKER [Index] Wiring:getResourceCapabilities?>
<?FM MARKER [Index] getResourceCapabilities?>
getResourceCapabilities(String)
public List&lt;Capability&gt; getResourceCapabilities ( String namespace
) 
	namespace	The namespace of the capabilities to return or null to
return the capabilities from all namespaces.
	
Returns the capabilities provided by this wiring.  
Only capabilities considered by the resolver are returned. For example,
capabilities with effective directive not equal to resolve are not
returned.  
A capability may not be required by any wiring and thus there may
be no wires for the capability.  
A wiring for a non-fragment resource provides a subset of the declared
capabilities from the resource and all attached fragment resources†
. Not all declared capabilities may be provided since some may be
discarded. For example, if a package is declared to be both exported
and imported, only one is selected and the other is discarded. 
A wiring for a fragment resource with a symbolic name must provide
exactly one osgi.identity capability. 
† The osgi.identity capability provided by attached fragment resource
must not be included in the capabilities of the host wiring.
	Returns	A list containing a snapshot of the Capabilitys, or an
empty list if this wiring provides no capabilities in the specified
namespace. For a given namespace, the list contains the wires in the
order the capabilities were specified in the manifests of the resource
and the attached fragment resources†  of this wiring. There is no
ordering defined between capabilities in different namespaces.
<?FM MARKER [Cross-Ref] Wiring.getResourceRequirements(String)?>
<?FM MARKER [Index] Wiring:getResourceRequirements?>
<?FM MARKER [Index] getResourceRequirements?>
getResourceRequirements(String)
public List&lt;Requirement&gt; getResourceRequirements ( String namespace
) 
	namespace	The namespace of the requirements to return or null to
return the requirements from all namespaces.
	
Returns the requirements of this wiring.  
Only requirements considered by the resolver are returned. For example,
requirements with effective directive not equal to resolve are not
returned.  
A wiring for a non-fragment resource has a subset of the declared
requirements from the resource and all attached fragment resources.
Not all declared requirements may be present since some may be discarded.
For example, if a package is declared to be optionally imported
and is not actually imported, the requirement must be discarded.
	Returns	A list containing a snapshot of the Requirements, or an
empty list if this wiring uses no requirements in the specified
namespace. For a given namespace, the list contains the wires in
the order the requirements were specified in the manifests of the
resource and the attached fragment resources of this wiring. There
is no ordering defined between requirements in different namespaces.

</phrase></INSET><INSET xml:id="i3907769"><phrase role="body">org.osgi.framework.wiring<?FM MARKER [Cross-Ref] org.osgi.framework.wiring?>
<?FM MARKER [Index] org.osgi.framework.wiring?>
<?FM MARKER [Cross-Ref] package:org.osgi.framework.wiring?>

Framework Wiring Package Version 1.1.  
Bundles wishing to use this package must list the package in the
Import-Package header of the bundle’s manifest. For example: 
 Import-Package: org.osgi.framework.wiring; version=”[1.1,2.0)”
Summary
BundleCapability –  A capability that has been declared from a bundle
revision. 
BundleRequirement –  A requirement that has been declared from a
bundle revision. 
BundleRevision –  Bundle Revision. 
BundleRevisions –  The bundle revisions of a bundle. 
BundleWire –  A wire connecting a BundleCapability to a BundleRequirement. 
BundleWiring –  A wiring for a bundle. 
FrameworkWiring –  Query and modify wiring information for the framework. 
Permissions
<?FM MARKER [Cross-Ref] BundleCapability?>
<?FM MARKER [Index] BundleCapability?>
<?FM MARKER [Index] interface:BundleCapability?>
BundleCapability
public interface BundleCapability
	extends Capability
A capability that has been declared from a bundle revision. 
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleCapability.getAttributes()?>
<?FM MARKER [Index] BundleCapability:getAttributes?>
<?FM MARKER [Index] getAttributes?>
getAttributes()
public Map&lt;String,Object&gt; getAttributes ( ) 
	
Returns the attributes of this capability. 
	Returns	An unmodifiable map of attribute names to attribute values
for this capability, or an empty map if this capability has no attributes.
<?FM MARKER [Cross-Ref] BundleCapability.getDirectives()?>
<?FM MARKER [Index] BundleCapability:getDirectives?>
<?FM MARKER [Index] getDirectives?>
getDirectives()
public Map&lt;String,String&gt; getDirectives ( ) 
	
Returns the directives of this capability.  
All capability directives not specified by the wiring namespaces
have no specified semantics and are considered extra user defined
information.
	Returns	An unmodifiable map of directive names to directive values
for this capability, or an empty map if this capability has no directives.
<?FM MARKER [Cross-Ref] BundleCapability.getNamespace()?>
<?FM MARKER [Index] BundleCapability:getNamespace?>
<?FM MARKER [Index] getNamespace?>
getNamespace()
public String getNamespace ( ) 
	
Returns the namespace of this capability. 
	Returns	The namespace of this capability.
<?FM MARKER [Cross-Ref] BundleCapability.getResource()?>
<?FM MARKER [Index] BundleCapability:getResource?>
<?FM MARKER [Index] getResource?>
getResource()
public BundleRevision getResource ( ) 
	
Returns the resource declaring this capability.  
This method returns the same value as getRevision().
	Returns	The resource declaring this capability.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleCapability.getRevision()?>
<?FM MARKER [Index] BundleCapability:getRevision?>
<?FM MARKER [Index] getRevision?>
getRevision()
public BundleRevision getRevision ( ) 
	
Returns the bundle revision declaring this capability. 
	Returns	The bundle revision declaring this capability.
<?FM MARKER [Cross-Ref] BundleRequirement?>
<?FM MARKER [Index] BundleRequirement?>
<?FM MARKER [Index] interface:BundleRequirement?>
BundleRequirement
public interface BundleRequirement
	extends Requirement
A requirement that has been declared from a bundle revision. 
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleRequirement.getAttributes()?>
<?FM MARKER [Index] BundleRequirement:getAttributes?>
<?FM MARKER [Index] getAttributes?>
getAttributes()
public Map&lt;String,Object&gt; getAttributes ( ) 
	
Returns the attributes of this requirement.  
Requirement attributes have no specified semantics and are considered
extra user defined information.
	Returns	An unmodifiable map of attribute names to attribute values
for this requirement, or an empty map if this requirement has no
attributes.
<?FM MARKER [Cross-Ref] BundleRequirement.getDirectives()?>
<?FM MARKER [Index] BundleRequirement:getDirectives?>
<?FM MARKER [Index] getDirectives?>
getDirectives()
public Map&lt;String,String&gt; getDirectives ( ) 
	
Returns the directives of this requirement.  
All requirement directives not specified by the wiring namespaces
have no specified semantics and are considered extra user defined
information.
	Returns	An unmodifiable map of directive names to directive values
for this requirement, or an empty map if this requirement has no
directives.
<?FM MARKER [Cross-Ref] BundleRequirement.getNamespace()?>
<?FM MARKER [Index] BundleRequirement:getNamespace?>
<?FM MARKER [Index] getNamespace?>
getNamespace()
public String getNamespace ( ) 
	
Returns the namespace of this requirement. 
	Returns	The namespace of this requirement.
<?FM MARKER [Cross-Ref] BundleRequirement.getResource()?>
<?FM MARKER [Index] BundleRequirement:getResource?>
<?FM MARKER [Index] getResource?>
getResource()
public BundleRevision getResource ( ) 
	
Returns the resource declaring this requirement.  
This method returns the same value as getRevision().
	Returns	The resource declaring this requirement. This can be null
if this requirement is synthesized.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleRequirement.getRevision()?>
<?FM MARKER [Index] BundleRequirement:getRevision?>
<?FM MARKER [Index] getRevision?>
getRevision()
public BundleRevision getRevision ( ) 
	
Returns the bundle revision declaring this requirement. 
	Returns	The bundle revision declaring this requirement.
<?FM MARKER [Cross-Ref] BundleRequirement.matches(BundleCapability)?>
<?FM MARKER [Index] BundleRequirement:matches?>
<?FM MARKER [Index] matches?>
matches(BundleCapability)
public boolean matches ( BundleCapability capability ) 
	capability	The capability to match to this requirement.
	
Returns whether the specified capability matches this requirement. 
	Returns	true if the specified capability has the same namespace
as this requirement and the filter for this requirement matches
the attributes of the specified capability; false otherwise.
<?FM MARKER [Cross-Ref] BundleRevision?>
<?FM MARKER [Index] BundleRevision?>
<?FM MARKER [Index] interface:BundleRevision?>
BundleRevision
public interface BundleRevision
	extends BundleReference , Resource
Bundle Revision. When a bundle is installed and each time a bundle
is updated, a new bundle revision of the bundle is created. Since
a bundle update can change the entries in a bundle, different bundle
wirings for the same bundle can be associated with different bundle
revisions. 
For a bundle that has not been uninstalled, the most recent bundle
revision is defined to be the current bundle revision. A bundle
in the UNINSTALLED state does not have a current revision. The current
bundle revision for a bundle can be obtained by calling bundle.adapt
(BundleRevision.class). Since a bundle in the UNINSTALLED state
does not have a current revision, adapting such a bundle returns
null.  
The framework defines namespaces for package, bundle and host capabilities
and requirements. These namespaces are defined only to express wiring
information by the framework. They must not be used in Provide-Capability
and Require-Capability manifest headers.
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleRevision.BUNDLE_NAMESPACE?>
<?FM MARKER [Index] BundleRevision:BUNDLE_NAMESPACE?>
<?FM MARKER [Index] BUNDLE_NAMESPACE?>
BUNDLE_NAMESPACE
public static final String BUNDLE_NAMESPACE = “osgi.wiring.bundle”<?FM MARKER [Index] osgi.wiring.bundle?>

Namespace for bundle capabilities and requirements.  
The bundle symbolic name of the bundle is stored in the capability
attribute of the same name as this namespace (osgi.wiring.bundle).
The other directives and attributes of the bundle, from the Bundle-SymbolicName
manifest header, can be found in the cabability’s directives and
attributes. The bundle-version capability attribute must contain
the Version of the bundle from the Bundle-Version manifest header
if one is specified or Version.emptyVersion if not specified.  
A non-fragment revision declares exactly one†  bundle capability
(that is, the bundle can be required by another bundle). A fragment
revision must not declare a bundle capability.  
A bundle wiring for a non-fragment revision provides exactly one†
 bundle capability (that is, the bundle can be required by another
bundle) and requires zero or more bundle capabilities (that is, requires
other bundles). 
† A bundle with no bundle symbolic name (that is, a bundle with
Bundle-ManifestVersion &lt; 2) must not provide a bundle capability.
	See Also	BundleNamespace
<?FM MARKER [Cross-Ref] BundleRevision.HOST_NAMESPACE?>
<?FM MARKER [Index] BundleRevision:HOST_NAMESPACE?>
<?FM MARKER [Index] HOST_NAMESPACE?>
HOST_NAMESPACE
public static final String HOST_NAMESPACE = “osgi.wiring.host”<?FM MARKER [Index] osgi.wiring.host?>

Namespace for host capabilities and requirements.  
The bundle symbolic name of the bundle is stored in the capability
attribute of the same name as this namespace (osgi.wiring.host).
The other directives and attributes of the bundle, from the Bundle-SymbolicName
manifest header, can be found in the cabability’s directives and
attributes. The bundle-version capability attribute must contain
the Version of the bundle from the Bundle-Version manifest header
if one is specified or Version.emptyVersion if not specified.  
A non-fragment revision declares zero or one†  host capability if
the bundle allows fragments to be attached. A fragment revision
must declare exactly one host requirement. 
A bundle wiring for a non-fragment revision provides zero or one†
 host capability if the bundle allows fragments to be attached.
A bundle wiring for a fragment revision requires a host capability for
each host to which it is attached. 
† A bundle with no bundle symbolic name (that is, a bundle with
Bundle-ManifestVersion &lt; 2) must not provide a host capability.
	See Also	HostNamespace
<?FM MARKER [Cross-Ref] BundleRevision.PACKAGE_NAMESPACE?>
<?FM MARKER [Index] BundleRevision:PACKAGE_NAMESPACE?>
<?FM MARKER [Index] PACKAGE_NAMESPACE?>
PACKAGE_NAMESPACE
public static final String PACKAGE_NAMESPACE = “osgi.wiring.package”<?FM MARKER [Index] osgi.wiring.package?>

Namespace for package capabilities and requirements.  
The name of the package is stored in the capability attribute of
the same name as this namespace (osgi.wiring.package). The other
directives and attributes of the package, from the Export-Package manifest
header, can be found in the cabability’s directives and attributes.
The version capability attribute must contain the Version of the
package if one is specified or Version.emptyVersion if not specified.
The bundle-symbolic-name capability attribute must contain the symbolic
name of the provider if one is specified. The bundle-version capability
attribute must contain the version of the provider if one is specified
or Version.emptyVersion if not specified.  
The package capabilities provided by the system bundle, that is
the bundle with id zero, must include the package specified by the
Constants.FRAMEWORK_SYSTEMPACKAGES and Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA
framework properties as well as any other package exported by the
framework implementation. 
A bundle revision declares zero or more package capabilities (this
is, exported packages) and declares zero or more package requirements. 
A bundle wiring provides zero or more resolved package capabilities
(that is, exported packages) and requires zero or more resolved
package requirements (that is, imported packages). The number of package
wires required by a bundle wiring may change as the bundle wiring
may dynamically import additional packages.
	See Also	PackageNamespace
<?FM MARKER [Cross-Ref] BundleRevision.TYPE_FRAGMENT?>
<?FM MARKER [Index] BundleRevision:TYPE_FRAGMENT?>
<?FM MARKER [Index] TYPE_FRAGMENT?>
TYPE_FRAGMENT
public static final int TYPE_FRAGMENT = 1
Bundle revision type indicating the bundle revision is a fragment. 
	See Also	getTypes()
<?FM MARKER [Cross-Ref] BundleRevision.getCapabilities(String)?>
<?FM MARKER [Index] BundleRevision:getCapabilities?>
<?FM MARKER [Index] getCapabilities?>
getCapabilities(String)
public List&lt;Capability&gt; getCapabilities ( String namespace ) 
	namespace	The namespace of the declared capabilities to return
or null to return the declared capabilities from all namespaces.
	
Returns the capabilities declared by this resource.  
This method returns the same value as getDeclaredCapabilities(String).
	Returns	An unmodifiable list containing the declared Capabilitys
from the specified namespace. The returned list will be empty if
this resource declares no capabilities in the specified namespace.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleRevision.getDeclaredCapabilities(String)?>
<?FM MARKER [Index] BundleRevision:getDeclaredCapabilities?>
<?FM MARKER [Index] getDeclaredCapabilities?>
getDeclaredCapabilities(String)
public List&lt;BundleCapability&gt; getDeclaredCapabilities ( String
namespace ) 
	namespace	The namespace of the declared capabilities to return
or null to return the declared capabilities from all namespaces.
	
Returns the capabilities declared by this bundle revision. 
	Returns	An unmodifiable list containing the declared BundleCapabilitys
from the specified namespace. The returned list will be empty if
this bundle revision declares no capabilities in the specified namespace.
The list contains the declared capabilities in the order they are
specified in the manifest.
<?FM MARKER [Cross-Ref] BundleRevision.getDeclaredRequirements(String)?>
<?FM MARKER [Index] BundleRevision:getDeclaredRequirements?>
<?FM MARKER [Index] getDeclaredRequirements?>
getDeclaredRequirements(String)
public List&lt;BundleRequirement&gt; getDeclaredRequirements ( String
namespace ) 
	namespace	The namespace of the declared requirements to return
or null to return the declared requirements from all namespaces.
	
Returns the requirements declared by this bundle revision. 
	Returns	An unmodifiable list containing the declared BundleRequirements
from the specified namespace. The returned list will be empty if
this bundle revision declares no requirements in the specified namespace.
The list contains the declared requirements in the order they are
specified in the manifest.
<?FM MARKER [Cross-Ref] BundleRevision.getRequirements(String)?>
<?FM MARKER [Index] BundleRevision:getRequirements?>
<?FM MARKER [Index] getRequirements?>
getRequirements(String)
public List&lt;Requirement&gt; getRequirements ( String namespace ) 
	namespace	The namespace of the declared requirements to return
or null to return the declared requirements from all namespaces.
	
Returns the requirements declared by this bundle resource.  
This method returns the same value as getDeclaredRequirements(String).
	Returns	An unmodifiable list containing the declared Requirement
s from the specified namespace. The returned list will be empty
if this resource declares no requirements in the specified namespace.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleRevision.getSymbolicName()?>
<?FM MARKER [Index] BundleRevision:getSymbolicName?>
<?FM MARKER [Index] getSymbolicName?>
getSymbolicName()
public String getSymbolicName ( ) 
	
Returns the symbolic name for this bundle revision. 
	Returns	The symbolic name for this bundle revision.
	See Also	Bundle.getSymbolicName()
<?FM MARKER [Cross-Ref] BundleRevision.getTypes()?>
<?FM MARKER [Index] BundleRevision:getTypes?>
<?FM MARKER [Index] getTypes?>
getTypes()
public int getTypes ( ) 
	
Returns the special types of this bundle revision. The bundle revision
type values are: 
TYPE_FRAGMENT
A bundle revision may be more than one type at a time. A type code
is used to identify the bundle revision type for future extendability.
 
If this bundle revision is not one or more of the defined types
then 0 is returned.
	Returns	The special types of this bundle revision. The type values
are ORed together.
<?FM MARKER [Cross-Ref] BundleRevision.getVersion()?>
<?FM MARKER [Index] BundleRevision:getVersion?>
<?FM MARKER [Index] getVersion?>
getVersion()
public Version getVersion ( ) 
	
Returns the version for this bundle revision. 
	Returns	The version for this bundle revision, or Version.emptyVersion
if this bundle revision has no version information.
	See Also	Bundle.getVersion()
<?FM MARKER [Cross-Ref] BundleRevision.getWiring()?>
<?FM MARKER [Index] BundleRevision:getWiring?>
<?FM MARKER [Index] getWiring?>
getWiring()
public BundleWiring getWiring ( ) 
	
Returns the bundle wiring which is using this bundle revision. 
	Returns	The bundle wiring which is using this bundle revision or
null if no bundle wiring is using this bundle revision.
	See Also	BundleWiring.getRevision()
<?FM MARKER [Cross-Ref] BundleRevisions?>
<?FM MARKER [Index] BundleRevisions?>
<?FM MARKER [Index] interface:BundleRevisions?>
BundleRevisions
public interface BundleRevisions
	extends BundleReference
The bundle revisions of a bundle. When a bundle is installed and
each time a bundle is updated, a new bundle revision of the bundle
is created. For a bundle that has not been uninstalled, the most recent
bundle revision is defined to be the current bundle revision. A
bundle in the UNINSTALLED state does not have a current revision.
An in use bundle revision is associated with an in useBundleWiring.
The current bundle revision, if there is one, and all in use bundle
revisions are returned. 
The bundle revisions for a bundle can be obtained by calling bundle.adapt(BundleRevisions.class). getRevisions()
on the bundle.
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleRevisions.getRevisions()?>
<?FM MARKER [Index] BundleRevisions:getRevisions?>
<?FM MARKER [Index] getRevisions?>
getRevisions()
public List&lt;BundleRevision&gt; getRevisions ( ) 
	
Return the bundle revisions for the referenced bundle.  
The result is a list containing the current bundle revision, if
there is one, and all in use bundle revisions. The list may also
contain intermediate bundle revisions which are not in use.  
The list is ordered in reverse chronological order such that the
first item is the most recent bundle revision and last item is the
oldest bundle revision.  
Generally the list will have at least one bundle revision for the
bundle: the current bundle revision. However, for an uninstalled
bundle with no in use bundle revisions, the list may be empty.
	Returns	A list containing a snapshot of the BundleRevisions for
the referenced bundle.
<?FM MARKER [Cross-Ref] BundleWire?>
<?FM MARKER [Index] BundleWire?>
<?FM MARKER [Index] interface:BundleWire?>
BundleWire
public interface BundleWire
	extends Wire
A wire connecting a BundleCapability to a BundleRequirement. 
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleWire.getCapability()?>
<?FM MARKER [Index] BundleWire:getCapability?>
<?FM MARKER [Index] getCapability?>
getCapability()
public BundleCapability getCapability ( ) 
	
Returns the BundleCapability for this wire. 
	Returns	The BundleCapability for this wire.
<?FM MARKER [Cross-Ref] BundleWire.getProvider()?>
<?FM MARKER [Index] BundleWire:getProvider?>
<?FM MARKER [Index] getProvider?>
getProvider()
public BundleRevision getProvider ( ) 
	
Returns the resource providing the capability.  
The returned resource may differ from the resource referenced by
the capability.  
This method returns the same value as getProviderWiring(). getRevision().
	Returns	The resource providing the capability.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleWire.getProviderWiring()?>
<?FM MARKER [Index] BundleWire:getProviderWiring?>
<?FM MARKER [Index] getProviderWiring?>
getProviderWiring()
public BundleWiring getProviderWiring ( ) 
	
Returns the bundle wiring providing the capability.  
The bundle revision referenced by the returned bundle wiring may
differ from the bundle revision referenced by the capability.
	Returns	The bundle wiring providing the capability. If the bundle
wiring providing the capability is not in use, null will be returned.
<?FM MARKER [Cross-Ref] BundleWire.getRequirement()?>
<?FM MARKER [Index] BundleWire:getRequirement?>
<?FM MARKER [Index] getRequirement?>
getRequirement()
public BundleRequirement getRequirement ( ) 
	
Return the BundleRequirement for this wire. 
	Returns	The BundleRequirement for this wire.
<?FM MARKER [Cross-Ref] BundleWire.getRequirer()?>
<?FM MARKER [Index] BundleWire:getRequirer?>
<?FM MARKER [Index] getRequirer?>
getRequirer()
public BundleRevision getRequirer ( ) 
	
Returns the resource who requires the capability.  
The returned resource may differ from the resource referenced by
the requirement.  
This method returns the same value as getRequirerWiring(). getRevision().
	Returns	The resource who requires the capability.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleWire.getRequirerWiring()?>
<?FM MARKER [Index] BundleWire:getRequirerWiring?>
<?FM MARKER [Index] getRequirerWiring?>
getRequirerWiring()
public BundleWiring getRequirerWiring ( ) 
	
Returns the bundle wiring who requires the capability.  
The bundle revision referenced by the returned bundle wiring may
differ from the bundle revision referenced by the requirement.
	Returns	The bundle wiring whose requirement is wired to the capability.
If the bundle wiring requiring the capability is not in use, null
will be returned.
<?FM MARKER [Cross-Ref] BundleWiring?>
<?FM MARKER [Index] BundleWiring?>
<?FM MARKER [Index] interface:BundleWiring?>
BundleWiring
public interface BundleWiring
	extends BundleReference , Wiring
A wiring for a bundle. Each time a bundle is resolved, a new bundle
wiring for the bundle is created. A bundle wiring is associated
with a bundle revision and represents the dependencies with other
bundle wirings.  
The bundle wiring for a bundle is the current bundle wiring if it
is the most recent bundle wiring for the current bundle revision.
A bundle wiring is in use if it is the current bundle wiring or
if some other in use bundle wiring is dependent upon it. For example,
another bundle wiring is wired to a capability provided by the bundle
wiring. An in use bundle wiring for a non-fragment bundle has a class
loader. All bundles with non-current, in use bundle wirings are
considered removal pending. Once a bundle wiring is no longer in
use, it is considered stale and is discarded by the framework.  
The current bundle wiring for a bundle can be obtained by calling
bundle.adapt(BundleWiring.class). A bundle in the INSTALLED or UNINSTALLED
state does not have a current wiring, adapting such a bundle returns
null.
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleWiring.FINDENTRIES_RECURSE?>
<?FM MARKER [Index] BundleWiring:FINDENTRIES_RECURSE?>
<?FM MARKER [Index] FINDENTRIES_RECURSE?>
FINDENTRIES_RECURSE
public static final int FINDENTRIES_RECURSE = 1
The find entries operation must recurse into subdirectories.  
This bit may be set when calling findEntries(String, String, int)
to specify the result must include the matching entries from the
specified path and its subdirectories. If this bit is not set, then
the result must only include matching entries from the specified
path.
	See Also	findEntries(String, String, int)
<?FM MARKER [Cross-Ref] BundleWiring.LISTRESOURCES_LOCAL?>
<?FM MARKER [Index] BundleWiring:LISTRESOURCES_LOCAL?>
<?FM MARKER [Index] LISTRESOURCES_LOCAL?>
LISTRESOURCES_LOCAL
public static final int LISTRESOURCES_LOCAL = 2
The list resource names operation must limit the result to the names
of matching resources contained in this bundle wiring’s bundle revision
and its attached fragment revisions. The result must not include
resource names for resources in package names which are imported
by this wiring.  
This bit may be set when calling listResources(String, String, int)
to specify the result must only include the names of matching resources
contained in this bundle wiring’s bundle revision and its attached
fragment revisions. If this bit is not set, then the result must
include the names of matching resources reachable from this bundle
wiring’s class loader which may include the names of matching resources
contained in imported packages and required bundles.
	See Also	listResources(String, String, int)
<?FM MARKER [Cross-Ref] BundleWiring.LISTRESOURCES_RECURSE?>
<?FM MARKER [Index] BundleWiring:LISTRESOURCES_RECURSE?>
<?FM MARKER [Index] LISTRESOURCES_RECURSE?>
LISTRESOURCES_RECURSE
public static final int LISTRESOURCES_RECURSE = 1
The list resource names operation must recurse into subdirectories.
 
This bit may be set when calling listResources(String, String, int)
to specify the result must include the names of matching resources
from the specified path and its subdirectories. If this bit is not
set, then the result must only include names of matching resources
from the specified path.
	See Also	listResources(String, String, int)
<?FM MARKER [Cross-Ref] BundleWiring.findEntries(String,String,int)?>
<?FM MARKER [Index] BundleWiring:findEntries?>
<?FM MARKER [Index] findEntries?>
findEntries(String,String,int)
public List&lt;URL&gt; findEntries ( String path , String filePattern
, int options ) 
	path	The path name in which to look. The path is always relative
to the root of this bundle wiring and may begin with “/”. A path
value of “/” indicates the root of this bundle wiring.
	filePattern	The file name pattern for selecting entries in the
specified path. The pattern is only matched against the last element
of the entry path. If the entry is a directory then the trailing
“/” is not used for pattern matching. Substring matching is supported,
as specified in the Filter specification, using the wildcard character
(”*”). If null is specified, this is equivalent to “*” and matches
all files.
	options	The options for listing resource names. See FINDENTRIES_RECURSE.
The method must ignore unrecognized options.
	
Returns entries in this bundle wiring’s bundle revision and its
attached fragment revisions. This bundle wiring’s class loader is
not used to search for entries. Only the contents of this bundle
wiring’s bundle revision and its attached fragment revisions are
searched for the specified entries. 
This method takes into account that the “contents” of this bundle
wiring can have attached fragments. This “bundle space” is not a
namespace with unique members; the same entry name can be present
multiple times. This method therefore returns a list of URL objects.
These URLs can come from different JARs but have the same path name.
This method can either return only entries in the specified path
or recurse into subdirectories returning entries in the directory
tree beginning at the specified path. 
URLs for directory entries must have their path end with “/”. 
Note: Jar and zip files are not required to include directory entries.
URLs to directory entries will not be returned if the bundle contents
do not contain directory entries.
	Returns	An unmodifiable list of URL objects for each matching entry,
or an empty list if no matching entry could be found, if this bundle
wiring is for a fragment revision or if the caller does not have
the appropriate AdminPermission[bundle,RESOURCE] and the Java Runtime
Environment supports permissions. The list is ordered such that
entries from the bundle revision are returned first followed by
the entries from attached fragment revisions in attachment order.
If this bundle wiring is not in use, null must be returned.
	See Also	Bundle.findEntries(String, String, boolean)
<?FM MARKER [Cross-Ref] BundleWiring.getCapabilities(String)?>
<?FM MARKER [Index] BundleWiring:getCapabilities?>
<?FM MARKER [Index] getCapabilities?>
getCapabilities(String)
public List&lt;BundleCapability&gt; getCapabilities ( String namespace
) 
	namespace	The namespace of the capabilities to return or null to
return the capabilities from all namespaces.
	
Returns the capabilities provided by this bundle wiring.  
Only capabilities considered by the resolver are returned. For example,
capabilities with effective directive not equal to resolve are not
returned.  
A capability may not be required by any bundle wiring and thus there
may be no wires for the capability.  
A bundle wiring for a non-fragment revision provides a subset of
the declared capabilities from the bundle revision and all attached
fragment revisions† . Not all declared capabilities may be provided since
some may be discarded. For example, if a package is declared to
be both exported and imported, only one is selected and the other
is discarded. 
A bundle wiring for a fragment revision with a symbolic name must
provide exactly one identity capability. 
† The identity capability provided by attached fragment revisions
must not be included in the capabilities of the host bundle wiring.
	Returns	A list containing a snapshot of the BundleCapabilitys,
or an empty list if this bundle wiring provides no capabilities
in the specified namespace. If this bundle wiring is not in use,
null will be returned. For a given namespace, the list contains
the wires in the order the capabilities were specified in the manifests
of the bundle revision and the attached fragments†  of this bundle
wiring. There is no ordering defined between capabilities in different
namespaces.
<?FM MARKER [Cross-Ref] BundleWiring.getClassLoader()?>
<?FM MARKER [Index] BundleWiring:getClassLoader?>
<?FM MARKER [Index] getClassLoader?>
getClassLoader()
public ClassLoader getClassLoader ( ) 
	
Returns the class loader for this bundle wiring. Since a bundle
refresh creates a new bundle wiring for a bundle, different bundle
wirings for the same bundle will have different class loaders. 
	Returns	The class loader for this bundle wiring. If this bundle
wiring is not in use or this bundle wiring is for a fragment revision,
null will be returned.
	Throws	SecurityException –  If the caller does not have the appropriate
RuntimePermission(”getClassLoader”), and the Java Runtime Environment
supports permissions. 
<?FM MARKER [Cross-Ref] BundleWiring.getProvidedResourceWires(String)?>
<?FM MARKER [Index] BundleWiring:getProvidedResourceWires?>
<?FM MARKER [Index] getProvidedResourceWires?>
getProvidedResourceWires(String)
public List&lt;Wire&gt; getProvidedResourceWires ( String namespace
) 
	namespace	The namespace of the capabilities for which to return
wires or null to return the wires for the capabilities in all namespaces.
	
Returns the Wires to the provided capabilities of this wiring.  
This method returns the same value as getProvidedWires(String).
	Returns	A list containing a snapshot of the Wires for the capabilities
of this wiring, or an empty list if this wiring has no capabilities
in the specified namespace. For a given namespace, the list contains
the wires in the order the capabilities were specified in the manifests
of the resource and the attached fragment resources of this wiring.
There is no ordering defined between capabilities in different namespaces.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleWiring.getProvidedWires(String)?>
<?FM MARKER [Index] BundleWiring:getProvidedWires?>
<?FM MARKER [Index] getProvidedWires?>
getProvidedWires(String)
public List&lt;BundleWire&gt; getProvidedWires ( String namespace ) 
	namespace	The namespace of the capabilities for which to return
wires or null to return the wires for the capabilities in all namespaces.
	
Returns the BundleWires to the provided capabilities of this bundle
wiring. 
	Returns	A list containing a snapshot of the BundleWires for the
capabilities of this bundle wiring, or an empty list if this bundle
wiring has no capabilities in the specified namespace. If this bundle
wiring is not in use, null will be returned. For a given namespace,
the list contains the wires in the order the capabilities were specified
in the manifests of the bundle revision and the attached fragments
of this bundle wiring. There is no ordering defined between capabilities
in different namespaces.
<?FM MARKER [Cross-Ref] BundleWiring.getRequiredResourceWires(String)?>
<?FM MARKER [Index] BundleWiring:getRequiredResourceWires?>
<?FM MARKER [Index] getRequiredResourceWires?>
getRequiredResourceWires(String)
public List&lt;Wire&gt; getRequiredResourceWires ( String namespace
) 
	namespace	The namespace of the requirements for which to return
wires or null to return the wires for the requirements in all namespaces.
	
Returns the Wires to the requirements in use by this wiring. 
This method returns the same value as getRequiredWires(String).
	Returns	A list containing a snapshot of the Wires for the requirements
of this wiring, or an empty list if this wiring has no requirements
in the specified namespace. For a given namespace, the list contains
the wires in the order the requirements were specified in the manifests
of the resource and the attached fragment resources of this wiring.
There is no ordering defined between requirements in different namespaces.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleWiring.getRequiredWires(String)?>
<?FM MARKER [Index] BundleWiring:getRequiredWires?>
<?FM MARKER [Index] getRequiredWires?>
getRequiredWires(String)
public List&lt;BundleWire&gt; getRequiredWires ( String namespace ) 
	namespace	The namespace of the requirements for which to return
wires or null to return the wires for the requirements in all namespaces.
	
Returns the BundleWires to the requirements in use by this bundle
wiring.  
This method may return different results if this bundle wiring adds
wires to more requirements. For example, dynamically importing a
package will establish a new wire to the dynamically imported package.
	Returns	A list containing a snapshot of the BundleWires for the
requirements of this bundle wiring, or an empty list if this bundle
wiring has no requirements in the specified namespace. If this bundle
wiring is not in use, null will be returned. For a given namespace,
the list contains the wires in the order the requirements were specified
in the manifests of the bundle revision and the attached fragments
of this bundle wiring. There is no ordering defined between requirements
in different namespaces.
<?FM MARKER [Cross-Ref] BundleWiring.getRequirements(String)?>
<?FM MARKER [Index] BundleWiring:getRequirements?>
<?FM MARKER [Index] getRequirements?>
getRequirements(String)
public List&lt;BundleRequirement&gt; getRequirements ( String namespace
) 
	namespace	The namespace of the requirements to return or null to
return the requirements from all namespaces.
	
Returns the requirements of this bundle wiring.  
Only requirements considered by the resolver are returned. For example,
requirements with effective directive not equal to resolve are not
returned.  
A bundle wiring for a non-fragment revision has a subset of the
declared requirements from the bundle revision and all attached
fragment revisions. Not all declared requirements may be present
since some may be discarded. For example, if a package is declared
to be optionally imported and is not actually imported, the requirement
must be discarded.
	Returns	A list containing a snapshot of the BundleRequirements,
or an empty list if this bundle wiring uses no requirements in the
specified namespace. If this bundle wiring is not in use, null will
be returned. For a given namespace, the list contains the wires
in the order the requirements were specified in the manifests of
the bundle revision and the attached fragments of this bundle wiring.
There is no ordering defined between requirements in different namespaces.
<?FM MARKER [Cross-Ref] BundleWiring.getResource()?>
<?FM MARKER [Index] BundleWiring:getResource?>
<?FM MARKER [Index] getResource?>
getResource()
public BundleRevision getResource ( ) 
	
Returns the resource associated with this wiring.  
This method returns the same value as getRevision().
	Returns	The resource associated with this wiring.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleWiring.getResourceCapabilities(String)?>
<?FM MARKER [Index] BundleWiring:getResourceCapabilities?>
<?FM MARKER [Index] getResourceCapabilities?>
getResourceCapabilities(String)
public List&lt;Capability&gt; getResourceCapabilities ( String namespace
) 
	namespace	The namespace of the capabilities to return or null to
return the capabilities from all namespaces.
	
Returns the capabilities provided by this wiring.  
Only capabilities considered by the resolver are returned. For example,
capabilities with effective directive not equal to resolve are not
returned.  
A capability may not be required by any wiring and thus there may
be no wires for the capability.  
A wiring for a non-fragment resource provides a subset of the declared
capabilities from the resource and all attached fragment resources†
. Not all declared capabilities may be provided since some may be
discarded. For example, if a package is declared to be both exported
and imported, only one is selected and the other is discarded. 
A wiring for a fragment resource with a symbolic name must provide
exactly one osgi.identity capability. 
† The osgi.identity capability provided by attached fragment resource
must not be included in the capabilities of the host wiring.  
This method returns the same value as getCapabilities(String).
	Returns	A list containing a snapshot of the Capabilitys, or an
empty list if this wiring provides no capabilities in the specified
namespace. For a given namespace, the list contains the wires in the
order the capabilities were specified in the manifests of the resource
and the attached fragment resources†  of this wiring. There is no
ordering defined between capabilities in different namespaces.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleWiring.getResourceRequirements(String)?>
<?FM MARKER [Index] BundleWiring:getResourceRequirements?>
<?FM MARKER [Index] getResourceRequirements?>
getResourceRequirements(String)
public List&lt;Requirement&gt; getResourceRequirements ( String namespace
) 
	namespace	The namespace of the requirements to return or null to
return the requirements from all namespaces.
	
Returns the requirements of this wiring.  
Only requirements considered by the resolver are returned. For example,
requirements with effective directive not equal to resolve are not
returned.  
A wiring for a non-fragment resource has a subset of the declared
requirements from the resource and all attached fragment resources.
Not all declared requirements may be present since some may be discarded.
For example, if a package is declared to be optionally imported
and is not actually imported, the requirement must be discarded.
 
This method returns the same value as getRequirements(String).
	Returns	A list containing a snapshot of the Requirements, or an
empty list if this wiring uses no requirements in the specified
namespace. For a given namespace, the list contains the wires in
the order the requirements were specified in the manifests of the
resource and the attached fragment resources of this wiring. There
is no ordering defined between requirements in different namespaces.
	Since	1.1
<?FM MARKER [Cross-Ref] BundleWiring.getRevision()?>
<?FM MARKER [Index] BundleWiring:getRevision?>
<?FM MARKER [Index] getRevision?>
getRevision()
public BundleRevision getRevision ( ) 
	
Returns the bundle revision for the bundle in this bundle wiring.
Since a bundle update can change the entries in a bundle, different
bundle wirings for the same bundle can have different bundle revisions.
 
The bundle object referenced by the returned BundleRevision may
return different information than the returned BundleRevision since
the returned BundleRevision may refer to an older revision of the bundle.
	Returns	The bundle revision for this bundle wiring.
	See Also	BundleRevision.getWiring()
<?FM MARKER [Cross-Ref] BundleWiring.isCurrent()?>
<?FM MARKER [Index] BundleWiring:isCurrent?>
<?FM MARKER [Index] isCurrent?>
isCurrent()
public boolean isCurrent ( ) 
	
Returns true if this bundle wiring is the current bundle wiring.
The bundle wiring for a bundle is the current bundle wiring if it
is the most recent bundle wiring for the current bundle revision.
All bundles with non-current, in use bundle wirings are considered
removal pending. 
	Returns	true if this bundle wiring is the current bundle wiring;
false otherwise.
<?FM MARKER [Cross-Ref] BundleWiring.isInUse()?>
<?FM MARKER [Index] BundleWiring:isInUse?>
<?FM MARKER [Index] isInUse?>
isInUse()
public boolean isInUse (  ) 
	
Returns true if this bundle wiring is in use. A bundle wiring is
in use if it is the current wiring or if some other in use bundle
wiring is dependent upon it. Once a bundle wiring is no longer in
use, it is considered stale and is discarded by the framework. 
	Returns	true if this bundle wiring is in use; false otherwise.
<?FM MARKER [Cross-Ref] BundleWiring.listResources(String,String,int)?>
<?FM MARKER [Index] BundleWiring:listResources?>
<?FM MARKER [Index] listResources?>
listResources(String,String,int)
public Collection&lt;String&gt; listResources ( String path , String
filePattern , int options ) 
	path	The path name in which to look. The path is always relative
to the root of this bundle wiring’s class loader and may begin with
“/”. A path value of “/” indicates the root of this bundle wiring’s
class loader.
	filePattern	The file name pattern for selecting resource names
in the specified path. The pattern is only matched against the last
element of the resource path. If the resource is a directory then the
trailing “/” is not used for pattern matching. Substring matching
is supported, as specified in the Filter specification, using the
wildcard character (”*”). If null is specified, this is equivalent
to “*” and matches all files.
	options	The options for listing resource names. See LISTRESOURCES_LOCAL
and LISTRESOURCES_RECURSE. This method must ignore unrecognized
options.
	
Returns the names of resources visible to this bundle wiring’s class
loader. The returned names can be used to access the resources via
this bundle wiring’s class loader. 
Only the resource names for resources in bundle wirings will be
returned. The names of resources visible to a bundle wiring’s parent
class loader, such as the bootstrap class loader, must not be included
in the result. 
Only established wires will be examined for resources. This method
must not cause new wires for dynamic imports to be established. 
	Returns	An unmodifiable collection of resource names for each matching
resource, or an empty collection if no matching resource could be
found, if this bundle wiring is for a fragment revision or if the
caller does not have the appropriate AdminPermission[bundle,RESOURCE]
and the Java Runtime Environment supports permissions. The collection
is unordered and must contain no duplicate resource names. If this
bundle wiring is not in use, null must be returned.
<?FM MARKER [Cross-Ref] FrameworkWiring?>
<?FM MARKER [Index] FrameworkWiring?>
<?FM MARKER [Index] interface:FrameworkWiring?>
FrameworkWiring
public interface FrameworkWiring
	extends BundleReference
Query and modify wiring information for the framework. The framework
wiring object for the framework can be obtained by calling bundle.adapt(FrameworkWiring.class)
on the system bundle. Only the system bundle can be adapted to a
FrameworkWiring object. 
The system bundle associated with this FrameworkWiring object can
be obtained by calling BundleReference.getBundle().
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] FrameworkWiring.getDependencyClosure(Collection)?>
<?FM MARKER [Index] FrameworkWiring:getDependencyClosure?>
<?FM MARKER [Index] getDependencyClosure?>
getDependencyClosure(Collection)
public Collection&lt;Bundle&gt; getDependencyClosure ( Collection&lt;Bundle&gt;
bundles ) 
	bundles	The initial bundles for which to generate the dependency
closure.
	
Returns the dependency closure for the specified bundles.  
A graph of bundles is computed starting with the specified bundles.
The graph is expanded by adding any bundle that is either wired
to a package that is currently exported by a bundle in the graph
or requires a bundle in the graph. The graph is fully constructed
when there is no bundle outside the graph that is wired to a bundle
in the graph. The graph may contain UNINSTALLED bundles that are removal
pending.
	Returns	A collection containing a snapshot of the dependency closure
of the specified bundles, or an empty collection if there were no
specified bundles.
	Throws	IllegalArgumentException –  If the specified Bundles were
not created by the same framework instance associated with this
FrameworkWiring. 
<?FM MARKER [Cross-Ref] FrameworkWiring.getRemovalPendingBundles()?>
<?FM MARKER [Index] FrameworkWiring:getRemovalPendingBundles?>
<?FM MARKER [Index] getRemovalPendingBundles?>
getRemovalPendingBundles()
public Collection&lt;Bundle&gt; getRemovalPendingBundles ( ) 
	
Returns the bundles that have non-current, in use bundle wirings.
This is typically the bundles which have been updated or uninstalled
since the last call to refreshBundles(Collection, FrameworkListener...). 
	Returns	A collection containing a snapshot of the Bundles which
have non-current, in use BundleWirings, or an empty collection if
there are no such bundles.
<?FM MARKER [Cross-Ref] FrameworkWiring.refreshBundles(Collection,FrameworkListener...)?>
<?FM MARKER [Index] FrameworkWiring:refreshBundles?>
<?FM MARKER [Index] refreshBundles?>
refreshBundles(Collection,FrameworkListener...)
public void refreshBundles ( Collection&lt;Bundle&gt; bundles , FrameworkListener
... listeners ) 
	bundles	The bundles to be refreshed, or null to refresh the removal
pending bundles.
	listeners	Zero or more listeners to be notified when the bundle
refresh has been completed. The specified listeners do not need
to be otherwise registered with the framework. If a specified listener
is already registered with the framework, it will be notified twice.
	
Refreshes the specified bundles. This forces the update (replacement)
or removal of packages exported by the specified bundles. 
The technique by which the framework refreshes bundles may vary
among different framework implementations. A permissible implementation
is to stop and restart the framework.  
This method returns to the caller immediately and then performs
the following steps on a separate thread: 
Compute the dependency closure of the specified bundles. If no bundles
are specified, compute the dependency closure of the removal pending
bundles.  
Each bundle in the dependency closure that is in the ACTIVE state
will be stopped as described in the Bundle.stop method.  
Each bundle in the dependency closure that is in the RESOLVED state
is unresolved and thus moved to the INSTALLED state. The effect
of this step is that bundles in the dependency closure are no longer
RESOLVED.  
Each bundle in the dependency closure that is in the UNINSTALLED
state is removed from the dependency closure and is now completely
removed from the Framework. 
Each bundle in the dependency closure that was in the ACTIVE state
prior to Step 2 is started as described in the Bundle.start method,
causing all bundles required for the restart to be resolved. It
is possible that, as a result of the previous steps, packages that
were previously exported no longer are. Therefore, some bundles
may be unresolvable until bundles satisfying the dependencies have
been installed in the Framework. 
For any exceptions that are thrown during any of these steps, a
framework event of type FrameworkEvent.ERROR is fired containing
the exception. The source bundle for these events should be the
specific bundle to which the exception is related. If no specific
bundle can be associated with the exception then the System Bundle
must be used as the source bundle for the event. All framework events
fired by this method are also delivered to the specified FrameworkListeners
in the order they are specified. 
When this process completes after the bundles are refreshed, the
Framework will fire a Framework event of type FrameworkEvent.PACKAGES_REFRESHED
to announce it has completed the bundle refresh. The specified FrameworkListeners
are notified in the order specified. Each specified FrameworkListener
will be called with a Framework event of type FrameworkEvent.PACKAGES_REFRESHED.
	Throws	IllegalArgumentException –  If the specified Bundles were
not created by the same framework instance associated with this
FrameworkWiring. 
		SecurityException –  If the caller does not have AdminPermission[System
Bundle,RESOLVE] and the Java runtime environment supports permissions. 
<?FM MARKER [Cross-Ref] FrameworkWiring.resolveBundles(Collection)?>
<?FM MARKER [Index] FrameworkWiring:resolveBundles?>
<?FM MARKER [Index] resolveBundles?>
resolveBundles(Collection)
public boolean resolveBundles ( Collection&lt;Bundle&gt; bundles ) 
	bundles	The bundles to resolve or null to resolve all unresolved
bundles installed in the Framework.
	
Resolves the specified bundles. The Framework must attempt to resolve
the specified bundles that are unresolved. Additional bundles that
are not included in the specified bundles may be resolved as a result
of calling this method. A permissible implementation of this method
is to attempt to resolve all unresolved bundles installed in the
framework.  
If no bundles are specified, then the Framework will attempt to
resolve all unresolved bundles. This method must not cause any bundle
to be refreshed, stopped, or started. This method will not return until
the operation has completed.
	Returns	true if all specified bundles are resolved; false otherwise.
	Throws	IllegalArgumentException –  If the specified Bundles were
not created by the same framework instance associated with this
FrameworkWiring. 
		SecurityException –  If the caller does not have AdminPermission[System
Bundle,RESOLVE] and the Java runtime environment supports permissions. 

</phrase></INSET><INSET xml:id="i3908381"><phrase role="body">org.osgi.framework.startlevel<?FM MARKER [Cross-Ref] org.osgi.framework.startlevel?>
<?FM MARKER [Index] org.osgi.framework.startlevel?>
<?FM MARKER [Cross-Ref] package:org.osgi.framework.startlevel?>

Framework Start Level Package Version 1.0.  
The Framework Start Level package allows management agents to manage
a start level assigned to each bundle and the active start level
of the Framework. This package is a replacement for the now deprecated
org.osgi.service.startlevel package.  
A start level is defined to be a state of execution in which the
Framework exists. Start level values are defined as unsigned integers
with 0 (zero) being the state where the Framework is not launched.
Progressively higher integral values represent progressively higher
start levels. For example, 2 is a higher start level than 1.  
AdminPermission is required to modify start level information.  
Start Level support in the Framework includes the ability to modify
the active start level of the Framework and to assign a specific
start level to a bundle. The beginning start level of a Framework
is specified via the org.osgi.framework.Constants.FRAMEWORK_BEGINNING_STARTLEVEL
framework property when configuring a framework. 
When the Framework is first started it must be at start level zero.
In this state, no bundles are running. This is the initial state
of the Framework before it is launched. When the Framework is launched,
the Framework will enter start level one and all bundles which are
assigned to start level one and whose autostart setting indicates
the bundle should be started are started as described in the org.osgi.framework.Bundle.start(int)
method. The Framework will continue to increase the start level,
starting bundles at each start level, until the Framework has reached
a beginning start level. At this point the Framework has completed
starting bundles and will then fire a Framework event of type org.osgi.framework.FrameworkEvent.STARTED
to announce it has completed its launch. 
Within a start level, bundles may be started in an order defined
by the Framework implementation. This may be something like ascending
org.osgi.framework.Bundle.getBundleId() order or an order based
upon dependencies between bundles. A similar but reversed order
may be used when stopping bundles within a start level.  
The Framework Start Level package can be used by management bundles
to alter the active start level of the framework. 
Bundles wishing to use this package must list the package in the
Import-Package header of the bundle’s manifest. For example: 
 Import-Package: org.osgi.framework.startlevel; version=”[1.0,2.0)”
Summary
BundleStartLevel –  Query and modify the start level information
for a bundle. 
FrameworkStartLevel –  Query and modify the start level information
for the framework. 
Permissions
<?FM MARKER [Cross-Ref] BundleStartLevel?>
<?FM MARKER [Index] BundleStartLevel?>
<?FM MARKER [Index] interface:BundleStartLevel?>
BundleStartLevel
public interface BundleStartLevel
	extends BundleReference
Query and modify the start level information for a bundle. The start
level object for a bundle can be obtained by calling bundle.adapt(BundleStartLevel.class)
on the bundle.  
The bundle associated with this BundleStartLevel object can be obtained
by calling BundleReference.getBundle().
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] BundleStartLevel.getStartLevel()?>
<?FM MARKER [Index] BundleStartLevel:getStartLevel?>
<?FM MARKER [Index] getStartLevel?>
getStartLevel()
public int getStartLevel ( ) 
	
Return the assigned start level value for the bundle. 
	Returns	The start level value of the bundle.
	Throws	IllegalStateException –  If the bundle has been uninstalled. 
	See Also	setStartLevel(int)
<?FM MARKER [Cross-Ref] BundleStartLevel.isActivationPolicyUsed()?>
<?FM MARKER [Index] BundleStartLevel:isActivationPolicyUsed?>
<?FM MARKER [Index] isActivationPolicyUsed?>
isActivationPolicyUsed()
public boolean isActivationPolicyUsed ( ) 
	
Returns whether the bundle’s autostart setting indicates that the
activation policy declared in the bundle manifest must be used. 
The autostart setting of a bundle indicates whether the bundle’s
declared activation policy is to be used when the bundle is started.
	Returns	true if the bundle’s autostart setting indicates the activation
policy declared in the manifest must be used. false if the bundle
must be eagerly activated.
	Throws	IllegalStateException –  If the bundle has been uninstalled. 
	See Also	Bundle.START_ACTIVATION_POLICY
<?FM MARKER [Cross-Ref] BundleStartLevel.isPersistentlyStarted()?>
<?FM MARKER [Index] BundleStartLevel:isPersistentlyStarted?>
<?FM MARKER [Index] isPersistentlyStarted?>
isPersistentlyStarted()
public boolean isPersistentlyStarted ( ) 
	
Returns whether the bundle’s autostart setting indicates it must
be started. 
The autostart setting of a bundle indicates whether the bundle is
to be started when its start level is reached.
	Returns	true if the autostart setting of the bundle indicates it
is to be started. false otherwise.
	Throws	IllegalStateException –  If this bundle has been uninstalled. 
	See Also	Bundle.START_TRANSIENT
<?FM MARKER [Cross-Ref] BundleStartLevel.setStartLevel(int)?>
<?FM MARKER [Index] BundleStartLevel:setStartLevel?>
<?FM MARKER [Index] setStartLevel?>
setStartLevel(int)
public void setStartLevel ( int startlevel ) 
	startlevel	The new start level for the bundle.
	
Assign a start level value to the bundle.  
The bundle will be assigned the specified start level. The start
level value assigned to the bundle will be persistently recorded
by the Framework. 
If the new start level for the bundle is lower than or equal to
the active start level of the Framework and the bundle’s autostart
setting indicates this bundle must be started, the Framework will
start the bundle as described in the Bundle.start(int) method using
the Bundle.START_TRANSIENT option. The Bundle.START_ACTIVATION_POLICY
option must also be used if isActivationPolicyUsed() returns true.
The actual starting of the bundle must occur asynchronously. 
If the new start level for the bundle is higher than the active
start level of the Framework, the Framework will stop the bundle
as described in the Bundle.stop(int) method using the Bundle.STOP_TRANSIENT
option. The actual stopping of the bundle must occur asynchronously.
	Throws	IllegalArgumentException –  If the specified start level
is less than or equal to zero, or if the bundle is the system bundle. 
		IllegalStateException –  If the bundle has been uninstalled. 
		SecurityException –  If the caller does not have AdminPermission[bundle,EXECUTE]
and the Java runtime environment supports permissions. 
<?FM MARKER [Cross-Ref] FrameworkStartLevel?>
<?FM MARKER [Index] FrameworkStartLevel?>
<?FM MARKER [Index] interface:FrameworkStartLevel?>
FrameworkStartLevel
public interface FrameworkStartLevel
	extends BundleReference
Query and modify the start level information for the framework.
The start level object for the framework can be obtained by calling
bundle.adapt(FrameworkStartLevel.class) on the system bundle. Only
the system bundle can be adapted to a FrameworkStartLevel object.
 
The system bundle associated with this FrameworkStartLevel object
can be obtained by calling BundleReference.getBundle().
	Concurrency	Thread-safe 
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] FrameworkStartLevel.getInitialBundleStartLevel()?>
<?FM MARKER [Index] FrameworkStartLevel:getInitialBundleStartLevel?>
<?FM MARKER [Index] getInitialBundleStartLevel?>
getInitialBundleStartLevel()
public int getInitialBundleStartLevel ( ) 
	
Return the initial start level value that is assigned to a Bundle
when it is first installed. 
	Returns	The initial start level value for Bundles.
	See Also	setInitialBundleStartLevel(int)
<?FM MARKER [Cross-Ref] FrameworkStartLevel.getStartLevel()?>
<?FM MARKER [Index] FrameworkStartLevel:getStartLevel?>
<?FM MARKER [Index] getStartLevel?>
getStartLevel()
public int getStartLevel ( ) 
	
Return the active start level value of the Framework.  If the Framework
is in the process of changing the start level this method must return
the active start level if this differs from the requested start level. 
	Returns	The active start level value of the Framework.
<?FM MARKER [Cross-Ref] FrameworkStartLevel.setInitialBundleStartLevel(int)?>
<?FM MARKER [Index] FrameworkStartLevel:setInitialBundleStartLevel?>
<?FM MARKER [Index] setInitialBundleStartLevel?>
setInitialBundleStartLevel(int)
public void setInitialBundleStartLevel ( int startlevel ) 
	startlevel	The initial start level for newly installed bundles.
	
Set the initial start level value that is assigned to a Bundle when
it is first installed. 
The initial bundle start level will be set to the specified start
level. The initial bundle start level value will be persistently
recorded by the Framework.  
When a Bundle is installed via BundleContext.installBundle, it is
assigned the initial bundle start level value. 
The default initial bundle start level value is 1 unless this method
has been called to assign a different initial bundle start level
value. 
This method does not change the start level values of installed
bundles.
	Throws	IllegalArgumentException –  If the specified start level
is less than or equal to zero. 
		SecurityException –  If the caller does not have AdminPermission[System
Bundle,STARTLEVEL] and the Java runtime environment supports permissions. 
<?FM MARKER [Cross-Ref] FrameworkStartLevel.setStartLevel(int,FrameworkListener...)?>
<?FM MARKER [Index] FrameworkStartLevel:setStartLevel?>
<?FM MARKER [Index] setStartLevel?>
setStartLevel(int,FrameworkListener...)
public void setStartLevel ( int startlevel , FrameworkListener ...
listeners ) 
	startlevel	The requested start level for the Framework.
	listeners	Zero or more listeners to be notified when the start
level change has been completed. The specified listeners do not
need to be otherwise registered with the framework. If a specified
listener is already registered with the framework, it will be notified
twice.
	
Modify the active start level of the Framework and notify when complete.
 
The Framework will move to the requested start level. This method
will return immediately to the caller and the start level change
will occur asynchronously on another thread. The specified FrameworkListener
s are notified, in the order specified, when the start level change
is complete. When the start level change completes normally, each
specified FrameworkListener will be called with a Framework event
of type FrameworkEvent.STARTLEVEL_CHANGED. If the start level change
does not complete normally, each specified FrameworkListener will
be called with a Framework event of type FrameworkEvent.ERROR.  
If the specified start level is higher than the active start level,
the Framework will continue to increase the start level until the
Framework has reached the specified start level.  At each intermediate
start level value on the way to and including the target start level,
the Framework must: 
Change the active start level to the intermediate start level value.
Start bundles at the intermediate start level whose autostart setting
indicate they must be started. They are started as described in
the Bundle.start(int) method using the Bundle.START_TRANSIENT option.
The Bundle.START_ACTIVATION_POLICY option must also be used if BundleStartLevel.isActivationPolicyUsed()
returns true for the bundle.
When this process completes after the specified start level is reached,
the Framework will fire a Framework event of type FrameworkEvent.STARTLEVEL_CHANGED
to announce it has moved to the specified start level. 
If the specified start level is lower than the active start level,
the Framework will continue to decrease the start level until the
Framework has reached the specified start level.  At each intermediate
start level value on the way to and including the specified start
level, the framework must: 
Stop bundles at the intermediate start level as described in the
Bundle.stop(int) method using the Bundle.STOP_TRANSIENT option.
Change the active start level to the intermediate start level value.
When this process completes after the specified start level is reached,
the Framework will fire a Framework event of type FrameworkEvent.STARTLEVEL_CHANGED
to announce it has moved to the specified start level. 
If the specified start level is equal to the active start level,
then no bundles are started or stopped, however, the Framework must
fire a Framework event of type FrameworkEvent.STARTLEVEL_CHANGED
to announce it has finished moving to the specified start level.
This event may arrive before this method returns.
	Throws	IllegalArgumentException –  If the specified start level
is less than or equal to zero. 
		SecurityException –  If the caller does not have AdminPermission[System
Bundle,STARTLEVEL] and the Java runtime environment supports permissions. 

</phrase></INSET><INSET xml:id="i3908522"><phrase role="body">org.osgi.framework.namespace<?FM MARKER [Cross-Ref] org.osgi.framework.namespace?>
<?FM MARKER [Index] org.osgi.framework.namespace?>
<?FM MARKER [Cross-Ref] package:org.osgi.framework.namespace?>

Namespace Package Version 1.0.  
Bundles should not need to import this package at runtime since
all the types in this package just contain constants for capability
and  requirement namespaces specified by the OSGi Alliance.
Summary
AbstractWiringNamespace –  Wiring Capability and Requirement Namespaces
base class. 
BundleNamespace –  Bundle Capability and Requirement Namespace. 
ExecutionEnvironmentNamespace –  Execution Environment Capability
and Requirement Namespace. 
HostNamespace –  Host Capability and Requirement Namespace. 
IdentityNamespace –  Identity Capability and Requirement Namespace. 
PackageNamespace –  Package Capability and Requirement Namespace. 
Permissions
<?FM MARKER [Cross-Ref] AbstractWiringNamespace?>
<?FM MARKER [Index] AbstractWiringNamespace?>
<?FM MARKER [Index] class:AbstractWiringNamespace?>
AbstractWiringNamespace
public abstract class AbstractWiringNamespace
	extends Namespace
Wiring Capability and Requirement Namespaces base class.  
This class is the common class shared by all OSGi defined wiring
namespaces. It defines the names for the common attributes and directives
for the OSGi specified wiring namespaces.  
The values associated with these keys are of type String, unless
otherwise indicated.
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] AbstractWiringNamespace.CAPABILITY_BUNDLE_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] AbstractWiringNamespace:CAPABILITY_BUNDLE_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_BUNDLE_VERSION_ATTRIBUTE?>
CAPABILITY_BUNDLE_VERSION_ATTRIBUTE
public static final String CAPABILITY_BUNDLE_VERSION_ATTRIBUTE =
“bundle-version”<?FM MARKER [Index] bundle-version?>

The capability attribute contains the Version of the resource providing
the capability if one is specified or 0.0.0 if not specified. The
value of this attribute must be of type Version. 
<?FM MARKER [Cross-Ref] AbstractWiringNamespace.CAPABILITY_MANDATORY_DIRECTIVE?>
<?FM MARKER [Index] AbstractWiringNamespace:CAPABILITY_MANDATORY_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_MANDATORY_DIRECTIVE?>
CAPABILITY_MANDATORY_DIRECTIVE
public static final String CAPABILITY_MANDATORY_DIRECTIVE = “mandatory”<?FM MARKER [Index] mandatory?>

The capability directive used to specify the comma separated list
of mandatory attributes which must be specified in the filter of
a requirement in order for the capability to match the requirement. 
<?FM MARKER [Cross-Ref] BundleNamespace?>
<?FM MARKER [Index] BundleNamespace?>
<?FM MARKER [Index] class:BundleNamespace?>
BundleNamespace
public final class BundleNamespace
	extends AbstractWiringNamespace
Bundle Capability and Requirement Namespace.  
This class defines the names for the attributes and directives for
this namespace. All unspecified capability attributes are of type
String and are used as arbitrary matching attributes for the capability.
The values associated with the specified directive and attribute
keys are of type String, unless otherwise indicated.  
Unless otherwise noted, all directives specified on the Bundle-SymbolicName
header are visible in the capability and all directives specified
on the Require-Bundle header are visible in the requirement. 
The uses directive must be ignored. A uses directive specified on
the Bundle-SymbolicName header must be ignored. A uses directive
must not be present in the capability.
The effectivedirectives must be ignored. This namespace is only
effective at resolve time. An effective directive specified on the
Bundle-SymbolicName or Require-Bundle headers must be ignored. An effective
directive must not be present in a capability or requirement.
The cardinality directive must be ignored. A cardinality directive
specified on the Require-Bundle header must be ignored. A cardinality
directive must not be present in a requirement.
A non-fragment resource with the osgi.bundle type identity provides
exactly one†  bundle capability (that is, the bundle can be required
by another bundle). A fragment resource with the osgi.fragment type
identity must not declare a bundle capability. A resource requires
zero or more bundle requirements (that is, required bundles). 
† A resource with no symbolic name must not provide a bundle capability.
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] BundleNamespace.BUNDLE_NAMESPACE?>
<?FM MARKER [Index] BundleNamespace:BUNDLE_NAMESPACE?>
<?FM MARKER [Index] BUNDLE_NAMESPACE?>
BUNDLE_NAMESPACE
public static final String BUNDLE_NAMESPACE = “osgi.wiring.bundle”<?FM MARKER [Index] osgi.wiring.bundle?>

Namespace name for bundle capabilities and requirements.  
Also, the capability attribute used to specify the symbolic name
of the bundle.
<?FM MARKER [Cross-Ref] BundleNamespace.CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE?>
<?FM MARKER [Index] BundleNamespace:CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE?>
CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE
public static final String CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE
= “fragment-attachment”<?FM MARKER [Index] fragment-attachment?>

The capability directive identifying if and when a fragment may
attach to a host bundle. 
This directive should be examined using the host namespace.
	See Also	HostNamespace.CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE
<?FM MARKER [Cross-Ref] BundleNamespace.CAPABILITY_SINGLETON_DIRECTIVE?>
<?FM MARKER [Index] BundleNamespace:CAPABILITY_SINGLETON_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_SINGLETON_DIRECTIVE?>
CAPABILITY_SINGLETON_DIRECTIVE
public static final String CAPABILITY_SINGLETON_DIRECTIVE = “singleton”<?FM MARKER [Index] singleton?>

The capability directive identifying if the resource is a singleton.
A String value of “true“ indicates the resource is a singleton;
any other value or null indicates the resource is not a singleton. 
This directive should be examined using the identity namespace.
	See Also	IdentityNamespace.CAPABILITY_SINGLETON_DIRECTIVE
<?FM MARKER [Cross-Ref] BundleNamespace.REQUIREMENT_EXTENSION_DIRECTIVE?>
<?FM MARKER [Index] BundleNamespace:REQUIREMENT_EXTENSION_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_EXTENSION_DIRECTIVE?>
REQUIREMENT_EXTENSION_DIRECTIVE
public static final String REQUIREMENT_EXTENSION_DIRECTIVE = “extension”<?FM MARKER [Index] extension?>

The requirement directive used to specify the type of the extension
fragment. 
This directive should be examined using the host namespace.
	See Also	HostNamespace.REQUIREMENT_EXTENSION_DIRECTIVE
<?FM MARKER [Cross-Ref] BundleNamespace.REQUIREMENT_VISIBILITY_DIRECTIVE?>
<?FM MARKER [Index] BundleNamespace:REQUIREMENT_VISIBILITY_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_VISIBILITY_DIRECTIVE?>
REQUIREMENT_VISIBILITY_DIRECTIVE
public static final String REQUIREMENT_VISIBILITY_DIRECTIVE = “visibility”<?FM MARKER [Index] visibility?>

The requirement directive used to specify the visibility type for
a requirement. The default value is private. 
	See Also	private , reexport
<?FM MARKER [Cross-Ref] BundleNamespace.VISIBILITY_PRIVATE?>
<?FM MARKER [Index] BundleNamespace:VISIBILITY_PRIVATE?>
<?FM MARKER [Index] VISIBILITY_PRIVATE?>
VISIBILITY_PRIVATE
public static final String VISIBILITY_PRIVATE = “private”<?FM MARKER [Index] private?>

The directive value identifying a private visibility type. A private
visibility type indicates that any packages that are exported by
the required bundle are not made visible on the export signature
of the requiring bundle. . 
	See Also	REQUIREMENT_VISIBILITY_DIRECTIVE
<?FM MARKER [Cross-Ref] BundleNamespace.VISIBILITY_REEXPORT?>
<?FM MARKER [Index] BundleNamespace:VISIBILITY_REEXPORT?>
<?FM MARKER [Index] VISIBILITY_REEXPORT?>
VISIBILITY_REEXPORT
public static final String VISIBILITY_REEXPORT = “reexport”<?FM MARKER [Index] reexport?>

The directive value identifying a reexport visibility type. A reexport
visibility type indicates any packages that are exported by the
required bundle are re-exported by the requiring bundle. 
	See Also	REQUIREMENT_VISIBILITY_DIRECTIVE
<?FM MARKER [Cross-Ref] ExecutionEnvironmentNamespace?>
<?FM MARKER [Index] ExecutionEnvironmentNamespace?>
<?FM MARKER [Index] class:ExecutionEnvironmentNamespace?>
ExecutionEnvironmentNamespace
public final class ExecutionEnvironmentNamespace
	extends Namespace
Execution Environment Capability and Requirement Namespace.  
This class defines the names for the attributes and directives for
this namespace. All unspecified capability attributes are of type
String and are used as arbitrary matching attributes for the capability.
The values associated with the specified directive and attribute
keys are of type String, unless otherwise indicated.
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] ExecutionEnvironmentNamespace.CAPABILITY_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] ExecutionEnvironmentNamespace:CAPABILITY_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_VERSION_ATTRIBUTE?>
CAPABILITY_VERSION_ATTRIBUTE
public static final String CAPABILITY_VERSION_ATTRIBUTE = “version”<?FM MARKER [Index] version?>

The capability attribute contains the versions of the execution
environment. The value of this attribute must be of type List&lt;Version&gt;. 
<?FM MARKER [Cross-Ref] ExecutionEnvironmentNamespace.EXECUTION_ENVIRONMENT_NAMESPACE?>
<?FM MARKER [Index] ExecutionEnvironmentNamespace:EXECUTION_ENVIRONMENT_NAMESPACE?>
<?FM MARKER [Index] EXECUTION_ENVIRONMENT_NAMESPACE?>
EXECUTION_ENVIRONMENT_NAMESPACE
public static final String EXECUTION_ENVIRONMENT_NAMESPACE = “osgi.ee”<?FM MARKER [Index] osgi.ee?>

Namespace name for execution environment capabilities and requirements.
 
Also, the capability attribute used to specify the name of the execution
environment.
<?FM MARKER [Cross-Ref] HostNamespace?>
<?FM MARKER [Index] HostNamespace?>
<?FM MARKER [Index] class:HostNamespace?>
HostNamespace
public final class HostNamespace
	extends AbstractWiringNamespace
Host Capability and Requirement Namespace.  
This class defines the names for the attributes and directives for
this namespace. All unspecified capability attributes are of type
String and are used as arbitrary matching attributes for the capability.
The values associated with the specified directive and attribute
keys are of type String, unless otherwise indicated.  
Unless otherwise noted, all directives specified on the Bundle-SymbolicName
header are visible in the capability and all directives specified
on the Fragment-Host header are visible in the requirement. 
The uses directive must be ignored. A uses directive specified on
the Bundle-SymbolicName header must be ignored. A uses directive
must not be present in the capability.
The effectivedirectives must be ignored. This namespace is only
effective at resolve time. An effective directive specified on the
Bundle-SymbolicName or Fragment-Host headers must be ignored. An effective
directive must not be present in a capability or requirement.
The cardinality directive has limited applicability to this namespace.
A cardinality directive specified on the Fragment-Host header must
be ignored. All requirements must have the cardinality directive set
to multiple.
A non-fragment resource with the with the osgi.bundle type identity
provides zero or one†  host capabilities. A fragment resource with
the osgi.fragment type identity must not declare a host capability
and must declare exactly one host requirement. 
† A resource with no bundle symbolic name must not provide a host
capability.
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] HostNamespace.CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE?>
<?FM MARKER [Index] HostNamespace:CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE?>
CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE
public static final String CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE
= “fragment-attachment”<?FM MARKER [Index] fragment-attachment?>

The capability directive identifying if and when a fragment may
attach to a host bundle. The default value is always. 
	See Also	FRAGMENT_ATTACHMENT_ALWAYS , FRAGMENT_ATTACHMENT_RESOLVETIME
, FRAGMENT_ATTACHMENT_NEVER
<?FM MARKER [Cross-Ref] HostNamespace.CAPABILITY_SINGLETON_DIRECTIVE?>
<?FM MARKER [Index] HostNamespace:CAPABILITY_SINGLETON_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_SINGLETON_DIRECTIVE?>
CAPABILITY_SINGLETON_DIRECTIVE
public static final String CAPABILITY_SINGLETON_DIRECTIVE = “singleton”<?FM MARKER [Index] singleton?>

The capability directive identifying if the resource is a singleton.
A String value of “true“ indicates the resource is a singleton;
any other value or null indicates the resource is not a singleton. 
This directive should be examined using the identity namespace.
	See Also	IdentityNamespace.CAPABILITY_SINGLETON_DIRECTIVE
<?FM MARKER [Cross-Ref] HostNamespace.EXTENSION_BOOTCLASSPATH?>
<?FM MARKER [Index] HostNamespace:EXTENSION_BOOTCLASSPATH?>
<?FM MARKER [Index] EXTENSION_BOOTCLASSPATH?>
EXTENSION_BOOTCLASSPATH
public static final String EXTENSION_BOOTCLASSPATH = “bootclasspath”<?FM MARKER [Index] bootclasspath?>

The directive value indicating that the extension fragment is to
be loaded by the boot class loader. 
	See Also	REQUIREMENT_EXTENSION_DIRECTIVE
<?FM MARKER [Cross-Ref] HostNamespace.EXTENSION_FRAMEWORK?>
<?FM MARKER [Index] HostNamespace:EXTENSION_FRAMEWORK?>
<?FM MARKER [Index] EXTENSION_FRAMEWORK?>
EXTENSION_FRAMEWORK
public static final String EXTENSION_FRAMEWORK = “framework”<?FM MARKER [Index] framework?>

The directive value indicating that the extension fragment is to
be loaded by the framework’s class loader. 
	See Also	REQUIREMENT_EXTENSION_DIRECTIVE
<?FM MARKER [Cross-Ref] HostNamespace.FRAGMENT_ATTACHMENT_ALWAYS?>
<?FM MARKER [Index] HostNamespace:FRAGMENT_ATTACHMENT_ALWAYS?>
<?FM MARKER [Index] FRAGMENT_ATTACHMENT_ALWAYS?>
FRAGMENT_ATTACHMENT_ALWAYS
public static final String FRAGMENT_ATTACHMENT_ALWAYS = “always”<?FM MARKER [Index] always?>

The directive value indicating that fragments are allowed to attach
to the host bundle at any time (while the host is resolved or during
the process of resolving the host bundle). 
	See Also	CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE
<?FM MARKER [Cross-Ref] HostNamespace.FRAGMENT_ATTACHMENT_NEVER?>
<?FM MARKER [Index] HostNamespace:FRAGMENT_ATTACHMENT_NEVER?>
<?FM MARKER [Index] FRAGMENT_ATTACHMENT_NEVER?>
FRAGMENT_ATTACHMENT_NEVER
public static final String FRAGMENT_ATTACHMENT_NEVER = “never”<?FM MARKER [Index] never?>

The directive value indicating that no fragments are allowed to
attach to the host bundle at any time. 
	See Also	CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE
<?FM MARKER [Cross-Ref] HostNamespace.FRAGMENT_ATTACHMENT_RESOLVETIME?>
<?FM MARKER [Index] HostNamespace:FRAGMENT_ATTACHMENT_RESOLVETIME?>
<?FM MARKER [Index] FRAGMENT_ATTACHMENT_RESOLVETIME?>
FRAGMENT_ATTACHMENT_RESOLVETIME
public static final String FRAGMENT_ATTACHMENT_RESOLVETIME = “resolve-time”<?FM MARKER [Index] resolve-time?>

The directive value indicating that fragments are allowed to attach
to the host bundle only during the process of resolving the host
bundle. 
	See Also	CAPABILITY_FRAGMENT_ATTACHMENT_DIRECTIVE
<?FM MARKER [Cross-Ref] HostNamespace.HOST_NAMESPACE?>
<?FM MARKER [Index] HostNamespace:HOST_NAMESPACE?>
<?FM MARKER [Index] HOST_NAMESPACE?>
HOST_NAMESPACE
public static final String HOST_NAMESPACE = “osgi.wiring.host”<?FM MARKER [Index] osgi.wiring.host?>

Namespace name for host capabilities and requirements.  
Also, the capability attribute used to specify the symbolic name
of the host.
<?FM MARKER [Cross-Ref] HostNamespace.REQUIREMENT_EXTENSION_DIRECTIVE?>
<?FM MARKER [Index] HostNamespace:REQUIREMENT_EXTENSION_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_EXTENSION_DIRECTIVE?>
REQUIREMENT_EXTENSION_DIRECTIVE
public static final String REQUIREMENT_EXTENSION_DIRECTIVE = “extension”<?FM MARKER [Index] extension?>

The requirement directive used to specify the type of the extension
fragment. 
	See Also	EXTENSION_FRAMEWORK , EXTENSION_BOOTCLASSPATH
<?FM MARKER [Cross-Ref] HostNamespace.REQUIREMENT_VISIBILITY_DIRECTIVE?>
<?FM MARKER [Index] HostNamespace:REQUIREMENT_VISIBILITY_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_VISIBILITY_DIRECTIVE?>
REQUIREMENT_VISIBILITY_DIRECTIVE
public static final String REQUIREMENT_VISIBILITY_DIRECTIVE = “visibility”<?FM MARKER [Index] visibility?>

The requirement directive used to specify the visibility type for
a requirement. 
This directive should be examined using the bundle namespace.
	See Also	BundleNamespace.REQUIREMENT_VISIBILITY_DIRECTIVE
<?FM MARKER [Cross-Ref] IdentityNamespace?>
<?FM MARKER [Index] IdentityNamespace?>
<?FM MARKER [Index] class:IdentityNamespace?>
IdentityNamespace
public final class IdentityNamespace
	extends Namespace
Identity Capability and Requirement Namespace.  
This class defines the names for the attributes and directives for
this namespace. All unspecified capability attributes are of type
String and are used as arbitrary matching attributes for the capability.
The values associated with the specified directive and attribute
keys are of type String, unless otherwise indicated.  
Each resource provides exactly one†  identity capability that can
be used to identify the resource. 
The bundle wiring for the bundle revision provides exactly one†
 identity capability.  
† A resource with no symbolic name must not provide an identity
capability.
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] IdentityNamespace.CAPABILITY_COPYRIGHT_ATTRIBUTE?>
<?FM MARKER [Index] IdentityNamespace:CAPABILITY_COPYRIGHT_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_COPYRIGHT_ATTRIBUTE?>
CAPABILITY_COPYRIGHT_ATTRIBUTE
public static final String CAPABILITY_COPYRIGHT_ATTRIBUTE = “copyright”<?FM MARKER [Index] copyright?>

The capability attribute that contains a human readable copyright
notice for the resource. See the Bundle-Copyright manifest header. 
<?FM MARKER [Cross-Ref] IdentityNamespace.CAPABILITY_DESCRIPTION_ATTRIBUTE?>
<?FM MARKER [Index] IdentityNamespace:CAPABILITY_DESCRIPTION_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_DESCRIPTION_ATTRIBUTE?>
CAPABILITY_DESCRIPTION_ATTRIBUTE
public static final String CAPABILITY_DESCRIPTION_ATTRIBUTE = “description”<?FM MARKER [Index] description?>

The capability attribute that contains a human readable description
for the resource. See the Bundle-Description manifest header. 
<?FM MARKER [Cross-Ref] IdentityNamespace.CAPABILITY_DOCUMENTATION_ATTRIBUTE?>
<?FM MARKER [Index] IdentityNamespace:CAPABILITY_DOCUMENTATION_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_DOCUMENTATION_ATTRIBUTE?>
CAPABILITY_DOCUMENTATION_ATTRIBUTE
public static final String CAPABILITY_DOCUMENTATION_ATTRIBUTE =
“documentation”<?FM MARKER [Index] documentation?>

The capability attribute that contains the URL to documentation
for the resource. See the Bundle-DocURL manifest header. 
<?FM MARKER [Cross-Ref] IdentityNamespace.CAPABILITY_LICENSE_ATTRIBUTE?>
<?FM MARKER [Index] IdentityNamespace:CAPABILITY_LICENSE_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_LICENSE_ATTRIBUTE?>
CAPABILITY_LICENSE_ATTRIBUTE
public static final String CAPABILITY_LICENSE_ATTRIBUTE = “license”<?FM MARKER [Index] license?>

The capability attribute that contains the URL to the license for
the resource. See the name portion of the Bundle-License manifest
header. 
<?FM MARKER [Cross-Ref] IdentityNamespace.CAPABILITY_SINGLETON_DIRECTIVE?>
<?FM MARKER [Index] IdentityNamespace:CAPABILITY_SINGLETON_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_SINGLETON_DIRECTIVE?>
CAPABILITY_SINGLETON_DIRECTIVE
public static final String CAPABILITY_SINGLETON_DIRECTIVE = “singleton”<?FM MARKER [Index] singleton?>

The capability directive identifying if the resource is a singleton.
A String value of “true” indicates the resource is a singleton;
any other value or null indicates the resource is not a singleton. 
<?FM MARKER [Cross-Ref] IdentityNamespace.CAPABILITY_TYPE_ATTRIBUTE?>
<?FM MARKER [Index] IdentityNamespace:CAPABILITY_TYPE_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_TYPE_ATTRIBUTE?>
CAPABILITY_TYPE_ATTRIBUTE
public static final String CAPABILITY_TYPE_ATTRIBUTE = “type”<?FM MARKER [Index] type?>

The capability attribute identifying the resource type. If the resource
has no type then the value unknown must be used for the attribute. 
	See Also	TYPE_BUNDLE , TYPE_FRAGMENT , TYPE_UNKNOWN
<?FM MARKER [Cross-Ref] IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] IdentityNamespace:CAPABILITY_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_VERSION_ATTRIBUTE?>
CAPABILITY_VERSION_ATTRIBUTE
public static final String CAPABILITY_VERSION_ATTRIBUTE = “version”<?FM MARKER [Index] version?>

The capability attribute identifying the Version of the resource
if one is specified or 0.0.0 if not specified. The value of this
attribute must be of type Version. 
<?FM MARKER [Cross-Ref] IdentityNamespace.CLASSIFIER_JAVADOC?>
<?FM MARKER [Index] IdentityNamespace:CLASSIFIER_JAVADOC?>
<?FM MARKER [Index] CLASSIFIER_JAVADOC?>
CLASSIFIER_JAVADOC
public static final String CLASSIFIER_JAVADOC = “javadoc”<?FM MARKER [Index] javadoc?>

The attribute value identifying the resource classifier as an archive
containing the javadoc in the same directory layout as the resource. 
	See Also	REQUIREMENT_CLASSIFIER_DIRECTIVE
<?FM MARKER [Cross-Ref] IdentityNamespace.CLASSIFIER_SOURCES?>
<?FM MARKER [Index] IdentityNamespace:CLASSIFIER_SOURCES?>
<?FM MARKER [Index] CLASSIFIER_SOURCES?>
CLASSIFIER_SOURCES
public static final String CLASSIFIER_SOURCES = “sources”<?FM MARKER [Index] sources?>

The attribute value identifying the resource classifier as an archive
containing the source code in the same directory layout as the resource. 
	See Also	REQUIREMENT_CLASSIFIER_DIRECTIVE
<?FM MARKER [Cross-Ref] IdentityNamespace.IDENTITY_NAMESPACE?>
<?FM MARKER [Index] IdentityNamespace:IDENTITY_NAMESPACE?>
<?FM MARKER [Index] IDENTITY_NAMESPACE?>
IDENTITY_NAMESPACE
public static final String IDENTITY_NAMESPACE = “osgi.identity”<?FM MARKER [Index] osgi.identity?>

Namespace name for identity capabilities and requirements.  
Also, the capability attribute used to specify the symbolic name
of the resource.
<?FM MARKER [Cross-Ref] IdentityNamespace.REQUIREMENT_CLASSIFIER_DIRECTIVE?>
<?FM MARKER [Index] IdentityNamespace:REQUIREMENT_CLASSIFIER_DIRECTIVE?>
<?FM MARKER [Index] REQUIREMENT_CLASSIFIER_DIRECTIVE?>
REQUIREMENT_CLASSIFIER_DIRECTIVE
public static final String REQUIREMENT_CLASSIFIER_DIRECTIVE = “classifier”<?FM MARKER [Index] classifier?>

The requirement directive that classifies the relationship with
another resource. 
	See Also	CLASSIFIER_SOURCES , CLASSIFIER_JAVADOC
<?FM MARKER [Cross-Ref] IdentityNamespace.TYPE_BUNDLE?>
<?FM MARKER [Index] IdentityNamespace:TYPE_BUNDLE?>
<?FM MARKER [Index] TYPE_BUNDLE?>
TYPE_BUNDLE
public static final String TYPE_BUNDLE = “osgi.bundle”<?FM MARKER [Index] osgi.bundle?>

The attribute value identifying the resource type as an OSGi bundle. 
	See Also	CAPABILITY_TYPE_ATTRIBUTE
<?FM MARKER [Cross-Ref] IdentityNamespace.TYPE_FRAGMENT?>
<?FM MARKER [Index] IdentityNamespace:TYPE_FRAGMENT?>
<?FM MARKER [Index] TYPE_FRAGMENT?>
TYPE_FRAGMENT
public static final String TYPE_FRAGMENT = “osgi.fragment”<?FM MARKER [Index] osgi.fragment?>

The attribute value identifying the resource type as an OSGi fragment. 
	See Also	CAPABILITY_TYPE_ATTRIBUTE
<?FM MARKER [Cross-Ref] IdentityNamespace.TYPE_UNKNOWN?>
<?FM MARKER [Index] IdentityNamespace:TYPE_UNKNOWN?>
<?FM MARKER [Index] TYPE_UNKNOWN?>
TYPE_UNKNOWN
public static final String TYPE_UNKNOWN = “unknown”<?FM MARKER [Index] unknown?>

The attribute value identifying the resource type as unknown. 
	See Also	CAPABILITY_TYPE_ATTRIBUTE
<?FM MARKER [Cross-Ref] PackageNamespace?>
<?FM MARKER [Index] PackageNamespace?>
<?FM MARKER [Index] class:PackageNamespace?>
PackageNamespace
public final class PackageNamespace
	extends AbstractWiringNamespace
Package Capability and Requirement Namespace.  
A resource provides zero or more package capabilities (this is,
exported packages) and requires zero or more package requirements
(that is, imported packages).  
This class defines the names for the attributes and directives for
this namespace. All unspecified capability attributes are of type
String and are used as arbitrary matching attributes for the capability.
The values associated with the specified directive and attribute
keys are of type String, unless otherwise indicated.  
Unless otherwise noted, all directives specified on the Export-Package
header are visible in the capability and all directives specified
on the Import-Package and DynamicImport-Package headers are visible
in the requirement.  
The effectivedirectives must be ignored. This namespace is only
effective at resolve time. An effective directive specified on the
Export-Package, Import-Package or DynamicImport-Package headers
must be ignored. An effective directive must not be present in a
capability or requirement.
The cardinality directive has limited applicability to this namespace.
A cardinality directive specified on the Import-Package or DynamicImport-Package
headers must be ignored. Only requirements with resolution set to
dynamic and the package name contains a wildcard must have the cardinality
directive set to multiple. Otherwise, a cardinality directive must
not be present in a requirement.
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] PackageNamespace.CAPABILITY_BUNDLE_SYMBOLICNAME_ATTRIBUTE?>
<?FM MARKER [Index] PackageNamespace:CAPABILITY_BUNDLE_SYMBOLICNAME_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_BUNDLE_SYMBOLICNAME_ATTRIBUTE?>
CAPABILITY_BUNDLE_SYMBOLICNAME_ATTRIBUTE
public static final String CAPABILITY_BUNDLE_SYMBOLICNAME_ATTRIBUTE
= “bundle-symbolic-name”<?FM MARKER [Index] bundle-symbolic-name?>

The capability attribute contains the symbolic name of the resource
providing the package. 
<?FM MARKER [Cross-Ref] PackageNamespace.CAPABILITY_EXCLUDE_DIRECTIVE?>
<?FM MARKER [Index] PackageNamespace:CAPABILITY_EXCLUDE_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_EXCLUDE_DIRECTIVE?>
CAPABILITY_EXCLUDE_DIRECTIVE
public static final String CAPABILITY_EXCLUDE_DIRECTIVE = “exclude”<?FM MARKER [Index] exclude?>

The capability directive used to specify the comma separated list
of classes which must not be allowed to be exported. 
<?FM MARKER [Cross-Ref] PackageNamespace.CAPABILITY_INCLUDE_DIRECTIVE?>
<?FM MARKER [Index] PackageNamespace:CAPABILITY_INCLUDE_DIRECTIVE?>
<?FM MARKER [Index] CAPABILITY_INCLUDE_DIRECTIVE?>
CAPABILITY_INCLUDE_DIRECTIVE
public static final String CAPABILITY_INCLUDE_DIRECTIVE = “include”<?FM MARKER [Index] include?>

The capability directive used to specify the comma separated list
of classes which must be allowed to be exported. 
<?FM MARKER [Cross-Ref] PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] PackageNamespace:CAPABILITY_VERSION_ATTRIBUTE?>
<?FM MARKER [Index] CAPABILITY_VERSION_ATTRIBUTE?>
CAPABILITY_VERSION_ATTRIBUTE
public static final String CAPABILITY_VERSION_ATTRIBUTE = “version”<?FM MARKER [Index] version?>

The capability attribute contains the Version of the package if
one is specified or 0.0.0 if not specified. The value of this attribute
must be of type Version. 
<?FM MARKER [Cross-Ref] PackageNamespace.PACKAGE_NAMESPACE?>
<?FM MARKER [Index] PackageNamespace:PACKAGE_NAMESPACE?>
<?FM MARKER [Index] PACKAGE_NAMESPACE?>
PACKAGE_NAMESPACE
public static final String PACKAGE_NAMESPACE = “osgi.wiring.package”<?FM MARKER [Index] osgi.wiring.package?>

Namespace name for package capabilities and requirements.  
Also, the capability attribute used to specify the name of the package.
<?FM MARKER [Cross-Ref] PackageNamespace.RESOLUTION_DYNAMIC?>
<?FM MARKER [Index] PackageNamespace:RESOLUTION_DYNAMIC?>
<?FM MARKER [Index] RESOLUTION_DYNAMIC?>
RESOLUTION_DYNAMIC
public static final String RESOLUTION_DYNAMIC = “dynamic”<?FM MARKER [Index] dynamic?>

The directive value identifying a dynamic requirement resolution
type. A dynamic resolution type indicates that the requirement is
resolved dynamically at runtime (such as a dynamically imported package)
and the resource will be resolved without the requirement being
resolved. 
	See Also	Namespace.REQUIREMENT_RESOLUTION_DIRECTIVE

</phrase></INSET>
</chapter>
