<?xml version="1.0" encoding="utf-8"?>
<chapter label="121"
         revision="$Id$"
         version="5" xml:id="service.blueprint"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Blueprint Container Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.blueprint.container-version"
    linkend="org.osgi.service.blueprint.container"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>One of the great promises of object oriented languages was the
    greater reuse it should enable. However, over time it turned out that
    reuse was still hard. One of the key reasons was
    <emphasis>coupling</emphasis>. Trying to reuse a few classes usually ended
    up in dragging in many more classes, that in their turn dragged in even
    more classes, ad nauseum.</para>

    <para>One of the key innovations in the Java language to address this
    coupling issue were <emphasis>interfaces</emphasis>. Interfaces
    significantly could minimize coupling because they were void of any
    implementation details. Any class can use an interface, where that
    interface can be implemented by any other class. However, coupling was
    still necessary because objects need to be created, and for creating an
    object its concrete class is necessary.</para>

    <para>One of the most successful insights in the software industry of late
    has been <emphasis>inversion of control</emphasis>, or more specific
    <emphasis>dependency injection</emphasis>. With dependency injection, an
    object is given the collaborators that it needs to work with. By not
    creating these dependencies itself, the object is not coupled to the
    concrete type of these implementations and their transitive implementation
    dependencies. However, these objects are not useful on their own, they can
    only function when an external party provides these objects with their
    collaborating objects.</para>

    <para>An injection framework creates these objects, and also their
    concrete dependencies, and wires them together. Injection frameworks can
    significantly increase reuse and provide increased flexibility. For
    example, during testing it is possible to inject mocked up objects instead
    of the actual objects.</para>

    <para>There exists a number of these injection frameworks in the market,
    for example <xref linkend="i1954805"/>, <xref
    linkend="i1954924"/>, and <xref linkend="i1954940"/>. These containers are configured with XML, Java
    annotations, or provide automatic configuration based on types.</para>

    <para>Decoupling is one of the primary drivers for the OSGi
    specifications. The module layer provides many mechanisms to hide
    implementation details and explicitly defines any dependencies. The
    service layer provides a mechanism to collaborate with other bundles
    without caring about who that other bundle is. However, using the OSGi
    APIs to construct an application out of services and objects also implies
    coupling to these OSGi APIs.</para>

    <para>This specification therefore defines a dependency injection
    framework, specifically for OSGi bundles, that understands the unique
    dynamic nature of services. It provides an OSGi bundle programming model
    with minimal implementation dependencies and virtually no accidental
    complexity in the Java code. Bundles in this programming model contain a
    number of XML definition resources which are used by the Blueprint
    Container to wire the application together and start it when the bundle is
    active.</para>

    <para>This Blueprint Container specification is derived from the <xref
    linkend="i1954997"/> project.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Dependency Injection Framework</emphasis> – Provide
          an advanced dependency injection framework for bundles that can
          create and wire objects and services together into an
          application.</para>
        </listitem>

        <listitem>
          <para><emphasis>Inversion of Control</emphasis> – (IOC) A pattern in
          which a framework/library provides the control over the component
          instances instead of the other way around. Dependency injection is a
          form of IOC.</para>
        </listitem>

        <listitem>
          <para><emphasis>Extender Model</emphasis> – Enable the configuration
          of components inside a bundle based on configuration data provided
          by the bundle developer. The life cycle of these components is
          controlled by the extender based on the extended bundle’s
          state.</para>
        </listitem>

        <listitem>
          <para><emphasis>Unencumbered</emphasis> – Do not require any special
          bundle activator or other code to be written inside the bundle in
          order to have components instantiated and configured.</para>
        </listitem>

        <listitem>
          <para><emphasis>Services</emphasis> – Enable the usage of OSGi
          services as injected dependencies.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dependencies</emphasis> – Allow components to depend
          on other components like services and beans as well as register as
          services, with the full breadth of the OSGi capabilities.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dynamicity</emphasis> – Minimize the complexity of
          using the dynamicity of services</para>
        </listitem>

        <listitem>
          <para><emphasis>Business Logic</emphasis> – A focus on writing
          business logic in regular Java classes that are not required to
          implement certain framework APIs or contracts in order to integrate
          with a container.</para>
        </listitem>

        <listitem>
          <para><emphasis>Declarative</emphasis> – This facilitates
          independent testing of components and reduces environment
          dependencies.</para>
        </listitem>

        <listitem>
          <para><emphasis>Familiarity</emphasis> – Familiar to enterprise Java
          developers.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Blueprint Extender </emphasis>– The bundle that
          creates and injects component instances for a Blueprint bundle as
          configured in that Blueprint bundle’s XML definition
          resources.</para>
        </listitem>

        <listitem>
          <para><emphasis>Blueprint Container</emphasis> – Represents the
          activities of the Blueprint Extender for a specific Blueprint
          Bundle.</para>
        </listitem>

        <listitem>
          <para><emphasis>Blueprint Bundle</emphasis> – A bundle that is being
          constructed by the Blueprint Container because it has a
          Bundle-Blueprint header or it contains XML resources in the
          <code>OSGI-INF/blueprint</code> directory.</para>
        </listitem>

        <listitem>
          <para><emphasis>Manager –</emphasis> A manager is responsible for
          the life cycle of all <emphasis>component instances</emphasis> for
          one <emphasis>component definition</emphasis>. There are the
          following types of managers. A manager is a <emphasis>bean
          manager</emphasis>, a <emphasis>service</emphasis>
          <emphasis>reference manager</emphasis>, or a <emphasis>service
          manager</emphasis>. A manager can have <emphasis>explicit</emphasis>
          and <emphasis>implicit</emphasis> dependencies on other manager.
          During instantiation and runtime, a manager can
          <emphasis>provide</emphasis> a component instance to be injected or
          used in other ways.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component</emphasis> – A loosely defined term for
          the application building blocks and their infrastructure. Components
          are instantiated into <emphasis>component instances</emphasis> by a
          <emphasis>manager</emphasis> that is configured with a
          <emphasis>Component Metadata</emphasis> subclass that is derived
          from a <emphasis>Component Definition</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Instance</emphasis> – An object that is
          part of the application. Component Instances are created and managed
          by their component <emphasis>manager</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Definition</emphasis> – Configuration data
          used by a manager to construct and manage component instances. This
          configuration data is represented in Metadata, an interface
          hierarchy starting with the <emphasis>Metadata</emphasis>
          interface.</para>
        </listitem>

        <listitem>
          <para><emphasis>Bean Manager</emphasis> – A manager that has
          metadata for creating Java objects and injecting them with objects
          and component instances that come from other managers it implicitly
          depends on.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Manager</emphasis> – A manager that handles
          the registration of a service object that is provided by a component
          instance.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Reference Manager</emphasis> – The general
          name for the reference and reference-list managers.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reference Manager</emphasis>– A manager that handles
          the dependency on a single OSGi service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reference-list Manager </emphasis>– A manager that
          handles the dependency on a list of OSGi services.</para>
        </listitem>

        <listitem>
          <para><emphasis>Environment Manager</emphasis> – A manager that can
          provide information from the Bundle’s environment. For example, the
          <code>BlueprintContainer</code> object is made available through an
          environment manager.</para>
        </listitem>

        <listitem>
          <para><emphasis>Target </emphasis>– A manager type useful in a
          callback context. These are the ref (which is an indirection to), a
          reference, and a bean manager.</para>
        </listitem>

        <listitem>
          <para><emphasis>Property</emphasis> – A conceptual instance variable
          of a component instance provided by a bean manager that is set on
          the component instance with a corresponding
          <code>set&lt;Name&gt;</code> method.</para>
        </listitem>

        <listitem>
          <para><emphasis>Argument</emphasis> – Metadata for an argument in a
          constructor or method.</para>
        </listitem>

        <listitem>
          <para><emphasis>Type Converter</emphasis> – A component instance
          defined, or referenced, in the type-converters section implementing
          the <code>Converter</code> interface.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Blueprint Class and Service Overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="3.062in"
                       contentwidth="7.000in" fileref="blueprint-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Synopsis</title>

      <para>The Blueprint Extender bundle waits for Blueprint bundles. These
      are bundles that contain Blueprint XML resources called the definitions.
      These XML resources can be found in a fixed location or pointed to from
      a manifest header. When a Blueprint extender bundle detects that a
      Blueprint bundle is ready, it creates a Blueprint Container to manage
      that Blueprint bundle.</para>

      <para>The Blueprint Container then parses the definitions into metadata
      objects. All top-level elements in the definitions are
      <code>ComponentMetadata</code> objects and are registered in the
      Blueprint Container by their id.</para>

      <para>For each of the <code>ComponentMetadata</code> objects, the
      Blueprint Container has a corresponding component manager. For example,
      a <code>BeanMetadata</code> object relates to a Bean Manager instance.
      There are the following types of managers:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Bean Managers</emphasis> – Can provide general
          objects that are properly constructed and configured</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Managers</emphasis> – Can register
          services</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Reference Managers</emphasis> – Provide
          proxies to one or more services. there are two sub-types:
          reference-list and reference.</para>
        </listitem>

        <listitem>
          <para><emphasis>Environment Managers</emphasis> – Holding
          environment values like the Blueprint <code>Bundle</code>
          object</para>
        </listitem>
      </itemizedlist>

      <para>After creation, all managers are not yet activated. A manager is
      activated on demand when it has to provide a component instance for the
      first time.</para>

      <para>All service reference managers track services in the service
      registry in order to determine if they are satisfied or not. If not, the
      Blueprint Container can optionally start a <emphasis>grace</emphasis>
      period. During the grace period, the Blueprint Container waits for all
      mandatory service reference managers to become satisfied. If this does
      not happen during the grace period, the Blueprint Container must abort
      the initialization.</para>

      <para>From now on, the Blueprint Container is ready to provide component
      instances. Whenever a manager is asked to provide a component instance
      for the first time, the manager is activated. This activation will first
      request all its dependencies to provide a component instance, activating
      these managers if not already activated, recursively.</para>

      <para>However, the activation needs a trigger to start. There are two
      triggers.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Service Request</emphasis> – All service managers
          must have a Service Factory registered with the OSGi service
          registry whenever that service manager is enabled, see <xref
          linkend="i2630717"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Eager Managers</emphasis> – To kick start the
          application in the bundle, the Blueprint Container must ask all
          eager managers to provide a component instance, thereby activating
          these managers, see <xref linkend="i2081951"/>.</para>
        </listitem>
      </itemizedlist>

      <para>Service references must actuate their reference listeners when
      they are activated.</para>

      <para>Bean managers have a scope. This scope can be
      <code>singleton</code>, where the manager always provides the same
      object, or <code>prototype</code>, where the manager creates a new
      object for each request.</para>

      <para>Service reference managers provide proxies to the actual service
      objects and fetch the service object lazily. They provide a constant
      reference that dampen the dynamics of the underlying service
      objects.</para>

      <para>If the Blueprint Container has successfully activated the eager
      managers, it will register a Blueprint Container service.</para>

      <para>When the Blueprint Container must be destroyed because: the
      Blueprint bundle has stopped, there is a failure, or the Blueprint
      extender is stopped, then the Blueprint Container service is
      unregistered and all managers are deactivated. This will unregister any
      services and disable listeners, which release the component instances.
      Then all component instances are destroyed in reverse dependency order.
      That is, a component instance is destroyed when no other component
      instances depend on it.</para>
    </section>
  </section>

  <section>
    <title>Managers</title>

    <para>The key feature of the Blueprint Container specification is to let
    the application in the bundle be constructed in the proper order from
    objects that are not required to be aware of Blueprint, OSGi, or even each
    other. These objects are called <emphasis>component instances</emphasis>.
    The active entity that orchestrates the life cycle of the bundle
    application is the <emphasis>Blueprint Container</emphasis>. It is
    configured by XML resources in the Blueprint bundle. The Blueprint
    Container is responsible for construction and configuration of the
    component instances as well as the interaction with the service
    registry.</para>

    <para>Inside the Blueprint Container, component instances are managed by a
    <emphasis>manager</emphasis>. A manager is configured with one Component
    Definition, for example a bean definition, and can then provide one or
    more component instances. Such a configured manager instance is also
    loosely called a <emphasis>component</emphasis>.</para>

    <para>A manager can have additional behavior associated with it. This
    behavior is controlled by the manager’s <emphasis>type</emphasis>. This
    specification defines a number of manager types: bean, service,
    environment, reference, and reference-list. These types are further
    defined in the next section.</para>

    <para>These managers are conceptual, they are not visible in the API of
    this specification. That is, an implementation is free to implement the
    specification without these objects as long as the externally observable
    behavior is the same.</para>

    <para>As an example, a trivial echo service:</para>

    <programlisting>&lt;blueprint&gt;
   &lt;service id="echoService" 
            interface="com.acme.Echo" ref="echo"/&gt;
   &lt;bean id="echo" class="com.acme.EchoImpl"&gt;
     &lt;property name="message" value="Echo: "/&gt;
   &lt;/bean&gt;
&lt;/blueprint&gt;

public interface Echo {
  public String echo(String m);
}
public class EchoImpl implements Echo {
  String message;
  public void setMessage(String m) {
    this.message= m;
  }
  public void echo(String s) { return message + s; }
}  </programlisting>

    <para>The example defines two <emphasis>top-level</emphasis> managers:
    <code>echoService</code> and <code>echo</code>. The
    <code>echoService</code> manager is of type <emphasis>service</emphasis>,
    and the <code>echo</code> manager is of type <emphasis>bean</emphasis>.
    The service manager is responsible for registering an OSGi service, where
    the service object will be the component instance provided by the
    <code>echo</code> manager. The <code>echo</code> component instance gets a
    message injected.</para>

    <para>As seen from the example, managers can use component instances from
    other managers to construct their component instances. The use of other
    managers creates an <emphasis>implicit dependency</emphasis>. Managers can
    also declare <emphasis>explicit dependencies</emphasis>. Dependencies are
    transitive, see <xref linkend="i2739446"/> for
    more information. In the previous example, the <code>echoService</code>
    service manager depends on the <code>echo</code> manager, this is an
    implicit dependency.</para>

    <para>Managers have their own life cycle. They are conceptually created
    after the Blueprint Container has decided to run the application, see
    <xref linkend="i2931886"/>. However, the
    intention of this specification is to allow the bundle application to
    lazily <emphasis>activate</emphasis>. That is, no application code is used
    until there is a trigger like a service request or a service manager has
    an explicit dependency. A manager must always be atomically activated
    before it provides its first component instance. During activation,
    listeners are actuated and notified, service objects are requested, etc.
    The details are described in the appropriate manager’s type
    description.</para>

    <para>Each manager type has an associated <emphasis>component</emphasis>
    <emphasis>metadata</emphasis> type. Component Metadata is used to
    configure a manager. XML definition resources in the bundle define the
    source for this Metadata. In the previous example, the
    <code>service</code> and <code>bean</code> XML element are translated to a
    <code>ServiceMetadata</code> and <code>BeanMetadata</code> object
    respectively.</para>

    <para>The Blueprint Container maintains a registry of managers by their
    <emphasis>id</emphasis>. These are the managers that are called the
    <emphasis>top-level</emphasis> managers. Top level managers are managers
    defined as child elements of the top XML <code>blueprint</code> element or
    bean managers in the <code>type-converters</code> element. Their Metadata
    is registered under their id (or calculated id) in the Blueprint
    Container. All top level managers share a single namespace. That is, it is
    an error if the same <code>id</code> is used multiple times or attempts to
    override the built-in environment managers.</para>

    <para>Top level managers can depend on other top level managers but there
    are many places where a manager can depend on an <emphasis>inlined
    </emphasis>manager. In these places, a complete manager can be defined
    inside another manager. Such inlined managers are always
    <emphasis>anonymous</emphasis>: they must not have an id and must not be
    registered as a top-level manager. Inlined beans are further constrained
    to always have <code>prototype</code> scope. That is, every time they are
    asked to provide a component instance, they must return a different
    object.</para>

    <para>When the Blueprint Container must be <emphasis>destroyed</emphasis>,
    all <code>singleton</code> component instances that have been created must
    be destroyed. This must first <emphasis>deactivate</emphasis> all
    activated managers. All these managers must release their dependencies on
    any component instances they hold. Then the Blueprint Container must
    destroy all <code>singleton</code> component instances. The order of this
    destruction must be such that a component instance is only destroyed if
    there are no other component instances depending on it. See <xref
    linkend="i2491884"/>.</para>

    <para>The relations between manager types, component instances, metadata
    and the Blueprint Container is schematically depicted in <xref
    linkend="i2517280" xrefstyle="template:Figure %n on page %p"/>.</para>

    <figure xml:id="i2517280">
      <title>Managers and Metadata</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="3.751in"
                     contentwidth="4.901in" fileref="managers-metadata.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Manager Types</title>

      <para>Blueprint only supports a fixed set of the following
      <emphasis>manager types</emphasis>:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Bean</emphasis> – A bean manager provides regular
          Java objects as component instances. It has the following
          features:</para>

          <itemizedlist>
            <listitem>
              <para>Construction via class name, static factory method, or a
              factory method on a <emphasis>target</emphasis>. A
              <emphasis>target</emphasis> is a reference to a top level
              manager of type bean or service reference, or a referral to a
              top level manager of those types.</para>
            </listitem>

            <listitem>
              <para>Can have <emphasis>arguments</emphasis> for a constructor
              or factory method.</para>
            </listitem>

            <listitem>
              <para>Can have <emphasis>properties</emphasis> that are
              injected.</para>
            </listitem>

            <listitem>
              <para>Manages a singleton or creates objects on demand depending
              on its <emphasis>scope</emphasis>.</para>
            </listitem>

            <listitem>
              <para>Life cycle callbacks for end of initialization and
              destruction.</para>
            </listitem>
          </itemizedlist>

          <para>See <xref linkend="i2217757"/> for
          more details.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reference</emphasis> – Reference managers track a
          service in the OSGi service registry. When activated, they provide a
          proxy to a service object. See <xref linkend="i2468749"/> for more details. A reference is
          satisfied when its selection matches a service in the
          registry.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reference-list</emphasis> – Reference-list managers
          track multiple services. A reference-list is satisfied when its
          selection matches one or more services in the registry. See <xref
          linkend="i2468749"/> for more
          details.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service</emphasis> – Service managers maintain the
          registration of an OSGi service object. Service managers provide a
          proxied <code>ServiceRegistration</code> object so that the
          application code has a constant reference, even if the service is
          unregistered and then registered again. A service manager is
          <emphasis>enabled</emphasis> if all the mandatory service references
          in its dependencies are satisfied. See <xref linkend="i1947792"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Environment</emphasis> – Environment managers
          provide access to the environment of the Blueprint bundle, for
          example its Bundle Context. See <xref linkend="i2088582"/> for more details.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Metadata Objects</title>

      <para><code>Metadata</code> objects hold the configuration information
      (from the Component Definition) for the managers. These metadata objects
      represent the element structure found in the XML definitions in
      canonical form. Each element in the XML has a corresponding Metadata
      sub-type that has a name that maps directly to the element. For example,
      the <code>bean</code> element represents the bean manager that has its
      configuration data defined in the <code>BeanMetadata</code>
      interface.</para>

      <para>There are <code>Metadata</code> interfaces for all the manager
      types, except the environment type. Some dependency injections require
      the construction of arrays, maps, properties, simple objects, etc. For
      these type of objects, additional Metadata sub-interfaces are defined;
      these interfaces provide the information to construct the basic
      programming types. For example, the <code>CollectionMetadata</code>
      interface contains the information to construct an Array or Collection
      of a given type, where its member values are defined by other
      <code>Metadata</code> objects.</para>

      <para>The set of Metadata types is fixed in this specification, just
      like the set of manager types. It is impossible to extend this set with
      user defined Metadata types. For more information about Metadata, see
      <xref linkend="i2373727"/>.</para>
    </section>

    <section>
      <title>Activation and Deactivation</title>

      <para>Managers are created after all the definitions are parsed. Some
      managers can already show some activity, for example service managers
      always activate explicit dependencies and register a Service Factory
      with the OSGi service registry. However, in this state a manager should
      attempt to not use any resources from the Blueprint bundle until it is
      activated itself.</para>

      <para>A manager must be atomically activated when it has to provide its
      first component instance. During activation it can perform a manager
      specific initialization that will actually consume resources from the
      Blueprint bundle. This activation must be atomic. That is, if a manager
      is being activated then other threads must block until the activation is
      completed.</para>

      <para>Deactivation only happens during the destruction of the Blueprint
      Container. During deactivation, a manager must release any dependencies
      on resources of the Blueprint bundle. No components instances are
      destroyed during deactivation because the singleton component instance
      destruction must happen after all managers are deactivated.</para>

      <para>Each manager type has a dedicated section that describes what must
      happen during its activation and deactivation.</para>
    </section>

    <section xml:id="i2739446">
      <title>Manager Dependencies</title>

      <para>Managers that refer to other managers depend on these managers
      transitively. For example, a service manager depends directly on the
      manager that provides the service object. In its turn, that service
      object could depend on any provided objects that were used to construct
      and inject this service object, and so on. This transitive set of
      dependencies are called <emphasis>implicit dependencies</emphasis>
      because these dependencies are implicitly created by the use of other
      managers in the Component Definitions.</para>

      <para>Managers can also be configured with <emphasis>explicit
      dependencies</emphasis>. The XML definitions for all managers have a
      <code>depends-on</code> attribute with a whitespace delimited list of
      manager ids. Each of these <code>depends-on</code> managers must provide
      an object, that will be ignored. The timing of activation of
      dependencies depends on the specific managers but in general should
      happen before any observable behavior.</para>

      <para>There is no ordering guarantee between independent sets of
      dependencies. The dependency graph is based on the managers, not the
      component instances. For example, the following definition:</para>

      <programlisting>&lt;blueprint default-activation=’eager’&gt;
  &lt;bean id=’A’...&gt;  &lt;argument ref=’B’&gt; &lt;/bean&gt;
  &lt;bean id=’B’ depends-on=’C E’...&gt;  
    &lt;argument ref=’C’&gt; 
  &lt;/bean&gt;
  &lt;bean id=’C’ scope=’prototype’ ...&gt;  
    &lt;argument ref=’D’&gt; 
  &lt;/bean&gt;
  &lt;bean id=’D’ .../&gt;
  &lt;bean id=’E’ ...&gt; &lt;argument ref=’C’/&gt; &lt;/bean&gt;
  &lt;bean id=’F’ depends-on=’B’ activation="lazy"/&gt;
&lt;/blueprint&gt;</programlisting>

      <para>After initialization, there will be the following component
      instances: <code>a</code>, <code>b</code>, <code>d</code>,
      <code>e</code>, and three <code>c</code>’s. Lower case names are used
      for instances, the corresponding upper case is its manager. The ordering
      guarantee is that manager <code>D</code> is activated before manager
      <code>C</code>, manager <code>C</code> is activated before manager
      <code>E</code> and <code>B</code>, manager <code>E</code> is activated
      before manager <code>B</code>, and manager <code>B</code> is activated
      before manager <code>A</code>. There will be no component instance
      <code>f</code> created because <code>F</code> is a lazy manager. There
      are three <code>c</code>’s because manager <code>E</code> and
      <code>B</code> have an implicit dependency on <code>C</code> and manager
      <code>B</code> has an additional explicit dependency, totalling 3
      dependencies. One of these <code>c</code>’s is an orphan and will be
      garbage collected over time because it is not referred to by any
      component instance.</para>

      <para>The example is depicted in <xref linkend="i2660491"
      xrefstyle="template:Figure %n on page %p"/>.</para>

      <figure xml:id="i2660491">
        <title>Dependency Graph after initialization</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.882in"
                       contentwidth="4.948in" fileref="graph-after-init.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="i2491884">
      <title>Reverse Dependency Order</title>

      <para>The destruction of component instances must be done in
      <emphasis>reverse dependency order</emphasis>. This concept is defined
      as only destroying a singleton component instance (in a manager specific
      way) when no other activated singleton component instance has an
      implicit or explicit dependency on it. That is, a component instance has
      no more field references to other component instances. A component that
      never was activated does not have any dependencies.</para>

      <para>This strategy will ensure that a component instance cannot have an
      instance field that refers to an component instance that has been
      destroyed.</para>

      <para>Deactivating the manager will release its dependencies, which then
      frees up other component instances until all component instances are
      destroyed, or there are cyclic references. In the case of cyclic
      dependencies, the order of destruction is undefined.</para>

      <para>In the example depicted in <xref linkend="i2660491"
      xrefstyle="template:Figure %n on page %p"/>, the previous rules imply that component
      instance <code>a</code> can be immediately destroyed first because it
      has no clients. After component instance <code>a</code> is destroyed,
      component instance <code>b</code> becomes free because no other
      component instances refer to it. The explicit dependency from manager
      <code>F</code> to manager <code>B</code> was never activated, so it is
      not taken into account. The destruction of component instance
      <code>b</code> frees up component instance <code>e</code> and
      <code>c</code> because now the explicit dependency from manager
      <code>B</code> to manager <code>E</code> and manager <code>B</code> to
      manager <code>C</code> have been released. Manager <code>C</code> is
      deactivated but no component instances are destructed because it has
      prototype scope; these managers do not destroy their component
      instances. Then component instance <code>d</code> can be
      destructed.</para>
    </section>

    <section>
      <title>Cyclic Dependencies</title>

      <para>The implicit and explicit dependencies of a component form a
      dependency graph. In the ideal case, this graph should be free from
      <emphasis>cycles</emphasis>. A cycle occurs when a set of one or more
      managers find themselves in their own implicit or explicit dependencies.
      For example:</para>

      <programlisting>public class A { public A(B b); }
public class B { public void setA(A a); }

&lt;bean id="a" class="A"&gt; &lt;argument ref="b"/&gt; &lt;/bean&gt;
&lt;bean id="b" class="B"&gt; &lt;property name="a" ref="a"/&gt; &lt;/bean&gt;</programlisting>

      <para>In this example, the cycle is the set <code>{a,b}</code>. Managers
      can be part of multiple cycles.</para>

      <para>When a member of a cycle is requested to provide a component
      instance, the Blueprint Container must break the cycle by finding one
      <emphasis>breaking member</emphasis> in the cycle’s members. A breaking
      member must be a singleton bean and use property injection for the
      dependency that causes the cycle. The Blueprint Container can pick any
      suitable member of the cycle for breaking member, if no such member can
      be found, then initialization fails or the
      <code>getComponentInstance</code> method must throw a Component
      Definition Exception.</para>

      <para>In the previous example, manager <code>b</code> can be a breaking
      member because it uses the property injection for the cyclic dependency
      on manager <code>a</code>. Manager <code>a</code> cannot be a breaking
      member because the cyclic dependency is caused by a constructor
      argument, a breaking member must use property injection for the cyclic
      dependency to be broken.</para>

      <para>A breaking member must return a partially initialized component
      instance when it is asked to provide an object. A partially initialized
      object has done all possible initialization but has not yet been called
      with the <code>initMethod</code> (if specified) nor has it been injected
      any of the properties that causes a cycle. The
      <emphasis>finalization</emphasis> of the partially initialized component
      instance must be delayed until the breaking member has been injected in
      all referring members of the cycles. Finalization means injecting any
      remaining unset properties and calling of the <code>initMethod</code>,
      if specified.</para>

      <para>The consequence of partially initialized component instances is
      that they can be used before they have all properties set, applications
      must be aware of this.</para>

      <para>All partially initialized component instances must be finalized
      before the Blueprint Container enters the Runtime phase and before a
      call to the <code>getComponentInstance</code> method returns a component
      instance.</para>

      <para>All detected cycles should be logged.</para>

      <para>Consider the following example:</para>

      <programlisting>public class A {
 public A(B b) {}
}
public class B {
 public B(A a) {}
}</programlisting>

      <para>And the configuration:</para>

      <programlisting>&lt;bean id="a" class="A"&gt; &lt;argument ref="b"/&gt; &lt;/bean&gt;
&lt;bean id="b" class="B"&gt; &lt;argument ref="a"/&gt; &lt;/bean&gt;</programlisting>

      <para>In this case, the cycle cannot be broken because neither manager
      qualifies as breaking manager because they have a constructor/factory
      argument dependency. That is, it is impossible to construct an object
      without using the dependency. However, consider the following
      example:</para>

      <programlisting>public class A {
 public A(B b) {}
}
public class B {
 public B(C c) {}
}
public class C {
  public void setA(A a) {}
}</programlisting>

      <para>And the configuration:</para>

      <programlisting>&lt;bean id="a" class="A"&gt; &lt;argument ref="b"/&gt; &lt;/bean&gt;
&lt;bean id="b" class="B"&gt; &lt;argument ref="c"/&gt; &lt;/bean&gt;
&lt;bean id="c" class="C" init-method="done"&gt; 
    &lt;property name="a" ref="a"/&gt;      
&lt;/bean&gt;</programlisting>

      <para>This configuration is depicted in <xref linkend="i2799562"
      xrefstyle="template:Figure %n on page %p"/>. This cycle <code>{a,b,c}</code> can be
      broken by selecting manager <code>c</code> as the breaking member. If
      manager <code>a</code> is requested to provide a component instance for
      the first time, then the following sequence takes place:</para>

      <programlisting>activate a
  activate b
    activate c
      c = new C()
    b = new B(c)
  a = new A(b)
  c.seta(a)
  c.done()
return a</programlisting>

      <figure xml:id="i2799562">
        <title>Cyclic Dependency</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="0.635in"
                       contentwidth="4.948in" fileref="cyclic-dependency.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Cycles must be broken, if possible, both for
      <code>singleton</code> managers as well as <code>prototype</code> beans,
      although a breaking manager must always be a <code>singleton</code> bean
      because a <code>prototype</code> bean must always return a new object,
      making it impossible to break the cycle by returning a partially
      initialized component instance. That is, the following definition is not
      allowed to attempt to create an infinite loop:</para>

      <programlisting>&lt;bean id="a" scope="singleton" class="A"&gt; 
  &lt;property name="a" ref="a"&gt;
&lt;/bean&gt;</programlisting>

      <para>The previous definition must create an <code>A</code> object that
      refers to itself. However, if the example had used a
      <code>prototype</code> scope, it would be an unbreakable cycle.</para>
    </section>

    <section>
      <title>Eager Managers</title>

      <para>The Blueprint Container can force the activation of the
      application in the Blueprint bundle with <emphasis>eager</emphasis>
      managers. An eager manager is a manager that has the
      <code>activation</code> set to <code>eager</code>. A bean manager can
      only be <code>eager</code> if it has <code>singleton</code>
      <code>scope</code>.</para>

      <para>Eager managers are explicitly activated by asking them to provide
      a component instance after all other initialization is done. A bundle
      that wants to be lazily initialized should not define any eager
      managers.</para>
    </section>
  </section>

  <section xml:id="i2931886">
    <title>Blueprint Life-Cycle</title>

    <para>A bundle is a <emphasis>Blueprint bundle</emphasis> if it contains
    one or more blueprint XML <emphasis>definition</emphasis> resources in the
    <code>OSGI-INF/blueprint</code> directory or it contains the
    Bundle-Blueprint manifest header referring to existing resources.</para>

    <para>A <emphasis>Blueprint extender</emphasis> is an implementation of
    this specification and must track<emphasis> </emphasis>blueprint bundles
    that are <emphasis>type compatible</emphasis> for the Blueprint packages
    and initialize them appropriately. The timing and ordering of the
    initialization process is detailed in the following section.</para>

    <para>There should be only one Blueprint extender present in an OSGi
    framework because this specification does not specify a way to resolve the
    conflicts that arise when two Blueprint extenders extend the same
    Blueprint bundle.</para>

    <section>
      <title>Class Space Compatibility</title>

      <para>A Blueprint extender must not manage a Blueprint bundle if there
      is a class space incompatibility for the
      <code>org.osgi.service.blueprint</code> packages. For example, if the
      Blueprint bundle uses the <code>BlueprintContainer</code> class, then it
      must import the <code>org.osgi.service.blueprint.container</code>
      package. The Blueprint extender and the Blueprint bundle must then share
      the same class space for this package. Type compatibility can be
      verified by loading a class from the blueprint packages via the
      Blueprint extender bundle and the Blueprint bundle’s
      <code>loadClass</code> methods. If the Blueprint bundle cannot load the
      class or the class is identical to the class loaded from the extender,
      then the two bundles are compatible for the given package. If the
      Blueprint extender is not class space compatible with the Blueprint
      bundle, then Blueprint extender must not start to manage the Blueprint
      bundle.</para>
    </section>

    <section xml:id="i2272468">
      <title>Initialization of a Blueprint Container</title>

      <para>A Blueprint extender manages the application life cycle of
      Blueprint bundles based on:</para>

      <itemizedlist>
        <listitem>
          <para>The Blueprint bundle state,</para>
        </listitem>

        <listitem>
          <para>The Blueprint definitions,</para>
        </listitem>

        <listitem>
          <para>The Blueprint extender’s bundle state</para>
        </listitem>

        <listitem>
          <para>The class space compatibility</para>
        </listitem>
      </itemizedlist>

      <para>All activities on behalf of the Blueprint bundle must use the
      Bundle Context of the Blueprint bundle. All dynamic class loads must use
      the Blueprint bundle’s <code>Bundle</code> <code>loadClass</code>
      method.</para>

      <para>The following sections describe a linear process that handles one
      Blueprint bundle as if it was managed by a special thread, that is,
      waits are specified if the thread waits. Implementations are likely to
      use a state machine instead for each managed Blueprint bundle, the
      linear description is only used for simplicity.</para>

      <para>In the following description of the initialization steps, the
      Blueprint Container will update its state. State changes are broadcast
      as events, see <xref linkend="i2148562"/>.</para>

      <para>If any failure occurs during initialization, or the Blueprint
      bundle or Blueprint extender bundle is stopped, the Blueprint Container
      must be destroyed, see <xref linkend="i2143970"/>. These checks are not indicated in the
      normal flow for clarity.</para>

      <section xml:id="i2959082">
        <title>Initialization Steps</title>

        <para>The initialization process of a Blueprint Container is defined
        in the following steps:</para>

        <orderedlist>
          <listitem>
            <para>Wait until a blueprint bundle is <emphasis>ready</emphasis>.
            A blueprint bundle is ready when it is in the <code>ACTIVE</code>
            state, and for blueprint bundles that have a <code>lazy</code>
            activation policy, also in the <code>STARTING</code> state.</para>
          </listitem>

          <listitem>
            <para>Prepare, verify if this Blueprint bundle must be managed,
            see <xref linkend="i2959070"/>.</para>
          </listitem>

          <listitem>
            <para>State = <code>CREATING</code></para>
          </listitem>

          <listitem>
            <para>Parse the XML definition resources.</para>
          </listitem>

          <listitem>
            <para>Service reference managers must start tracking their
            satisfiablity without actually activating. See <xref
            linkend="i2157344"/>.</para>
          </listitem>

          <listitem>
            <para>If all mandatory service references are satisfied, or the
            <code>blueprint.graceperiod</code> is <code>false</code>, then go
            to step <xref linkend="i2543924"/>.</para>
          </listitem>

          <listitem>
            <para>State = <code>GRACE_PERIOD</code></para>
          </listitem>

          <listitem>
            <para>Perform the <emphasis>grace period</emphasis>. This period
            waits until all mandatory service references are satisfied. See
            <xref linkend="i2456332"/>. This step
            fails if the mandatory dependencies are not satisfied at the end
            of the grace period.</para>
          </listitem>

          <listitem xml:id="i2543924">
            <para>The Blueprint Container is now ready to provide component
            instances.</para>
          </listitem>

          <listitem>
            <para>Service managers must initialize their explicit dependencies
            and have a Service Factory registered during the periods that they
            are enabled. See <xref linkend="i2584179"/>.</para>
          </listitem>

          <listitem>
            <para>Ask all eager managers to provide a component instance. See
            <xref linkend="i2081951"/>.</para>
          </listitem>

          <listitem>
            <para>State = <code>CREATED</code></para>
          </listitem>

          <listitem>
            <para>Register the Blueprint Container</para>
          </listitem>

          <listitem>
            <para>The components are now active and perform their function
            until the Blueprint bundle or the Blueprint extender bundle are
            stopped.</para>
          </listitem>

          <listitem>
            <para>State = <code>DESTROYING</code></para>
          </listitem>

          <listitem>
            <para>Perform the Destroy phase, see <xref linkend="i2497674"/>.</para>
          </listitem>

          <listitem>
            <para>State = <code>DESTROYED</code></para>
          </listitem>
        </orderedlist>
      </section>

      <section xml:id="i2143970">
        <title>Failure</title>

        <para>If at any time there is a failure, the Blueprint Container
        must:</para>

        <orderedlist>
          <listitem>
            <para>State = <code>FAILURE</code></para>
          </listitem>

          <listitem>
            <para>Unregister the Blueprint Container service.</para>
          </listitem>

          <listitem>
            <para>Destroy the Blueprint Container.</para>
          </listitem>

          <listitem>
            <para>Wait for the Blueprint bundle to be stopped.</para>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>Diagram</title>

        <para>This initialization process is depicted in <xref
        linkend="i2055945" xrefstyle="template:Figure %n on page %p"/>.</para>

        <figure xml:id="i2055945">
          <title>Blueprint Bundle Initialization</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" contentdepth="5.423in"
                         contentwidth="4.947in"
                         fileref="blueprint-bundle-init.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>Extensions</title>

      <para>A compliant implementation of this specification must follow the
      rules as outlined. However, implementations can provide functional
      extensions by including attributes or elements of other namespaces. For
      example, a Blueprint extender implementation that supports proxying of
      certain classes and a number of additional type converters could include
      a <code>http://www.acme.com/extensions</code> namespace that adds an
      <code>extensions</code> attribute on the <code>blueprint</code>
      element:</para>

      <programlisting>&lt;xml version="1.0" encoding="UTF-8"&gt;
&lt;blueprint
 xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
 xmlns:ext="http://www.acme.com/extensions"

  ext:extensions="proxyClasses"
&gt;
  ...
&lt;/blueprint&gt;</programlisting>

      <para>Blueprint extenders that detect the use of an unrecognized
      namespace must fail to signal a portability problem.</para>
    </section>

    <section xml:id="i2959070">
      <title>Preparing</title>

      <para>Blueprint definitions are stored as resources in the Blueprint
      bundle. If a Bundle-Blueprint manifest header is defined, then this
      header contains a list of paths. The Bundle-Blueprint header has the
      following syntax:</para>

      <programlisting>Bundle-Blueprint ::= header 
                     // Core <phrase role="xref">3.2.4 Common Header Syntax</phrase></programlisting>

      <para>This specification does not define any attributes or directives
      for this header. Implementations can provide proprietary parameters that
      should be registered with the OSGi Alliance to prevent name collisions.
      The non-localized version of the header must be used.</para>

      <para>The last component of each path in the Bundle-Blueprint header may
      use wildcards so that <code>Bundle.findEntries</code> can be used to
      locate the XML document within the bundle and its fragments. The
      <code>findEndtries</code> method must always be used in the
      non-recursive mode. Valid paths in the header have one of the following
      forms:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>absolute path</emphasis> – The path to a resource in
          the fragment or directory, this resource must exist. For example
          <code>cnf/start.xml</code>.</para>
        </listitem>

        <listitem>
          <para><emphasis>directory</emphasis> – The path to directory in a
          fragment or main bundle, the path must end in a solidus (slash
          <code>’/’ \u002F</code>). The pattern used in the
          <code>findEntries</code> method must then be <code>*.xml</code>. The
          directory is allowed to be empty.</para>
        </listitem>

        <listitem>
          <para><emphasis>pattern</emphasis> – The last component of the path
          specifies a filename with optional wildcards. The part before is the
          path of directory in the bundle or one of its fragments. These two
          parts specify the parameter to <code>findEntries</code>. It is
          allowed to have no matching resources. An example of a pattern is:
          <code>cnf/*.xml</code>.</para>
        </listitem>
      </itemizedlist>

      <para>If no resources can be found, then the Blueprint bundle will not
      be managed and the initialization exits.</para>

      <para>For example, the following header will read the resources
      <code>/lib/account.xml</code>, <code>/security.bp</code>, and all
      resources which path ends in <code>.xml</code> in the <code>/cnf</code>
      directory:</para>

      <programlisting>Bundle-Blueprint: lib/account.xml, security.bp,cnf/*.xml</programlisting>

      <para>If the Bundle-Blueprint header is not defined, then its default
      value is:</para>

      <programlisting>OSGI-INF/blueprint/*.xml</programlisting>

      <para>A Bundle-Blueprint manifest header specified in a fragment is
      ignored by the Blueprint Container. However, XML documents referenced by
      a bundle’s Bundle-Blueprint manifest header, or its default, may be
      contained in attached fragments, as defined by the
      <code>findEntries</code> method.</para>

      <para>If the Bundle-Blueprint header is specified but empty, then the
      Blueprint bundle must not be managed. This can be used to temporarily
      disable a Blueprint bundle.</para>
    </section>

    <section>
      <title>Parsing</title>

      <para>The Blueprint Container must parse the XML definitions into the
      Blueprint Container’s metadata registry. Parsing fails if:</para>

      <itemizedlist>
        <listitem>
          <para>A path from the Bundle-Blueprint header cannot be found in the
          bundle or any of its fragments.</para>
        </listitem>

        <listitem>
          <para>An XML definition does not validate against its schema.</para>
        </listitem>

        <listitem>
          <para>The XML elements do not meet one or more of their
          constraints</para>
        </listitem>

        <listitem>
          <para>Any errors occur</para>
        </listitem>
      </itemizedlist>

      <para>For failure, see <xref linkend="i2009036"/>.</para>
    </section>

    <section xml:id="i2157344">
      <title>Tracking References</title>

      <para>Service reference managers must track the service registry to see
      if they are satisfied or not. These managers must not be activated to
      register these service listeners nor must they activate any dependencies
      until they are activated. That is, no component instances for the
      reference listeners are obtained until the service reference manager is
      activated.</para>
    </section>

    <section xml:id="i2456332">
      <title>Grace Period</title>

      <para>A Blueprint Container by default will wait for its dependencies in
      the <emphasis>grace period</emphasis>. However, this can be overridden
      with a directive on the Bundle-SymbolicName header of the Blueprint
      bundle:</para>

      <itemizedlist>
        <listitem>
          <para><code>blueprint.graceperiod</code> (
          <code>true</code>|<code>false</code>) – If set to <code>true</code>,
          then the Blueprint Container must enter the grace period and wait
          for dependencies, this is the default. Otherwise, it must skip the
          grace period and progress to the next phase regardless if there are
          any unsatisfied service references.</para>
        </listitem>
      </itemizedlist>

      <para>The purpose of the grace period is to handle the initialization of
      multiple bundles <emphasis>gracefully</emphasis>. The grace period will
      first wait a configurable time for all mandatory service references to
      become satisfied, or for the bundle to stop. If these mandatory services
      are satisfied, then the grace period succeeds, otherwise it will fail.
      If the bundle is stopped during the grace period, then the Blueprint
      Container must be destroyed.</para>

      <para>During the waiting period services can come and go. Each time such
      a service event takes place that involves any of the mandatory service
      references, the Blueprint Container must send out another
      <code>GRACE_PERIOD</code> event if that event does not result in ending
      the grace period. The event contains the complete filters of the
      unsatisfied service references, see <xref linkend="i2951918"/>.</para>

      <para>The wait time for the grace period is defined in a directive on
      the Bundle-SymbolicName header of the Blueprint bundle:</para>

      <itemizedlist>
        <listitem>
          <para><code>blueprint.timeout</code> (<code>Integer &gt;= 0</code>)
          – The time to wait in the grace period for dependencies to become
          satisfied in milliseconds. The default is 300000, which is 5
          minutes. If the <code>timeout</code> is 0, an indefinite wait will
          take place.</para>
        </listitem>
      </itemizedlist>

      <para>OSGi services are dynamic, therefore the grace period does not
      guarantee that all mandatory service references are still available. It
      only guarantees that at one moment in time they were available. A
      mandatory reference can become <emphasis>unsatisfied</emphasis> at any
      moment in time when a service is not available. See the <xref
      linkend="i1766539"/> for a description of how
      this is handled.</para>

      <para>For example, the following header will make the bundle wait a
      maximum of 10 seconds for its mandatory service references to be
      satisfied. These dependencies must be satisfied, or a failure
      occurs.</para>

      <programlisting>Bundle-SymbolicName: com.acme.foo;
    blueprint.graceperiod:=true;
    blueprint.timeout:= 10000</programlisting>
    </section>

    <section xml:id="i2584179">
      <title>Service Registration</title>

      <para>A service manager must first activate all its explicit
      dependencies but it must not activate. It must then ensure that a
      Service Factory object is registered as a service when that service is
      <emphasis>enabled</emphasis>. Enabled means that all of the mandatory
      service references in its dependencies are satisfied.</para>

      <para>Once the Service Factory is registered, any bundle can get the
      corresponding service object. Such a request must activate the service
      manager, if it is not already activated. Activation of a service manager
      must obtain a component instance from the Blueprint Container for the
      service object and any registration listeners. The registration
      listeners are then actuated and notified of the initial state.</para>
    </section>

    <section xml:id="i2081951">
      <title>Eager Instantiation</title>

      <para>After all initialization is done, the Blueprint Container is
      ready. It is now possible to request component instances. If a bundle
      needs immediate startup because they cannot wait until they are
      triggered, then it should set the <code>activation</code> of its bean
      managers to <code>eager</code>. The Blueprint Container must request all
      eager managers to provide a component instance in this instantiation
      phase, see also <xref linkend="i2707929"/>.</para>
    </section>

    <section>
      <title>Runtime Phase</title>

      <para>The Blueprint Container must be registered as a service with the
      following service properties:</para>

      <itemizedlist>
        <listitem>
          <para><code>osgi.blueprint.container.symbolicname</code> – The
          bundle symbolic name of the Blueprint bundle</para>
        </listitem>

        <listitem>
          <para><code>osgi.blueprint.container.version</code> – The version of
          the Blueprint bundle</para>
        </listitem>
      </itemizedlist>

      <para>The Blueprint Container service must only be available during the
      runtime phase when initialization has succeeded.</para>

      <para>As long as the Blueprint extender and the Blueprint bundle are
      active, the application is in the runtime phase. The component instances
      perform their requested functionality in collaboration. The Blueprint
      Container can be used to provide objects from the defined managers, get
      information about the configuration, and general state information, see
      <xref linkend="i2088582"/>.</para>
    </section>

    <section xml:id="i2497674">
      <title>Destroy the Blueprint Container</title>

      <para>The Blueprint Container must be destroyed when any of the
      following conditions becomes true:</para>

      <itemizedlist>
        <listitem>
          <para>The Blueprint bundle is stopped, that is, it is no longer
          ready.</para>
        </listitem>

        <listitem>
          <para>The Blueprint extender is stopped</para>
        </listitem>

        <listitem>
          <para>One of the initialization phases failed.</para>
        </listitem>
      </itemizedlist>

      <para>Destroying the Blueprint Container must occur synchronously with
      the Bundle <code>STOPPING</code> event if that caused any of the
      previous conditions. For example, if the Blueprint extender is stopped,
      it must synchronously destroy all Blueprint Containers it has
      created.</para>

      <para>Destroying the Blueprint Container means:</para>

      <orderedlist>
        <listitem>
          <para>Unregistering the Blueprint Container service</para>
        </listitem>

        <listitem>
          <para>Deactivating all managers.</para>
        </listitem>

        <listitem>
          <para>Destroying all component instances in reverse dependency
          order, see <xref linkend="i2491884"/>.</para>
        </listitem>
      </orderedlist>

      <para>A Blueprint Container must continue to follow the destruction even
      when component instances throw exceptions or other problems occur. These
      errors should be logged.</para>

      <para>If the Blueprint extender is stopped, then all its active
      Blueprint Containers must be destroyed in an orderly fashion,
      synchronously with the stopping of the Blueprint extender bundle.
      Blueprint Containers must use the following algorithm to destroy
      multiple Blueprint Containers:</para>

      <orderedlist>
        <listitem>
          <para>Destroy Blueprint Containers that do not have any services
          registered that are in use by other bundles. More recently installed
          bundles must be destroyed before later installed bundles, that is,
          reverse bundle id order.</para>
        </listitem>

        <listitem>
          <para>The previous step can have released services, therefore,
          repeat step 1 until no more Blueprint Containers can be
          destroyed.</para>
        </listitem>

        <listitem>
          <para>If there are still Blueprint Containers that are not
          destroyed, then destroy the Blueprint Container with:</para>

          <itemizedlist>
            <listitem>
              <para>The registered service that is in use with the lowest
              ranking number, or if a tie</para>
            </listitem>

            <listitem>
              <para>The highest registered service id</para>
            </listitem>
          </itemizedlist>

          <para>If there are still Bundle Containers to be destroyed, retry
          step 1</para>
        </listitem>
      </orderedlist>

      <para>During the shutting down of an OSGi framework, it is likely that
      many bundles are stopped near simultaneously. The Blueprint extender
      should be able to handle this case, without deadlock, when the stop of a
      Blueprint bundle overlaps with the stop of the Blueprint extender
      bundle.</para>
    </section>

    <section xml:id="i2009036">
      <title>Failure</title>

      <para>If a failure occurs during the initialization of the Blueprint
      bundle, then first a <code>FAILURE</code> event must be posted, see
      <xref linkend="i2148562"/>. Then the
      Blueprint Container should be destroyed, ensuring that no uninitialized
      or half initialized objects are destroyed. Failures should be logged if
      a Log Service is present.</para>
    </section>

    <section>
      <title>Lazy</title>

      <para>The Blueprint Container specification specifically allows lazy
      initialization of the application in the Blueprint bundle. No component
      instances are created until an eager manager is activated, or a service
      request comes in.</para>

      <para>If no eager managers are defined and no service has explicit
      dependencies, then no component instances are provided until an external
      trigger occurs. This trigger can be a service request or a call to the
      <code>getComponentInstance</code> method of the Blueprint Container,
      which is registered as a service. This allows a Blueprint bundle to not
      create component instances, and thereby load classes, until they are
      really needed. This can significantly reduce startup time.</para>

      <para>Some features of the component definitions can only be verified by
      inspecting a class. This class loading can break the lazy initialization
      of a Blueprint bundle. It is therefore allowed to delay this kind of
      verification until the activation of a manager.</para>

      <para>This lazy behavior is independent of the bundle’s lazy activation
      policy. Though the Blueprint extender recognizes this policy to detect
      when the bundle is ready (for a lazy activated bundle the
      <code>STARTING</code> state is like the <code>ACTIVE</code> state), it
      is further ignored. That is, the relation between a Bundle Activator
      that is lazily activated and the Blueprint Container is not
      defined.</para>
    </section>
  </section>

  <section>
    <title>Blueprint Definitions</title>

    <para>The Blueprint XML resources in a bundle are the<emphasis>
    definitions</emphasis>. Each definition can include multiple namespaces.
    Implementations of the Blueprint core namespace must strictly follow this
    specification, if they add additional behavior they must add additional
    namespaces that are actually used in the definitions to signal the
    deviation from this specification.</para>

    <para>The namespace for the core Blueprint definition resources is:</para>

    <programlisting>http://www.osgi.org/xmlns/blueprint/v1.0.0</programlisting>

    <para>Blueprint resources that use this core specification must have as
    top the <code>blueprint</code> element. The following example shows the
    body of a Blueprint definition:</para>

    <programlisting>&lt;xml version="1.0" encoding="UTF-8"&gt;
&lt;blueprint
 xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"&gt;
  ...
&lt;/blueprint&gt;</programlisting>

    <para>The recommended prefix for the Blueprint core namespace is
    <code>bp</code>.</para>

    <para>All elements in the Blueprint namespace are prepared for future
    extensions and provide a <code>description</code> child element in most
    positions.</para>

    <section>
      <title>XML</title>

      <para>In the following sections, the XML is explained using the normal
      syntax notation used for headers. There is, however, one addition to the
      normal usage specific to XML, and that is the use of the angled brackets
      ( &lt;&gt;). A term enclosed in angled brackets, indicates the use of a
      real element. Without the angled brackets it is the definition of a term
      that is expanded later to a one or more other terms or elements. For
      example:</para>

      <programlisting>people     ::= &lt;person&gt; *
person     ::= &lt;child&gt;* address
address    ::= &lt;fr&gt; | &lt;us&gt; | &lt;nl&gt;</programlisting>

      <para>Describes for example the following XML:</para>

      <programlisting>&lt;people&gt;
    &lt;person id="mieke"&gt;
        &lt;child name="mischa"/&gt;
        &lt;child name="thomas"/&gt;
        &lt;fr zip="34160"/&gt;
    &lt;/person&gt;
&lt;/people&gt;</programlisting>

      <para>Attributes are described in tables that define how they map to
      their corresponding Metadata. As a rule, the XML elements and attributes
      are expressed directly in the Metadata.</para>

      <para>The text in the following sections is a normative description of
      the semantics of the schema. However, the structure information is
      illustrative. For example, all <code>description</code> elements have
      been ignored for brevity. The exact structure is described by the XML
      schema, see <xref linkend="i2152341"/>.</para>

      <para>There are a number of convenient XML types used in the following
      sections. There schema types are defined here:</para>

      <itemizedlist>
        <listitem>
          <para><code>qname</code> – A fully qualified Java class name in
          dotted form, for example <code>java.lang.String</code>.</para>
        </listitem>

        <listitem>
          <para><code>method</code> – A valid Java method name, for example
          <code>setFoo</code>.</para>
        </listitem>

        <listitem>
          <para><code>NCName</code> – A string syntax for names defined in
          <xref linkend="i2584676"/>.</para>
        </listitem>

        <listitem>
          <para><code>ID</code> – A string syntax for ids defined in <xref
          linkend="i2584676"/>.</para>
        </listitem>

        <listitem>
          <para><code>type</code> – A name of a Java type including arrays,
          see the next section <xref linkend="i2972566"/>.</para>
        </listitem>

        <listitem>
          <para><code>target</code> – An inline bean, reference, or ref, see
          <xref linkend="i2983382"/>.</para>
        </listitem>

        <listitem>
          <para><code>object</code> – An object value, see <xref
          linkend="i2352936"/></para>
        </listitem>
      </itemizedlist>

      <para>In several cases, the actual syntax depends on the type
      conversion. This type of syntax is indicated with
      <code>&lt;&lt;type&gt;&gt;</code> indicates that the syntax of the
      string depends on the type conversion, where ten type is usually given
      as a parameter on the same Metadata.</para>
    </section>

    <section xml:id="i2972566">
      <title>Syntax for Java types</title>

      <para>A number of elements can refer to a Java type, for example the
      <code>value</code> element has a <code>type</code> attribute and a
      <code>map</code> element has a <code>key-type</code> attribute. The
      syntax for these types is as follows:</para>

      <programlisting>type    ::= qname array
array   ::= ’[]’ *</programlisting>

      <para>Where <code>qname</code> is the fully qualified name of a Java
      class or interface, or the name of a primitive type.</para>

      <para>For example:</para>

      <programlisting>&lt;value type="java.lang.String[]"/&gt;</programlisting>

      <para>It is not possible to specify generic information in this
      syntax.</para>
    </section>

    <section>
      <title>XML and Metadata</title>

      <para>The Blueprint Container parses the XML into <code>Metadata</code>
      objects, see <xref linkend="i2373727"/>.
      During parsing, the XML parser validates against the detailed Blueprint
      schema and will therefore catch many errors. However, the XML schema and
      the Metadata type are not equivalent. The XML contains many conveniences
      that the Blueprint Container must convert to the canonical type in the
      Metadata. A number of general rules apply for this conversion:</para>

      <itemizedlist>
        <listitem>
          <para>An absent attribute will result in <code>null</code>, unless
          the schema element provides a default value. In that case, the
          default must be returned from the Metadata object. That is, a
          default is indistinguishable from a specifically set value.</para>
        </listitem>

        <listitem>
          <para>Defaults from the <code>blueprint</code> element are filled in
          the <code>Metadata</code> objects, they are not available in any
          other way.</para>
        </listitem>

        <listitem>
          <para>Strings are trimmed from extraneous whitespace, as described
          in XML normalization.</para>
        </listitem>

        <listitem>
          <para>Child elements are represented by <code>List</code> objects,
          in the order of their definition. If no child elements are
          specified, the list will be empty.</para>
        </listitem>
      </itemizedlist>

      <para>For example, the <code>activation</code> feature reflects the
      total of <code>default-activation</code> and <code>activation</code>
      attributes but does not reflect that a <code>prototype</code> scope
      always makes a bean lazy. That is, even if <code>activation</code> is
      <code>eager</code>, the bean must still have <code>lazy</code>
      <code>activation</code> when it has <code>prototype</code> scope.</para>
    </section>

    <section>
      <title>&lt;blueprint&gt;</title>

      <para>The <code>blueprint</code> element is the top element. The
      definitions consist of two sections: the <code>type-converter</code>
      section and the managers section.</para>

      <programlisting>blueprint           ::= &lt;type-converters&gt;manager*
manager             ::= &lt;bean&gt; | &lt;service&gt;  
                               | service-reference
service-reference   ::= &lt;reference&gt; | &lt;reference-list&gt;
type-converters     ::= &lt;bean&gt; | &lt;ref&gt;</programlisting>

      <para>In this specification, the reference and reference-list managers
      are referred to as <emphasis>service reference</emphasis>s when their
      differences are irrelevant. The <code>blueprint</code> element structure
      is visualized in <xref linkend="i1791257"/>.</para>

      <figure xml:id="i1791257">
        <title>Managers (bold = element name, plain=base type)</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.224in"
                       contentwidth="4.675in" fileref="managers.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Metadata</title>

      <para>The blueprint element has no corresponding Metadata class.</para>
    </section>

    <section>
      <title>Defaults</title>

      <para>The <code>blueprint</code> element supports the setting of the
      diverse defaults for the current definition resource with the following
      attributes:</para>

      <itemizedlist>
        <listitem>
          <para><code>default-activation</code> – Controls the default for the
          <code>activation</code> attribute on a manager. See <xref
          linkend="i2707929"/>. The default for
          this attribute is <code>eager</code>.</para>
        </listitem>

        <listitem>
          <para><code>default-availability</code> – The default availability
          of the service reference elements, see <xref linkend="i2468749"/>. The default for this attribute is
          <code>mandatory</code>.</para>
        </listitem>

        <listitem>
          <para><code>default-timeout</code> – The default for the
          <code>reference</code> element <code>timeout</code> attribute, see
          <xref linkend="i2468749"/>. The default
          for this attribute is is 30000, or 5 minutes.</para>
        </listitem>
      </itemizedlist>

      <para>These defaults are specific for one definition resource, they
      apply only to elements enclosed to any depth in the
      <code>blueprint</code> element. These defaults are not visible in the
      Metadata.</para>
    </section>

    <section xml:id="i2709370">
      <title>&lt;type-converters&gt;</title>

      <para>The Blueprint definitions are text based but the component
      instances require actual classes for their construction and dependency
      injection. Component instances are injected with general objects the
      target type is not always compatible with the source type. This
      specification therefore allows for <emphasis>type conversion</emphasis>.
      Type conversion rules are specified in <xref linkend="i1864218"/>. This section provides beans, or referrals
      to beans, that can be used in this type conversion process. They are
      listed in a separate section so they can be registered as a type
      converter, pre-instantiated, and preventing dependencies that easily
      become cyclic. Beans defined in the <code>type-converters</code> element
      must be registered as top-level managers.</para>

      <para>The structure of the <code>type-converters</code> element
      is:</para>

      <programlisting>type-converters     ::= ( &lt;bean&gt; | &lt;ref&gt;)*</programlisting>

      <para>Type converters defined with the <code>ref</code> element can
      refer to bean managers or reference managers. Type converters must have
      ids distinct from any other manager and are available through the
      Blueprint Container’s <code>getComponentInstance</code> method.</para>
    </section>

    <section xml:id="i3005561">
      <title>manager</title>

      <para>The component XML schema type is the base type of the
      <code>bean</code>, <code>service</code>, <code>reference-list</code>,
      and <code>reference</code> elements. All manager sub-types share the
      following attributes:</para>

      <itemizedlist>
        <listitem>
          <para><code>id</code> – The manager and its Metadata are identified
          by its <code>id</code> as defined in its Component Definition. In
          general this id is therefore referred to as the <emphasis>component
          id</emphasis>. This is an optional attribute. If it is not defined,
          a default calculated unique id will be assigned to it for top-level
          managers. For inlined managers, the <code>id</code> attribute cannot
          be set, their Metadata must return <code>null</code>. All top level
          manager ids must be unique in a Blueprint Container.</para>

          <para>The id attribute must be of type <code>ID</code> as defined in
          XML Schema, see <xref linkend="i2584676"/>.
          The syntax for an id is therefore:</para>

          <programlisting>id  ::=     ID              // See <xref
              linkend="i2584676"/> #ID</programlisting>

          <para>Ids generally use camel case, like <code>myComponent</code>,
          and they are case sensitive. That is, component id
          <code>madHatter</code> and <code>madhatter</code> are distinct ids.
          Applications should not use ids starting with the prefix
          <code>blueprint</code>.</para>

          <para>Ids are not required, if no component id is specified, the
          Blueprint Container must assign a unique id when it is a configured
          in a top level element. This calculated <code>id</code> must start
          with a full stop (<code>’.’ \u002E</code>).</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><code>activation</code> – Defines the activation mode to be
          lazy or eager. See <xref linkend="i2081951"/>.</para>
        </listitem>

        <listitem>
          <para><code>dependsOn</code> – The list of explicit dependencies
          that must be activated. See <xref linkend="i2706015"/>.</para>
        </listitem>
      </itemizedlist>

      <para>The Metadata interface of top level managers will be a
      sub-interface of <code>ComponentMetadata</code> and is available from
      the Blueprint Container by its component id.</para>

      <figure>
        <title>Inheritance hierarchy for managers</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.032in"
                       contentwidth="4.936in"
                       fileref="manager-inheritance-hierarchy.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="i2706015">
      <title>Explicit Dependencies</title>

      <para>The <code>dependsOn</code> list contains the ids of the top-level
      managers the bean explicitly depends on. Unless stated otherwise in the
      specific manager description, explicit dependencies must be activated
      before their manager is activated.</para>

      <para>For example:</para>

      <programlisting>&lt;bean id="alice" class="com.acme.MadHatter" 
        depends-on="cheshire rabbit queen"/&gt;</programlisting>

      <para>This example will ask the top level managers
      <code>cheshire</code>, <code>rabbit</code>, and <code>queen</code> to
      provide an object before <code>alice</code> is activated. For a
      discussion about dependencies see <xref linkend="i2739446"/>.</para>
    </section>

    <section xml:id="i2707929">
      <title>Lazy and Eager</title>

      <para>During initialization, all <emphasis>eager</emphasis> top level
      managers are requested to provide a component instance. Applications can
      use this request as an indication to start providing their intended
      functionality.</para>

      <para>Managers that are <emphasis>lazy</emphasis>, that is, not
      <code>singleton</code> <code>scope</code>, <code>activation</code> is
      <code>lazy</code>, or inlined, are activated when they are first asked
      to provide a component instance. Therefore, even lazy managers can
      activate during initialization when they happen to be a dependency of
      another manager that activates its dependencies.</para>

      <para>Services and service references can also have <code>lazy</code> or
      <code>eager</code> activation. The <code>eager</code> activation will
      ensure that all listeners are properly actuated during the corresponding
      activation. For services, the service object is then also requested at
      startup.</para>

      <para>The following example defines an eager bean by making it a
      <code>singleton</code> and setting the <code>activation</code> to
      <code>eager</code>:</para>

      <programlisting>&lt;bean id="eager" scope="singleton"
        class="com.acme.FooImpl" <code>activation</code>="eager"/&gt;</programlisting>
    </section>

    <section xml:id="i2983382">
      <title>Target</title>

      <para>In several places in the Blueprint schema it is necessary to refer
      to a <emphasis>target</emphasis>. A target is a:</para>

      <itemizedlist>
        <listitem>
          <para><code>ref</code> – Must reference one of the following
          managers</para>
        </listitem>

        <listitem>
          <para><code>reference</code> – An inlined reference manager</para>
        </listitem>

        <listitem>
          <para><code>bean</code> – An inlined bean manager</para>
        </listitem>
      </itemizedlist>

      <para>The target type is normally used for listeners, service objects,
      and other places where a general application component instance is
      required.</para>
    </section>
  </section>

  <section xml:id="i2217757">
    <title>Bean Manager</title>

    <para>A bean manager provides an arbitrary Java object. It constructs this
    object from a given class or factory and then configures the object by
    injecting its <emphasis>properties</emphasis> with other component
    instances or more general object values.</para>

    <para>The provided component instance can be a <code>singleton</code> or a
    new object can be returned on every invocation (<code>prototype</code>),
    this behavior is defined with the <code>scope</code> attribute, see <xref
    linkend="i3015704"/>.</para>

    <para>The provided object can optionally be notified when all of its
    properties have been injected, and when the providing bean manager will be
    deactivated, see <xref linkend="i2339865"/>.</para>

    <section>
      <title>Bean Component XML</title>

      <para>The structure of a <code>bean</code> element is:</para>

      <programlisting>bean    ::= ( &lt;argument&gt; | &lt;property&gt;)*</programlisting>

      <figure>
        <title>Bean Structure</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.586in"
                       contentwidth="4.675in" fileref="bean-structure.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>&lt;bean&gt;</title>

      <para>The Metadata for a bean manager is represented in the
      <code>BeanMetadata</code> interface, which extends
      <code>ComponentMetadata</code>. <phrase role="xref">Table 121.1 on
      page 269</phrase> provides an overview of the related XML definitions
      and the <code>BeanMetadata</code> interface. The table only provides a
      summary, the sometimes subtle interactions between the different
      features are discussed in later sections.</para>

      <table>
        <title>Bean Manager Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Syntax</entry>

              <entry>Bean Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>id</code></entry>

              <entry><code>ID</code></entry>

              <entry><para><code>id</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The id of a top level manager, must be unique in
              the Blueprint Container. All inlined managers must return
              <code>null</code> for their id.</para></entry>
            </row>

            <row>
              <entry><code>activation</code></entry>

              <entry><para><code> lazy</code></para><para><code>|
              eager</code></para></entry>

              <entry><para><code>activation</code></para><para><code>:
              int</code></para></entry>

              <entry><para>Defines if this bean is lazily or eagerly
              activated. If not explicitly set, the <code>blueprint</code>
              element’s value for the <code>default-activation</code>
              attributes is used. If this is also not set, the value is
              <code>eager</code>. See <xref linkend="i2707929"/>.</para></entry>
            </row>

            <row>
              <entry><code>depends-on</code></entry>

              <entry><code>NCName*</code></entry>

              <entry><para><code>dependsOn</code></para><para><code>:
              List&lt;String&gt;</code></para></entry>

              <entry><para>Explicit list of ids that are the dependencies.
              These referred managers must be activated before this bean can
              provide an object. See <xref linkend="i2706015"/>. This is a whitespace separated
              list.</para></entry>
            </row>

            <row>
              <entry><code>class</code></entry>

              <entry><code>qname</code></entry>

              <entry><para><code>className</code></para><para><code>:
              String</code></para></entry>

              <entry><para>Class name of the object to be provided or the
              class name for a static factory. See <xref linkend="i2339858"/>.</para></entry>
            </row>

            <row>
              <entry><code>scope</code></entry>

              <entry><para><code> singleton</code></para><para><code>|
              prototype</code></para></entry>

              <entry><para><code>scope</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The scope defines the construction strategy for the
              component instance. The default is <code>singleton</code> except
              for inlined bean managers, where it is <code>prototype</code>.
              There is no schema default, so if it is not explicitly set, the
              Metadata will be <code>null</code>. See <xref linkend="i3015704"/>.</para></entry>
            </row>

            <row>
              <entry><code>init-method</code></entry>

              <entry><code>method</code></entry>

              <entry><para><code>initMethod</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The name of a method to invoke when a provided
              object has been injected with all its properties. If this is not
              set, it is <code>null</code>. See <xref linkend="i2339865"/>.</para></entry>
            </row>

            <row>
              <entry><code>destroy-method</code></entry>

              <entry><code>method</code></entry>

              <entry><para><code>destroyMethod</code></para><para><code>:
              String</code></para></entry>

              <entry><para>A name of a method to invoke on the provided
              objects with <code>singleton</code> scope when the Blueprint
              Container is destroyed. If this is not set, it is
              <code>null</code>. See <xref linkend="i2339865"/>.</para></entry>
            </row>

            <row>
              <entry><code>factory-method</code></entry>

              <entry><code>method</code></entry>

              <entry><para><code>factoryMethod</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The name of the method on a static or component
              instance factory. See <xref linkend="i2339858"/>.</para></entry>
            </row>

            <row>
              <entry><code>factory-ref</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>factoryComponent</code></para><para><code>:
              String</code></para></entry>

              <entry><para>A reference to a manager that acts as the factory.
              See <xref linkend="i2339858"/>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;argument&gt;</code></entry>

              <entry><link
              linkend="i3002456"><code>Table</code></link></entry>

              <entry><para><code>arguments</code></para><para><code>:
              List&lt;BeanArgument&gt;</code></para></entry>

              <entry><para>Defined as sub-elements of the <code>bean</code>
              element. A <code>BeanArgument</code> object contains the value
              of an argument in the factory method or constructor. The order
              of the arguments is declaration order. See <xref
              linkend="i2339858"/>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;property&gt;</code></entry>

              <entry><link
              linkend="i2355653"><code>Table</code></link></entry>

              <entry><para><code>properties</code></para><para><code>:
              List&lt;BeanProperties&gt;</code></para></entry>

              <entry><para>Defined as sub-elements of the <code>bean</code>
              element. A <code>BeanProperty</code> object provides the
              property name and injection value. See <xref linkend="i2318920"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The bean element has the following constraints that are not
      enforced by the schema but must be enforced by the Blueprint
      Container:</para>

      <itemizedlist>
        <listitem>
          <para>The <code>destroyMethod</code> must not be set when the scope
          is <code>prototype</code>.</para>
        </listitem>

        <listitem>
          <para>The <code>activation</code> must not be set to
          <code>eager</code> if the bean also has <code>prototype</code>
          scope.</para>
        </listitem>

        <listitem>
          <para>The following combinations of arguments are valid, all other
          combinations are invalid:</para>

          <itemizedlist>
            <listitem>
              <para><code>className</code></para>
            </listitem>

            <listitem>
              <para><code>className</code>, <code>factory-method</code></para>
            </listitem>

            <listitem>
              <para><code>factory-ref</code>,
              <code>factory-method</code></para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3002456">
      <title>&lt;argument&gt;</title>

      <para>The <code>argument</code> element holds a value for a constructor
      or factory method’s parameters.</para>

      <table>
        <title>Bean Argument Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Syntax</entry>

              <entry>Bean Argument</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>index</code></entry>

              <entry><code>int &gt;= 0</code></entry>

              <entry><para><code>index</code></para><para><code>:
              int</code></para></entry>

              <entry><para>The index of the argument in the constructor or
              factory-method signature. If this is not set, the Blueprint
              Container must use the type information to calculate it to match
              the disambiguation algorithm. The index will be -1 when not
              explicitly set.</para></entry>
            </row>

            <row>
              <entry><code>type</code></entry>

              <entry><code>qname</code></entry>

              <entry><para><code>valueType</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The fully qualified class name of a Java type to
              match the argument to the signature against.</para></entry>
            </row>

            <row>
              <entry><code>ref</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>value</code></para><para><code>:
              RefMetadata</code></para></entry>

              <entry><para>A reference to a top level manager that provides
              the value for the <code>argument</code>.</para></entry>
            </row>

            <row>
              <entry><code>value</code></entry>

              <entry><code>&lt;&lt;type&gt;&gt;</code></entry>

              <entry><para><code>value</code></para><para><code>:
              ValueMetadata</code></para></entry>

              <entry><para>The Value Metadata based on the value
              property.</para></entry>
            </row>

            <row>
              <entry><code>&lt;...&gt;</code></entry>

              <entry><code>object</code></entry>

              <entry><para><code>value</code></para><para><code>:
              Metadata</code></para></entry>

              <entry><para>An inlined value.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The argument element has the following additional
      constraints:</para>

      <itemizedlist>
        <listitem>
          <para>Either all arguments have a specified index or none have a
          specified index.</para>
        </listitem>

        <listitem>
          <para>If indexes are specified, they must be unique and run from
          <code>0..(n-1)</code>, where <code>n</code> is the number of
          arguments.</para>
        </listitem>

        <listitem>
          <para>The following attributes and elements are mutually
          exclusive:</para>

          <itemizedlist>
            <listitem>
              <para><code>ref</code></para>
            </listitem>

            <listitem>
              <para><code>value</code></para>
            </listitem>

            <listitem>
              <para>An inlined object value</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i2355653">
      <title>&lt;property&gt;</title>

      <para>The <code>property</code> element holds the information to inject
      a bean property with an object value.</para>

      <table>
        <title>Bean Property Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Syntax</entry>

              <entry>Bean Property</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>name</code></entry>

              <entry><code>method</code> <code>( ’.’ method )*</code></entry>

              <entry><para><code>name</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The property name, for example <code>foo</code>.
              The method name can consist of full stop separated method names,
              indicating nested property access.</para></entry>
            </row>

            <row>
              <entry><code>ref</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>value</code></para><para><code>:
              RefMetadata</code></para></entry>

              <entry><para>A reference to a top level manager.</para></entry>
            </row>

            <row>
              <entry><code>value</code></entry>

              <entry><code>&lt;&lt;type&gt;&gt;</code></entry>

              <entry><para><code>value</code></para><para><code>:
              ValueMetadata</code></para></entry>

              <entry><para>A Value Metadata where the type is
              <code>null</code>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;...&gt;</code></entry>

              <entry><code>object</code></entry>

              <entry><para><code>value</code></para><para><code>:
              Metadata</code></para></entry>

              <entry><para>An inlined object value.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The argument element has the following additional
      constraints:</para>

      <itemizedlist>
        <listitem>
          <para>The following attributes/elements are mutually
          exclusive</para>

          <itemizedlist>
            <listitem>
              <para><code>ref</code></para>
            </listitem>

            <listitem>
              <para><code>value</code></para>
            </listitem>

            <listitem>
              <para>An inlined object value</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3015704">
      <title>Scope</title>

      <para>A bean manager has a recipe for the construction and injection of
      an object value. However, there can be different strategies in
      constructing its component instance, this strategy is reflected in the
      <code>scope</code>. The following scopes are architected for this
      specification:</para>

      <itemizedlist>
        <listitem>
          <para><code>singleton</code> – The bean manager only holds a single
          component instance. This object is created and set when the bean is
          activated. Subsequent requests must provide the same instance.
          Singleton is the default scope. It is usually used for core
          component instances as well as stateless services.</para>
        </listitem>

        <listitem>
          <para><code>prototype</code> – The object is created and configured
          anew each time the bean is requested to provide a component
          instance, that is, every call to <code>getComponentInstance</code>
          must result in a new component instance. This is usually the only
          possible scope for stateful objects. All inlined beans are always
          <code>prototype</code> scope.</para>
        </listitem>
      </itemizedlist>

      <para>Implementations can provide additional scope types. However, these
      types must only be allowed when a defining namespace is included in the
      definitions and is actually used in the definitions to specify the
      dependency on this feature.</para>
    </section>

    <section xml:id="i2339858">
      <title>Construction</title>

      <para>The Blueprint specification supports a number of ways for a bean
      manager to construct an object. Each possibility is a combination of the
      following Metadata properties:</para>

      <itemizedlist>
        <listitem>
          <para><code>className</code> – Defines the fully qualified name of a
          class to construct, or the name of a class with a static factory
          method. The class must be loadable from the Blueprint bundle
          <code>loadClass</code> method.</para>
        </listitem>

        <listitem>
          <para><code>factoryMethod</code> – A static or instance factory
          method name that corresponds to a publicly accessible method on the
          given class or factory manager.</para>
        </listitem>

        <listitem>
          <para><code>factoryComponent</code> – The id of a top-level target
          manager in the Blueprint Container that is an instance
          factory.</para>
        </listitem>
      </itemizedlist>

      <para>The Bean manager can have a number of <code>BeanArgument</code>
      objects that specify arguments for the constructor or for the factory
      class/object method. The matching constructor or method must be publicly
      accessible. The argument’s <code>valueType</code> can be used to
      disambiguate between multiple signatures of constructors or methods. See
      <xref linkend="i1800540"/>.</para>

      <para>The <code>value</code> of the argument is always a
      <code>Metadata</code> object. Such an object can be converted into a
      general object value, see <xref linkend="i2352936"/>.</para>

      <para>The construction properties can be used in a rather large number
      of combinations, however, not all combinations are valid. <phrase
      role="xref">Table 121.4</phrase> shows the different valid combinations.
      If none of the combinations matches, then the Bean Metadata is
      erroneous.</para>

      <para>In <phrase role="xref">Table 121.4</phrase>, a variation of the
      following bean definition is assumed:</para>

      <programlisting>&lt;bean class="C" factory-method="f" factory-ref="fc"&gt;
    &lt;argument value="1"/&gt;
    &lt;argument value="2"/&gt;
&lt;/bean&gt;</programlisting>

      <para>This definition is invalid because it specifies an invalid
      combination of metadata properties. The only valid combinations are
      subsets, they are all specified in the following table.</para>

      <table>
        <title>Component Attributes and Construction</title>

        <tgroup cols="5">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="1*"/>

          <colspec colnum="4" colwidth="1*"/>

          <colspec colnum="5" colwidth="2*"/>

          <thead>
            <row>
              <entry>className</entry>

              <entry>factory-method</entry>

              <entry>factory-ref</entry>

              <entry>argument</entry>

              <entry>Corresponding Java Code</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>C</code></entry>

              <entry/>

              <entry/>

              <entry/>

              <entry><code>new C</code></entry>
            </row>

            <row>
              <entry><code>C</code></entry>

              <entry><code>f</code></entry>

              <entry/>

              <entry/>

              <entry><code>C.f()</code></entry>
            </row>

            <row>
              <entry><code>C</code></entry>

              <entry/>

              <entry/>

              <entry><code>1,2</code></entry>

              <entry><code>new C(1,2)</code></entry>
            </row>

            <row>
              <entry><code>C</code></entry>

              <entry><code>f</code></entry>

              <entry/>

              <entry><code>1,2</code></entry>

              <entry><code>C.f(1,2)</code></entry>
            </row>

            <row>
              <entry/>

              <entry><code>f</code></entry>

              <entry><code>$fc</code></entry>

              <entry/>

              <entry><code>$fc.f()</code></entry>
            </row>

            <row>
              <entry/>

              <entry><code>f</code></entry>

              <entry><code>$fc</code></entry>

              <entry><code>1,2</code></entry>

              <entry><code>$fc.f(1,2)</code></entry>
            </row>

            <row>
              <entry><code>*</code></entry>

              <entry><code>*</code></entry>

              <entry><code>*</code></entry>

              <entry><code>*</code></entry>

              <entry><code>failure</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The object created this way will be the provided object of the
      bean after any properties are injected. If the
      <code>factoryMethod</code> returns a primitive type, then this primitive
      must be converted to the corresponding wrapper type before any
      usage.</para>
    </section>

    <section xml:id="i2318920">
      <title>Properties</title>

      <para>Dependency injection configures a constructed object with the help
      of the <code>properties</code>, which is a a List of
      <code>BeanProperty</code> objects. A Bean Property has the following
      features:</para>

      <itemizedlist>
        <listitem>
          <para><code>name</code> – The name of the bean property. This name
          refers to the <code>set</code> method on the constructed object as
          specified in the design pattern for beans getters and setters, see
          <xref linkend="i1704220"/>. For example, if
          the property name is <code>foo</code>, then the public method
          <code>setFoo(arg)</code> will be used to set the value. There should
          only be one set method with a single argument for a specific
          property. If overloaded properties are encountered, the chosen set
          method is unspecified.</para>

          <para>Nested property names are allowed when setting bean
          properties, as long as all parts of the path, except the property
          that is set, result in a <code>non-null</code> value. The parts of
          the path are separated with a full stop (<code>’.’ \u002E</code>).
          For example:</para>

          <programlisting>&lt;property name="foo.bar.baz" value="42"/&gt;</programlisting>

          <para>This example gets the <code>foo</code> property, from the
          constructed object, it then gets the <code>bar</code> property and
          then sets the <code>baz</code> property on that object with the
          given value.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><code>value</code> – The value of the property is always a
          Metadata object. This <code>Metadata</code> object can be converted
          to a value object, see <xref linkend="i2352936"/>.</para>
        </listitem>
      </itemizedlist>

      <para>After the Metadata object is converted to an object value, it must
      be injected into the property. If the value object is not directly
      assignable to the property type (as defined by its only set method and
      the rules in <xref linkend="i2736197"/> ),
      then the Blueprint Container must use the type conversion mechanism to
      create a new object that matches the desired type, or fail. See <xref
      linkend="i2381582"/> for more information
      about dependency injection.</para>

      <para>For example, the following bean creates an instance and then
      injects a three into a the <code>foo</code> property that it gets from
      the <code>bar</code> property. The string that holds the three is
      converted to a <code>double</code>:</para>

      <programlisting>&lt;bean id="foo" class="com.acme.Foo"&gt;
  &lt;property name="bar.foo" value="3"/&gt;
&lt;/bean&gt;

// Classes
package com.acme;
public class Bar {
    double v;
    public void setFoo(double v) { this.v = v; }
}
public class Foo {
    Bar bar = new Bar();
    public void getBar() { return bar; }
}

// Corresponding Java code
Foo foo = new Foo();
foo.getBar().setFoo(3.0);</programlisting>
    </section>

    <section xml:id="i2339865">
      <title>Life Cycle Callbacks</title>

      <para>The <code>bean</code> element provides two attributes that define
      the <emphasis>callback</emphasis> method names for initialization and
      destruction. A callback must be implemented as a publicly accessible
      method without any arguments. The callback method names must exist as
      <code>void()</code> methods.</para>

      <para>The <code>initMethod</code> specifies the name of an
      initialization method that is called after all properties have been
      injected. The <code>destroyMethod</code> specifies the name of a destroy
      method that is called when the Blueprint Container has destroyed a
      component instance. Only bean managers with <code>singleton</code> scope
      support the <code>destroyMethod</code>. The destroy callback cannot be
      used for beans that have <code>prototype</code> scope, the
      responsibility for destroying those instances lies with the
      application.</para>
    </section>

    <section>
      <title>Activation and Deactivation</title>

      <para>A singleton bean manager must construct its single object during
      activation and then callback its <code>initMethod</code> method.
      Prototype scoped beans are created after activation and also have their
      <code>initMethod</code> invoked. The destroy method is called during the
      destruction of all the beans in <code>singleton</code> scope, this
      happens after deactivation.</para>

      <para>A <code>prototype</code> bean manager has no special activities
      for deactivation.</para>
    </section>
  </section>

  <section xml:id="i1947792">
    <title>Service Manager</title>

    <para>The service manager defined by a <code>service</code> element is
    responsible for registering a service object with the service registry. It
    must ensure that this service is only registered when it is
    <emphasis>enabled</emphasis>. Where enabled means that all its mandatory
    service reference managers in its dependencies are satisfied.</para>

    <section>
      <title>&lt;service&gt;</title>

      <para>The XML structure of the <code>&lt;service&gt;</code> manager
      is:</para>

      <programlisting>service               ::= &lt;interfaces&gt;
                          &lt;service-properties&gt;
                          &lt;registration-listener&gt;*
                          target
interfaces            ::= &lt;value&gt;+
service-properties    ::= &lt;entry&gt;+
registration-listener ::= target</programlisting>

      <para>The service manager has the features outlined in</para>

      <table>
        <title>Service Manager Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Type</entry>

              <entry>Service Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>id</code></entry>

              <entry><code>ID</code></entry>

              <entry><para><code>id</code></para><para><code>:
              String</code></para></entry>

              <entry><para>Optional component id of the manager, if it is a
              top level manager.</para></entry>
            </row>

            <row>
              <entry><code>activation</code></entry>

              <entry><para><code> lazy</code></para><para><code>|
              eager</code></para></entry>

              <entry><para><code>activation</code></para><para><code>:
              int</code></para></entry>

              <entry><para>Defines if this service is lazily or eagerly
              initialized. If not explicitly set, the <code>blueprint</code>
              element’s value for the <code>default-activation</code>
              attributes is used. If this is also not set, the value is
              <code>eager</code>. See also <xref linkend="i2707929"/>.</para></entry>
            </row>

            <row>
              <entry><code>depends-on</code></entry>

              <entry><code>NCName*</code></entry>

              <entry><para><code>dependsOn</code></para><para><code>:
              List&lt;String&gt;</code></para></entry>

              <entry><para>Explicit list of ids that are the dependencies.
              These managers must be activated at the start of the
              registration phase. See <xref linkend="i2706015"/>. This is a whitespace separated
              list.</para></entry>
            </row>

            <row>
              <entry><code>interface</code></entry>

              <entry><code>qname</code></entry>

              <entry><para><code>interfaces</code></para><para><code>:
              List&lt;String&gt;</code></para></entry>

              <entry><para>Name of the interface under which this service
              should be registered. See <xref linkend="i2392232"/>.</para></entry>
            </row>

            <row>
              <entry><code>auto-export</code></entry>

              <entry><para><code> disabled</code></para><para><code>|
              interfaces</code></para><para><code>|
              class-</code><code>hierarchy</code></para><para><code>|
              all-classes</code></para></entry>

              <entry><para><code>autoExport</code></para><para><code>:
              int</code></para></entry>

              <entry><para>Defines the way the class must be analyzed to find
              the interfaces under which the service must be registered. The
              schema default is <code>disabled</code>. See <xref
              linkend="i2392232"/></para></entry>
            </row>

            <row>
              <entry><code>ranking</code></entry>

              <entry><code>int</code></entry>

              <entry><para><code>ranking</code></para><para><code>:
              int</code></para></entry>

              <entry><para>The <code>service.ranking</code> value. The schema
              default is 0, which implies no service property. See <xref
              linkend="i2392470"/>. </para></entry>
            </row>

            <row>
              <entry><code>ref</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>value</code></para><para><code>:
              RefMetadata</code></para></entry>

              <entry><para>Reference to the manager that provides the service
              object. See <xref linkend="i2392545"/>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;service-</code><code>properties&gt;</code></entry>

              <entry><code>See <xref linkend="i1979502"/></code>.</entry>

              <entry><para><code>serviceProperties</code></para><para><code>:
              List&lt;MapEntry&gt;</code></para></entry>

              <entry><para>The service properties for this service. See <xref
              linkend="i1942131"/>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;registration-</code><code>listener&gt;</code></entry>

              <entry><code>See <phrase role="xref">Table
              121.6</phrase></code></entry>

              <entry><para><code>registrationListeners</code></para><para><code>:
              List&lt;Registration</code> <code>
              Listener&gt;</code></para></entry>

              <entry><para>The registration listeners. See <xref
              linkend="i2392507"/>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;interfaces&gt;</code></entry>

              <entry><code>&lt;value&gt;*</code></entry>

              <entry><para><code>interfaces</code></para><para><code>:
              List&lt;String&gt;</code></para></entry>

              <entry><para>Names of interfaces under which this service should
              be registered. Each interface name must be listed as a child
              <code>value</code> element. This value element has no
              attributes. For example:</para><programlisting>&lt;interfaces&gt;
 &lt;value&gt;com.acme.Foo&lt;/value&gt;
 &lt;value&gt;com.acme.Bar&lt;/value&gt;
&lt;/interfaces&gt;</programlisting><para>The value element must only hold a
              string value. See <xref linkend="i2392232"/></para></entry>
            </row>

            <row>
              <entry><code>&lt;...&gt;</code></entry>

              <entry><code>target</code></entry>

              <entry><para><code>value</code></para><para><code>:
              Target</code></para></entry>

              <entry><para>An inlined target manager that is used for the
              service object. See <xref linkend="i2392545"/></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><phrase role="xref">Table 121.5 on page 275</phrase>. The
      following additional constraints apply:</para>

      <itemizedlist>
        <listitem>
          <para>The <code>interface</code> attribute and
          <code>interfaces</code> element are mutually exclusive.</para>
        </listitem>

        <listitem>
          <para>If the <code>auto-export</code> attribute is set to anything
          else but <code>disabled</code>, neither the <code>interface</code>
          attribute nor the <code>interfaces</code> element must be
          used.</para>
        </listitem>

        <listitem>
          <para>The <code>ref</code> attribute and <code>inlined</code>
          element are mutually exclusive</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>&lt;registration-listener&gt;</title>

      <para>The <code>service</code> element can contain zero or more
      <code>registration-listener</code> elements, that define registration
      listeners to be notified of service registration and unregistration
      events. This element has the following structure:</para>

      <programlisting>registration-listener   ::= target*</programlisting>

      <para>The <code>registration-listener</code> element defines the
      callback methods for registration and unregistration.</para>

      <table>
        <title>Registration Listener Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Type</entry>

              <entry>Registration Listener</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>ref</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>registrationListener</code></para><para><code>:
              Target</code></para></entry>

              <entry><para>A reference to a top level manager. </para></entry>
            </row>

            <row>
              <entry><code>registration-method</code></entry>

              <entry><code>method</code></entry>

              <entry><para><code>registrationMethod</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The name of the method to call after the service
              has been registered. See <xref linkend="i2392507"/>.</para></entry>
            </row>

            <row>
              <entry><code>unregistration-method</code></entry>

              <entry><code>method</code></entry>

              <entry><para><code>unregistrationMethod</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The name of the method to call before the service
              will be unregistered. See <xref linkend="i2392507"/>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;...&gt;</code></entry>

              <entry><code>target</code></entry>

              <entry><para><code>registrationListener</code></para><para><code>:
              Target</code></para></entry>

              <entry><para>An inlined target manager</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The additional constraint is:</para>

      <itemizedlist>
        <listitem>
          <para>The <code>ref</code> attribute and the inlined manager are
          mutually exclusive.</para>
        </listitem>

        <listitem>
          <para>Either or both of the <code>registrationMethod</code> and
          <code>unregistrationMethod</code> must be set.</para>
        </listitem>

        <listitem>
          <para>For each method name set, there must be at least one method
          matching the possible prototypes in the registration listener
          object, see <xref linkend="i2392507"/>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Explicit Dependencies</title>

      <para>A service manager must initialize any explicit dependencies in the
      start of its registration phase, even before it tracks its enabled
      state. The presence of explicit dependencies will not activate the
      service manager.</para>
    </section>

    <section>
      <title>Provided Object</title>

      <para>A service manager provides a proxy to a
      <code>ServiceRegistration</code> object. If this proxy is used when the
      dependencies are not met, and the service is therefore unregistered, an
      Illegal State Exception must be thrown. In all other cases, the proxy
      acts as if it was the <code>ServiceRegistration</code> object associated
      with the registration of its service object.</para>

      <para>The <code>unregister</code> method on the returned object must not
      be used. If the application code calls unregister then this must result
      in an Unsupported Operation Exception.</para>
    </section>

    <section xml:id="i2392232">
      <title>Service Interfaces</title>

      <para>Each service object is registered under one or more interface
      names. The list of interface names is provided by
      <code>interfaces</code> or <code>autoExport</code>.</para>

      <para>The <code>autoExport</code> tells the Blueprint Container to
      calculate the interface(s) from the type of the service object. The
      <code>autoExport</code> can have the following values:</para>

      <itemizedlist>
        <listitem>
          <para><code>disabled</code> – No auto-detection of service interface
          names is undertaken, the interface names must be found in
          <code>interfaces</code>. This is the default mode.</para>
        </listitem>

        <listitem>
          <para><code>interfaces</code> – The service object will be
          registered using all of its implemented public Java interface types,
          including any interfaces implemented by super classes.</para>
        </listitem>

        <listitem>
          <para><code>class-hierarchy</code> – The service object will be
          registered using its actual type and any public super-types up to
          the <code>Object</code> class (not included).</para>
        </listitem>

        <listitem>
          <para><code>all-classes</code> – The service object will be
          registered using its actual type, all public super-types up to the
          <code>Object</code> class (not including), as well as all public
          interfaces implemented by the service object and any of its super
          classes.</para>
        </listitem>
      </itemizedlist>

      <para>The <code>autoExport</code> requires the actual class object for
      introspection for all its modes except <code>disabled</code>,which can
      cause a bundle with a <code>lazy</code> activation policy to activate
      because a class will be loaded from the Blueprint bundle.</para>

      <para>As an example:</para>

      <programlisting>&lt;bean id="fooImpl" class="FooImpl"/&gt;

public class FooImpl implements Foo { ... }</programlisting>

      <para>Then the following service definitions are equivalent:</para>

      <programlisting>&lt;service id="foo"&gt;
    &lt;interfaces&gt;
        &lt;value&gt;com.acme.Foo&lt;/value&gt;
    &lt;/interface&gt;
&lt;/service&gt;
&lt;service id="foo" interface="com.acme.Foo" ref="fooImpl"/&gt;
&lt;service id="foo" auto-export="interfaces" ref="fooImpl"/&gt;</programlisting>
    </section>

    <section xml:id="i1942131">
      <title>Service Properties</title>

      <para>Each service can optionally be registered with <emphasis>service
      properties</emphasis>. The <code>serviceProperties</code> is a list of
      <code>MapEntry</code>, see <xref linkend="i2443675"/>. This metadata must be used to create the
      service properties. Service properties creation can have side effects
      because they can use component instances. The service properties must
      therefore be created once before the first time the first time the
      service is registered.</para>

      <para>The service manager adds the following automatic service
      properties that cannot be overridden. When these properties are
      explicitly set, they must be ignored.</para>

      <itemizedlist>
        <listitem>
          <para><code>osgi.service.blueprint.compname</code> – This will
          reflect the id of the manager that provides the service object,
          unless it is inlined. Inlined beans are always anonymous and must
          not have this property set.</para>
        </listitem>

        <listitem>
          <para><code>service.ranking</code> – If the ranking attribute is not
          zero, this property will be set and hold an <code>Integer</code>
          object with the given value, see <xref linkend="i2392470"/>.</para>
        </listitem>
      </itemizedlist>

      <para>For example, the following definition is followed by equivalent
      Java code needed to register the service:</para>

      <programlisting>&lt;service ref="fooImpl" interface="com.acme.Foo"&gt;
  &lt;service-properties&gt;
    &lt;entry key="size" value="42"/&gt;
  &lt;/service-properties&gt;
&lt;/service&gt;

Dictionary d = new Hashtable();
d.put("size", "42");
d.put("osgi.service.blueprint.compname", "fooImpl");
ServiceRegistration sr = 
    bundleContext.registerService("com.acme.Foo",
        blueprintContainer.getComponentInstance("fooImpl"),
      d);</programlisting>

      <para>Service properties should specify the <code>valueType</code> of
      the entry unless the value to be registered needs to be a
      <code>String</code> object. The service property types should be one
      of:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Primitives Number </emphasis>– <code>int, long,
          float, double, byte, short, char, boolean</code></para>
        </listitem>

        <listitem>
          <para><emphasis>Scalar</emphasis> – <code>String, Integer, Long,
          Float, Double, Byte, Short, Character, Boolean</code>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Array</emphasis> – An array of either the allowable
          primitive or scalar types.</para>
        </listitem>

        <listitem>
          <para><emphasis>Collection</emphasis> – An object implementing the
          <code>Collection</code> interface that contains scalar types.</para>
        </listitem>
      </itemizedlist>

      <para>See <xref linkend="i2443675"/> types
      for information how to create these types.</para>
    </section>

    <section xml:id="i2392545">
      <title>Service Object</title>

      <para>The service manager must not request the Blueprint Container for
      the service object until it is actually needed because a bundle requests
      it. The service object is represented in the <code>value</code>. This is
      a Metadata object that can be used to construct an object value, see
      <xref linkend="i2352936"/>.</para>

      <para>For example:</para>

      <programlisting>&lt;service id="fooService" ref="fooImpl".../&gt;

&lt;service id="fooService" ... &gt;
   &lt;bean class="com.acme.fooImpl"/&gt;
&lt;/service&gt;</programlisting>

      <para>The scope of the beans is ignored for the manager that provides
      the service object. Its value will only be created once the first time
      it is needed for the service.</para>
    </section>

    <section xml:id="i2715956">
      <title>Scope</title>

      <para>A service manager must always register a Service Factory as
      service object and then dispatch the service requests to the service
      object. A service manager must obtain a single component instance as
      service object. This component instance is shared between all bundles.
      That is, even if the service object comes from a prototype scoped
      manager, only one instance is ever created per service manager.</para>

      <para>If this component instance implements Service Factory, then all
      incoming service requests are forwarded to this single component
      instance.</para>
    </section>

    <section xml:id="i2392470">
      <title>Ranking</title>

      <para>When registering a service with the service registry, an optional
      <emphasis>service ranking</emphasis> can be specified that orders
      service references. The service ranking is registered as the
      <code>SERVICE_RANKING</code> property defined in the OSGi service layer.
      When a bundle looks up a service in the service registry, given two or
      more matching services, then the one with the highest number will be
      returned. The default ranking value for the OSGi service registry is
      zero, therefore, this property must not be registered when
      <code>ranking</code> is zero, which is also the default value.</para>

      <para>For example:</para>

      <programlisting>&lt;service ref="fooImpl" interface="com.acme.FooImpl"
            ranking="900" /&gt;</programlisting>

      <para>This will result in the following service property:</para>

      <programlisting>service.ranking=new Integer(900)</programlisting>
    </section>

    <section xml:id="i2392507">
      <title>Registration Listener</title>

      <para>The <code>registrationListeners</code> represent the objects that
      need to be called back after the service has been registered and just
      before it will be unregistered.</para>

      <para>The <code>listenerComponent</code> must be a <code>Target</code>
      object; it is the target for the following callbacks:</para>

      <itemizedlist>
        <listitem>
          <para><code>registrationMethod</code> – The name of the notification
          method that is called after this service has been registered.</para>
        </listitem>

        <listitem>
          <para><code>unregistrationMethod</code> – This method is called when
          this service will be unregistered.</para>
        </listitem>
      </itemizedlist>

      <para>The signatures for the callback methods depend on the scope and if
      the service object implements the <code>ServiceFactory</code> interface.
      The different possibilities are outlined in <phrase
      role="xref">Table 121.7 on page 280</phrase>.</para>

      <table>
        <title>Interaction scopes and types for callback signature.</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="2*"/>

          <colspec colnum="4" colwidth="3*"/>

          <thead>
            <row>
              <entry>Scope</entry>

              <entry>Type</entry>

              <entry>Signature</entry>

              <entry>Comment</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>singleton</code></entry>

              <entry><code>ServiceFactory</code></entry>

              <entry><code>void(ServiceFactory,Map)</code></entry>

              <entry><para>All service requests are handled by the component
              instance.</para></entry>
            </row>

            <row>
              <entry><code>singleton</code></entry>

              <entry><code>T</code></entry>

              <entry><code>void( super T,Map)</code></entry>

              <entry><para><code>T</code> is assignable from the service
              object’s type.</para></entry>
            </row>

            <row>
              <entry><code>prototype</code></entry>

              <entry><code>ServiceFactory</code></entry>

              <entry><code>void(ServiceFactory,Map)</code></entry>

              <entry><para>All service requests are handled by the first
              component instance.</para></entry>
            </row>

            <row>
              <entry><code>prototype</code></entry>

              <entry><code>T</code></entry>

              <entry><code>void(,Map)</code></entry>

              <entry><para>The first argument must be <code>null</code>
              because for <code>prototype</code> service objects, the
              component instance is created when a bundle requests the
              service. Therefore, at registration time there is no service
              object available.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If multiple signatures match, then all methods must be called in
      indeterminate order. At least one method must match.</para>

      <para>The service manager must provide the registration listener with
      the current registration state when the listener is registered. This
      initial notification must take place before any other callback methods
      are called on this listener on other threads. That is, if the service is
      registered at that time, it must call the registration method and
      otherwise the unregistration method.</para>

      <para>The following example shows two registration listeners, one with a
      referred bean and another one with an inlined bean.</para>

      <programlisting>&lt;service ref="fooImpl" interface="com.acme.Foo"&gt;
   &lt;registration-listener registration-method="reg"
            unregistration-method="unreg"&gt;
        &lt;bean class="com.acme.FooListener"/&gt;
    &lt;/registration-listener&gt;
&lt;/service&gt;

&lt;service ref="fooImpl" interface="com.acme.Foo"&gt;
   &lt;registration-listener registration-method="reg"
            unregistration-method="unreg" ref="fooListener"/&gt;
&lt;/service&gt;
&lt;bean id="fooListener" class="com.acme.FooListener"/&gt;

package com.acme;
public class FooListener {
  public void reg( Foo foo, Map properties ) { ... }
  public void unreg( Foo foo, Map properties ) { ... }
}</programlisting>

      <para>The manager that provides the registration listener object is an
      implicit dependency of the enclosing service manager. However, the
      registration listener component instance is specifically allowed to use
      to the service manager though this is technically a cyclic dependency.
      Therefore, a bean is allowed to be both be injected with a
      <code>ServiceRegistration</code> object from the service manager as well
      as being a registered listener to the same service manager.</para>

      <para>In the following example, the <code>foo</code> service manager
      uses manager <code>main</code>, both as a registration listener as well
      as top-level bean <code>main</code> being injected with reference
      <code>foo</code>.</para>

      <programlisting>&lt;service id="foo" interface="com.acme.Foo"ref="main"&gt;
  &lt;registration-listener 
        registration-method="register" ref="main"/&gt;
&lt;/service&gt;

&lt;bean id="main" class="com.acme.Main" init-method="done"&gt;
    &lt;property name="foo" ref="foo"/&gt;
&lt;/bean&gt;</programlisting>
    </section>

    <section xml:id="i2630717">
      <title>Enabled</title>

      <para>A service manager needs a service object that is referred to by
      the <code>value</code>Metadata property. This value can in its turn
      depend on other managers transitively. If any of these managers are
      service reference managers, then they can be satisfied or not. If these
      service reference managers are marked to be mandatory, then they
      influence the <emphasis>enabled</emphasis> state of the first service
      manager. Only if all of these mandatory service reference managers in
      the dependency graph are satisfied, then the first service manager is
      enabled.</para>

      <para>A service manager must have a Service Factory registered with the
      OSGi service registry after the primary initialization of the Blueprint
      Container has been done until the Blueprint Container is destroyed while
      it is enabled. See see <xref linkend="i2584179"/>.</para>
    </section>

    <section>
      <title>Activation and Deactivation</title>

      <para>When a service manager is activated, it must actuate its
      registration listeners. Each registration listener must be called back
      during its actuation with the current service registration state as
      described in the <xref linkend="i2392507"/>.
      Normally, this will also request the container for a service object but
      this can be further delayed in certain circumstances. See <xref
      linkend="i2392545"/> for more details.</para>

      <para>During deactivation, a service manager must disable any
      registration listeners and release any dependencies it has on these
      component instances.</para>
    </section>
  </section>

  <section xml:id="i2468749">
    <title>Service Reference Managers</title>

    <para>The <code>reference</code>, and <code>reference-list</code> elements
    are all <emphasis>service references</emphasis>. They select a number of
    services in the service registry. The structure of these elements is as
    follows:</para>

    <programlisting>reference       ::= &lt;reference-listener&gt;* 
reference-list  ::= &lt;reference-listener&gt;*</programlisting>

    <para>The inheritance hierarchy for service references is depicted in
    <xref linkend="i2331840" xrefstyle="template:Figure %n on page %p"/>.</para>

    <figure xml:id="i2331840">
      <title>Inheritance hierarchy for service references</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.422in"
                     contentwidth="4.936in"
                     fileref="reference-inheritance-hierarchy.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Service Reference</title>

      <para>The service reference managers have almost identical Metadata and
      share most behavior. The only schema differences between a reference
      manager and a reference-list manager are:</para>

      <itemizedlist>
        <listitem>
          <para><code>timeout</code> – A reference manager supports a
          <code>timeout</code>.</para>
        </listitem>

        <listitem>
          <para><code>memberType</code> – The reference-list can define its
          member-type</para>
        </listitem>
      </itemizedlist>

      <para>The features of the service references are explained in <phrase
      role="xref">Table 121.8 on page 283</phrase>.</para>

      <table>
        <title>Service Reference Manager Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Type</entry>

              <entry>ServiceReference-Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>id</code></entry>

              <entry><code>ID</code></entry>

              <entry><para><code>id</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The component id of a top level
              manager</para></entry>
            </row>

            <row>
              <entry><code>activation</code></entry>

              <entry><para><code> lazy</code></para><para><code>|
              eager</code></para></entry>

              <entry><para><code>activation</code></para><para><code>:
              int</code></para></entry>

              <entry><para>Defines if this service reference is lazily of
              eagerly initialized. If not explicitly set, the
              <code>blueprint</code> element’s value for the
              <code>default-activation</code> attributes is used. If this is
              also not set, the value is <code>eager</code>. See also <xref
              linkend="i2707929"/>.</para></entry>
            </row>

            <row>
              <entry><code>depends-on</code></entry>

              <entry><code>NCName*</code></entry>

              <entry><para><code>dependsOn</code></para><para><code>:
              List&lt;String&gt;</code></para></entry>

              <entry><para>Explicit list of component ids that are the
              dependencies. These managers must be activated before this
              service reference’s activation. See <xref linkend="i2706015"/>. This is a whitespace separated
              List.</para></entry>
            </row>

            <row>
              <entry><code>availability</code></entry>

              <entry><para><code> mandatory</code></para><para><code>|
              optional</code></para></entry>

              <entry><para><code>availability</code></para><para><code>:
              int</code></para></entry>

              <entry><para>Defines if a service reference is mandatory or
              optional. The default for the <code>availability</code>
              attribute is defined by the <code>default-availability</code>
              attribute in the <code>blueprint</code> element. If the
              <code>default-availability</code> attribute is not defined, the
              value is <code>mandatory</code>. </para></entry>
            </row>

            <row>
              <entry><code>interface</code></entry>

              <entry><code>qname</code></entry>

              <entry><para><code>interface</code></para><para><code>:
              String</code></para></entry>

              <entry><para>A single name of an interface class. It is allowed
              to not specify an interface name. </para></entry>
            </row>

            <row>
              <entry><code>component-name</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>componentName</code></para><para><code>:
              String</code></para></entry>

              <entry><para>Points to another manager in another Blueprint
              Container registered in the service registry. If set, the
              component name must be part of the effective
              filter.</para></entry>
            </row>

            <row>
              <entry><code>filter</code></entry>

              <entry><code>filter</code></entry>

              <entry><para><code>filter</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The given filter string, can be
              <code>null</code>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;reference-listener&gt;</code></entry>

              <entry><code>See <xref linkend="i2985507"/></code></entry>

              <entry><para><code>referenceListeners</code></para><para><code>:
              List&lt;Listener&gt;</code></para></entry>

              <entry><para>The Metadata of the reference
              listeners</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The additional constraints for service references are:</para>

      <itemizedlist>
        <listitem>
          <para>The <code>interface</code>, if set, must refer to a public
          interface.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>&lt;reference&gt;</title>

      <para>A reference manager, selecting a single service, has the
      additional feature explained in <phrase role="xref">Table  on
      page 284</phrase>.</para>

      <table>
        <title>Reference Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Type</entry>

              <entry>Reference Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>timeout</code></entry>

              <entry><code>long &gt;= 0</code></entry>

              <entry><para><code>timeout</code></para><para><code>:
              long</code></para></entry>

              <entry><para>The <code>timeout</code> in ms. Zero is
              indefinite.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>An additional constraint on the reference is:</para>

      <itemizedlist>
        <listitem>
          <para>The <code>timeout</code> must be equal or larger than
          zero.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>&lt;reference-list&gt;</title>

      <para>A reference-list manager, selecting multiple services, has the
      additional feature explained in <phrase role="xref">Table 121.9 on
      page 285</phrase>.</para>

      <table>
        <title>Reference-list Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Type</entry>

              <entry>Reference List Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>member-type</code></entry>

              <entry><para><code> service-object</code></para><para><code>|
              service-reference</code></para></entry>

              <entry><para><code>memberType</code></para><para><code>:
              int</code></para></entry>

              <entry><para>Defines if the members of the list are
              <code>ServiceReference</code> objects or the proxies to the
              actual service objects.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="i2985507">
      <title>&lt;reference-listener&gt;</title>

      <para>The <code>reference</code> element can notify reference listeners
      of the service selection changes with the
      <code>referenceListeners</code>. The <code>reference-listener</code>
      element has the following structure:</para>

      <programlisting>reference-listener  ::= target*</programlisting>

      <para>The <code>reference-listener</code> element defines the callback
      methods for binding and unbinding a service.</para>

      <table>
        <title>Reference Listener Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Type</entry>

              <entry>Reference Listener</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>ref</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>listenerComponent</code></para><para><code>:
              Target</code></para></entry>

              <entry><para>A reference to a top level target manager.
              </para></entry>
            </row>

            <row>
              <entry><code>bind-method</code></entry>

              <entry><code>method</code></entry>

              <entry><para><code>bindMethod</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The name of the method to call after the service
              has been bound. See <xref linkend="i2039720"/>.</para></entry>
            </row>

            <row>
              <entry><code>unbind-method</code></entry>

              <entry><code>method</code></entry>

              <entry><para><code>unbindMethod</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The name of the method to call before the service
              will be unbound. See <xref linkend="i2039720"/>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;...&gt;</code></entry>

              <entry><code>target</code></entry>

              <entry><para><code>listenerComponent</code></para><para><code>:
              Target</code></para></entry>

              <entry><para>An inlined target manager</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The additional constraints are:</para>

      <itemizedlist>
        <listitem>
          <para>The <code>ref</code> attribute and the inlined manager are
          mutually exclusive.</para>
        </listitem>

        <listitem>
          <para>Either or both <code>bindMethod</code> and
          <code>unbindMethod</code> must be specified.</para>
        </listitem>

        <listitem>
          <para>At least one specified method must exist with each given
          method name, see <xref linkend="i2039720"/>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i2748212">
      <title>Provided Object For a Reference</title>

      <para>The provided object for a service reference manager is a
      <emphasis>proxy</emphasis> backed by a service object from the service
      registry. Therefore, even though the injected object will remain
      constant, it can change its reference to a backing service at any time,
      implying it can only be used with stateful services if reference
      listeners are used. If use when no suitable backing service is
      available, it will wait until it times out. See <xref linkend="i1766539"/> for more details. The model is depicted in
      <xref linkend="i2751824"/>.</para>

      <figure xml:id="i2751824">
        <title>Constant references with dynamic selection</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.265in"
                       contentwidth="4.917in" fileref="dynamic-selection.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The following example shows how a property can be set to the
      service object.</para>

      <programlisting>public class C {
    public void setProxy(T ref) { ... }
}
&lt;reference id="p" interface="T"/&gt;
&lt;bean id="c" class="C"&gt;
    &lt;property name="proxy" ref="p"/&gt;
&lt;/bean&gt;</programlisting>
    </section>

    <section xml:id="i2748237">
      <title>Provided Object For a Reference-list</title>

      <para>The reference-list provided object implements the
      <code>List</code> interface; this List contains proxies to the backing
      services. These proxies do not have a <code>timeout</code>. That is,
      when a proxy from a reference-list is used, it must not wait when the
      backing service is no longer available but it must immediately throw a
      Service Unavailable Exception.</para>

      <para>Changes to the list are dynamic. When a backing service is
      unregistered, the corresponding proxy is removed from the list
      synchronously with the service event. When a new service enters the
      selection, it is added synchronously with the service event. Proxies to
      newly discovered services must be added at the end of the list. The
      structure is depicted in <xref linkend="i2751839"/>.</para>

      <figure xml:id="i2751839">
        <title>Constant reference to list with dynamic selection</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.265in"
                       contentwidth="4.917in"
                       fileref="dynamic-selection-list.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The member type of the list depends on the
      <code>memberType</code>. If this is set to:</para>

      <itemizedlist>
        <listitem>
          <para><code>service-object</code> – Inject a List of service
          objects, this is the default.</para>
        </listitem>

        <listitem>
          <para><code>service-reference</code> – Inject a list of
          <code>ServiceReference</code> objects</para>
        </listitem>
      </itemizedlist>

      <para>If generics information is available, then it is an error if the
      generic member type of the target list is not assignable with the
      <code>memberType</code>. If the member target type is in itself
      specified with generic arguments, like
      <code>List&lt;T&lt;U&gt;&gt;</code>, then the assignment must fail
      because this would require conversion and no conversion can take place
      for this assignment. For information about generics, see <xref
      linkend="i2814178"/>.</para>
    </section>

    <section>
      <title>Read Only Lists</title>

      <para>The list is a read-only view on the actual set of proxies to the
      service objects. This <code>List</code> object must only support the
      following methods:</para>

      <programlisting>contains(Object)
containsAll(Collection)
equals(Object)
get(int)
hashCode()
indexOf(Object)
isEmpty()
iterator()          // no remove method
lastIndexOf(Object)
listIterator()      // not supported
listIterator(int)   // not supported
size()
subList(int, int)   // same list type as parent
toArray()
toArray(T[])</programlisting>

      <para>All other methods must throw an Unsupported Operation Exception.
      The List Iterator is not supported for these lists.</para>
    </section>

    <section xml:id="i2748268">
      <title>Selection</title>

      <para>A service reference must provide a <emphasis>selection</emphasis>
      of services from the service registry. The Blueprint Container must
      logically use a filter for the selection that is the <code>and</code>
      (&amp;) of the following assertions:</para>

      <itemizedlist>
        <listitem>
          <para>The <code>interface</code>, if specified</para>
        </listitem>

        <listitem>
          <para>If <code>componentName</code> is not null, a filter that
          asserts <code>osgi.blueprint.compname=$componentName</code> This is
          a convenience function to easily refer to managers in other
          Blueprint Containers. Registered Blueprint services will
          automatically get this property set to their blueprint name.</para>
        </listitem>

        <listitem>
          <para>If <code>filter</code> is not <code>null</code>, the
          <code>filter</code></para>
        </listitem>
      </itemizedlist>

      <para>The selection is defined as the set of Service References selected
      by the given filter.</para>
    </section>

    <section>
      <title>Availability</title>

      <para>A service reference is <emphasis>satisfied</emphasis> when one or
      more services match the selection. The <code>availability</code> is used
      to specify whether a service reference needs to be satisfied before
      initialization, see <xref linkend="i2456332"/>, or if it controls the registration state
      of any service managers that depend on this service reference manager
      (explicit and implicit), see <xref linkend="i2416456"/>. The <code>availability</code> can have the
      following values:</para>

      <itemizedlist>
        <listitem>
          <para><code>mandatory</code> – Mandatory indicates that the service
          reference needs to be satisfied.</para>
        </listitem>

        <listitem>
          <para><code>optional</code> – Optional indicates that the
          satisfaction of this reference is not relevant for any registered
          services, or for the grace period.</para>
        </listitem>
      </itemizedlist>

      <para>It is an error to declare a mandatory reference to a service that
      is registered by the same bundle. Such a definition could cause either
      deadlock or a timeout.</para>

      <para>The fact that Blueprint specification has mandatory service
      references gives no guarantee that a valid service object is available
      when the service reference is used, in the dynamic world of OSGi,
      services can get unregistered at any time.</para>

      <para>The following example declares a mandatory service reference for a
      single service. The usage of the reference can stall a maximum of 5
      seconds if no service matches the selection.</para>

      <programlisting>&lt;reference 
    id          ="log" 
    interface   ="org.osgi.service.log.LogService"
    availability="mandatory"
    timeout     ="5000" /&gt;</programlisting>
    </section>

    <section xml:id="i2039720">
      <title>Reference Listeners</title>

      <para>The <code>referenceListeners</code> are represented as
      <code>ReferenceListener</code> objects. They define the following
      callbacks:</para>

      <itemizedlist>
        <listitem>
          <para><code>bindMethod</code> – Called after a service is selected
          by the service reference manager. For a reference manager, this
          method can be called repeatedly without an intermediate unbind
          callback. This happens when a service is unregistered but a
          replacement can be found immediately.</para>
        </listitem>

        <listitem>
          <para><code>unbindMethod</code> – Called when the service is no
          longer used by the service reference manager but before it has been
          returned to the service registry with the <code>unget</code> method.
          For a reference manager, no unbind method is called when the service
          can immediately be replaced with an alternative service when the
          service goes away.</para>
        </listitem>
      </itemizedlist>

      <para>A reference listener callback can have any of the following
      signatures:</para>

      <itemizedlist>
        <listitem>
          <para><code>public void(ServiceReference)</code> – Provide the
          <code>ServiceReference</code> object associated with this service
          reference. This callback type provides access to the service’s
          properties without actually getting the service.</para>
        </listitem>

        <listitem>
          <para><code>public void( super T) –</code> Provide the proxy to the
          service object, where T is on of the types implemented by the
          service object proxy.</para>
        </listitem>

        <listitem>
          <para><code>public void ( super T,Map)</code> – Provide the proxy to
          the service object. <code>T</code> is a type that is assignable from
          the service object. The <code>Map</code> object provides the service
          properties of the corresponding <code>ServiceReference</code>
          object.</para>
        </listitem>
      </itemizedlist>

      <para>All signatures must be supported regardless of the value of
      <code>memberType</code> that was specified in the reference-list. The
      service object given to the reference listeners must be the proxy to the
      service object.</para>

      <para>The callbacks must be made synchronously with the corresponding
      OSGi service event. For reference-list callbacks, the service proxy is
      guaranteed to be available in the collection before a bind callback is
      invoked, and to remain in the collection until after an unbind callback
      has completed.</para>

      <para>If a service listener defines multiple overloaded methods for a
      callback, then every method with a matching signature is invoked in an
      undefined order.</para>

      <para>For example, the following definition will result in calling all
      the <code>setLog</code> methods on a <code>FooImpl</code> object:</para>

      <programlisting>&lt;reference id="log"
        interface="org.osgi.service.log.LogService"&gt;
  &lt;reference-listener
        bind-method="setLog"&gt;
        &lt;bean class="com.acme.FooImpl"/&gt;
    &lt;/reference-listener&gt;
&lt;/reference&gt;

public class FooImpl {
    public void setLog(Object o, Map m) { ... }
    public void setLog(LogService l, Map m) { ... }
    public void setLog(ServiceReference ref) { ... }
}</programlisting>

      <para>The manager that provides the reference listener object is treated
      as an implicit dependency of the enclosing service reference. This
      manager is specifically allowed to use to the service reference in a
      property injection or constructor argument, though this is technically a
      cyclic dependency. Therefore, a bean must be allowed to both be injected
      with a reference as well as listening to the bind and unbind callbacks
      of that same reference.</para>

      <para>In the following example, the <code>foo</code> reference manager
      uses manager <code>main</code>, both as a reference listener as well as
      manager <code>main</code> being injected with reference
      <code>foo</code>.</para>

      <programlisting>&lt;reference id="foo" interface="com.acme.Foo"&gt;
  &lt;reference-listener bind-method="setL" ref="main"/&gt;
&lt;/reference&gt;
&lt;bean id="main" class="com.acme.Main"&gt;
    &lt;property name="r" ref="foo"/&gt;
&lt;/bean&gt;</programlisting>
    </section>

    <section>
      <title>Service Proxies</title>

      <para>The Blueprint extender must generate proxies for the service
      reference managers. Reference managers provide proxies that dynamically
      select a <emphasis>backing</emphasis> service, which can change over
      time. A reference-list provides a list of proxies that have a fixed
      backing service, these proxies are added and removed from the list.
      based on the selection, they do not have a time-out.</para>

      <para>The backing service for a reference proxy must not be gotten from
      the OSGi service registry until an actual service object is needed, that
      is, when an actual method is called on the proxy. If the backing service
      becomes unregistered, then the proxy must unget the reference to the
      backing service (if it had gotten it) and get another service object the
      next time a method on the proxy is called. If a replacement can be found
      immediately, the reference listener’s bind method must be called without
      calling the unbind method. Other threads that need the same service
      object must block until the service object has become available or times
      out.</para>

      <para>The proxies must implement all the methods that are defined in the
      <code>interface</code>. The <code>interface</code> must refer to an
      interface, not a class. The proxy must only support the methods in the
      given interface. That is, it must not proxy methods available on the
      service object that are not available in the given interface. If no
      interface is defined, the proxy must be implemented as if the interface
      had no methods defined.</para>

      <para>Blueprint bundles must ensure that the proper semantics are
      maintained for <code>hashCode</code> and <code>equals</code> methods. If
      these methods are not defined in the interface, then the proxy must use
      the default semantics of the <code>Object</code> class for
      <code>equals</code> and <code>hashCode</code> methods.</para>
    </section>

    <section>
      <title>Activation and Deactivation</title>

      <para>Service reference managers are active before activation because
      they must handle the enable status of service managers.</para>

      <para>During activation, a service reference must actuate its listeners
      and provide these listeners with the initial state of the reference. For
      a reference, if there is a selected object, the bind method must be
      called with the proxy object, otherwise the unbind method must be called
      with a <code>null</code> as proxy object. For a reference-list, the bind
      method must be called for each member of the list. If the list is empty,
      the unbind method must be called with a <code>null</code> as proxy
      object.</para>

      <para>During deactivation, the listeners must be disabled.</para>
    </section>
  </section>

  <section xml:id="i2352936">
    <title>Object Values</title>

    <para>Top-level managers can use <emphasis>object values</emphasis> in
    different places. These object values are defined with XML elements and
    attributes. After parsing, they are all converted to sub-interfaces of the
    <code>Metadata</code> interface, transitively reachable from top-level
    managers. For example, the following definition creates a bean that is
    injected with the byte array: <code>byte[] {7,42}</code>:</para>

    <programlisting>&lt;bean class="com.acme.FooImpl"&gt;
    &lt;property name="array"&gt;
        &lt;array value-type="byte"&gt;
            &lt;value&gt;7&lt;/value&gt;
            &lt;value&gt;42&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

    <para>This definition provides the configuration data for an
    <emphasis>array value</emphasis>, which is represented by the
    <code>CollectionMetadata</code> interface. A <code>Metadata</code> object
    can be used to construct its object value during runtime whenever a new
    object must be constructed.</para>

    <para>In most places where an object value can be used, it can be
    anything, including objects provided by a managers and even
    <code>null</code>. However, maps require non-null keys. The object values
    are therefore split in <code>value</code> and <code>nonNullValue</code>
    types.</para>

    <para>The syntax for object values has the following structure:</para>

    <programlisting>nonNullValue ::= &lt;ref&gt;
               | &lt;idref&gt;
               | &lt;value&gt;
               | &lt;map&gt;
               | &lt;props&gt;
               | collection
               | manager // see <xref linkend="i3005561"/>
value        ::= nonNullValue | &lt;null&gt;
collection   ::= &lt;list&gt; | &lt;set&gt; | &lt;array&gt;</programlisting>

    <para>Object values also include inlined managers. The use of an inlined
    manager for an object value means that manager will provide a value every
    time the object value is constructed. Each of the object values is created
    anew and the types are mutable, except for the service references. The use
    of managers in object values must create an implicit dependency between
    the top level managers and any transitively reachable manager from their
    Metadata.</para>

    <section xml:id="i1979542">
      <title>&lt;ref&gt;</title>

      <para>The <code>ref</code> element is a reference to a top-level manager
      in the same Blueprint Container. The <code>ref</code> element has a
      single attribute <code>component-id</code>.</para>

      <table>
        <title>Ref Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Type</entry>

              <entry>Ref Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>component-id</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>componentId</code></para><para><code>:
              String</code></para></entry>

              <entry><para>A reference to a top level manager. </para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, the following definition uses the <code>foo</code>
      manager to instantiate the service object.</para>

      <programlisting>&lt;service id="fooService" interface="com.acme.Foo"&gt;
    &lt;ref component-id="fooImpl"/&gt; 
&lt;/service&gt;
&lt;bean id="fooImpl" class="com.acme.FooImpl"/&gt;

public class FooImpl implements Foo { }</programlisting>
    </section>

    <section xml:id="i1979564">
      <title>&lt;idref&gt;</title>

      <para>The <code>idref</code> element provides the component id of
      another manager in the same Blueprint Container. This reference can then
      be used by the application to look up a manager in the Blueprint
      Container during runtime. The <code>idref</code> element is a safe way
      to provide a component id because the Blueprint Container will verify
      that the component id exists, thereby showing errors early. The
      <code>idref</code> does not create an implicit dependency on the given
      manager.</para>

      <table>
        <title>IdRef Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Type</entry>

              <entry>Id Ref Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>component-id</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>componentId</code></para><para><code>:
              String</code></para></entry>

              <entry><para>A reference to a top level manager. </para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The following example provides the <code>foo</code> object with
      the reference to the database.</para>

      <programlisting>&lt;bean id="foo" class="com.acme.FooImpl"&gt;
    &lt;property name="db"&gt;
        &lt;idref component-id="jdbc"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="jdbc" ... /&gt;</programlisting>

      <para>The following definition is equivalent to except that a non
      existent component id will not be detected until the <code>foo</code>
      object access the Blueprint Container. In the previous example this was
      detected directly after the definitions were parsed.</para>

      <programlisting>&lt;bean id="foo" class="com.acme.FooImpl"&gt;
    &lt;property name="db" value="jdbc"/&gt;
&lt;/bean&gt; 
&lt;bean id="jdbc" ... /&gt; </programlisting>
    </section>

    <section xml:id="i1979526">
      <title>&lt;value&gt;</title>

      <para>A value element represents an object that can directly be
      constructed from a string formed by its text contents.</para>

      <table>
        <title>Value Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute, Element</entry>

              <entry>Type</entry>

              <entry>Value Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>type</code></entry>

              <entry><code>type</code></entry>

              <entry><para><code>type</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The optional type name to be used in type
              converting the given string to a target type. This type can
              commit the conversion to a specific choice. If this type is not
              set, then it must return null. For the type syntax, see <xref
              linkend="i2972566"/>.</para></entry>
            </row>

            <row>
              <entry><code>...</code></entry>

              <entry><code>&lt;&lt;type&gt;&gt;</code></entry>

              <entry><para><code>stringValue</code></para><para><code>:
              String</code></para></entry>

              <entry><para>The string value that must be converted to the
              target type, if set.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If a value element is used as a member in a <code>list</code>,
      <code>map</code>, <code>array</code>, or <code>set</code> then the
      enclosing collection can define a default value for the type attribute
      of its value elements.</para>

      <para>The following example creates a list of two OSGi version
      objects.</para>

      <programlisting>&lt;list value-type="org.osgi.framework.Version"&gt;
    &lt;value&gt;1.3.4&lt;/value&gt;
    &lt;value&gt;5.6.2.v200911121020&lt;/value&gt;
&lt;/list&gt;</programlisting>

      <para>The corresponding Java code is:</para>

      <programlisting>Arrays.asList( new Version("1.3.4"), 
    new Version("5.6.2.v200911121020") )</programlisting>
    </section>

    <section xml:id="i1979534">
      <title>&lt;null&gt;</title>

      <para>A null element results in a Java <code>null</code>. It has no
      attributes and no elements. It corresponds to Null Metadata.</para>
    </section>

    <section xml:id="i1979486">
      <title>&lt;list&gt;, &lt;set&gt;, &lt;array&gt;</title>

      <para>Lists, sets, and arrays are referred to as
      <emphasis>collections</emphasis>. List and array are ordered sequences
      of objects, where equal objects can occur multiple times. A set discards
      equal objects.</para>

      <para>The structure of a collection element is:</para>

      <programlisting>collection  ::=  value *
 </programlisting>

      <table>
        <title>Collection Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colname="col3" colnum="3" colwidth="3*"/>

          <colspec colname="col4" colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Type</entry>

              <entry>Collection Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry morerows="1"><code>value-type</code></entry>

              <entry morerows="1"><code>type</code></entry>

              <entry><para><code>valueType</code></para><para><code>:
              String</code></para></entry>

              <entry><para>Optionally set the type for
              <code>ValueMetadata</code> children.</para></entry>
            </row>

            <row>
              <entry
              colname="col3"><para><code>collectionClass</code></para><para><code>:
              Class&lt;</code> <code>List | Set | Object[]
              &gt;</code></para></entry>

              <entry colname="col4"><para>The actual collection class to be
              used, derived from the appropriate definition. </para></entry>
            </row>

            <row>
              <entry><code>&lt;...&gt;</code></entry>

              <entry><code>object*</code></entry>

              <entry><para><code>values</code></para><para><code>:
              List&lt;Metadata&gt;</code></para></entry>

              <entry><para>The Metadata for the children of the
              collection</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <code>valueType</code> sets the default for any contained
      <code>ValueMetadata</code> objects. The result of a collection element
      is an object that implements the given collection interface or is an
      <code>Object[]</code>. That is, the resulting object is mutable and can
      be used by the application. However, type conversion can create a copy
      of this list.</para>

      <para>The following example creates a List of Lists of 2x2 of
      <code>int</code> values:</para>

      <programlisting>&lt;list&gt;
    &lt;list value-type="int"&gt;
        &lt;value&gt;2&lt;/value&gt;
        &lt;value&gt;7&lt;/value&gt;
    &lt;/list&gt;
    &lt;list value-type="int"&gt;
        &lt;value&gt;9&lt;/value&gt;
        &lt;value&gt;5&lt;/value&gt;
    &lt;/list&gt;
&lt;/list&gt;</programlisting>

      <para>The corresponding Java code is:</para>

      <programlisting>Arrays.asList( 
    new int[] {2,7},
    new int[]{9,5},
)</programlisting>
    </section>

    <section xml:id="i1979502">
      <title>&lt;map&gt;</title>

      <para>A map is a sequence of associations between a
      <emphasis>key</emphasis> and some object., this association is called an
      <emphasis>entry</emphasis>. The structure of a <code>map</code> element
      is therefore:</para>

      <programlisting>map ::= &lt;entry&gt; *</programlisting>

      <table>
        <title>Map Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute or Element</entry>

              <entry>Type</entry>

              <entry>Map Metadata</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>key-type</code></entry>

              <entry><code>type</code></entry>

              <entry><para><code>keyType</code></para><para><code>:
              String</code></para></entry>

              <entry><para>Optional default type for keys. For the syntax see
              <xref linkend="i2972566"/>.</para></entry>
            </row>

            <row>
              <entry><code>value-type</code></entry>

              <entry><code>type</code></entry>

              <entry><para><code>valueType</code></para><para><code>:
              String</code></para></entry>

              <entry><para>Optional default type for values. For the syntax
              see <xref linkend="i2972566"/>.</para></entry>
            </row>

            <row>
              <entry><code>&lt;entry&gt;</code></entry>

              <entry><code>See <xref linkend="i2443675"/></code></entry>

              <entry><para><code>values</code></para><para><code>:
              List&lt;MapEntry&gt;</code></para></entry>

              <entry><para>The <code>MapEntry</code> object for the children
              of the map or properties.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>There are no additional constraints.</para>
    </section>

    <section xml:id="i2443675">
      <title>&lt;entry&gt;</title>

      <para>The entry element provides an association between a key and a
      value. The structure of the element is:</para>

      <programlisting>entry   ::= &lt;key&gt; object
key     ::= nonNullValue</programlisting>

      <table>
        <title>Entry Features</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="3*"/>

          <colspec colnum="4" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Type</entry>

              <entry>Map Entry</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>key</code></entry>

              <entry><code>&lt;&lt;type&gt;&gt;</code></entry>

              <entry><para><code>key</code></para><para><code>:
              NonNullMetadata</code></para></entry>

              <entry><para>Specify the key of the entry.</para></entry>
            </row>

            <row>
              <entry><code>key-ref</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>key</code></para><para><code>:
              NonNullMetadata</code></para></entry>

              <entry><para>Reference to a top-level manager</para></entry>
            </row>

            <row>
              <entry><code>&lt;key&gt;</code></entry>

              <entry><code>nonNull-Value</code></entry>

              <entry><para><code>key</code></para><para><code>:
              NonNullMetadata</code></para></entry>

              <entry><para>Contains an inlined value that is never
              null.</para></entry>
            </row>

            <row>
              <entry><code>value</code></entry>

              <entry><code>&lt;&lt;type&gt;&gt;</code></entry>

              <entry><para><code>value</code></para><para><code>:
              Metadata</code></para></entry>

              <entry><para>Specify the value directly, this will be a string
              type.</para></entry>
            </row>

            <row>
              <entry><code>value-ref</code></entry>

              <entry><code>NCName</code></entry>

              <entry><para><code>value</code></para><para><code>:
              RefMetadata</code></para></entry>

              <entry><para>A reference to a top-level manager</para></entry>
            </row>

            <row>
              <entry><code>&lt;...&gt;</code></entry>

              <entry><code>object</code></entry>

              <entry><para><code>value</code></para><para><code>:
              Metadata</code></para></entry>

              <entry><para>An inlined manager</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Additional constraints:</para>

      <itemizedlist>
        <listitem>
          <para><code>key</code>, <code>key-ref</code> attributes and
          <code>key</code> element are mutually exclusive.</para>
        </listitem>

        <listitem>
          <para><code>value</code>, <code>value-ref</code> attributes and
          <code>value</code> element are mutually exclusive.</para>
        </listitem>

        <listitem>
          <para>The resulting object of a key must not be a primitive
          type.</para>
        </listitem>
      </itemizedlist>

      <para>The following example shows the different way an entry can get its
      key. In this case the value is always a string.</para>

      <programlisting>&lt;map&gt;
    &lt;entry key="bar"     value="..."/&gt;    // 1
    &lt;entry key-ref="bar" value="..."/&gt;    // 2
    &lt;entry value="..."&gt;                   // 3
        &lt;key&gt;
            &lt;value type="org.osgi.framework.Version"&gt;
                2.71
            &lt;/value&gt;
        &lt;/key&gt;
    &lt;/entry&gt;
&lt;/map&gt;</programlisting>

      <para>The previous example is equivalent to the following Java
      code:</para>

      <programlisting>Map m = new HashMap();
m.put( "bar", "...");
m.put( container.getComponentInstance("bar"), "...");
m.put( new Version("2.71"), "...");</programlisting>

      <para>The following examples shows the different ways a value of an
      entry can be defined.</para>

      <programlisting>&lt;map&gt;
    &lt;entry key="1" value="1"/&gt;
    &lt;entry key="2" value-ref="foo"/&gt;
    &lt;entry key="3"&gt;
        &lt;value type="org.osgi.framework.Version"&gt;3.14&lt;/value&gt;
    &lt;/entry&gt;
&lt;/map&gt;</programlisting>

      <para>The previous code is equivalent to the following Java code.</para>

      <programlisting>Map m = new HashMap()
m.put("1", "1");
m.put("2", container.getComponentInstance("foo"))
m.put("3", new Version("3.14"));</programlisting>
    </section>

    <section xml:id="i1979518">
      <title>&lt;props&gt;</title>

      <para>The <code>props</code> element specifies a <code>Properties</code>
      object. The structure of a <code>props</code> element is as
      follows:</para>

      <programlisting> props  ::= prop *</programlisting>

      <para>Each <code>prop</code> element is an association between two
      strings. It defines the following attributes:</para>

      <itemizedlist>
        <listitem>
          <para><code>key</code> – A string specifying the property key. This
          attribute is required.</para>
        </listitem>

        <listitem>
          <para><code>value</code> – A string specifying the property
          value.</para>
        </listitem>
      </itemizedlist>

      <para>The following example initializes the same <code>Properties</code>
      object in two s ways.</para>

      <programlisting>&lt;props&gt;
    &lt;prop key="1"&gt;one&lt;/prop&gt;
    &lt;prop key="2"&gt;two&lt;/prop&gt;
&lt;/props&gt;

&lt;props&gt;
    &lt;prop key="1" value="one"/&gt;
    &lt;prop key="2" value="two"/&gt;
&lt;/props&gt;</programlisting>

      <para>This is equivalent to the following Java code:</para>

      <programlisting>Properties p = new Properties();
p.setProperty( "1", "one");
p.setProperty( "2", "two");</programlisting>
    </section>

    <section>
      <title>Manager as Value</title>

      <para>Each manager can be the provider of component instances that act
      as object values. When a manager is used in an object value, then that
      is the manager asked to provide a component instance. The managers are
      specified in <xref linkend="i3005561"/>. The
      simple example is a bean. Any inlined bean can act as an object value.
      For example:</para>

      <programlisting>&lt;list&gt;
    &lt;bean class="com.acme.FooImpl"/&gt;
&lt;/list&gt;</programlisting>

      <para>Some managers have side effects when they are instantiated. For
      example, a service manager will result in a
      <code>ServiceRegistration</code> object but it will also register a
      service.</para>

      <programlisting>&lt;map&gt;
    &lt;entry key="foo"&gt;
        &lt;service interface="com.acme.Foo"&gt;
            &lt;bean class="com.acme.FooImpl"/&gt;
        &lt;/service&gt;
    &lt;/entry&gt;
&lt;/map&gt;    </programlisting>
    </section>
  </section>

  <section xml:id="i2381582">
    <title>Dependency Injection</title>

    <para>A bean has a recipe for constructing a component instance with a
    constructor or factory and then providing it with its
    <emphasis>properties</emphasis>. These properties are then injected with
    <emphasis>object values</emphasis>, see <xref linkend="i2352936"/>.</para>

    <para>The following types of dependencies can be injected:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Constructor arguments</emphasis> – The
        <code>arguments</code> specify the parameters for a
        constructor.</para>
      </listitem>

      <listitem>
        <para><emphasis>Static Factory arguments </emphasis>– The
        <code>arguments</code> specify the parameters for a static
        method.</para>
      </listitem>

      <listitem>
        <para><emphasis>Instance Factory arguments</emphasis> – The
        <code>arguments</code> specify the parameters for a method on an
        object provided by another manager.</para>
      </listitem>

      <listitem>
        <para>P<emphasis>roperties</emphasis> – The <code>value</code> of the
        Bean Property specifies the single parameter for the property’s set
        method.</para>
      </listitem>
    </itemizedlist>

    <para>In all the previous cases, the Blueprint Container must find an
    appropriate method or constructor to inject the dependent objects into the
    bean. The process of selecting the correct method or constructor is
    described in the following section, which assumes a Bean Argument as
    context, where a Bean Property acts as a Bean Argument without an
    <code>index</code> or <code>type</code> set.</para>

    <section xml:id="i1800540">
      <title>Signature Disambiguation</title>

      <para>Constructors, factory methods, and property set methods are
      described with Metadata. The Blueprint Container must map these
      descriptions to an actual method or constructor. In practice, there can
      be multiple methods/constructors that could potentially map to the same
      description. It is therefore necessary to disambiguate this selection.
      Both factory methods and constructors have the same concept of
      <emphasis>signatures</emphasis>. A signature consists of an ordered
      sequence of zero or more types. For methods, only publicly accessible
      methods with the appropriate name are considered. For constructors, all
      publicly accessible constructors are considered. The disambiguation
      process described here is valid for all constructors and methods because
      the signature concept applies to both of them.</para>

      <orderedlist>
        <listitem>
          <para>Discard any signatures that have the wrong cardinality</para>
        </listitem>

        <listitem>
          <para>Find the list of signatures that have
          <emphasis>assignable</emphasis> types for each argument in their
          corresponding positions. Assignable is defined in <xref
          linkend="i2736197"/>. If a
          <code>type</code> was specified for an argument, then this
          <code>type</code> must match the name of the corresponding reified
          type in the signature exactly.</para>
        </listitem>

        <listitem>
          <para>If this result list has one element, then this element is the
          answer. If this list has more than one element, then the
          disambiguation fails.</para>
        </listitem>

        <listitem>
          <para>Otherwise, find the list of signatures that have
          <emphasis>compatible</emphasis> types for each argument in their
          corresponding positions. Compatibility is defined in <xref
          linkend="i2736197"/>.</para>
        </listitem>

        <listitem>
          <para>If this result list has one element, then this element is the
          answer. If the list has more than one element, then the
          disambiguation fails.</para>
        </listitem>

        <listitem>
          <para>If the arguments cannot be reordered (the <code>index</code>
          of the <code>argument</code> is used and is thus not -1, or there
          are less than two arguments) then the disambiguation fails.</para>
        </listitem>

        <listitem>
          <para>Find all signatures that match a re-ordered combination of the
          arguments. Reordering must begin with the first argument and match
          this argument against the first <emphasis>assignable</emphasis>
          types in a signature, going from position 0 to <code>n</code>. If
          the type is assignable from the argument, then it is locked in that
          position. If the argument has a <code>type</code>, then it must
          exactly match the name of the selected signature type. The same is
          done for the subsequent arguments. If all arguments can find an
          exclusive position in the signature this way, than the signature is
          added to the result.</para>
        </listitem>

        <listitem>
          <para>If the result list contains one signature, then this is the
          resulting signature. If the list has more than one element, then the
          disambiguation fails.</para>
        </listitem>

        <listitem>
          <para>Repeat step 6, but now look for
          <emphasis>compatible</emphasis> types instead of assignable
          types.</para>
        </listitem>

        <listitem>
          <para>If the result list contains one signature, then this is the
          resulting signature.</para>
        </listitem>

        <listitem>
          <para>Otherwise, the disambiguation fails</para>
        </listitem>
      </orderedlist>

      <para>An example elucidates how the disambiguation works. Assuming the
      following definition and classes:</para>

      <programlisting>&lt;bean ...&gt;
    &lt;argument&gt;
        &lt;bean class="Bar"/&gt;
    &lt;/argument&gt;
    &lt;argument&gt;
        &lt;bean class="Foo"/&gt;
    &lt;/argument&gt;
&lt;bean&gt;

public class Bar extends Foo {}
public class Foo {}</programlisting>

      <para>The following bullets provide examples how signatures are matched
      against the previous definition.</para>

      <itemizedlist>
        <listitem>
          <para><code>(Bar,Foo)</code> – The arguments will be in the given
          order and the orderd match will succeed. This is the normal
          case.</para>
        </listitem>

        <listitem>
          <para><code>(Foo,Bar)</code> – This will not match because in the
          re-ordered match, the Bar argument (which is a <code>Foo</code>
          sub-type) is matched against the first argument. The second
          <code>Foo</code> argument can then no longer find a compatible type
          because that slot is taken by the <code>Bar</code> instance.</para>
        </listitem>

        <listitem>
          <para><code>(Object,Object)</code> – This will be called with
          <code>(aBar,aFoo)</code>.</para>
        </listitem>
      </itemizedlist>

      <para>Multiple constructors on a class can require disambiguation with
      the arguments <code>type</code>. In the following example, the
      <code>Multiple</code> class has two constructors that would both match
      the constructor arguments because a <code>String</code> object can be
      converted to both a <code>File</code> object and a <code>URL</code>
      object.</para>

      <programlisting>public class Multiple {
    public Multiple(URL a);
    public Multiple(File a);
}</programlisting>

      <para>An attempt to configure a <code>Multiple</code> object without the
      <code>type</code> will fail, because it is not possible to determine the
      correct constructor. Therefore, the <code>type</code> should be set to
      disambiguate this:</para>

      <programlisting>&lt;bean class=”Multiple”&gt;
  &lt;argument type="java.net.URL" value=”http://www.acme.us”/&gt;
&lt;/bean&gt;</programlisting>
    </section>

    <section xml:id="i2736197">
      <title>Type Compatibility</title>

      <para>During injection, it is necessary to decide about type
      <emphasis>assignability</emphasis> or type
      <emphasis>compatibility</emphasis> in several places. If generics are
      present, a type must be <emphasis>reified</emphasis> in its class, see
      <xref linkend="i2814178"/>. In this
      specification, the canonical representation for a type is
      <code>T&lt;P1..Pn&gt;</code>, where <code>n</code> is zero for a
      non-parameterized type, which is always true in a VM less than Java 5.
      The <code>ReifiedType</code> class models this kind of type.</para>

      <para>If type <code>T</code> or <code>S</code> is primitive, then they
      are treated as their corresponding wrapper class for deciding
      assignability and compatibility. Therefore, a type
      <code>T&lt;P1..Pn&gt;</code> (target) is <emphasis>assignable</emphasis>
      from an object <code>s</code> of type <code>S</code> (source) when the
      following is true:</para>

      <itemizedlist>
        <listitem>
          <para><code>n == 0, and</code></para>
        </listitem>

        <listitem>
          <para><code>T.isAssignableFrom(S)</code></para>
        </listitem>
      </itemizedlist>

      <para><code>T&lt;P1..Pn&gt;</code>is <emphasis>compatible</emphasis>
      with an object <code>s</code> of type <code>S</code> when it is
      assignable or it can be converted using the Blueprint built-in type
      converter. The convertability must be verified with the
      <code>canConvert(s,T&lt;P1..Pn&gt;)</code> method. That is, type
      compatibility is defined as:</para>

      <itemizedlist>
        <listitem>
          <para><code>assignable(T&lt;P1..Pn&gt;,S), and</code></para>
        </listitem>

        <listitem>
          <para><code>cs.canConvert(s,T&lt;P1..Pn&gt;)</code> returns
          <code>true</code></para>
        </listitem>
      </itemizedlist>

      <para>Where <code>cs</code> is the Blueprint built in type converter
      that also uses the custom type converters.</para>
    </section>

    <section xml:id="i1864218">
      <title>Type Conversion</title>

      <para>Strings in Blueprint definitions, object values, and component
      instances must be made compatible with the type expected by an injection
      target (method or constructor argument, or property) before being
      injected, which can require <emphasis>type conversion</emphasis>. The
      Blueprint Container supports a number of built-in type conversions, and
      provides an extension mechanism for configuring additional type
      converters. Custom type converters have priority over built-in
      converters.</para>

      <para>The goal of the type conversion is to convert a source object
      <code>s</code> with type <code>S</code> to a target type
      <code>T&lt;P1..Pn&gt;</code>. The conversion of the Blueprint built-in
      type converter must take place in the following order:</para>

      <orderedlist>
        <listitem>
          <para>If <code>T&lt;P1..Pn&gt;</code> is assignable from
          <code>S</code>, which implies n=0, then no conversion is necessary,
          except that primitives must be converted to their wrapper
          types.</para>
        </listitem>

        <listitem>
          <para>Try all type converters in declaration order with the
          <code>canConvert(s,T&lt;P1..Pn&gt;)</code> method, exceptions are
          ignored and logged. The first converter that returns
          <code>true</code> is considered the converter, its result is
          obtained by calling <code>convert(s,T&lt;P1..Pn&gt;)</code>.
          Exceptions in this method must be treated as an error.</para>
        </listitem>

        <listitem>
          <para>If <code>T</code> is an array, then <code>S</code> must be an
          array or it must implement <code>Collection</code>, otherwise the
          conversion fails. Each member of array <code>s</code> must be type
          converted to the component type of <code>T</code> using the generics
          information if available, see the <code>getComponentType</code>
          method on <code>Class</code>. This is a recursive process. The
          result must be stored in an array of type <code>T</code>.</para>
        </listitem>

        <listitem>
          <para>If <code>T</code> implements <code>Collection</code>, then
          <code>S</code> must be an array or implement
          <code>Collection</code>, otherwise the conversion fails. If the
          platform supports generics, the members of object <code>s</code>
          must be converted to the member type of the collection if this is
          available from the generics information, or to <code>Object</code>
          otherwise. The Blueprint Container must create a target collection
          and add all members of <code>s</code> to this new object in the
          iteration order of <code>s</code>. The target collection depends on
          type <code>T</code>:</para>

          <itemizedlist>
            <listitem>
              <para>If <code>T</code> is one of the interfaces listed in <xref
              linkend="i2779480"/>, then the target
              collection must be the corresponding concrete class.</para>
            </listitem>

            <listitem>
              <para><code>T</code> must represent a public concrete class with
              an empty publicly accessible constructor, the target collection
              is then a new instance of <code>T</code>.</para>
            </listitem>

            <listitem>
              <para>Otherwise <code>T</code> represents an interface and the
              conversion must fail.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If <code>T</code> implements <code>Map</code> or extends
          <code>Dictionary</code>, then <code>S</code> must implement
          <code>Map</code> or extend <code>Dictionary</code> as well,
          otherwise the conversion fails. If the platform supports generics,
          the members of map <code>s</code> must be converted to the key and
          value type of the target map. This is a recursive process. Without
          generics, the members are not converted and put as is.</para>

          <para>The target map depends on T:</para>

          <itemizedlist>
            <listitem>
              <para>If <code>T</code> is a public concrete class (not
              interface) with an empty publicly accessible constructor then
              the target map must be a new instance of <code>T</code>.</para>
            </listitem>

            <listitem>
              <para>If <code>T</code> is one of the <code>Map</code>
              interfaces or <code>Dictionary</code> listed in <xref
              linkend="i2779480"/>, then the target
              map must be the corresponding concrete class.</para>
            </listitem>

            <listitem>
              <para>Otherwise, the conversion fails.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If <code>T</code> is one of the primitive types (<code>byte,
          char, short, int, long, float, double, boolean</code>) then treat
          <code>T</code> as the corresponding wrapper class.</para>
        </listitem>

        <listitem>
          <para>If <code>T</code> extends class <code>Number</code> and
          <code>S</code> extends also class <code>Number</code> then convert
          the source to a number of type <code>T</code>. If the target type
          cannot hold the value then the conversion fails. However, precision
          may be lost if a <code>double</code> or <code>float</code> is
          converted to one of the integer types.</para>
        </listitem>

        <listitem>
          <para>If source type <code>S</code> is not class
          <code>String</code>, then the conversion fails.</para>
        </listitem>

        <listitem>
          <para>The conversion is attempted based on the target type
          <code>T</code> from the string <code>s</code>. The following target
          types are supported:</para>

          <itemizedlist>
            <listitem>
              <para><code>boolean</code> or <code>Boolean</code> – Construct
              the appropriate boolean type while accepting the following
              additional values for <code>true</code> and <code>false</code>
              respectively:</para>

              <itemizedlist>
                <listitem>
                  <para><code>yes</code>, <code>no</code></para>
                </listitem>

                <listitem>
                  <para><code>on</code>, <code>off</code></para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><code>Character</code> – The string <code>s</code> must
              have a length of 1, this single character is then converted to a
              <code>Character</code> object.</para>
            </listitem>

            <listitem>
              <para><code>Locale</code> – The string <code>s</code> is
              converted to a <code>Locale</code> using the following syntax
              (no spaces are allowed between terms).</para>

              <programlisting>locale  ::= &lt;java language-code&gt; ( ’_’ country)+
country ::= &lt;java country-code&gt; (’_’ &lt;java variant-code&gt;)+</programlisting>
            </listitem>
          </itemizedlist>

          <itemizedlist>
            <listitem>
              <para><code>Pattern</code> – Create the <code>Pattern</code>
              object with <code>Pattern.compile(String)</code>.</para>
            </listitem>

            <listitem>
              <para><code>Properties</code> – Create a new
              <code>Properties</code> object and load the properties from the
              string. The string must follow the format described with the
              <code>Properties.load method</code>.</para>
            </listitem>

            <listitem>
              <para><code>Enum</code> <code>subclass</code> – Convert the
              string <code>s</code> to the appropriate member of the given
              enum with the <code>Enum.valueOf</code> method. If the string is
              not one of the enum values, then the conversion must
              fail.</para>
            </listitem>

            <listitem>
              <para><code>Class</code> – The string <code>s</code> must
              conform to the syntax in <xref linkend="i2972566"/>. This type must be loaded through
              the Bundle’s <code>loadClass</code> method. The resulting class
              must match any generic constraints on <code>T</code>. If this
              fails, the conversion fails.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If target type <code>T</code> has a constructor
          <code>(String)</code>, then use this constructor to create an
          instance with the source string <code>s</code>. This convention
          caters for many of the built-in Java types such as
          <code>BigDecimal</code>, <code>BigInteger</code>, <code>File</code>,
          <code>URL</code>, and so on, as well as for custom types.</para>
        </listitem>
      </orderedlist>

      <para>If none of the above steps has found a proper conversion than the
      conversion fails. Failing a conversion must end with throwing an Illegal
      Argument Exception.</para>
    </section>

    <section>
      <title>Type Converters</title>

      <para>A type converter converts a source type to a target type. The
      source type for a type converter is not constrained. A type converter
      must support the following methods:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.Converter.canConvert-Object-ReifiedType-"/>
          – A light weight method that inspects the object and returns
          <code>true</code> if it can convert it to the given Reified Type,
          <code>false</code> otherwise. Converters normally can convert a type
          <code>S</code> to a type <code>T&lt;...&gt;</code>. However,
          converters can convert to multiple types and the value of the source
          object can influence the returned type. For example, a converter
          could convert a string to a type based on its content.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.Converter.convert-Object-ReifiedType-"/>
          – The actual conversion method. This method should not fail if the
          <code>canConvert</code> method has returned
          <code>true</code>.</para>
        </listitem>
      </itemizedlist>

      <para>The <code>ReifiedType</code> class provides access to the target
      class. In a Java 1.4 environment, the <code>ReifiedType</code> object
      will provide a <code>Class</code> object for conversion and no type
      arguments. In a Java 5 environment, the <code>ReifiedType</code> object
      provides access to the reified class as well as the type arguments.
      Generics and reified types are described in <xref linkend="i2814178"/>.</para>

      <para>Type converters are normal managers with some limitations due to
      the dependency handling. If they depend on general managers or services
      then there is a change that cyclic dependencies are created.</para>

      <para>Converters must be defined in the <code>type-converters</code>
      element, see <xref linkend="i2709370"/>, to
      be registered as a converter. Component instances of managers in this
      section must implement the <code>Converter</code> interface. Converters
      must also only transitively depend on built-in converters. It must be
      possible to initialize all converters before any of them are used. Type
      converters should not use the type conversion before all type converters
      are fully configured.</para>

      <para>Converters are ordered within one definition resource but there is
      no resource ordering, so the overall ordering is not defined, making it
      a good practice to concentrate all converters in a single XML
      definition. The definition ordering is used during type conversion. That
      is, converters are not ordered by their specialization, a converter that
      is earlier can convert a more general type will override a converter
      that is later in the list but could have converted to a more specific
      type.</para>

      <para>Converters must always use the type arguments of the given Reified
      Type, even if they are running on Java 1.4. The default behavior of the
      Reified Type will automatically work.</para>

      <para>The following example demonstrates how a converter can use
      generics to use an <code>AtomicReference&lt;T&gt;</code> whenever type T
      is supported. Such a type could be for a property like:</para>

      <programlisting>public void setInteger( AtomicReference&lt;Integer&gt;atomic );</programlisting>

      <para>The Atomic Converter uses the generic argument to convert a source
      object to an Integer and then creates an <code>AtomicReference</code>
      with this converted object. The definition of the type converter looks
      like:</para>

      <programlisting>&lt;type-converters&gt;
  &lt;bean class="AtomicConverter"&gt;
    &lt;argument ref="blueprintConverter"/&gt;
  &lt;/bean&gt;
&lt;/type-converters&gt; </programlisting>

      <para>The Blueprint converter is injected in the constructor of the
      <code>AtomicInteger</code> class, in order to allow the conversion of
      the generic arguments. The Blueprint built-in type converter must not be
      used before all type converters are registered because a needed type
      converter might not have been registered yet. This is the reason type
      converters should not require type conversion in their initialization
      because the state of this converter is not well defined at this
      time.</para>

      <para>The conversion class looks like:</para>

      <programlisting>public class AtomicConverter {
  Converter bpc;
  public AtomicConverter(Converter bpc) { this.bpc=bpc; }

  public boolean canConvert(Object s,ReifiedType T) {
    return T.getRawClass() == AtomicReference.class
    &amp;&amp; bpc.canConvert(s, T.getActualTypeArgument(0));
  }

  public Object convert( Object s, ReifiedType T )
      throws Exception {
    Object obj = bpc.convert(
        s,T.getActualTypeArgument(0) );

     return new AtomicReference&lt;Object&gt;(obj);
  }
}</programlisting>

      <para>Any injection that now targets an
      <code>AtomicReference&lt;T&gt;</code> value will automatically be
      converted into an <code>AtomicReference</code> of the appropriate type
      because of the example converter. The following definitions test this
      behavior:</para>

      <programlisting>public class Foo&lt;T extends Integer&gt; {
  public Foo( AtomicReference&lt;T&gt; v) {}
}

&lt;bean id="foo" class="Foo"&gt; &lt;argument value="6"/&gt; &lt;/bean&gt; </programlisting>

      <para>This definition will create an <code>foo</code> object with the
      <code>Foo(AtomicReference&lt;T&gt;)</code> constructor. The source type
      is a string and there is no assignability for an Atomic Reference, so
      the registered type converters are consulted. The Atomic Converter
      recognizes that the target <code>T</code> is an
      <code>AtomicReference</code> class and indicates it can convert. The
      convert method then uses the generic argument information, which is an
      <code>Integer</code> object in the example, to convert the string "6" to
      an Integer object and return the appropriate
      <code>AtomicReference</code> object.</para>
    </section>

    <section xml:id="i2250799">
      <title>Built-in Converter</title>

      <para>A Blueprint Container must contain an environment manager called
      <code>blueprintConverter</code>. The related component instance must
      implement the <code>Converter</code> interface.</para>

      <para>The built-in Converter provides access to the provided type
      converters as well as the built in types. This service provides the type
      conversion as defined in <xref linkend="i1864218"/>.</para>

      <para>Injecting a reference to the <code>blueprintConverter</code>
      environment manager into a bean provides access to all the type
      conversions that the Blueprint Container and registered type converters
      are able to perform. However, if this converter is injected in a type
      converter, then by definition, not all custom type converters are yet
      registered with the built-in converter. Type converters should therefore
      in general not rely on type conversion during their construction.</para>
    </section>

    <section xml:id="i2779480">
      <title>Concrete Types for Interfaces</title>

      <para>The Blueprint extender can choose an implementation class when it
      provides an instance during conversion to an interface as well as when
      it natively provides an object. The actual implementation class can make
      a noticeable difference in disambiguation, type conversion, and general
      behavior. Therefore this sections describe the concrete types an
      implementation must use for specific interfaces if the platform allows
      this.</para>

      <table>
        <title>Implementation types for interfaces</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="3*"/>

          <colspec colnum="3" colwidth="3*"/>

          <thead>
            <row>
              <entry><para/></entry>

              <entry>Interface/Abstract class</entry>

              <entry>Implementation class</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para/></entry>

              <entry><para><code>Collection</code></para></entry>

              <entry><para><code>ArrayList</code></para></entry>
            </row>

            <row>
              <entry><para/></entry>

              <entry><para><code>List</code></para></entry>

              <entry><para><code>ArrayList</code></para></entry>
            </row>

            <row>
              <entry><para>Java 5</para></entry>

              <entry><para><code>Queue</code></para></entry>

              <entry><para><code>LinkedList</code></para></entry>
            </row>

            <row>
              <entry><para/></entry>

              <entry><para><code>Set</code></para></entry>

              <entry><para><code>LinkedHashSet</code></para></entry>
            </row>

            <row>
              <entry><para/></entry>

              <entry><para><code>SortedSet</code></para></entry>

              <entry><para><code>TreeSet</code></para></entry>
            </row>

            <row>
              <entry><para/></entry>

              <entry><para><code>Map</code></para></entry>

              <entry><para><code>LinkedHashMap</code></para></entry>
            </row>

            <row>
              <entry><para/></entry>

              <entry><para><code>SortedMap</code></para></entry>

              <entry><para><code>TreeMap</code></para></entry>
            </row>

            <row>
              <entry><para>Java 5</para></entry>

              <entry><para><code>ConcurrentMap</code></para></entry>

              <entry><para><code>ConcurrentHashMap</code></para></entry>
            </row>

            <row>
              <entry><para/></entry>

              <entry><para><code>Dictionary</code></para></entry>

              <entry><para><code>Hashtable</code></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If possible, the instances of these types must preserve the
      definition ordering.</para>
    </section>

    <section xml:id="i2814178">
      <title>Generics</title>

      <para>Java 5 introduced the concept of <emphasis>generics</emphasis>.
      Before Java 5, a <emphasis>type</emphasis>, was simply a class or
      interface, both represented by the <code>Class</code> object. Generics
      augment these classes and interfaces with additional <emphasis>type
      constraints</emphasis>. These type constraints are not available on an
      instance because an instance always references a raw <code>Class</code>.
      For an instance all generic type constraints are
      <emphasis>erased</emphasis>. That is, a <code>List&lt;Integer&gt;</code>
      object is indistinguishable from a <code>List&lt;String&gt;</code>
      object, which are indistinguishable from a <code>List</code> object.
      Objects always refer to a raw <code>Class</code> object, this is the one
      returned from the <code>getClass</code> method. This Class object is
      shared between all instances and can therefore not have the actual type
      constraints (like <code>String</code>, <code>Integer</code> in the list
      examples).</para>

      <para>When a class is used the compiler captures the type constraints
      and associates them with the specific use and encodes them in a
      <code>Type</code> object. For example, a field declaration captures the
      full generic type information:</para>

      <programlisting>List&lt;String&gt; strings;</programlisting>

      <para>A field has a <code>getGenericType</code> method that provides
      access to a <code>Type</code> object, which is a super interface for all
      type information in the Java 5 and later runtime. In the previous
      example, this would be a Parameterized Type that has a raw class of
      <code>List</code> and a type argument that is the <code>String</code>
      class. These constraints are reflectively available for:</para>

      <itemizedlist>
        <listitem>
          <para>A superclass</para>
        </listitem>

        <listitem>
          <para>Implemented interfaces</para>
        </listitem>

        <listitem>
          <para>Fields</para>
        </listitem>

        <listitem>
          <para>For each method or constructor:</para>

          <itemizedlist>
            <listitem>
              <para>Return type</para>
            </listitem>

            <listitem>
              <para>Exception types</para>
            </listitem>

            <listitem>
              <para>Parameter types</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Generics influence the type conversion rules because most of the
      time the Blueprint extender knows the actual <code>Type</code> object
      for an injection. Therefore, conversion must take place to a type like
      <code>T&lt;P1..Pn&gt;</code>, where T is a raw Class object and
      <code>P1..Pn</code> form the available type parameters. For a
      non-parametrized class and for other VMs than 1.4, <code>n</code> is
      always zero, that is no type arguments are available. The <code>P</code>
      arguments are in itself instances of <code>Type</code>. The form
      <code>T&lt;P1..Pn&gt;</code> is called the <emphasis>reified</emphasis>
      form. It can be constructed by traversing the <code>Type</code> graph
      and calculating a class that matches the constraints. For example
      <code>&lt; extends List&lt;T&gt;&gt;</code> defines a <emphasis>wild
      card</emphasis> constraint, that has a <code>List&lt;T&gt;</code> as
      reified type, where <code>T</code> is a Type Variable defined elsewhere
      that can have additional constraints. The resulting type must be an
      instance of <code>List&lt;T&gt;</code>. A reified type will use an
      object implementing <code>List</code> for such an example because that
      is the only class that is guaranteed to be compatible. The rules to
      reify the different <code>Type</code> interfaces are:</para>

      <itemizedlist>
        <listitem>
          <para><code>Class</code> – A Class represents unparameterized raw
          type and is reified into T&lt;&gt;. For example:</para>

          <programlisting>String string;</programlisting>
        </listitem>

        <listitem>
          <para><code>ParameterizedType</code> – A Parameterized Type defines
          a raw type and 1..n typed parameters. The raw type of the
          Parameterized Type is also reified and represents <code>T</code>.
          The arguments map directly to the arguments of the reified form. An
          example of a Parameterized Type is:</para>

          <programlisting>Map&lt;String,Object&gt; map;</programlisting>
        </listitem>

        <listitem>
          <para><code>TypeVariable</code> – Represents a Type Variable. A type
          variable is listed in a generics type declaration, for example in
          <code>Map&lt;K,V&gt;</code>, the <code>K</code> and <code>V</code>
          are the type variables. A type variable is bounded by a number of
          types because it is possible to declare a bounded type like:
          <code>&lt;A extends Readable&amp;Closeable&gt;</code>. A Type
          Variable is reified by taking its first bound in reified form, this
          is the same as in Java 5 where the first bounds is the erasure type.
          However, this can fail if multiple bounds are present. An example of
          a Type Variable is:</para>

          <programlisting>public &lt;T extends ServiceTracker&gt; void setMap(T st) {} </programlisting>

          <para>In this example, the parameter <code>st</code> will have a
          reified type of <code>ServiceTracker</code>.</para>
        </listitem>

        <listitem>
          <para><code>WildcardType</code> – A Wildcard Type constrains a type
          to a set of lower bounds and a set of upper bounds, at least in the
          reflective API. In the Java 5 and later syntax a Wildcard Type can
          only specify 0 or one lower and one upper bound, for example
          <code>&lt;T extends Number&gt;</code> constraints the Type Variable
          <code>T</code> to at least extend the <code>Number</code> class. A
          Wildcard Type is reified into its reified upper bound when no lower
          bound is set, and otherwise it is reified into its reified lower
          bound. An example of a Wildcard Type is seen in the example of a
          Type Variable.</para>
        </listitem>

        <listitem>
          <para><code>GenericArrayType</code> – A Generic Array Type
          represents an array. Its component type is reified and then
          converted to an array. The Reified Type will have the array class as
          reified class and the type arguments reflect the type arguments of
          the component type. For example:</para>

          <programlisting>public void setLists(List&lt;String&gt;[] lists) {}</programlisting>

          <para>This example will have a Reified Type of
          <code>List[]&lt;String&gt;</code>.</para>
        </listitem>
      </itemizedlist>

      <para>This specification is written to allow Java 1.4 implementations
      and clients, the API therefore has no generics. Therefore, the Type
      class in Java 5 and later cannot be used in the API. However, even if it
      could use the <code>Type</code> class, using the type classes to create
      the reified form is non-trivial and error prone. The API therefore
      provides a concrete class that gives convenient access to the reified
      form without requiring the usage of the <code>Type</code> class.</para>

      <para>The <code>ReifiedType</code> class provides access to the reified
      form of <code>Class</code>, which is itself and has no type arguments.
      However, Blueprint extender implementations that recognize Java 5
      generics should subclass the <code>ReifiedType</code> class and use this
      in the conversion process. The subclass can calculate the reified form
      of any <code>Type</code> subclasses.</para>
    </section>
  </section>

  <section xml:id="i1766539">
    <title>Service Dynamics</title>

    <para>The Blueprint Container specification handles the complexities of
    the dynamic nature of OSGi by <emphasis>hiding</emphasis> the dynamic
    behavior of the OSGi service registry, at least temporarily. This dynamic
    behavior is caused by service references that select one or more services
    that can come and go at runtime.</para>

    <para>The Blueprint Container must handle the dynamics in the following
    way:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Proxied references</emphasis> – Service reference
        managers must provide a proxy implementing the specified interfaces,
        instead of the actual service object it refers to. The proxy must
        fetch the real service lazily. For reference managers, when a proxy is
        used, and no candidate is available, a candidate must be found within
        a limited time. If no candidate service is available during this time,
        a Service Unavailable Exception must be thrown. The reference-list
        manager also maintains proxies but these proxies must throw a Service
        Unavailable Exception immediately when the proxy is used and the
        backing service is no longer available.</para>

        <para>When proxied references are used with stateful services, then
        the application code must register a reference listener to perform the
        necessary initialization and cleanup when a new backing service is
        bound.</para>
      </listitem>

      <listitem>
        <para><emphasis>Conditional Service Registrations</emphasis> – The
        service manager is responsible for registering a service with the OSGi
        service registry. A service manager is statically dependent on the
        transitive set of managers that it depends on. If these static
        dependencies contain mandatory service references, then the manager’s
        service must not be registered when any of these mandatory service
        references is unsatisfied, see <xref linkend="i2630717"/>.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="i2630744">
      <title>Damping</title>

      <para>When an operation is invoked on an unsatisfied proxy from a
      reference manager (either optional or mandatory), the invocation must
      block until either the reference becomes satisfied or a time-out expires
      (whichever comes first). During this wait, a <code>WAITING</code> event
      must be broadcast, see <xref linkend="i2148562"/>.</para>

      <para>The default <code>timeout</code> for service invocations is 5
      minutes. The optional <code>timeout</code> of the reference element
      specifies an alternate <code>timeout</code> (in milliseconds). If no
      matching service becomes available within the <code>timeout</code>, then
      a Service Unavailable Exception must be thrown. A <code>timeout</code>
      of zero means infinite and a negative <code>timeout</code> is an
      error.</para>

      <para>For example:</para>

      <programlisting>&lt;reference id="logService"
        interface="org.osgi.service.log.LogService" 
      timeout="100000" /&gt;

&lt;bean id="bar" class="BarImpl"&gt;
  &lt;property name="log" ref="logService"/&gt;           
&lt;/bean&gt;</programlisting>

      <para>When this Blueprint Container is instantiated, the reference
      manager provides a proxy for the Log Service, which gets injected in the
      <code>log</code> property. If no Log Service is available, then the
      proxy will have no backing service. If the <code>bar</code> object
      attempts to log, it will block and if the <code>timeout</code> expires
      the proxy must throw a Service Unavailable Exception.</para>

      <para>If at some later point in time, a Log Service is registered then
      it becomes satisfied again. If <code>bar</code> now logs a message, the
      proxy will get the service object again and forward the method
      invocation to the actual Log Service implementation.</para>

      <para>The damping ensures that a mandatory service reference that
      becomes unsatisfied does not cause the Blueprint Container to be
      destroyed. Temporary absences of mandatory services are tolerated to
      allow for administrative operations and continuous operation of as much
      of the system as possible.</para>

      <para>A reference-list manager does not provide damping. It only removes
      the service proxy from the collection if its service goes away. Using a
      collection reference manager will never block, it will just have no
      members if its selection is empty. A <code>timeout</code> attribute is
      therefore not supported by the <code>reference-list</code> elements.
      However, the elements are proxied and it is possible that they throw a
      Service Unavailable Exception when used and the backing service has
      disappeared. The exceptions for a reference-list proxy will be thrown
      immediately when the proxy is used.</para>
    </section>

    <section>
      <title>Iteration</title>

      <para>The provided object of a reference-list manager implements the
      <code>List</code> interface. Depending on the <code>memberType</code> or
      the optional generics information, it provides a collection that
      contains the member objects, that is, either proxies to the service
      object, or <code>ServiceReference</code> objects. These collections are
      read-only for the receiver, however, their contents can dynamically
      change due to changes in the selection. The access to these collections
      with iterators must give a number of guarantees:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Safe</emphasis> – All iterators of reference-list
          managers must be safe to traverse according to the
          <code>Iterator</code> interface contract, even while the underlying
          collection is being modified locally or in another thread. If the
          <code>hasNext</code> method returns <code>true</code>, the iterator
          must return a member object on the subsequent <code>next</code>
          method invocation. If there is no longer a service object available
          when requested, then a dummy proxy must be returned that throws a
          Service Unavailable Exception whenever it is used.</para>
        </listitem>

        <listitem>
          <para><emphasis>Visibility</emphasis> – All the changes made to the
          collection that affect member objects not yet returned by the
          iterator must be visible in the iteration. Proxies for new services
          must be added at the end of the List. Proxies already returned can
          be affected by changes in the service registry after the iterator
          has returned them.</para>
        </listitem>
      </itemizedlist>

      <para>After the iterator has returned <code>false</code> for the
      <code>hasNext</code> method, no more objects can be obtained from it. A
      List Iterator must not be supported.</para>
    </section>

    <section xml:id="i2416456">
      <title>Mandatory Dependencies</title>

      <para>A service manager can have mandatory service reference managers in
      its transitive dependencies. Such a service manager must ensure that the
      service object is registered with the OSGi service registry during the
      runtime phase when all its mandatory service references that it depends
      on are satisfied. This called <emphasis>tracking</emphasis> the
      dependency. A service manager is <emphasis>enabled</emphasis> when all
      its mandatory references in its dependencies are satisfied.</para>

      <para>This tracking only works for dependencies declared directly in the
      definitions; dependencies established during runtime by calling the
      <code>getComponentInstance</code> method are not tracked.</para>

      <para>In the following example, service manager <code>S</code> has a
      transitive dependency on the mandatory reference manager <code>M</code>,
      which means the Blueprint Container must ensure that the service object
      provided by bean <code>A</code> is registered when reference manager
      <code>M</code> is satisfied.</para>

      <programlisting>&lt;service id="S" ref="A" interface="com.acme.Foo"/&gt;
&lt;bean id="A" class="com.acme.FooImpl"&gt;
   &lt;property name="bar" ref="m"/&gt;
&lt;/bean&gt; 
&lt;reference id="M" interface="com.acme.Bar"
     availability="mandatory"/&gt;</programlisting>

      <para>However, if the dependency from manager <code>A</code> on manager
      <code>M</code> is not declared but created through code that manipulates
      the Blueprint Container then the dependency is not tracked.</para>
    </section>
  </section>

  <section xml:id="i2088582">
    <title>Blueprint Container</title>

    <para>The Blueprint Container has a registry where all top-level managers,
    as well as <emphasis>environment</emphasis> managers, are registered by
    their component id. The Blueprint Container can be injected in application
    code with the environment <code>blueprintContainer</code> manager. For
    example:</para>

    <programlisting>&lt;bean class="com.acme.FooImpl"&gt;
    &lt;property name="container" ref="blueprintContainer"/&gt;
&lt;/bean&gt;</programlisting>

    <para>The Blueprint Container allows application code to get objects that
    are provided by the top-level managers through the
    <code>getComponentInstance</code> method. However, the Blueprint Container
    should not be required to get a component instance; the proper way to use
    Blueprint is to inject them. This declarative approach makes the Blueprint
    Container aware of any dependencies; one of the primary goals of a
    dependency injection framework. The Blueprint Container’s introspective
    features are commonly used for management and other non-application
    purposes.</para>

    <para>The Blueprint Container is registered as a service during the
    runtime phase so that other bundles can use it for these, and other,
    purposes.</para>

    <section>
      <title>Environment Managers</title>

      <para>The Blueprint Container provides a number of <emphasis>environment
      managers</emphasis>. These managers have defined names and provide
      convenient access to information about the environment. Environment
      managers cannot be overridden by explicitly defined managers because it
      is invalid to define a manager with an existing component id. All
      component ids starting with <code>blueprint</code> are reserved for this
      specification and future incarnations.</para>

      <para>There is no XML definition for environment managers but their
      Metadata must be provided as <code>ComponentMetadata</code>
      objects.</para>

      <para>The following ids are used for the environment managers:</para>

      <itemizedlist>
        <listitem>
          <para><code>blueprintContainer</code> – The Blueprint
          Container.</para>
        </listitem>

        <listitem>
          <para><code>blueprintBundle</code> – A manager that provides the
          Blueprint bundle’s <code>Bundle</code> object.</para>
        </listitem>

        <listitem>
          <para><code>blueprintBundleContext –</code> A manager that provides
          the Blueprint bundle’s <code>BundleContext</code> object.</para>
        </listitem>

        <listitem>
          <para><code>blueprintConverter</code> – A manager that provides an
          object implementing the <code>Converter</code> interface. This
          represents the built-in conversion facility that the Blueprint
          Container uses to convert objects. See <xref linkend="i2250799"/>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Component Instances</title>

      <para>The Blueprint Container provides access to the component instances
      that the top level managers can provide, as well as their Metadata. The
      Blueprint Container has the following methods for requesting a component
      instance and to find out what managers are available:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintContainer.getComponentInstance-String-"/>
          – This method will provide a component instance from the component
          id. If the manager has not been activated yet, it must atomically
          activate and ensure its explicit and implicit dependencies are
          activated transitively.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintContainer.getComponentIds--"/>
          – Returns a set of component ids in this Blueprint Container. These
          ids must consist of all top level managers (including calculated
          ids) and environment managers.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Access to Component Metadata</title>

      <para>Each of the manager types has specific Component Metadata subtypes
      associated with it, except Environment managers that use Component
      Metadata. The Blueprint Container provides access by component id to the
      Component Metadata of the top level managers. However, managers can also
      be defined inline, in which case they do not have a component id.
      Therefore, the Blueprint Container can also enumerate all the managers
      that are represented by a <code>Metadata</code> sub-interface.</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintContainer.getComponentMetadata-String-"/>
          – Answer the Component Metadata sub-type for the given component id.
          Environment managers will return a <code>ComponentMetadata</code>
          object, the other managers each have their own specific Metadata
          type.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintContainer.getMetadata-Class-"/>
          – Answer a collection with the Metadata of the given type,
          regardless if it is defined as/in a top-level or inlined manager.
          For example, <code>getMetadata(ServiceMetadata.class)</code> returns
          all Service Metadata in the Blueprint container. This includes all
          top level managers as well as any inlined managers. For Environment
          Managers, this method returns a <code>ComponentMetadata</code>
          object.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Concurrency</title>

      <para>A Blueprint Container must be thread safe. Each method must handle
      the case when multiple threads access the underlying registry of
      managers. Activation of managers must be atomic. That is, other threads
      must be blocked until a manager is completely activated.</para>

      <para>The Blueprint Container must handle reentrant calls.</para>
    </section>
  </section>

  <section xml:id="i2148562">
    <title>Events</title>

    <para>The Blueprint Container must track all Blueprint Listener services
    and keep these listeners updated of the progress or failure of all its
    managed bundles. The Blueprint Listener is kept informed by sending it
    events synchronously. These events are therefore normally delivered in
    order but in exceptional cases this can be seen out of order for a
    listener when new events are initiated synchronously from within a
    callback. Therefore, Blueprint Listener services should see the event as a
    notification, where actual work should be processed on another
    thread.</para>

    <para>Blueprint Events must be sent to each registered Blueprint Listener
    service. This service has the following method:</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.service.blueprint.container.BlueprintListener.blueprintEvent-BlueprintEvent-"/>
        – Notify the listener of a new Blueprint Event. These events are send
        synchronously with their cause. That is, all listeners must be
        notified before the Blueprint Container continues to the next
        step.</para>
      </listitem>
    </itemizedlist>

    <para>The events must be delivered as <code>BlueprintEvent</code> objects.
    The event types that they represent, and the data that these objects
    carry, is further described in <xref linkend="i2951918"/>.</para>

    <para>A Blueprint Listener services must be given the initial state of all
    managed bundles before normal processing starts, see <xref
    linkend="i2680219"/>.</para>

    <para>Blueprint Listener services that throw Exceptions or do not return
    in a reasonable time as judged by the Blueprint extender implementation,
    should be logged, if possible, and further ignored.</para>

    <section xml:id="i2951918">
      <title>Blueprint Event</title>

      <para>The Blueprint Event supports the following event types:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.CREATING"/>
          – The Blueprint extender has started creating a Blueprint Container
          for the bundle.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.GRACE_PERIOD"/>
          – The Blueprint Container enters the grace period. This event can be
          repeated multiple times when the list of dependencies changes due to
          changes in the service registry.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.CREATED"/>
          – The Blueprint Container is ready. The application is now
          running.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.WAITING"/>
          – A service reference is blocking because of unsatisfied mandatory
          dependencies. This event can happen multiple times in a row.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.DESTROYING"/>
          – The Blueprint Container is being destroyed because the Blueprint
          bundle or Blueprint extender has stopped.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.DESTROYED"/>
          – The Blueprint Container is completely destroyed.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.FAILURE"/>
          – An error occurred during the creation of the Blueprint
          Container.</para>
        </listitem>
      </itemizedlist>

      <para>The Blueprint Event provides the following methods:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.getBundle--"/>
          – The Blueprint bundle</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.getCause--"/>
          – Any occurred exception or <code>null</code></para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.getDependencies--"/>
          – A list of filters that specify the unsatisfied mandatory
          references.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.getExtenderBundle--"/>
          – The Blueprint extender bundle.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.getTimestamp--"/>
          – The time the event occurred</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.getType--"/>
          – The type of the event.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.BlueprintEvent.isReplay--"/>
          – Indicates if the event is a replay (<code>true</code>) or if it is
          a new event (<code>false</code>), see <xref linkend="i2680219"/>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i2680219">
      <title>Replay</title>

      <para>The Blueprint Extender must remember the last Blueprint Event for
      each ready bundle that it manages, see <xref linkend="i2959082"/>. During the (synchronous) service
      registration event of a Blueprint Listener service, the Blueprint
      extender must inform the Blueprint Listener service about all its
      managed bundles by sending it the last known event for each bundle the
      Blueprint extender manages. This initial event is called the
      <emphasis>replay</emphasis> event, and is marked as such.</para>

      <para>The replay event must be delivered to the Blueprint Listener
      service as the first event, before any other event is delivered, during
      the registration of the Blueprint Listener service. That is, the
      <code>blueprintEvent</code> method must have returned before the first
      non-replay event can be delivered and no events must be lost. The replay
      events must be sent every time a Blueprint Listener service is
      registered.</para>

      <para>The set of managed bundles is defined by bundles that are active
      and are managed by the Blueprint extender, even if their initialization
      ended in failure.</para>

      <para>The <code>BlueprintEvent</code> object for a replay event must
      return <code>true</code> for the <xref
      linkend="org.osgi.service.blueprint.container.BlueprintEvent.isReplay--"/>
      method in this situation, and <code>false</code> in all other
      situations.</para>
    </section>

    <section>
      <title>Event Admin Mapping</title>

      <para>When the Event Admin service is present, the Blueprint extender
      must create an Event Admin event for each defined Blueprint Event. This
      Event Admin event must be asynchronously given to the Event Admin
      service with the <code>postEvent</code> method.</para>

      <para>The topic of the Event Admin event is derived from the Blueprint
      event type with a fixed prefix. All topics must have the prefix
      of:</para>

      <programlisting><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.TOPIC_BLUEPRINT_EVENTS"/></programlisting>

      <para>After this prefix, the name of the Blueprint Event type must be
      used as the suffix. That is, <code>CREATING</code>,
      <code>GRACE_PERIOD</code>, etc. For example,
      <code>org/osgi/service/blueprint/container/GRACE_PERIOD</code>.</para>

      <para>For each Blueprint event the following properties must be
      included:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.TYPE"/>
          – The type of the Event, see <xref linkend="i2951918"/>.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.BUNDLE"/>
          – (<code>Bundle</code>) The <code>Bundle</code> object of the
          Blueprint bundle</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.BUNDLE_ID"/>
          – (<code>Long</code>) The id of the Blueprint bundle.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.BUNDLE_SYMBOLICNAME"/>
          – (<code>String</code>) The Bundle Symbolic Name of the Blueprint
          bundle.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.BUNDLE_VERSION"/>
          - (<code>Version</code>) The version of the Blueprint bundle.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.EXTENDER_BUNDLE"/>
          – (<code>Bundle</code>) the <code>Bundle</code> object of the
          Blueprint extender bundle.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.EXTENDER_BUNDLE_ID"/>
          – (<code>Long</code>) The id of the Blueprint extender bundle</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.EXTENDER_BUNDLE_SYMBOLICNAME"/>
          – (<code>String</code>) The Bundle Symbolic Name of the Blueprint
          extender bundle.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.EXTENDER_BUNDLE_VERSION"/>
          – (<code>Version</code>) The version of the Blueprint extender
          bundle</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.TIMESTAMP"/>
          – (<code>Long</code>) The time when the event occurred</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.CAUSE"/>
          – (<code>Throwable</code>) The failure cause, only included for a
          <code>FAILURE</code> event.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.DEPENDENCIES"/>
          – (<code>String[]</code>) The filter of an unsatisfied service
          reference. Can only appear in a <code>GRACE_PERIOD</code>,
          <code>WAITING</code> or <code>FAILURE</code> event caused by a
          time-out.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.blueprint.container.EventConstants.EVENT"/>
          – (<code>BlueprintEvent</code>) The <code>BlueprintEvent</code>
          object that caused this event.</para>
        </listitem>
      </itemizedlist>

      <para>The property names for Blueprint Listener events may be
      conveniently referenced using the constants defined in the
      <code>org.osgi.service.event.EventConstants</code> and
      <code>EventConstants</code> interfaces.</para>

      <para>The Event Admin events do not follow the replay model in use for
      Blueprint Listener services. That is, the Event Admin must only be kept
      informed about events as they occur.</para>
    </section>
  </section>

  <section xml:id="i2304671">
    <title>Class Loading</title>

    <para>The module layer in OSGi provides advanced class loading rules that
    potentially can cause bundles to live in different class spaces. This
    means that not all bundles can collaborate because the classes involved in
    the collaboration can come from different class loaders, which results in
    confusing Class Cast Exceptions on classes with the same name. It is
    therefore crucial that the Blueprint Container uses the Bundle Context and
    the bundle class loader of the Blueprint bundle for all actions that are
    made on behalf of the Blueprint bundle. Especially, access to the OSGi
    service registry must use the Bundle Context of the Blueprint bundle. Any
    dynamic class loading must use the Blueprint bundle’s
    <code>loadClass</code> method. The normal OSGi mechanics will then ensure
    class space consistency for resolved bundles.</para>

    <section>
      <title>Blueprint Extender and Bundle Compatibility</title>

      <para>For many Blueprint bundles, there is no class space compatibility
      issue. These bundles do not use any Blueprint classes and are therefore
      by definition compatible with any extender. However, if the Blueprint
      bundle uses some of the Blueprint packages, it must import these
      packages. Blueprint Containers must verify that they are <emphasis>type
      compatible</emphasis> with the Blueprint bundle before they attempt to
      manage it. See <xref linkend="i2455588"/>.</para>
    </section>

    <section>
      <title>XML and Class Loading</title>

      <para>The Blueprint definition resources contain textual references to
      classes. These textual references will be loaded with the class loader
      of the Blueprint bundle. This implies that all the classes of provided
      component instances must be either imported or available from the
      bundle.</para>

      <para>The Blueprint specification has the following attributes and
      elements that can cause imports:</para>

      <itemizedlist>
        <listitem>
          <para><code>class</code></para>
        </listitem>

        <listitem>
          <para><code>value-type</code></para>
        </listitem>

        <listitem>
          <para>interface</para>
        </listitem>

        <listitem>
          <para>interfaces</para>
        </listitem>

        <listitem>
          <para>type</para>
        </listitem>

        <listitem>
          <para>key-type</para>
        </listitem>
      </itemizedlist>

      <para>All these attributes and elements are defined with the
      <code>Tclass</code> and <code>Ttype</code> XML Schema type for the
      Blueprint namespace. The <code>Tclass</code> defines simple class names,
      and <code>Ttype</code> defines types defined in <xref linkend="i2972566"/>.</para>
    </section>

    <section>
      <title>Foreign Bundle Context</title>

      <para>When using the Blueprint Container in its Blueprint bundle, the
      types that the managers provide are guaranteed to be compatible with the
      caller.</para>

      <para>When using a Blueprint Container service in another bundle (for
      example, getting it as a service) then there is no guarantee of type
      compatibility or even visibility between the versions of the types of
      the returned managers, and the versions of the types visible to the
      caller. Care must therefore be taken when casting the return value of
      the <code>getComponentInstance</code> method to a more specific
      type.</para>
    </section>

    <section>
      <title>Converters and Class Loading</title>

      <para>A converter is closely coupled to its target class. If the
      converter comes from another bundle, then the converter bundle must
      ensure class space consistency between the converter implementation and
      the target class. This can be achieved by specifying the target class in
      the <code>uses</code> directive.</para>

      <para>For example:</para>

      <programlisting>Export-Package:  
     com.converters.ac;uses:="com.converters.dc"</programlisting>

      <para>A bundle that references a type converter defined in the Blueprint
      bundle does not need to export that type. When creating a Blueprint
      Container, the extender bundle uses the class loader of the Blueprint
      bundle.</para>
    </section>

    <section xml:id="i2455588">
      <title>Type Compatibility</title>

      <para>Two bundles are type compatible for a given class if they both
      load the same class object, or if either bundle cannot load the given
      class.</para>

      <para>To mitigate type incompatibility problems, a Blueprint extender
      must export the <code>org.osgi.service.blueprint</code> package. In the
      <code>uses:</code> directive, it should list any packages of classes
      that can be shared between the Blueprint extender and the Blueprint
      bundle. Blueprint bundles should import this package.</para>
    </section>

    <section>
      <title>Visibility and Accessibility</title>

      <para>The Blueprint Container must load any classes it needs through the
      Blueprint bundle’s <code>loadClass</code> method. If a class can not be
      loaded, then the initialization fails. Class loading issues are further
      discussed in <xref linkend="i2304671"/>.</para>

      <para>The Blueprint Container must respect the accessibility of the
      class and any of its members. That is, the Blueprint Container must not
      use the <code>setAccessibility</code> method. All classes and reflected
      members must therefore be declared <code>public</code> or be implicitly
      <code>public</code> like the default constructor.</para>
    </section>
  </section>

  <section xml:id="i2373727">
    <title>Metadata</title>

    <para>An important aspect of the Blueprint specification is the so called
    <emphasis>metadata</emphasis> interfaces. These interfaces are used in the
    Blueprint Container to enable programmatic access to the XML definitions.
    During the parsing phase the Blueprint Container reads the XML and
    converts it to an object implementing the appropriate interface.</para>

    <para>The XML elements and XML Schema types map to the
    <code>Metadata</code> interfaces. For example, <code>&lt;bean&gt;</code>
    maps to <code>BeanMetadata</code>. However, in several cases, the
    attributes and/or sub-elements in the <code>Metadata</code> interfaces are
    merged when possible. For example, the <code>interface</code> attribute
    and <code>interfaces</code> element in the service element are merged in
    the <code>ServiceMetadata</code> class’ <code>getInterfaces()</code>
    method.</para>

    <para>The interfaces are arranged in a comprehensive hierarchy that
    reflects their usage and constraints. This hierarchy is depicted in <xref
    linkend="i2709656" xrefstyle="template:Figure %n on page %p"/>.</para>

    <para>The hierarchy can roughly be divided in two parts. The first part is
    the sub-interfaces of the <code>ComponentMetadata</code> interface. These
    interfaces are defining the configuration data of the top-level and
    inlined managers. The manager’s component instance(s) are injected with
    values during runtime. The configuration of how to create a specific value
    is also described with Metadata interfaces. For example, a
    <code>Map</code> object is described with configuration information in the
    <code>MapMetadata</code> interface. The hierarchy makes it clear that
    Component Metadata is also a value that can be injected. Keys in maps or
    properties can not be <code>null</code>. This is the reason the hierarchy
    is split at the top into a <code>null</code> value branch and a branch
    that can only generates non-<code>null</code> values.</para>

    <para>The <code>Target</code> interface describes managers that can be
    used as the target for the reference listener or the registration
    listener, or a ref.</para>

    <figure xml:id="i2709656">
      <title>Metadata Interfaces Hierarchy</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="3.259in"
                     contentwidth="4.972in"
                     fileref="metadata-interfaces-hierarchy.svg"/>
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section xml:id="i2152341">
    <title>Blueprint XML Schema</title>

    <para>The Blueprint schema included in this specification can be found in
    digital form at <xref linkend="i2930811"/>. The
    schema listed here is not annotated, the digital form has
    annotations.</para>

    <programlisting role="pgwide">&lt;xml version="1.0" encoding="UTF-8"&gt;
&lt;xsd:schema 
    xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0" 
    xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
    targetNamespace="http://www.osgi.org/xmlns/blueprint/v1.0.0" 
    elementFormDefault="qualified" 
    attributeFormDefault="unqualified" 
    version="1.0.0"&gt;
   &lt;xsd:complexType name="Tcomponent" abstract="true"&gt;
      &lt;xsd:attribute name="id" type="xsd:ID"/&gt;
      &lt;xsd:attribute name="activation" type="Tactivation"/&gt;
      &lt;xsd:attribute name="depends-on" type="TdependsOn"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:element name="blueprint" type="Tblueprint"/&gt;
   &lt;xsd:complexType name="Tblueprint"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="description" type="Tdescription"minOccurs="0"/&gt;
         &lt;xsd:element name="type-converters" type="Ttype-converters" 
                    minOccurs="0" maxOccurs="1"/&gt;
         &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xsd:element name="service" type="Tservice"/&gt;
            &lt;xsd:element name="reference-list" type="Treference-list"/&gt;
            &lt;xsd:element name="bean" type="Tbean"/&gt;
            &lt;xsd:element name="reference" type="Treference"/&gt;
            &lt;xsd:any namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="default-activation" default="eager"type="Tactivation"/&gt;
      &lt;xsd:attribute name="default-timeout" type="Ttimeout"default="300000"/&gt;
      &lt;xsd:attribute name="default-availability" type="Tavailability"default="mandatory"/&gt;
      &lt;xsd:anyAttribute namespace="##other" processContents="strict"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Ttype-converters"&gt;
      &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
         &lt;xsd:element name="bean" type="Tbean"/&gt;
         &lt;xsd:element name="reference" type="Treference"/&gt;
         &lt;xsd:element name="ref" type="Tref"/&gt;
         &lt;xsd:any namespace="##other" processContents="strict"/&gt;
      &lt;/xsd:choice&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:group name="GtargetComponent"&gt;
      &lt;xsd:choice&gt;
         &lt;xsd:element name="bean" type="Tinlined-bean"/&gt;
         &lt;xsd:element name="reference" type="Tinlined-reference"/&gt;
         &lt;xsd:element name="ref" type="Tref"/&gt;
         &lt;xsd:any namespace="##other" processContents="strict"/&gt;
      &lt;/xsd:choice&gt;
   &lt;/xsd:group&gt;
   &lt;xsd:group name="GallComponents"&gt;
      &lt;xsd:choice&gt;
         &lt;xsd:element name="service" type="Tinlined-service"/&gt;
         &lt;xsd:element name="reference-list" type="Tinlined-reference-list"/&gt;
         &lt;xsd:group ref="GtargetComponent"/&gt;
      &lt;/xsd:choice&gt;
   &lt;/xsd:group&gt;
   &lt;xsd:group name="GbeanElements"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="description" type="Tdescription"minOccurs="0"/&gt;
         &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xsd:element name="argument" type="Targument"/&gt;
            &lt;xsd:element name="property" type="Tproperty"/&gt;
            &lt;xsd:any namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
   &lt;/xsd:group&gt;
   &lt;xsd:complexType name="Tbean"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:extension base="Tcomponent"&gt;
            &lt;xsd:group ref="GbeanElements"/&gt;
            &lt;xsd:attribute name="class" type="Tclass"/&gt;
            &lt;xsd:attribute name="init-method" type="Tmethod"/&gt;
            &lt;xsd:attribute name="destroy-method" type="Tmethod"/&gt;
            &lt;xsd:attribute name="factory-method" type="Tmethod"/&gt;
            &lt;xsd:attribute name="factory-ref" type="Tidref"/&gt;
            &lt;xsd:attribute name="scope" type="Tscope"/&gt;
            &lt;xsd:anyAttribute namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tinlined-bean"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:restriction base="Tbean"&gt;
            &lt;xsd:group ref="GbeanElements"/&gt;
            &lt;xsd:attribute name="id" use="prohibited"/&gt;
            &lt;xsd:attribute name="depends-on" type="TdependsOn"/&gt;
            &lt;xsd:attribute name="activation" use="prohibited"fixed="lazy"/&gt;
            &lt;xsd:attribute name="class" type="Tclass"/&gt;
            &lt;xsd:attribute name="init-method" type="Tmethod"/&gt;
            &lt;xsd:attribute name="destroy-method" use="prohibited"/&gt;
            &lt;xsd:attribute name="factory-method" type="Tmethod"/&gt;
            &lt;xsd:attribute name="factory-ref" type="Tidref"/&gt;
            &lt;xsd:attribute name="scope" use="prohibited"fixed="prototype"/&gt;
            &lt;xsd:anyAttribute namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:restriction&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Targument"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="description" type="Tdescription"minOccurs="0"/&gt;
         &lt;xsd:group ref="Gvalue" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="index" type="xsd:nonNegativeInteger"/&gt;
      &lt;xsd:attribute name="type" type="Ttype"/&gt;
      &lt;xsd:attribute name="ref" type="Tidref"/&gt;
      &lt;xsd:attribute name="value" type="TstringValue"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tproperty"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="description" type="Tdescription"minOccurs="0"/&gt;
         &lt;xsd:group ref="Gvalue" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="name" type="Tmethod" use="required"/&gt;
      &lt;xsd:attribute name="ref" type="Tidref"/&gt;
      &lt;xsd:attribute name="value" type="TstringValue"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tkey"&gt;
      &lt;xsd:group ref="GnonNullValue"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Treference"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:extension base="TserviceReference"&gt;
            &lt;xsd:sequence&gt;
               &lt;xsd:any namespace="##other" 
                        minOccurs="0" maxOccurs="unbounded" processContents="strict"/&gt;
            &lt;/xsd:sequence&gt;
            &lt;xsd:attribute name="timeout" type="Ttimeout"/&gt;
         &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tinlined-reference"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:restriction base="Treference"&gt;
            &lt;xsd:sequence&gt;
               &lt;xsd:group ref="GserviceReferenceElements"/&gt;
               &lt;xsd:any namespace="##other" 
                        minOccurs="0" maxOccurs="unbounded" processContents="strict"/&gt;
            &lt;/xsd:sequence&gt;
            &lt;xsd:attribute name="id" use="prohibited"/&gt;
            &lt;xsd:attribute name="depends-on" type="TdependsOn"/&gt;
            &lt;xsd:attribute name="activation" use="prohibited"fixed="lazy"/&gt;
            &lt;xsd:attribute name="interface" type="Tclass"/&gt;
            &lt;xsd:attribute name="filter" type="xsd:normalizedString"/&gt;
            &lt;xsd:attribute name="component-name" type="Tidref"/&gt;
            &lt;xsd:attribute name="availability" type="Tavailability"/&gt;
            &lt;xsd:attribute name="timeout" type="Ttimeout"/&gt;
            &lt;xsd:anyAttribute namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:restriction&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Treference-list"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:extension base="TserviceReference"&gt;
            &lt;xsd:sequence&gt;
               &lt;xsd:any namespace="##other" 
                        minOccurs="0" maxOccurs="unbounded" processContents="strict"/&gt;
            &lt;/xsd:sequence&gt;
            &lt;xsd:attribute name="member-type" type="Tservice-use"default="service-object"/&gt;
         &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tinlined-reference-list"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:restriction base="Treference-list"&gt;
            &lt;xsd:sequence&gt;
               &lt;xsd:group ref="GserviceReferenceElements"/&gt;
               &lt;xsd:any namespace="##other" 
                        minOccurs="0" maxOccurs="unbounded" processContents="strict"/&gt;
            &lt;/xsd:sequence&gt;
            &lt;xsd:attribute name="id" use="prohibited"/&gt;
            &lt;xsd:attribute name="depends-on" type="TdependsOn"/&gt;
            &lt;xsd:attribute name="activation" use="prohibited"fixed="lazy"/&gt;
            &lt;xsd:attribute name="interface" type="Tclass"/&gt;
            &lt;xsd:attribute name="filter" type="xsd:normalizedString"/&gt;
            &lt;xsd:attribute name="component-name" type="Tidref"/&gt;
            &lt;xsd:attribute name="availability" type="Tavailability"/&gt;
            &lt;xsd:attribute name="member-type" type="Tservice-use"default="service-object"/&gt;
            &lt;xsd:anyAttribute namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:restriction&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="TserviceReference"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:extension base="Tcomponent"&gt;
            &lt;xsd:sequence&gt;
               &lt;xsd:group ref="GserviceReferenceElements"/&gt;
            &lt;/xsd:sequence&gt;
            &lt;xsd:attribute name="interface" type="Tclass"/&gt;
            &lt;xsd:attribute name="filter" type="xsd:normalizedString"/&gt;
            &lt;xsd:attribute name="component-name" type="Tidref"/&gt;
            &lt;xsd:attribute name="availability" type="Tavailability"/&gt;
            &lt;xsd:anyAttribute namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:group name="GserviceReferenceElements"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="description" type="Tdescription"minOccurs="0"/&gt;
         &lt;xsd:element name="reference-listener" 
                type="TreferenceListener" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
   &lt;/xsd:group&gt;
   &lt;xsd:complexType name="TreferenceListener"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:group ref="GtargetComponent" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="ref" type="Tidref"/&gt;
      &lt;xsd:attribute name="bind-method" type="Tmethod"/&gt;
      &lt;xsd:attribute name="unbind-method" type="Tmethod"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:simpleType name="Tactivation"&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
         &lt;xsd:enumeration value="eager"/&gt;
         &lt;xsd:enumeration value="lazy"/&gt;
      &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="Tavailability"&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
         &lt;xsd:enumeration value="mandatory"/&gt;
         &lt;xsd:enumeration value="optional"/&gt;
      &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:complexType name="Tservice"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:extension base="Tcomponent"&gt;
            &lt;xsd:sequence&gt;
               &lt;xsd:group ref="GserviceElements"/&gt;
            &lt;/xsd:sequence&gt;
            &lt;xsd:attribute name="interface" type="Tclass"/&gt;
            &lt;xsd:attribute name="ref" type="Tidref"/&gt;
            &lt;xsd:attribute name="auto-export" type="TautoExportModes"default="disabled"/&gt;
            &lt;xsd:attribute name="ranking" type="xsd:int"default="0"/&gt;
            &lt;xsd:anyAttribute namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tinlined-service"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:restriction base="Tservice"&gt;
            &lt;xsd:sequence&gt;
               &lt;xsd:group ref="GserviceElements"/&gt;
            &lt;/xsd:sequence&gt;
            &lt;xsd:attribute name="id" use="prohibited"/&gt;
            &lt;xsd:attribute name="depends-on" type="TdependsOn"/&gt;
            &lt;xsd:attribute name="activation" use="prohibited"fixed="lazy"/&gt;
            &lt;xsd:attribute name="interface" type="Tclass"/&gt;
            &lt;xsd:attribute name="ref" type="Tidref"/&gt;
            &lt;xsd:attribute name="auto-export" type="TautoExportModes"default="disabled"/&gt;
            &lt;xsd:attribute name="ranking" type="xsd:int"default="0"/&gt;
            &lt;xsd:anyAttribute namespace="##other" processContents="strict"/&gt;
         &lt;/xsd:restriction&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:group name="GbaseServiceElements"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="description" type="Tdescription"minOccurs="0"/&gt;
         &lt;xsd:element name="interfaces" type="Tinterfaces"minOccurs="0"/&gt;
         &lt;xsd:element name="service-properties" type="TserviceProperties"minOccurs="0"/&gt;
         &lt;xsd:element name="registration-listener" 
                type="TregistrationListener" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
   &lt;/xsd:group&gt;
   &lt;xsd:group name="GserviceElements"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:group ref="GbaseServiceElements"/&gt;
         &lt;xsd:group ref="GtargetComponent" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
   &lt;/xsd:group&gt;
   &lt;xsd:complexType name="TregistrationListener"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:group ref="GtargetComponent" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="ref" type="Tidref"/&gt;
      &lt;xsd:attribute name="registration-method" type="Tmethod"/&gt;
      &lt;xsd:attribute name="unregistration-method" type="Tmethod"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:group name="Gvalue"&gt;
      &lt;xsd:choice&gt;
         &lt;xsd:group ref="GnonNullValue"/&gt;
         &lt;xsd:element name="null" type="Tnull"/&gt;
      &lt;/xsd:choice&gt;
   &lt;/xsd:group&gt;
   &lt;xsd:complexType name="Tnull"/&gt;
   &lt;xsd:group name="GnonNullValue"&gt;
      &lt;xsd:choice&gt;
         &lt;xsd:group ref="GallComponents"/&gt;
         &lt;xsd:element name="idref" type="Tref"/&gt;
         &lt;xsd:element name="value" type="Tvalue"/&gt;
         &lt;xsd:element name="list" type="Tcollection"/&gt;
         &lt;xsd:element name="set" type="Tcollection"/&gt;
         &lt;xsd:element name="map" type="Tmap"/&gt;
         &lt;xsd:element name="array" type="Tcollection"/&gt;
         &lt;xsd:element name="props" type="Tprops"/&gt;
      &lt;/xsd:choice&gt;
   &lt;/xsd:group&gt;
   &lt;xsd:complexType name="Tref"&gt;
      &lt;xsd:attribute name="component-id" type="Tidref"use="required"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tvalue" mixed="true"&gt;
      &lt;xsd:attribute name="type" type="Ttype"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="TtypedCollection"&gt;
      &lt;xsd:attribute name="value-type" type="Ttype"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tcollection"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:extension base="TtypedCollection"&gt;
            &lt;xsd:group ref="Gvalue" minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tprops"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="prop" type="Tprop" minOccurs="0"maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tprop" mixed="true"&gt;
      &lt;xsd:attribute name="key" type="TstringValue" use="required"/&gt;
      &lt;xsd:attribute name="value" type="TstringValue"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tmap"&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:extension base="TtypedCollection"&gt;
            &lt;xsd:sequence&gt;
               &lt;xsd:element name="entry" type="TmapEntry"minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;/xsd:sequence&gt;
            &lt;xsd:attribute name="key-type" type="Ttype"/&gt;
         &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="TmapEntry"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="key" type="Tkey" minOccurs="0"/&gt;
         &lt;xsd:group ref="Gvalue" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="key" type="TstringValue"/&gt;
      &lt;xsd:attribute name="key-ref" type="Tidref"/&gt;
      &lt;xsd:attribute name="value" type="TstringValue"/&gt;
      &lt;xsd:attribute name="value-ref" type="Tidref"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="TserviceProperties"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:element name="entry" 
                type="TservicePropertyEntry" minOccurs="0" maxOccurs="unbounded"/&gt;
         &lt;xsd:any namespace="##other" 
                processContents="strict" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="TservicePropertyEntry"&gt;
      &lt;xsd:sequence&gt;
         &lt;xsd:group ref="Gvalue" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="key" type="TstringValue" use="required"/&gt;
      &lt;xsd:attribute name="value" type="TstringValue"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tdescription" mixed="true"&gt;
      &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"/&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:complexType name="Tinterfaces"&gt;
      &lt;xsd:choice minOccurs="1" maxOccurs="unbounded"&gt;
         &lt;xsd:element name="value" type="TinterfaceValue"/&gt;
      &lt;/xsd:choice&gt;
   &lt;/xsd:complexType&gt;
   &lt;xsd:simpleType name="TinterfaceValue"&gt;
      &lt;xsd:restriction base="Tclass"/&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="Tclass"&gt;
      &lt;xsd:restriction base="xsd:NCName"/&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="Ttype"&gt;
      &lt;xsd:restriction base="xsd:token"&gt;
         &lt;xsd:pattern value="[\i-[:]][\c-[:]]*(\[\])*"/&gt;
      &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="Tmethod"&gt;
      &lt;xsd:restriction base="xsd:NCName"/&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="Tidref"&gt;
      &lt;xsd:restriction base="xsd:NCName"/&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="TstringValue"&gt;
      &lt;xsd:restriction base="xsd:normalizedString"/&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="TautoExportModes"&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
         &lt;xsd:enumeration value="disabled"/&gt;
         &lt;xsd:enumeration value="interfaces"/&gt;
         &lt;xsd:enumeration value="class-hierarchy"/&gt;
         &lt;xsd:enumeration value="all-classes"/&gt;
      &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="Ttimeout"&gt;
      &lt;xsd:restriction base="xsd:unsignedLong"/&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="TdependsOn"&gt;
      &lt;xsd:restriction&gt;
         &lt;xsd:simpleType&gt;
            &lt;xsd:list itemType="Tidref"/&gt;
         &lt;/xsd:simpleType&gt;
         &lt;xsd:minLength value="1"/&gt;
      &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="Tscope"&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
         &lt;xsd:enumeration value="singleton"/&gt;
         &lt;xsd:enumeration value="prototype"/&gt;
      &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
   &lt;xsd:simpleType name="Tservice-use"&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
         &lt;xsd:enumeration value="service-object"/&gt;
         &lt;xsd:enumeration value="service-reference"/&gt;
      &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
&lt;/xsd:schema&gt;</programlisting>
  </section>

  <section>
    <title>Security</title>

    <section>
      <title>Blueprint Extender</title>

      <para>A Blueprint Extender must use the Bundle Context of the Blueprint
      bundle. This will ensure that much of the resources allocated will be
      used on behalf of the Blueprint bundle. However, most Java 2 permissions
      will also verify the stack and this will inevitably include the
      Blueprint extender’s code. Therefore, the Blueprint extender will
      require the combined set of permissions needed by all Blueprint bundles.
      It is therefore likely that in practical situations the Blueprint
      extender requires All Permission.</para>

      <para>The Blueprint bundle requires permission for all actions that are
      done by the Blueprint Container on behalf of this bundle. That is, the
      Blueprint Container must not give any extra permissions to the Blueprint
      bundle because it is being extended.</para>

      <para>A Blueprint Container must therefore use a
      <code>doPriviliged</code> block around all actions that execute code on
      behalf of the Blueprint bundle. This <code>doPrivileged</code> block
      must use an Access Control Context that represents the permissions of
      the Blueprint bundle.</para>

      <para>For example, if a Blueprint bundle defines the following
      bean:</para>

      <programlisting>&lt;bean class="java.lang.System" factory-method="exit"&gt;
    &lt;argument value="1"/&gt;
&lt;/bean&gt;</programlisting>

      <para>Then the Blueprint bundle must have the proper permission to exit
      the system or the Blueprint bundle must fail when the bean is
      constructed. At the same time, a Blueprint bundle must not be required
      to have any permission needed by the Blueprint Container to performs its
      tasks.</para>

      <para>A Blueprint Container must never use the
      <code>setAccessibility</code> method on a returned member. Only publicly
      accessible members must be used. Using a non-publicly accessible member
      must initiate failure, resulting in the destruction of the
      container.</para>
    </section>

    <section>
      <title>Blueprint Bundle</title>

      <para>A Blueprint Bundle must have all the permissions required by its
      code. There is one additional permission required for the Blueprint
      Bundle. The Blueprint extender will register a Blueprint Container
      service on behalf of the Blueprint bundle, and the Blueprint bundle must
      therefore have:</para>

      <programlisting>ServicePermission(...BlueprintContainer,[REGISTER])</programlisting>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.blueprint.container.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.blueprint.reflect.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i1954805"><title>Spring
      Framework</title>http://www.springsource.org/</bibliomixed>

      <bibliomixed xml:id="i1954997"><title>Spring Dynamic
      Modules</title>http://www.springsource.org/osgi</bibliomixed>

      <bibliomixed
      xml:id="i1954924"><title>Guice</title>http://code.google.com/p/google-guice/</bibliomixed>

      <bibliomixed
      xml:id="i1954940"><title>Picocontainer</title>http://www.picocontainer.org/</bibliomixed>

      <bibliomixed xml:id="i1704220"><title>Java Beans
      Specification</title>http://www.oracle.com/technetwork/java/javase/tech/index-jsp-138795.html</bibliomixed>

      <bibliomixed xml:id="i1807860"><title>XML
      Namespaces</title>http://www.w3.org/TR/REC-xml-names</bibliomixed>

      <bibliomixed><title>Properties
      format</title>http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Properties.html#load%28java.io.InputStream%29</bibliomixed>

      <bibliomixed xml:id="i2584676"><title>XML
      Schema</title>http://www.w3.org/XML/Schema</bibliomixed>

      <bibliomixed xml:id="i2930811"><title>OSGi XML
      Schemas</title>http://www.osgi.org/Release4/XMLSchemas</bibliomixed>
    </bibliolist>
  </section>
</chapter>
