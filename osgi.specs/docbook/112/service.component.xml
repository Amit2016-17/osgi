<?xml version="1.0" encoding="utf-8"?>
<chapter label="112"
         revision="$Id$"
         version="5" xml:id="service.component"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Declarative Services Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.component-version"
    linkend="org.osgi.service.component"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The OSGi Framework contains a procedural service model which
    provides a publish/find/bind model for using
    <emphasis>services</emphasis>. This model is elegant and powerful, it
    enables the building of applications out of bundles that communicate and
    collaborate using these services.</para>

    <para>This specification addresses some of the complications that arise
    when the OSGi service model is used for larger systems and wider
    deployments, such as:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Startup Time</emphasis> - The procedural service model
        requires a bundle to actively register and acquire its services. This
        is normally done at startup time, requiring all present bundles to be
        initialized with a Bundle Activator. In larger systems, this quickly
        results in unacceptably long startup times.</para>
      </listitem>

      <listitem>
        <para><emphasis>Memory Footprint</emphasis> - A service registered
        with the Framework implies that the implementation, and related
        classes and objects, are loaded in memory. If the service is never
        used, this memory is unnecessarily occupied. The creation of a class
        loader may therefore cause significant overhead.</para>
      </listitem>

      <listitem>
        <para><emphasis>Complexity</emphasis> - Service can come and go at any
        time. This dynamic behavior makes the service programming model more
        complex than more traditional models. This complexity negatively
        influences the adoption of the OSGi service model as well as the
        robustness and reliability of applications because these applications
        do not always handle the dynamicity correctly.</para>
      </listitem>
    </itemizedlist>

    <para>The <emphasis>service component</emphasis> model uses a declarative
    model for publishing, finding and binding to OSGi services. This model
    simplifies the task of authoring OSGi services by performing the work of
    registering the service and handling service dependencies. This minimizes
    the amount of code a programmer has to write; it also allows service
    components to be loaded only when they are needed. As a result, bundles
    need not provide a <code>BundleActivator</code> class to collaborate with
    others through the service registry.</para>

    <para>From a system perspective, the service component model means reduced
    startup time and potentially a reduction of the memory footprint. From a
    programmer's point of view the service component model provides a
    simplified programming model.</para>

    <para>The Service Component model makes use of concepts described in <xref
    linkend="i1550732"/>.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Backward Compatibility</emphasis> - The service
          component model must operate seamlessly with the existing service
          model.</para>
        </listitem>

        <listitem>
          <para><emphasis>Size Constraints</emphasis> - The service component
          model must not require memory and performance intensive subsystems.
          The model must also be applicable on resource constrained
          devices.</para>
        </listitem>

        <listitem>
          <para><emphasis>Delayed Activation</emphasis> - The service
          component model must allow delayed activation of a service
          component. Delayed activation allows for delayed class loading and
          object creation until needed, thereby reducing the overall memory
          footprint.</para>
        </listitem>

        <listitem>
          <para><emphasis>Simplicity</emphasis> - The programming model for
          using declarative services must be very simple and not require the
          programmer to learn a complicated API or XML sub-language.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reactive</emphasis> - It must be possible to react
          to changes in the external dependencies with different
          policies.</para>
        </listitem>

        <listitem>
          <para><emphasis>Annotations</emphasis> - Annotations must be
          provided that can leverage the type information to create the XML
          descriptor.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Service Component</emphasis> - A service component
          contains a description that is interpreted at run time to create and
          dispose objects depending on the availability of other services, the
          need for such an object, and available configuration data. Such
          objects can optionally provide a service. This specification also
          uses the generic term <emphasis>component</emphasis> to refer to a
          service component.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Description</emphasis> - The declaration
          of a service component. It is contained within an XML document in a
          bundle.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Properties</emphasis> - A set of
          properties which can be specified by the component description,
          Configuration Admin service and from the component factory.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Configuration</emphasis> - A component
          configuration represents a component description parameterized by
          component properties. It is the entity that tracks the component
          dependencies and manages a component instance. An activated
          component configuration has a component context.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Instance</emphasis> - An instance of the
          component implementation class. A component instance is created when
          a component configuration is activated and discarded when the
          component configuration is deactivated. A component instance is
          associated with exactly one component configuration.</para>
        </listitem>

        <listitem>
          <para><emphasis>Delayed Component</emphasis> - A component whose
          component configurations are activated when their service is
          requested.</para>
        </listitem>

        <listitem>
          <para><emphasis>Immediate Component</emphasis> - A component whose
          component configurations are activated immediately upon becoming
          satisfied.</para>
        </listitem>

        <listitem>
          <para><emphasis>Factory Component</emphasis> - A component whose
          component configurations are created and activated through the
          component's component factory.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reference</emphasis> - A specified dependency of a
          component on a set of target services.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Component Runtime (SCR)</emphasis> - The
          actor that manages the components and their life cycle.</para>
        </listitem>

        <listitem>
          <para><emphasis>Target Services</emphasis> - The set of services
          that is defined by the reference interface and target property
          filter.</para>
        </listitem>

        <listitem>
          <para><emphasis>Bound Services</emphasis> - The set of target
          services that are bound to a component configuration.</para>
        </listitem>

        <listitem>
          <para><emphasis>Event methods</emphasis> - The bind, updated, and
          unbind methods associated with a Reference.</para>
        </listitem>
      </itemizedlist>

      <figure pgwide="1">
        <title>Service Component Runtime, org.osgi.service.component
        package</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.876in"
                       contentwidth="7.000in" fileref="component-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Synopsis</title>

      <para>The Service Component Runtime reads component descriptions from
      started bundles. These descriptions are in the form of XML documents
      which define a set of components for a bundle. A component can refer to
      a number of services that must be available before a component
      configuration becomes satisfied. These dependencies are defined in the
      descriptions and the specific target services can be influenced by
      configuration information in the Configuration Admin service. After a
      component configuration becomes satisfied, a number of different
      scenarios can take place depending on the component type:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Immediate Component</emphasis> - The component
          configuration of an immediate component must be activated
          immediately after becoming satisfied. Immediate components may
          provide a service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Delayed Component</emphasis> - When a component
          configuration of a delayed component becomes satisfied, SCR will
          register the service specified by the <code>service</code> element
          without activating the component configuration. If this service is
          requested, SCR must activate the component configuration creating an
          instance of the component implementation class that will be returned
          as the service object. If the <code>servicefactory</code> attribute
          of the <code>service</code> element is <code>true</code>, then, for
          each distinct bundle that requests the service, a different
          component configuration is created and activated and a new instance
          of the component implementation class is returned as the service
          object.</para>
        </listitem>

        <listitem>
          <para><emphasis>Factory Component</emphasis> - If a component's
          description specifies the <code>factory</code> attribute of the
          <code>component</code> element, SCR will register a Component
          Factory service. This service allows client bundles to create and
          activate multiple component configurations and dispose of them. If
          the component's description also specifies a <code>service</code>
          element, then as each component configuration is activated, SCR will
          register it as a service.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Readers</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Architects</emphasis> - The chapter, <xref
          linkend="i1479629"/>, gives a comprehensive introduction to the
          capabilities of the component model. It explains the model with a
          number of examples. The section about <xref linkend="i1545305"/>
          provides some deeper insight in the life cycle of components.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Programmers</emphasis> - Service programmers
          should read <xref linkend="i1479629"/>. This chapter should suffice
          for the most common cases. For the more advanced possibilities, they
          should consult <xref linkend="i1524140"/> for the details of the XML
          grammar for component descriptions.</para>
        </listitem>

        <listitem>
          <para><emphasis>Deployers</emphasis> - Deployers should consult
          <xref linkend="i1479915"/>.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="i1479629">
    <title>Components</title>

    <para>A component is a normal Java class contained within a bundle. The
    distinguishing aspect of a component is that it is
    <emphasis>declared</emphasis> in an XML document. Component configurations
    are activated and deactivated under the full control of SCR. SCR bases its
    decisions on the information in the component's description. This
    information consists of basic component information like the name and
    type, optional services that are implemented by the component, and
    <emphasis>references</emphasis>. References are dependencies that the
    component has on other services.</para>

    <para>SCR must <emphasis>activate</emphasis> a component configuration
    when the component is enabled and the component configuration is satisfied
    and a component configuration is needed. During the life time of a
    component configuration, SCR can notify the component of changes in its
    bound references.</para>

    <para>SCR will <emphasis>deactivate </emphasis>a previously activated
    component configuration when the component becomes disabled, the component
    configuration becomes unsatisfied, or the component configuration is no
    longer needed.</para>

    <para>If an activated component configuration's configuration properties
    change, SCR must deactivate the component configuration and then attempt
    to reactivate the component configuration using the new configuration
    information.</para>

    <section>
      <title>Declaring a Component</title>

      <para>A component requires the following artifacts in the bundle:</para>

      <itemizedlist>
        <listitem>
          <para>An XML document that contains the component
          description.</para>
        </listitem>

        <listitem>
          <para>The <code>Service-Component</code> manifest header which names
          the XML documents that contain the component descriptions.</para>
        </listitem>

        <listitem>
          <para>An implementation class that is specified in the component
          description.</para>
        </listitem>
      </itemizedlist>

      <para>The elements in the component's description are defined in <xref
      linkend="i1524140"/>. The XML grammar for the component declaration is
      defined by the XML Schema, see <xref linkend="i1523991"/>.</para>
    </section>

    <section>
      <title>Immediate Component</title>

      <para>An <emphasis>immediate component</emphasis> is activated as soon
      as its dependencies are satisfied. If an immediate component has no
      dependencies, it is activated immediately. A component is an immediate
      component if it is not a factory component and either does not specify a
      service or specifies a service and the <code>immediate</code> attribute
      of the <code>component</code> element set to <code>true</code>. If an
      immediate component configuration is satisfied and specifies a service,
      SCR must register the component configuration as a service in the
      service registry and then activate the component configuration.</para>

      <para>For example, the bundle entry <code>/OSGI-INF/activator.xml</code>
      contains:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.activator"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.Activator"/&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The manifest header <code>Service-Component</code> must also be
      specified in the bundle manifest. For example:</para>

      <programlisting>Service-Component: OSGI-INF/activator.xml</programlisting>

      <para>An example class for this component could look like:</para>

      <programlisting>public class Activator {
    public Activator() {...}
    private void activate(BundleContext context) {...}
    private void deactivate() {...}  
}</programlisting>

      <para>This example component is virtually identical to a Bundle
      Activator. It has no references to other services so it will be
      satisfied immediately. It publishes no service so SCR will activate a
      component configuration immediately.</para>

      <para>The <code>activate</code> method is called when SCR activates the
      component configuration and the <code>deactivate</code> method is called
      when SCR deactivates the component configuration. If the
      <code>activate</code> method throws an Exception, then the component
      configuration is not activated and will be discarded.</para>
    </section>

    <section xml:id="i1613408">
      <title>Delayed Component</title>

      <para>A <emphasis>delayed component</emphasis> specifies a service, is
      not specified to be a factory component and does not have the
      <code>immediate</code> attribute of the <code>component</code> element
      set to <code>true</code>. If a delayed component configuration is
      satisfied, SCR must register the component configuration as a service in
      the service registry but the activation of the component configuration
      is delayed until the registered service is requested. The registered
      service of a delayed component looks like a normal registered service
      but does not incur the overhead of an ordinarily registered service that
      require a service's bundle to be initialized to register the
      service.</para>

      <para>For example, a bundle needs to see events of a specific topic. The
      Event Admin uses the white board pattern, receiving the events is
      therefore as simple as registering a Event Handler service. The example
      XML for the delayed component looks like:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.handler"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.HandlerImpl"/&gt;
    &lt;property name="event.topics"&gt;some/topic&lt;/property&gt;
    &lt;service&gt; 
        &lt;provide interface= 
            "org.osgi.service.event.EventHandler"/&gt; 
    &lt;/service&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The associated component class looks like:</para>

      <programlisting>public class HandlerImpl implements EventHandler{
    public void handleEvent(Event evt ) {
        ...
  }
}</programlisting>

      <para>The component configuration will only be activated once the Event
      Admin service requires the service because it has an event to deliver on
      the topic to which the component subscribed.</para>
    </section>

    <section xml:id="i1461154">
      <title>Factory Component</title>

      <para>Certain software patterns require the creation of component
      configurations on demand. For example, a component could represent an
      application that can be launched multiple times and each application
      instance can then quit independently. Such a pattern requires a factory
      that creates the instances. This pattern is supported with a
      <emphasis>factory component</emphasis>. A factory component is used if
      the <code>factory</code> attribute of the <code>component</code> element
      is set to a <emphasis>factory identifier</emphasis>. This identifier can
      be used by a bundle to associate the factory with externally defined
      information.</para>

      <para>SCR must register a Component Factory service on behalf of the
      component as soon as the component factory is satisfied. The service
      properties must be:</para>

      <itemizedlist>
        <listitem>
          <para><code>component.name</code> - The name of the
          component.</para>
        </listitem>

        <listitem>
          <para><code>component.factory</code> - The factory
          identifier.</para>
        </listitem>
      </itemizedlist>

      <para>The service properties of the Component Factory service must not
      include the component properties.</para>

      <para>New configurations of the component can be created and activated
      by calling the <code>newInstance</code> method on this Component Factory
      service. The <xref
      linkend="org.osgi.service.component.ComponentFactory.newInstance-Dictionary-"
      xrefstyle="hyperlink"/> method has a <code>Dictionary</code> object as
      argument. This Dictionary object is merged with the component properties
      as described in <xref linkend="i1407478"/>. If the component specifies a
      service, then the service is registered after the created component
      configuration is satisfied with the component properties. Then the
      component configuration is activated.</para>

      <para>For example, a component can provide a connection to a USB device.
      Such a connection should normally not be shared and should be created
      each time such a service is needed. The component description to
      implement this pattern looks like:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.factory"
    factory="usb.connection"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.USBConnectionImpl"/&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component class looks like:</para>

      <programlisting>public class USBConnectionImpl implementsUSBConnection {
    private void activate(Map properties) {
     ...
    }
}</programlisting>

      <para>A factory component can be associated with a service. In that
      case, such a service is registered for each component configuration. For
      example, the previous example could provide a USB Connection
      service.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.factory"    
    factory="usb.connection"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.USBConnectionImpl"/&gt;
    <emphasis role="underline">&lt;service&gt;</emphasis>
        &lt;provide interface="com.acme.USBConnection"/&gt;
    &lt;/service&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The associated component class looks like:</para>

      <programlisting>public class USBConnectionImpl implementsUSBConnection {
    private void activate(Map properties) {...}
    public void connect() { ... }
    ...
    public void close() { ... }
}</programlisting>

      <para>A new service will be registered each time a new component
      configuration is created and activated with the <code>newInstance</code>
      method. This allows a bundle other than the one creating the component
      configuration to utilize the service. If the component configuration is
      deactivated, the service must be unregistered.</para>
    </section>
  </section>

  <section>
    <title>References to Services</title>

    <para>Most bundles will require access to other services from the service
    registry. The dynamics of the service registry require care and attention
    of the programmer because referenced services, once acquired, could be
    unregistered at any moment. The component model simplifies the handling of
    these service dependencies significantly.</para>

    <para>The services that are selected by a reference are called the
    <emphasis>target services</emphasis>. These are the services selected by
    the <code>BundleContext.getServiceReferences</code> method where the first
    argument is the reference's interface and the second argument is the
    reference's target property, which must be a valid filter.</para>

    <para>A component configuration becomes <emphasis>satisfied</emphasis>
    when each specified reference is satisfied. A reference is
    <emphasis>satisfied</emphasis> if it specifies optional cardinality or
    when the target services contains at least one member. An activated
    component configuration that becomes <emphasis>unsatisfied</emphasis> must
    be deactivated.</para>

    <para>During the activation of a component configuration, SCR must bind
    some or all of the target services of a reference to the component
    configuration. Any target service that is bound to the component
    configuration is called a <emphasis>bound</emphasis> service. See <xref
    linkend="i1536739"/>.</para>

    <section xml:id="i1548427">
      <title>Accessing Services</title>

      <para>A component instance must be able to use the services that are
      referenced by the component configuration, that is, the bound services
      of the references. There are two strategies for a component instance to
      acquire these bound services:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Event strategy</emphasis> - SCR calls a method on
          the component instance when a service becomes bound, when a service
          becomes unbound, or when its properties are updated. These methods
          are the bind, updated, and unbind methods specified by the
          reference. The event strategy is useful if the component needs to be
          notified of changes to the bound services for a dynamic
          reference.</para>
        </listitem>

        <listitem>
          <para><emphasis>Lookup strategy</emphasis> - A component instance
          can use one of the <code>locateService</code> methods of <xref
          linkend="org.osgi.service.component.ComponentContext"
          xrefstyle="hyperlink"/> to locate a bound service. These methods
          take the <code>name</code> of the reference as a parameter. If the
          reference has a dynamic policy, it is important to not store the
          returned service object(s) but look it up every time it is
          needed.</para>
        </listitem>
      </itemizedlist>

      <para>A component may use either or both strategies to access bound
      services.</para>
    </section>

    <section>
      <title>Event Methods</title>

      <para>When using the event strategy the SCR must callback the components
      at the appropriate time. The SCR must callback on the following
      events:</para>

      <itemizedlist>
        <listitem>
          <para><code>bind</code> - The bind method is called to bind a new
          service to the component that matches the selection criteria. If the
          <code>policy</code> is <code>dynamic</code> then the bind method of
          a replacement service can be called before its corresponding unbind
          method.</para>
        </listitem>

        <listitem>
          <para><code>updated</code> - The updated method is called when the
          service properties of a bound services are modified and the
          resulting properties do not cause the service to become unbound
          because it is no longer selected by the <code>target</code>
          filter.</para>
        </listitem>

        <listitem>
          <para><code>unbind</code> - The unbind method is called when the SCR
          needs to unbind the service.</para>
        </listitem>
      </itemizedlist>

      <para>Together these methods are called the <emphasis>event
      methods</emphasis>. Event methods must have one of the following
      prototypes:</para>

      <programlisting>void &lt;method-name&gt;(ServiceReference);
void &lt;method-name&gt;(&lt;parameter-type&gt;);
void &lt;method-name&gt;(&lt;parameter-type&gt;, Map);</programlisting>

      <para>If an event method has the first prototype, then a Service
      Reference to the bound service will be passed to the method. This
      Service Reference may later be passed to the <xref
      linkend="org.osgi.service.component.ComponentContext.locateService-String-ServiceReference-"
      xrefstyle="hyperlink"/> method to obtain the actual service object. This
      approach is useful when the service properties need to be examined
      before accessing the service object. It also allows for the delayed
      activation of bound services when using the event strategy.</para>

      <para>If an event method has the second prototype, then the service
      object of the bound service is passed to the method. The method's
      parameter type must be assignable from the type specified by the
      reference's <code>interface</code> attribute. That is, the service
      object of the bound service must be castable to the method's parameter
      type.</para>

      <para>If an event method has the third prototype, then the service
      object of the bound service is passed to the method as the first
      argument and an unmodifiable Map containing the service properties of
      the bound service is passed as the second argument. The method's first
      parameter type must be assignable from the type specified by the
      reference's <code>interface</code> attribute. That is, the service
      object of the bound service must be castable to the method's first
      parameter type.</para>

      <para>The bind and unbind methods must be called once for each bound
      service. This implies that if the reference has multiple cardinality,
      then the methods may be called multiple times. The updated method can be
      called multiple times per service.</para>

      <para>A suitable method is selected using the following priority:</para>

      <orderedlist>
        <listitem>
          <para>The method takes a single argument and the type of the
          argument is <code>org.osgi.framework.ServiceReference</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single argument and the type of the
          argument is the type specified by the reference's
          <code>interface</code> attribute.</para>
        </listitem>

        <listitem>
          <para>The method takes a single argument and the type of the
          argument is assignable from the type specified by the reference's
          <code>interface</code> attribute. If multiple methods match this
          rule, this implies the method name is overloaded and SCR may choose
          any of the methods to call.</para>
        </listitem>

        <listitem>
          <para>The method takes two argument and the type of the first
          argument is the type specified by the reference's
          <code>interface</code> attribute and the type of the second argument
          is <code>java.util.Map</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes two argument and the type of the first
          argument is assignable from the type specified by the reference's
          <code>interface</code> attribute and the type of the second argument
          is <code>java.util.Map</code>. If multiple methods match this rule,
          this implies the method name is overloaded and SCR may choose any of
          the methods to call.</para>
        </listitem>
      </orderedlist>

      <para>When searching for an event method to call, SCR must locate a
      suitable method as specified in <xref linkend="i1641644"/>. If no
      suitable method is located, SCR must log an error message with the Log
      Service, if present, and there will be no bind, updated, or unbind
      notification.</para>

      <para>When the service object for a bound service is first provided to a
      component instance, that is passed to an event method or returned by a
      locate service method, SCR must get the service object from the OSGi
      Framework's service registry using the <code>getService</code> method on
      the component's Bundle Context. If the service object for a bound
      service has been obtained and the service becomes unbound, SCR must
      unget the service object using the <code>ungetService</code> method on
      the component's Bundle Context and discard all references to the service
      object.</para>

      <para>For example, a component requires the Log Service and uses the
      lookup strategy. The reference is declared without any bind, updated,
      and unbind methods:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.LogLookupImpl"/&gt;
    &lt;reference name="LOG"
        interface="org.osgi.service.log.LogService"/&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component implementation class must now lookup the service.
      This looks like:</para>

      <programlisting>public class LogLookupImpl {
    private void activate(ComponentContext ctxt) {
        LogService log = (LogService)
            ctxt.locateService("LOG");
        log.log(LogService.LOG_INFO, "Hello Components!"));
    }
}</programlisting>

      <para>Alternatively, the component could use the event strategy and ask
      to be notified with the Log Service by declaring bind, updated, and
      unbind methods.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.LogEventImpl"/&gt;
    &lt;reference name="LOG"
        interface="org.osgi.service.log.LogService"
        bind="setLog"
        updated="updatedLog"
        unbind="unsetLog"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component implementation class looks like:</para>

      <programlisting>public class LogEventImpl {
    LogService log;
    Integer    level;
    void setLog( LogService l, Map&lt;String,?&gt; ref ) {
        log = l;
        updatedLog(ref);
    }
    void updatedLog( LogService l, Map&lt;String,?&gt; ref) {
        level = (Integer) ref.get("level");
    }
    void unsetLog( LogService l ) { log = null; }

    private void activate() {
        log.log(LogService.LOG_INFO, "Hello Components!"));
    }
}</programlisting>

      <para>Event methods can be declared private in the component class but
      are only looked up in the inheritance chain when they are protected,
      public, or have default access. See <xref linkend="i1641644"/>.</para>
    </section>

    <section xml:id="i1440459">
      <title>Reference Cardinality</title>

      <para>A component implementation is always written with a certain
      <emphasis>cardinality</emphasis> in mind. The cardinality represents two
      important concepts:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Multiplicity</emphasis> - Does the component
          implementation assume a single service or does it explicitly handle
          multiple occurrences For example, when a component uses the Log
          Service, it only needs to bind to one Log Service to function
          correctly. Alternatively, when the Configuration Admin uses the
          Configuration Listener services it needs to bind to all target
          services present in the service registry to dispatch its events
          correctly.</para>
        </listitem>

        <listitem>
          <para><emphasis>Optionality</emphasis> - Can the component function
          without any bound service present Some components can still perform
          useful tasks even when no target service is available, other
          components must bind to at least one target service before they can
          be useful. For example, the Configuration Admin in the previous
          example must still provide its functionality even if there are no
          Configuration Listener services present. Alternatively, an
          application that solely presents a Servlet page has little to do
          when the Http Service is not present, it should therefore use a
          reference with a mandatory cardinality.</para>
        </listitem>
      </itemizedlist>

      <para>The cardinality is expressed with the following syntax:</para>

      <programlisting>cardinality  ::= optionality '..' multiplicity
optionality  ::= '0' | '1'
multiplicity ::= '1' | 'n'</programlisting>

      <para>A reference is <emphasis>satisfied</emphasis> if the number of
      target services is equal to or more than the <code>optionality</code>.
      The <code>multiplicity</code> is irrelevant for the satisfaction of the
      reference. The <code>multiplicity</code> only specifies if the component
      implementation is written to handle being bound to multiple services
      (<code>n</code>) or requires SCR to select and bind to a single service
      (<code>1</code>).</para>

      <para>The cardinality for a reference can be specified as one of four
      choices:</para>

      <itemizedlist>
        <listitem>
          <para><code>0..1</code> - Optional and unary.</para>
        </listitem>

        <listitem>
          <para><code>1..1</code> - Mandatory and unary (Default) .</para>
        </listitem>

        <listitem>
          <para><code>0..n</code> - Optional and multiple.</para>
        </listitem>

        <listitem>
          <para><code>1..n</code> - Mandatory and multiple.</para>
        </listitem>
      </itemizedlist>

      <para>When a satisfied component configuration is activated, there must
      be at most one bound service for each reference with a unary cardinality
      and at least one bound service for each reference with a mandatory
      cardinality. If the cardinality constraints cannot be maintained after a
      component configuration is activated, that is the reference becomes
      unsatisfied, the component configuration must be deactivated. If the
      reference has a unary cardinality and there is more than one target
      service for the reference, then the bound service must be the target
      service with the highest service ranking as specified by the
      <code>service.ranking</code> property. If there are multiple target
      services with the same service ranking, then the bound service must be
      the target service with the highest service ranking and the lowest
      service ID as specified by the <code>service.id</code> property.</para>

      <para>For example, a component wants to register a resource with all
      Http Services that are available. Such a scenario has the cardinality of
      <code>0..n</code>. The code must be prepared to handle multiple calls to
      the bind method for each Http Service in such a case. In this example,
      the code uses the <code>registerResources</code> method to register a
      directory for external access.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.HttpResourceImpl"/&gt;
    &lt;reference name="HTTP"
        interface="org.osgi.service.http.HttpService"
        cardinality="0..n"
        bind="setPage"
        unbind="unsetPage"
    /&gt;
&lt;/scr:component&gt;

public class HttpResourceImpl {
    private void setPage(HttpService http) {
        http.registerResources("/scr", "scr", null );
    }
    private void unsetPage(HttpService http) {
        http.unregister("/scr");
    }
}</programlisting>
    </section>

    <section xml:id="i1440474">
      <title>Reference Policy</title>

      <para>Once all the references of a component are satisfied, a component
      configuration can be activated and therefore bound to target services.
      However, the dynamic nature of the OSGi service registry makes it likely
      that services are registered, modified and unregistered after target
      services are bound. These changes in the service registry could make one
      or more bound services no longer a target service thereby making
      obsolete any object references that the component has to these service
      objects. Components therefore must specify a <emphasis>policy
      </emphasis>how to handle these changes in the set of bound services. A
      <emphasis>policy-option</emphasis> can further refine how changes affect
      bound services.</para>

      <para>The <emphasis>static policy</emphasis> is the most simple policy
      and is the default policy. A component instance never sees any of the
      dynamics. Component configurations are deactivated before any bound
      service for a reference having a static policy becomes unavailable. If a
      target service is available to replace the bound service which became
      unavailable, the component configuration must be reactivated and bound
      to the replacement service.</para>

      <para>If the <code>policy-option</code> is <code>reluctant</code> then
      the registration of an additional target service for a reference must
      not result in deactivating and reactivating a component configuration.
      If the <code>policy-option</code> is <code>greedy</code> then the
      component must be reactivated when new applicable services become
      available, see <xref linkend="service.component-policy.option.action"
      xrefstyle="template:Table %n on page %p"/>. A reference with a static
      policy is called a <emphasis>static reference</emphasis>. A static
      reference can still be updated dynamically if it specifies an updated
      method.</para>

      <para>The static policy can be very expensive if it depends on services
      that frequently unregister and re-register or if the cost of activating
      and deactivating a component configuration is high. Static policy is
      usually also not applicable if the cardinality specifies multiple bound
      services.</para>

      <para>The <emphasis>dynamic policy</emphasis> is slightly more complex
      since the component implementation must properly handle changes in the
      set of bound services that can occur on any thread. With the dynamic
      policy, SCR can change the set of bound services without deactivating a
      component configuration. If the component uses the event strategy to
      access services, then the component instance will be notified of changes
      in the set of bound services by calls to the bind, and unbind
      methods.</para>

      <para>If the <code>policy-option</code> is <code>reluctant</code> then a
      bound reference is not rebound even if a more suitable service becomes
      available for a 1..1 or 0..1 reference. If the
      <code>policy-option</code> is <code>greedy</code> then the component
      must be unbound and rebound for that reference.</para>

      <para>A reference with a dynamic policy is called a <emphasis>dynamic
      reference</emphasis>.</para>

      <para>The previous example with the registering of a resource directory
      used a static policy. This implied that the component configurations are
      deactivated when there is a change in the bound set of Http Services.
      The code in the example can be seen to easily handle the dynamics of
      Http Services that come and go. The component description can therefore
      be updated to:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.HttpResourceImpl"/&gt;
    &lt;reference name="HTTP"
        interface="org.osgi.service.http.HttpService"
        cardinality="0..n"
        <emphasis role="underline">policy="dynamic"</emphasis>
        bind="setPage"
        unbind="unsetPage"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The code is identical to the previous example.</para>
    </section>

    <section>
      <title>Policy Option</title>

      <para>The <code>policy-option</code> defines how eager the reference is
      to rebind when a new, potentially with a higher ranking, target service
      becomes available. It can have the following values:</para>

      <itemizedlist>
        <listitem>
          <para><code>reluctant</code> - Minimize rebinding and
          reactivating.</para>
        </listitem>

        <listitem>
          <para><code>greedy</code> - Maximize the use of the best service by
          deactivating static references or rebinding dynamic
          references.</para>
        </listitem>
      </itemizedlist>

      <para><xref linkend="service.component-policy.option.action"/> defines
      the actions that are taken when a <emphasis>better</emphasis> target
      service becomes available. In this context, better is when the reference
      is not bound or when the new target service has a higher ranking than
      the bound service.</para>

      <table pgwide="1" xml:id="service.component-policy.option.action">
        <title>Action taken for policy-option when a new or higher ranking
        service becomes available</title>

        <tgroup cols="5">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="2*"/>

          <colspec colnum="4" colwidth="2*"/>

          <colspec colnum="5" colwidth="2*"/>

          <thead>
            <row>
              <entry>Cardinality</entry>

              <entry>static reluctant</entry>

              <entry>static greedy</entry>

              <entry>dynamic reluctant</entry>

              <entry>dynamic greedy</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>0..1</code></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Reactivate to bind the better target
              service.</para></entry>

              <entry><para>If no service is bound, bind to new target service.
              Otherwise, ignore new target service.</para></entry>

              <entry><para>If no service is bound, bind to better target
              service. Otherwise, unbind the bound service and bind the better
              target service.</para></entry>
            </row>

            <row>
              <entry><code>1..1</code></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Reactivate to bind the better target
              service.</para></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Unbind the bound service, then bind the new
              service.</para></entry>
            </row>

            <row>
              <entry><code>0..n</code></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Reactivate</para></entry>

              <entry><para>Bind new target service</para></entry>

              <entry><para>Bind new target service</para></entry>
            </row>

            <row>
              <entry><code>1..n</code></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Reactivate</para></entry>

              <entry><para>Bind new target service</para></entry>

              <entry><para>Bind new target service</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="i1547893">
      <title>Selecting Target Services</title>

      <para>The target services for a reference are constrained by the
      reference's interface name and target property. By specifying a filter
      in the target property, the programmer and deployer can constrain the
      set of services that should be part of the target services.</para>

      <para>For example, a component wants to track all Component Factory
      services that have a factory identification of
      <code>acme.application</code>. The following component description shows
      how this can be done.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="com.acme.FactoryTracker"/&gt;
    &lt;reference name="FACTORY"
        interface=
            "org.osgi.service.component.ComponentFactory"
        target="(component.factory=acme.application)"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The filter is manifested as a component property called the
      <emphasis>target property</emphasis>. The target property can also be
      set by <code>property</code> and <code>properties</code> elements, see
      <xref linkend="i1544128"/>. The deployer can also set the target
      property by establishing a configuration for the component which sets
      the value of the target property. This allows the deployer to override
      the target property in the component description. See <xref
      linkend="i1407478"/> for more information.</para>
    </section>

    <section xml:id="i1540789">
      <title>Circular References</title>

      <para>It is possible for a set of component descriptions to create a
      circular dependency. For example, if component <code>A</code> references
      a service provided by component <code>B</code> and component
      <code>B</code> references a service provided by component <code>A</code>
      then a component configuration of one component cannot be satisfied
      without accessing a partially activated component instance of the other
      component. SCR must ensure that a component instance is never accessible
      to another component instance or as a service until it has been fully
      activated, that is it has returned from its <code>activate</code> method
      if it has one.</para>

      <para>Circular references must be detected by SCR when it attempts to
      satisfy component configurations and SCR must fail to satisfy the
      references involved in the cycle and log an error message with the Log
      Service, if present. However, if one of the references in the cycle has
      optional cardinality SCR must break the cycle. The reference with the
      optional cardinality can be satisfied and bound to zero target services.
      Therefore the cycle is broken and the other references may be
      satisfied.</para>
    </section>
  </section>

  <section xml:id="i1524140">
    <title>Component Description</title>

    <para>Component descriptions are defined in XML documents contained in a
    bundle and any attached fragments.</para>

    <para>If SCR detects an error when processing a component description, it
    must log an error message with the Log Service, if present, and ignore the
    component description. Errors can include XML parsing errors and
    ill-formed component descriptions.</para>

    <section>
      <title>Annotations</title>

      <para>A number of <code>CLASS</code> retention annotations have been
      provided to allow tools to construct the XML from the Java class files.
      These annotations will be discussed with the appropriate elements an
      attributes. Since the naming rules between XML and Java differ, some
      name changes are necessary.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Elements</emphasis> - The annotation class that
          corresponds to an element starts with an upper case. For example the
          <code>component</code> element is represented by the
          <code>@Component</code> annotation.</para>
        </listitem>

        <listitem>
          <para><emphasis>Attributes</emphasis> - Multi word attributes that
          use a minus sign (<code>'-' \u002D</code>) are changed to camel
          case. For example, the <code>component</code> element
          <code>configuration-pid</code> attribute is the
          <code>configurationPid</code> member in the <code>@Component</code>
          annotation.</para>
        </listitem>
      </itemizedlist>

      <para>Some elements do not have a corresponding annotation since the
      annotations can be parameterized by the type information in the Java
      class. For example, the <code>@Component</code> annotation synthesizes
      the <code>implement</code> element's <code>class</code> attribute from
      the type it is applied to.</para>

      <para>These annotations are intended to be used during build time to
      generate the XML and are not recognized by SCR at runtime.</para>
    </section>

    <section>
      <title>Service Component Header</title>

      <para>XML documents containing component descriptions must be specified
      by the Service-Component header in the manifest. The value of the header
      is a comma separated list of paths to XML entries within the
      bundle.</para>

      <programlisting>Service-Component ::= header // See Common Header Syntax in Core</programlisting>

      <para>The Service-Component header has no architected directives or
      properties. The header can be left empty.</para>

      <para>The last component of each path in the Service-Component header
      may use wildcards so that <code>Bundle.findEntries</code> can be used to
      locate the XML document within the bundle and its fragments. For
      example:</para>

      <programlisting>Service-Component: OSGI-INF/*.xml</programlisting>

      <para>A Service-Component manifest header specified in a fragment is
      ignored by SCR. However, XML documents referenced by a bundle's
      Service-Component manifest header may be contained in attached
      fragments.</para>

      <para>SCR must process each XML document specified in this header. If an
      XML document specified by the header cannot be located in the bundle and
      its attached fragments, SCR must log an error message with the Log
      Service, if present, and continue.</para>
    </section>

    <section>
      <title>XML Document</title>

      <para>A component description must be in a well-formed XML document,
      <xref linkend="i1636361"/>, stored in a <code>UTF-8</code> encoded
      bundle entry. The namespace for component descriptions is:</para>

      <programlisting>http://www.osgi.org/xmlns/scr/v1.2.0</programlisting>

      <para>The recommended prefix for this namespace is <code>scr</code>.
      This prefix is used by examples in this specification. XML documents
      containing component descriptions may contain a single, root
      <code>component</code> element or one or more <code>component</code>
      elements embedded in a larger document. Use of the namespace for
      component descriptions is mandatory. The attributes and sub-elements of
      a <code>component</code> element are always unqualified.</para>

      <para>If an XML document contains a single, root <code>component</code>
      element which does not specify a namespace, then the
      <code>http://www.osgi.org/xmlns/scr/v1.0.0</code> namespace is assumed.
      Component descriptions using the
      <code>http://www.osgi.org/xmlns/scr/v1.0.0</code> namespace must be
      treated according to version 1.0 of this specification.</para>

      <para>SCR must parse all <code>component</code> elements in the
      namespace. Elements not in this namespace must be ignored. Ignoring
      elements that are not recognized allows component descriptions to be
      embedded in any XML document. For example, an entry can provide
      additional information about components. These additional elements are
      parsed by another sub-system.</para>

      <para>See <xref linkend="i1523991"/> for component description
      schema.</para>
    </section>

    <section xml:id="i1441045">
      <title>Component Element</title>

      <para>The component element specifies the component description. The
      following text defines the structure of the XML grammar using a form
      that is similar to the normal grammar used in OSGi specifications. In
      this case the grammar should be mapped to XML elements:</para>

      <programlisting>&lt;component&gt; ::= &lt;implementation&gt; 
                (&lt;properties&gt; | &lt;property&gt;)* 
                &lt;service&gt;  
                &lt;reference&gt; *</programlisting>

      <para>SCR must not require component descriptions to specify the
      elements in the order listed above and as required by the XML schema.
      SCR must allow other orderings since arbitrary orderings of these
      elements do not affect the meaning of the component description. Only
      the relative ordering of <code>property</code> and
      <code>properties</code> element have meaning.</para>

      <para>The <code>component</code> element has the attributes and
      <code>@Component</code> annotations defined in the following
      table.</para>

      <table pgwide="1">
        <title>Component Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>name</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Component.name--"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>The <emphasis>name</emphasis> of a component must
              be unique within a bundle. The component name is used as a PID
              to retrieve component properties from the OSGi Configuration
              Admin service if present, unless a
              <code>configuration-pid</code> attribute has been defined. See
              <xref linkend="i1479915"/> for more information. If the
              component name is used as a PID then it should be unique within
              the framework. The XML schema allows the use of component names
              which are not valid PIDs. Care must be taken to use a valid PID
              for a component name if the component should be configured by
              the Configuration Admin service. This attribute is optional. The
              default value of this attribute is the value of the
              <code>class</code> attribute of the nested
              <code>implementation</code> element. If multiple
              <code>component</code> elements in a bundle use the same value
              for the <code>class</code> attribute of their nested
              <code>implementation</code> element, then using the default
              value for this attribute will result in duplicate component
              names. In this case, this attribute must be specified with a
              unique value. </para></entry>
            </row>

            <row>
              <entry><code>enabled</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Component.enabled--"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>Controls whether the component is
              <emphasis>enabled</emphasis> when the bundle is started. The
              default value is <code>true</code>. If <code>enabled</code> is
              set to <code>false</code>, the component is disabled until the
              method <code>enableComponent</code> is called on the
              <code>ComponentContext</code> object. This allows some
              initialization to be performed by some other component in the
              bundle before this component can become satisfied. See <xref
              linkend="i1545307"/>.</para></entry>
            </row>

            <row>
              <entry><code>factory</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Component.factory--"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>If set to a non-empty string, it indicates that
              this component is a <emphasis>factory component</emphasis>. SCR
              must register a Component Factory service for each factory
              component. See <xref linkend="i1461154"/>.</para></entry>
            </row>

            <row>
              <entry><code>immediate</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Component.immediate--"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>Controls whether component configurations must be
              immediately activated after becoming satisfied or whether
              activation should be delayed. The default value is
              <code>false</code> if the <code>factory</code> attribute or if
              the <code>service</code> element is specified and
              <code>true</code> otherwise. If this attribute is specified, its
              value must be <code>false</code> if the <code>factory</code>
              attribute is also specified or must be <code>true</code> unless
              the <code>service</code> element is also
              specified.</para></entry>
            </row>

            <row>
              <entry><code>configuration-policy</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Component.configurationPolicy--"
              xrefstyle="hyperlink"/></code> (<code><xref
              linkend="org.osgi.service.component.annotations.ConfigurationPolicy.OPTIONAL"
              xrefstyle="hyperlink"/></code>, <code><xref
              linkend="org.osgi.service.component.annotations.ConfigurationPolicy.REQUIRE"
              xrefstyle="hyperlink"/></code>, or <code><xref
              linkend="org.osgi.service.component.annotations.ConfigurationPolicy.IGNORE"
              xrefstyle="hyperlink"/></code>)</entry>

              <entry><para>Controls whether component configurations must be
              satisfied depending on the presence of a corresponding
              <code>Configuration</code> object in the OSGi Configuration
              Admin service. A corresponding configuration is a
              <code>Configuration</code> object where the PID is the name of
              the component.</para><itemizedlist>
                  <listitem>
                    <para><code>optional</code> - (default) Use the
                    corresponding <code>Configuration</code> object if present
                    but allow the component to be satisfied even if the
                    corresponding <code>Configuration</code> object is not
                    present.</para>
                  </listitem>

                  <listitem>
                    <para><code>require</code> - There must be a corresponding
                    <code>Configuration</code> object for the component
                    configuration to become satisfied.</para>
                  </listitem>

                  <listitem>
                    <para><code>ignore</code> - Always allow the component
                    configuration to be satisfied and do not use the
                    corresponding <code>Configuration</code> object even if it
                    is present.</para>
                  </listitem>
                </itemizedlist></entry>
            </row>

            <row>
              <entry><code>configuration-pid</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Component.configurationPid--"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>The configuration PID to be used for the component
              in conjunction with Configuration Admin. The default value for
              this attribute is the <code>name</code> of the component, or if
              this is also not specified, the implementation class
              name.</para></entry>
            </row>

            <row>
              <entry><code>activate</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Activate"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>Specifies the name of the method to call when a
              component configuration is activated. The default value of this
              attribute is <code>activate</code>. See <xref
              linkend="i1539155"/> for more information.</para><para>The
              annotation must be applied to the activate method and can only
              be used once.</para></entry>
            </row>

            <row>
              <entry><code>deactivate</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Deactivate"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>Specifies the name of the method to call when a
              component configuration is deactivated. The default value of
              this attribute is <code>deactivate</code>. See <xref
              linkend="i1576028"/> for more information.</para><para>The
              annotation must be applied to the deactivate method and can only
              be used once.</para></entry>
            </row>

            <row>
              <entry><code>modified</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Modified"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>Specifies the name of the method to call when the
              configuration properties for a component configuration is using
              a <code>Configuration</code> object from the Configuration Admin
              service and that <code>Configuration</code> object is modified
              without causing the component configuration to become
              unsatisfied. If this attribute is not specified, then the
              component configuration will become unsatisfied if its
              configuration properties use a <code>Configuration</code> object
              that is modified in any way. See <xref linkend="i1649781"/> for
              more information.</para><para>The annotation must be applied to
              the modified method and can only be used once.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Implementation Element</title>

      <para>The <code>implementation</code> element is required and defines
      the name of the component implementation class. The single attribute is
      defined in the following table.</para>

      <table pgwide="1">
        <title>Implementation Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>class</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para>The Java fully qualified name of the implementation
              class.</para><para>The component <xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> annotation will define the
              <code>implementation</code> element automatically from the type
              it is applied to.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The class is retrieved with the <code>loadClass</code> method of
      the component's bundle. The class must be public and have a public
      constructor without arguments (this is normally the default constructor)
      so component instances may be created by SCR with the
      <code>newInstance</code> method on <code>Class</code>.</para>

      <para>If the component description specifies a service, the class must
      implement all interfaces that are provided by the service.</para>
    </section>

    <section xml:id="i1544128">
      <title>Property Element</title>

      <para>A component description can define a number of properties. These
      can defined inline or from a resource in the bundle. The
      <code>property</code> and <code>properties</code> elements can occur
      multiple times and they can be interleaved. This interleaving is
      relevant because the properties are processed from top to bottom. Later
      properties override earlier properties that have the same name.</para>

      <para>Properties can also be overridden by a Configuration Admin
      service's <code>Configuration</code> object before they are exposed to
      the component or used as service properties. This is described in <xref
      linkend="i1407478"/> and <xref linkend="i1479915"/>.</para>

      <para>The <code>property</code> element has the attributes and
      annotations defined in the following table.</para>

      <table pgwide="1">
        <title>Property Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>name</code></entry>

              <entry><para><code><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.property--"
              xrefstyle="hyperlink"/></code></para></entry>

              <entry><para>The name of the property.</para></entry>
            </row>

            <row>
              <entry><code>value</code></entry>

              <entry><para/></entry>

              <entry><para>The value of the property. This value is parsed
              according to the property type. If the value attribute is
              specified, the body of the element is ignored. If the type of
              the property is not <code>String</code>, parsing of the value is
              done by the static <code>valueOf(String)</code> method in the
              given type. For <code>Character</code> types, the conversion
              must be handled by <code>Integer.valueOf</code> method, a
              Character is always represented by its Unicode
              value.</para></entry>
            </row>

            <row>
              <entry><code>type</code></entry>

              <entry><para/></entry>

              <entry><para>The type of the property. Defines how to interpret
              the value. The type must be one of the following Java
              types:</para><itemizedlist>
                  <listitem>
                    <para><code>String</code> (default)</para>
                  </listitem>

                  <listitem>
                    <para><code>Long</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Double</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Float</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Integer</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Byte</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Character</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Boolean</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Short</code></para>
                  </listitem>
                </itemizedlist></entry>
            </row>

            <row>
              <entry><code>&lt;body&gt;</code></entry>

              <entry><para/></entry>

              <entry><para> If the <code>value</code> attribute is not
              specified, the body of the property element must contain one or
              more values. The value of the property is then an array of the
              specified type. Except for <code>String</code> objects, the
              result will be translated to an array of primitive types. For
              example, if the type attribute specifies <code>Integer</code>,
              then the resulting array must be
              <code>int[]</code>.</para><para>Values must be placed one per
              line and blank lines are ignored. Parsing of the value is done
              by the <code>parse</code> methods in the class identified by the
              type, after trimming the line of any beginning and ending white
              space. <code>String</code> values are also trimmed of beginning
              and ending white space before being placed in the
              array.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, a component that needs an array of hosts can use the
      following property definition:</para>

      <programlisting>&lt;property name="hosts"&gt;
        www.acme.com
        backup.acme.com
&lt;/property&gt;</programlisting>

      <para>This property declaration results in the property hosts, with a
      value of <code>String[] { "www.acme.com", "backup.acme.com"
      }</code>.</para>

      <para>A property can also be set with the <code><xref
      linkend="org.osgi.service.component.annotations.Component.property--"
      xrefstyle="hyperlink"/></code> annotation element of
      <code>Component</code>. This element is an array of strings that must
      follow the following syntax:</para>

      <programlisting>property ::= name ( ':' type )? '=' value</programlisting>

      <para>In this case <code>name</code>, <code>type</code>, and
      <code>value</code> parts map to the attributes of the
      <code>property</code> element. If multiple values must be specified then
      the same name can be repeated multiple times. The annotation does not
      support ordering of properties. For example:</para>

      <programlisting>@Component(property={"foo:Integer=1","foo:Integer=2","foo:Integer=3"})
public class FooImpl {
  ...
}</programlisting>

      <para>The <code>properties</code> element references an entry in the
      bundle whose contents conform to a standard <xref
      linkend="i1567926"/>.</para>

      <para>The entry is read and processed to obtain the properties and their
      values. The properties element attributes are defined in the following
      table.</para>

      <table pgwide="1">
        <title>Properties Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>entry</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.properties--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The entry path relative to the root of the
              bundle</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, to include vendor identification properties that are
      stored in the OSGI-INF directory, the following definition could be
      used:</para>

      <programlisting>&lt;properties entry="OSGI-INF/vendor.properties"/&gt;</programlisting>

      <para>The <code><xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> <xref
      linkend="org.osgi.service.component.annotations.Component.properties--"
      xrefstyle="hyperlink"/></code> element can be used to provide the same
      information, this element consists of an array of strings where each
      string defines an entry. The order within the array is the order that
      must be used for the XML. However, the annotations do not allow mixing
      of the property and properties element.</para>

      <para>For example:</para>

      <programlisting>@Component(properties="OSGI-INF/vendor.properties")</programlisting>
    </section>

    <section>
      <title>Service Element</title>

      <para>The <code>service</code> element is optional. It describes the
      service information to be used when a component configuration is to be
      registered as a service.</para>

      <para>A service element has the following attribute defined in the
      following table.</para>

      <table pgwide="1">
        <title>Service Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>servicefactory</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.servicefactory--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Controls whether the service uses the
              <code>ServiceFactory</code> concept of the OSGi Framework. The
              default value is <code>false</code>. If
              <code>servicefactory</code> is set to <code>true</code>, a
              different component configuration is created, activated and its
              component instance returned as the service object for each
              distinct bundle that requests the service. Each of these
              component configurations has the same component properties.
              Otherwise, the same component instance from the single component
              configuration is returned as the service object for all bundles
              that request the service.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <code>servicefactory</code> attribute must not be
      <code>true</code> if the component is a factory component or an
      immediate component. This is because SCR is not free to create component
      configurations as necessary to support <code>servicefactory</code>. A
      component description is ill-formed if it specifies that the component
      is a factory component or an immediate component and
      <code>servicefactory</code> is set to <code>true</code>.</para>

      <para>The <code>service</code> element must have one or more
      <code>provide</code> elements that define the service interfaces. The
      <code>provide</code> element has the attribute defined in the following
      table.</para>

      <table pgwide="1">
        <title>Provide Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>interface</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.service--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The name of the interface that this service is
              registered under. This name must be the fully qualified name of
              a Java class. For example,
              <code>org.osgi.service.log.LogService</code>. The specified Java
              class should be an interface rather than a class, however
              specifying a class is supported. The component implementation
              class must implement all the specified service
              interfaces.</para><para>The Component annotation can specify the
              provided services, if this element is not specified all directly
              implemented interfaces on the component's type are defined as
              service interfaces. Specifying an empty array indicates that no
              service should be registered.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, a component implements an Event Handler
      service.</para>

      <programlisting>&lt;service&gt;
    &lt;provide interface=
        "org.osgi.service.eventadmin.EventHandler"/&gt;
&lt;/service&gt;</programlisting>

      <para>This previous example can be generated with the following
      annotation:</para>

      <programlisting>@Component
public class Foo implements EventHandler { ... }</programlisting>
    </section>

    <section>
      <title>Reference Element</title>

      <para>A <emphasis>reference</emphasis> declares a dependency that a
      component has on a<emphasis> </emphasis>set of target services. A
      component configuration is not satisfied, unless all its references are
      satisfied. A reference specifies target services by specifying their
      interface and an optional target filter.</para>

      <para>A <code>reference</code> element has the attributes defined in the
      following table.</para>

      <table pgwide="1">
        <title>Reference Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>name</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.name--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The name of the reference. This name is local to
              the component and can be used to locate a bound service of this
              reference with one of the <code>locateService</code> methods of
              <xref linkend="org.osgi.service.component.ComponentContext"
              xrefstyle="hyperlink"/>. Each <code>reference</code> element
              within the component must have a unique name. This
              <code>name</code> attribute is optional. The default value of
              this attribute is the value of the <code>interface</code>
              attribute of this element. If multiple <code>reference</code>
              elements in the component use the same interface name, then
              using the default value for this attribute will result in
              duplicate reference names. In this case, this attribute must be
              specified with a unique name for the reference to avoid an
              error.</para><para>The <code>Reference</code> annotation will
              use the name of the annotated method as the default reference
              name. If the method name begins with <code>bind</code>,
              <code>set</code> or <code>add</code>, that prefix is
              removed.</para></entry>
            </row>

            <row>
              <entry><code>interface</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.service--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Fully qualified name of the class that is used by
              the component to access the service. The service provided to the
              component must be type compatible with this class. That is, the
              component must be able to cast the service object to this class.
              A service must be registered under this name to be considered
              for the set of target services.</para><para>The
              <code>Reference</code> annotation will use the type of the first
              argument of the method it is applied for the
              <code>service</code> value.</para></entry>
            </row>

            <row>
              <entry><code>cardinality</code></entry>

              <entry><para> <xref
              linkend="org.osgi.service.component.annotations.Reference.cardinality--"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferenceCardinality.MANDATORY"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferenceCardinality.OPTIONAL"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferenceCardinality.MULTIPLE"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferenceCardinality.AT_LEAST_ONE"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para> Specifies if the reference is optional and if the
              component implementation support a single bound service or
              multiple bound services. See <xref
              linkend="i1440459"/>.</para></entry>
            </row>

            <row>
              <entry><code>policy</code></entry>

              <entry><para> <xref
              linkend="org.osgi.service.component.annotations.Reference.policy--"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicy.STATIC"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicy.DYNAMIC"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The policy declares the assumption of the component
              about dynamicity. See <xref linkend="i1440474"/>.</para></entry>
            </row>

            <row>
              <entry><code>policy-option</code></entry>

              <entry><para> <xref
              linkend="org.osgi.service.component.annotations.Reference.policyOption--"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicyOption.RELUCTANT"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicyOption.GREEDY"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Defines the policy when a better service becomes
              available. See <xref linkend="i1440474"/>.</para></entry>
            </row>

            <row>
              <entry><code>target</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.target--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>An optional OSGi Framework filter expression that
              further constrains the set of target services. The default is no
              filter, limiting the set of matched services to all service
              registered under the given reference interface. The value of
              this attribute is used to set a target property. See <xref
              linkend="i1547893"/>.</para></entry>
            </row>

            <row>
              <entry><code>bind</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The name of a method in the component
              implementation class that is used to notify that a service is
              bound to the component configuration. For static references,
              this method is only called before the <code>activate</code>
              method. For dynamic references, this method can also be called
              while the component configuration is active. See <xref
              linkend="i1548427"/>.</para><para>The <code>Reference</code>
              annotation will use the method it is applied to as the bind
              method.</para></entry>
            </row>

            <row>
              <entry><code>updated</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.updated--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para> The name of a method in the component
              implementation class that is used to notify that a bound service
              has modified its properties.</para></entry>
            </row>

            <row>
              <entry><code>unbind</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.unbind--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Same as bind, but is used to notify the component
              configuration that the service is unbound. For static
              references, the method is only called after the
              <code>deactivate</code> method. For dynamic references, this
              method can also be called while the component configuration is
              active. See <xref linkend="i1548427"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The following code demonstrates the use of the <code><xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/></code> annotation.</para>

      <programlisting>@Component
public class FooImpl implements Foo {
  @Activate
  void open() { ... }
  @Deactivate
  void close() { ... }

  @Reference( 
    policy = DYNAMIC, 
    policyOption=GREEDY,
    cardinality=MANDATORY )
  void setLog( LogService log) { ... }
  void unsetLog( LogService log) { ... }
  void updatedLog( Map&lt;String,?&gt; ref ) { ... }
}</programlisting>
    </section>
  </section>

  <section xml:id="i1545305">
    <title>Component Life Cycle</title>

    <section xml:id="i1545307">
      <title>Enabled</title>

      <para>A component must first be <emphasis>enabled</emphasis> before it
      can be used. A component cannot be enabled unless the component's bundle
      is started. See <emphasis>Starting Bundles</emphasis> in <xref
      linkend="intro.core.release" xrefstyle="template:%t"/>. All components
      in a bundle become disabled when the bundle is stopped. So the life
      cycle of a component is contained within the life cycle of its
      bundle.</para>

      <para>Every component can be enabled or disabled. The initial enabled
      state of a component is specified in the component description via the
      <code>enabled</code> attribute of the <code>component</code> element.
      See <xref linkend="i1441045"/>. Component configurations can be created,
      satisfied and activated only when the component is enabled.</para>

      <para>The enabled state of a component can be controlled with the
      Component Context <xref
      linkend="org.osgi.service.component.ComponentContext.enableComponent-String-"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.component.ComponentContext.disableComponent-String-"
      xrefstyle="hyperlink"/> methods. The purpose of later enabling a
      component is to be able to decide programmatically when a component can
      become enabled. For example, an immediate component can perform some
      initialization work before other components in the bundle are enabled.
      The component descriptions of all other components in the bundle can be
      disabled by having <code>enabled</code> set to <code>false</code> in
      their component descriptions. After any necessary initialization work is
      complete, the immediate component can call <code>enableComponent</code>
      to enable the remaining components.</para>

      <para>The <code>enableComponent</code> and <code>disableComponent</code>
      methods must return after changing the enabled state of the named
      component. Any actions that result from this, such as activating or
      deactivating a component configuration, must occur asynchronously to the
      method call. Therefore a component can disable itself.</para>

      <para>All components in a bundle can be enabled by passing a
      <code>null</code> as the argument to
      <code>enableComponent</code>.</para>
    </section>

    <section>
      <title>Satisfied</title>

      <para>Component configurations can only be activated when the component
      configuration is <emphasis>satisfied</emphasis>. A component
      configuration becomes satisfied when the following conditions are all
      satisfied:</para>

      <itemizedlist>
        <listitem>
          <para>The component is <emphasis>enabled</emphasis>.</para>
        </listitem>

        <listitem>
          <para>If the component description specifies
          <code>configuration-policy=required</code>, then a
          <code>Configuration</code> object for the component is present in
          the Configuration Admin service.</para>
        </listitem>

        <listitem>
          <para>Using the component properties of the component configuration,
          all the component's references are satisfied. A reference is
          satisfied when the reference specifies optional cardinality or there
          is at least one target service for the reference.</para>
        </listitem>
      </itemizedlist>

      <para>Once any of the listed conditions are no longer true, the
      component configuration becomes <emphasis>unsatisfied</emphasis>. An
      activated component configuration that becomes unsatisfied must be
      deactivated.</para>
    </section>

    <section>
      <title>Immediate Component</title>

      <para>A component is an immediate component when it must be activated as
      soon as its dependencies are satisfied. Once the component configuration
      becomes unsatisfied, the component configuration must be deactivated. If
      an immediate component configuration is satisfied and specifies a
      service, SCR must register the component configuration as a service in
      the service registry and then activate the component configuration. The
      service properties for this registration consist of the component
      properties as defined in <xref linkend="i1629621"/>.</para>

      <para>The state diagram is shown in <xref linkend="i1445265"/>.</para>

      <figure xml:id="i1445265">
        <title>Immediate Component Configuration</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.443in"
                       contentwidth="7.000in"
                       fileref="immediate-configuration.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Delayed Component</title>

      <para>A key attribute of a delayed component is the delaying of class
      loading and object creation. Therefore, the activation of a delayed
      component configuration does not occur until there is an actual request
      for a service object. A component is a delayed component when it
      specifies a service but it is not a factory component and does not have
      the <code>immediate</code> attribute of the <code>component</code>
      element set to <code>true</code>.</para>

      <para>SCR must register a service after the component configuration
      becomes satisfied. The registration of this service must look to
      observers of the service registry as if the component's bundle actually
      registered this service. This strategy makes it possible to register
      services without creating a class loader for the bundle and loading
      classes, thereby allowing reduction in initialization time and a delay
      in memory footprint.</para>

      <para>When SCR registers the service on behalf of a component
      configuration, it must avoid causing a class load to occur from the
      component's bundle. SCR can ensure this by registering a
      <code>ServiceFactory</code> object with the Framework for that service.
      By registering a <code>ServiceFactory</code> object, the actual service
      object is not needed until the <code>ServiceFactory</code> is called to
      provide the service object. The service properties for this registration
      consist of the component properties as defined in <xref
      linkend="i1629621"/>.</para>

      <para>The activation of a component configuration must be delayed until
      its service is requested. When the service is requested, if the service
      has the <code>servicefactory</code> attribute set to <code>true</code>,
      SCR must create and activate a unique component configuration for each
      bundle requesting the service. Otherwise, SCR must activate a single
      component configuration which is used by all bundles requesting the
      service. A component instance can determine the bundle it was activated
      for by calling the <xref
      linkend="org.osgi.service.component.ComponentContext.getUsingBundle--"
      xrefstyle="hyperlink"/> method on the Component Context.</para>

      <para>The activation of delayed components is depicted in a state
      diagram in <xref linkend="i1462979"/>. Notice that multiple component
      configurations can be created from the <code>REGISTERED</code> state if
      a delayed component specifies <code>servicefactory</code> set to
      <code>true</code>.</para>

      <para>If the service registered by a component configuration becomes
      unused because there are no more bundles using it, then SCR should
      deactivate that component configuration. This allows SCR implementations
      to eagerly reclaim activated component configurations.</para>

      <figure xml:id="i1462979">
        <title>Delayed Component Configuration</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.979in"
                       contentwidth="7.000in"
                       fileref="delayed-configuration.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Factory Component</title>

      <para>SCR must register a Component Factory service as soon as the
      <emphasis>component factory</emphasis> becomes satisfied. The component
      factory is satisfied when the following conditions are all
      satisfied:</para>

      <itemizedlist>
        <listitem>
          <para>The component is enabled.</para>
        </listitem>

        <listitem>
          <para>Using the component properties specified by the component
          description, all the component's references are satisfied. A
          reference is satisfied when the reference specifies optional
          cardinality or there is at least one target service for the
          reference</para>
        </listitem>
      </itemizedlist>

      <para>The component factory, however, does not use any of the target
      services and does not bind to them.</para>

      <para>Once any of the listed conditions are no longer true, the
      component factory becomes unsatisfied and the Component Factory service
      must be unregistered. Any component configurations activated via the
      component factory are unaffected by the unregistration of the Component
      Factory service, but may themselves become unsatisfied for the same
      reason.</para>

      <para>The Component Factory service must be registered under the name
      <code>org.osgi.service.component.ComponentFactory</code> with the
      following service properties:</para>

      <itemizedlist>
        <listitem>
          <para><code>component.name</code> - The name of the
          component.</para>
        </listitem>

        <listitem>
          <para><code>component.factory</code> - The value of the
          <code>factory</code> attribute.</para>
        </listitem>
      </itemizedlist>

      <para>The service properties of the Component Factory service must not
      include the component properties.</para>

      <para>New component configurations are created and activated when the
      <code>newInstance</code> method of the Component Factory service is
      called. If the component description specifies a service, the component
      configuration is registered as a service under the provided interfaces.
      The service properties for this registration consist of the component
      properties as defined in <xref linkend="i1629621"/>. The service
      registration must take place before the component configuration is
      activated. Service unregistration must take place before the component
      configuration is deactivated.</para>

      <figure>
        <title>Factory Component</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.929in"
                       contentwidth="7.000in" fileref="factory-component.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A Component Factory service has a single method: <xref
      linkend="org.osgi.service.component.ComponentFactory.newInstance-Dictionary-"
      xrefstyle="hyperlink"/>. This method must create, satisfy and activate a
      new component configuration and register its component instance as a
      service if the component description specifies a service. It must then
      return a <xref linkend="org.osgi.service.component.ComponentInstance"
      xrefstyle="hyperlink"/> object. This <xref
      linkend="org.osgi.service.component.ComponentInstance"
      xrefstyle="hyperlink"/> object can be used to get the component instance
      with the <xref
      linkend="org.osgi.service.component.ComponentInstance.getInstance--"
      xrefstyle="hyperlink"/> method.</para>

      <para>SCR must attempt to satisfy the component configuration created by
      <code>newInstance</code> before activating it. If SCR is unable to
      satisfy the component configuration given the component properties and
      the Dictionary argument to <code>newInstance</code>, the
      <code>newInstance</code> method must throw a
      <code>ComponentException</code>.</para>

      <para>The client of the Component Factory service can also deactivate a
      component configuration with the <xref
      linkend="org.osgi.service.component.ComponentInstance.dispose--"
      xrefstyle="hyperlink"/> method on the <xref
      linkend="org.osgi.service.component.ComponentInstance"
      xrefstyle="hyperlink"/> object. If the component configuration is
      already deactivated, or is being deactivated, then this method is
      ignored. Also, if the component configuration becomes unsatisfied for
      any reason, it must be deactivated by SCR.</para>

      <para>Once a component configuration created by the Component Factory
      has been deactivated, that component configuration will not be
      reactivated or used again.</para>
    </section>

    <section>
      <title>Activation</title>

      <para>Activating a component configuration consists of the following
      steps:</para>

      <orderedlist>
        <listitem>
          <para>Load the component implementation class.</para>
        </listitem>

        <listitem>
          <para>Create the component instance and component context.</para>
        </listitem>

        <listitem>
          <para>Bind the target services. See <xref
          linkend="i1536739"/>.</para>
        </listitem>

        <listitem>
          <para>Call the activate method, if present. See <xref
          linkend="i1539155"/>.</para>
        </listitem>
      </orderedlist>

      <para>Component instances must never be reused. Each time a component
      configuration is activated, SCR must create a new component instance to
      use with the activated component configuration. A component instance
      must complete activation before it can be deactivated. Once the
      component configuration is deactivated or fails to activate due to an
      exception, SCR must unbind all the component's bound services and
      discard all references to the component instance associated with the
      activation.</para>
    </section>

    <section xml:id="i1536739">
      <title>Binding Services</title>

      <para>When a component configuration's reference is satisfied, there is
      a set of zero or more target services for that reference. When the
      component configuration is activated, a subset of the target services
      for each reference are bound to the component configuration. The subset
      is chosen by the cardinality of the reference. See <xref
      linkend="i1440459"/>.</para>

      <para>When binding services, the references are processed in the order
      in which they are specified in the component description. That is,
      target services from the first specified reference are bound before
      services from the next specified reference.</para>

      <para>For each reference using the event strategy, the bind method must
      be called for each bound service of that reference. This may result in
      activating a component configuration of the bound service which could
      result in an exception. If the loss of the bound service due to the
      exception causes the reference's cardinality constraint to be violated,
      then activation of this component configuration will fail. Otherwise the
      bound service which failed to activate will be considered unbound. If a
      bind method throws an exception, SCR must log an error message
      containing the exception with the Log Service, if present, but the
      activation of the component configuration does not fail.</para>
    </section>

    <section xml:id="i1539155">
      <title>Activate Method</title>

      <para>A component instance can have an activate method. The name of the
      activate method can be specified by the <code>activate</code> attribute.
      See <xref linkend="i1441045"/>. If the <code>activate</code> attribute
      is not specified, the default method name of <code>activate</code> is
      used. The prototype of the activate method is:</para>

      <programlisting>void &lt;method-name&gt;(&lt;arguments&gt;);</programlisting>

      <para>The activate method can take zero or more arguments. Each argument
      must be of one of the following types:</para>

      <itemizedlist>
        <listitem>
          <para><code>ComponentContext</code> - The component instance will be
          passed the Component Context for the component configuration.</para>
        </listitem>

        <listitem>
          <para><code>BundleContext</code> - The component instance will be
          passed the Bundle Context of the component's bundle.</para>
        </listitem>

        <listitem>
          <para><code>Map</code> - The component instance will be passed an
          unmodifiable Map containing the component properties.</para>
        </listitem>
      </itemizedlist>

      <para>A suitable method is selected using the following priority:</para>

      <orderedlist>
        <listitem>
          <para>The method takes a single argument and the type of the
          argument is
          <code>org.osgi.service.component.ComponentContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single argument and the type of the
          argument is <code>org.osgi.framework.BundleContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single argument and the type of the
          argument is the <code>java.util.Map</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes two or more arguments and the type of each
          argument must be
          <code>org.osgi.service.component.ComponentContext</code>,
          <code>org.osgi.framework.BundleContext</code> or
          <code>java.util.Map</code>. If multiple methods match this rule,
          this implies the method name is overloaded and SCR may choose any of
          the methods to call.</para>
        </listitem>

        <listitem>
          <para>The method takes zero arguments.</para>
        </listitem>
      </orderedlist>

      <para>When searching for the activate method to call, SCR must locate a
      suitable method as specified in <xref linkend="i1641644"/>. If the
      <code>activate</code> attribute is specified and no suitable method is
      located, SCR must log an error message with the Log Service, if present,
      and the component configuration is not activated.</para>

      <para>If an activate method is located, SCR must call this method to
      complete the activation of the component configuration. If the activate
      method throws an exception, SCR must log an error message containing the
      exception with the Log Service, if present, and the component
      configuration is not activated.</para>
    </section>

    <section>
      <title>Component Context</title>

      <para>The Component Context is made available to a component instance
      via the <code>activate</code> and <code>deactivate</code> methods. It
      provides the interface to the execution context of the component, much
      like the Bundle Context provides a bundle the interface to the
      Framework. A Component Context should therefore be regarded as a
      capability and not shared with other components or bundles.</para>

      <para>Each distinct component instance receives a unique Component
      Context. Component Contexts are not reused and must be discarded when
      the component configuration is deactivated.</para>
    </section>

    <section xml:id="i1651072">
      <title>Bound Service Replacement</title>

      <para>If an active component configuration has a dynamic reference with
      unary cardinality and the bound service is modified or unregistered and
      ceases to be a target service, or the <code>policy-option</code> is
      <code>greedy</code> and a better target service becomes available then
      SCR must attempt to replace the bound service with a new target service.
      SCR must first bind a replacement target service and then unbind the
      outgoing service. This reversed order allows the component to not having
      to handle the inevitable gap between the unbind and bind methods.
      However, this means that in the unbind method care must be taken to not
      overwrite the newly bound service. For example, the following code
      handles the associated concurrency issues and simplify handling the
      reverse order.</para>

      <programlisting>final AtomicReference&lt;LogService&gt; log =new AtomicReference&lt;LogService&gt;();

void setLogService( LogService log ) {
    this.log.set(log);
}
void unsetLogService( LogService log ) {
    this.log.compareAndSet(log,null);
}</programlisting>

      <para>If the dynamic reference has a mandatory cardinality and no
      replacement target service is available, the component configuration
      must be deactivated because the cardinality constraints will be
      violated.</para>

      <para>If a component configuration has a static reference and a bound
      service is modified or unregistered and ceases to be a target service,
      or the <code>policy-option</code> is <code>greedy</code> and a better
      target service becomes available then SCR must deactivate the component
      configuration. Afterwards, SCR must attempt to activate the component
      configuration again if another target service can be used as a
      replacement for the outgoing service.</para>
    </section>

    <section>
      <title>Updated method</title>

      <para>If an active component is bound to a service that modifies it
      properties then the component can be notified with the update method
      specified on the <code>reference</code> element. This method can be
      called with a Service Reference or a Map to supply the updated service
      properties.</para>
    </section>

    <section xml:id="i1652198">
      <title>Modification</title>

      <para>Modifying a component configuration can occur if the component
      description specifies the <code>modified</code> attribute and the
      component properties of the component configuration use a
      <code>Configuration</code> object from the Configuration Admin service
      and that <code>Configuration</code> object is modified without causing
      the component configuration to become unsatisfied. If this occurs, the
      component instance will be notified of the change in the component
      properties.</para>

      <para>If the <code>modified</code> attribute is not specified, then the
      component configuration will become unsatisfied if its component
      properties use a <code>Configuration</code> object and that
      Configuration object is modified in any way.</para>

      <para>Modifying a component configuration consists of the following
      steps:</para>

      <orderedlist>
        <listitem>
          <para>Update the component context for the component configuration
          with the modified configuration properties.</para>
        </listitem>

        <listitem>
          <para>Call the modified method. See <xref
          linkend="i1649781"/>.</para>
        </listitem>

        <listitem>
          <para>Modify the bound services for the dynamic references if the
          set of target services changed due to changes in the target
          properties. See <xref linkend="i1651072"/>.</para>
        </listitem>

        <listitem>
          <para>If the component configuration is registered as a service,
          modify the service properties.</para>
        </listitem>
      </orderedlist>

      <para>A component instance must complete activation, or a previous
      modification, before it can be modified.</para>

      <para>See <xref linkend="i1649746"/> for more information.</para>
    </section>

    <section xml:id="i1649781">
      <title>Modified Method</title>

      <para>The name of the modified method is specified by the
      <code>modified</code> attribute. See <xref linkend="i1441045"/>. The
      prototype and selection priority of the modified method is identical to
      that of the activate method. See <xref linkend="i1539155"/>.</para>

      <para>SCR must locate a suitable method as specified in <xref
      linkend="i1641644"/>. If the <code>modified</code> attribute is
      specified and no suitable method is located, SCR must log an error
      message with the Log Service, if present, and the component
      configuration becomes unsatisfied and is deactivated as if the
      <code>modified</code> attribute was not specified.</para>

      <para>If a modified method is located, SCR must call this method to
      notify the component configuration of changes to the component
      properties. If the modified method throws an exception, SCR must log an
      error message containing the exception with the Log Service, if present
      and continue processing the modification.</para>
    </section>

    <section xml:id="i1649517">
      <title>Deactivation</title>

      <para>Deactivating a component configuration consists of the following
      steps:</para>

      <orderedlist>
        <listitem>
          <para>Call the deactivate method, if present. See <xref
          linkend="i1576028"/>.</para>
        </listitem>

        <listitem>
          <para>Unbind any bound services. See <xref
          linkend="i1543088"/>.</para>
        </listitem>

        <listitem>
          <para>Release all references to the component instance and component
          context.</para>
        </listitem>
      </orderedlist>

      <para>A component instance must complete activation or modification
      before it can be deactivated. A component configuration can be
      deactivated for a variety of reasons. The deactivation reason can be
      received by the deactivate method. The following reason values are
      defined:</para>

      <itemizedlist>
        <listitem>
          <para>0 - Unspecified.</para>
        </listitem>

        <listitem>
          <para>1 - The component was disabled.</para>
        </listitem>

        <listitem>
          <para>2 - A reference became unsatisfied.</para>
        </listitem>

        <listitem>
          <para>3 - A configuration was changed.</para>
        </listitem>

        <listitem>
          <para>4 - A configuration was deleted.</para>
        </listitem>

        <listitem>
          <para>5 - The component was disposed.</para>
        </listitem>

        <listitem>
          <para>6 - The bundle was stopped.</para>
        </listitem>
      </itemizedlist>

      <para>Once the component configuration is deactivated, SCR must discard
      all references to the component instance and component context
      associated with the activation.</para>
    </section>

    <section xml:id="i1576028">
      <title>Deactivate Method</title>

      <para>A component instance can have a deactivate method. The name of the
      deactivate method can be specified by the <code>deactivate</code>
      attribute. See <xref linkend="i1441045"/>. If the
      <code>deactivate</code> attribute is not specified, the default method
      name of <code>deactivate</code> is used. The prototype of the deactivate
      method is:</para>

      <programlisting>void &lt;method-name&gt;(&lt;arguments&gt;);</programlisting>

      <para>The deactivate method can take zero or more arguments. Each
      argument must be assignable from one of the following types:</para>

      <itemizedlist>
        <listitem>
          <para><code>ComponentContext</code> - The component instance will be
          passed the Component Context for the component.</para>
        </listitem>

        <listitem>
          <para><code>BundleContext</code> - The component instance will be
          passed the Bundle Context of the component's bundle.</para>
        </listitem>

        <listitem>
          <para><code>Map</code> - The component instance will be passed an
          unmodifiable Map containing the component properties.</para>
        </listitem>

        <listitem>
          <para><code>int</code> or <code>Integer</code> - The component
          instance will be passed the reason the component configuration is
          being deactivated. See <xref linkend="i1649517"/>.</para>
        </listitem>
      </itemizedlist>

      <para>A suitable method is selected using the following priority:</para>

      <orderedlist>
        <listitem>
          <para>The method takes a single argument and the type of the
          argument is
          <code>org.osgi.service.component.ComponentContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single argument and the type of the
          argument is <code>org.osgi.framework.BundleContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single argument and the type of the
          argument is the <code>java.util.Map</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single argument and the type of the
          argument is the <code>int</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single argument and the type of the
          argument is the <code>java.lang.Integer</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes two or more arguments and the type of each
          argument must be
          <code>org.osgi.service.component.ComponentContext</code>,
          <code>org.osgi.framework.BundleContext</code>,
          <code>java.util.Map</code>, <code>int</code> or
          <code>java.lang.Integer</code>. If multiple methods match this rule,
          this implies the method name is overloaded and SCR may choose any of
          the methods to call.</para>
        </listitem>

        <listitem>
          <para>The method takes zero arguments.</para>
        </listitem>
      </orderedlist>

      <para>When searching for the deactivate method to call, SCR must locate
      a suitable method as specified in <xref linkend="i1641644"/>. If the
      <code>deactivate</code> attribute is specified and no suitable method is
      located, SCR must log an error message with the Log Service, if present,
      and the deactivation of the component configuration will
      continue.</para>

      <para>If a deactivate method is located, SCR must call this method to
      commence the deactivation of the component configuration. If the
      deactivate method throws an exception, SCR must log an error message
      containing the exception with the Log Service, if present, and the
      deactivation of the component configuration will continue.</para>
    </section>

    <section xml:id="i1543088">
      <title>Unbinding</title>

      <para>When a component configuration is deactivated, the bound services
      are unbound from the component configuration.</para>

      <para>When unbinding services, the references are processed in the
      reverse order in which they are specified in the component description.
      That is, target services from the last specified reference are unbound
      before services from the previous specified reference.</para>

      <para>For each reference using the event strategy, the unbind method
      must be called for each bound service of that reference. If an unbind
      method throws an exception, SCR must log an error message containing the
      exception with the Log Service, if present, and the deactivation of the
      component configuration will continue.</para>
    </section>

    <section>
      <title>Life Cycle Example</title>

      <para>A component could declare a dependency on the Http Service to
      register some resources.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.binding"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.2.0"&gt;
    &lt;implementation class="example.Binding"/&gt;
    &lt;reference name="LOG"
        interface="org.osgi.service.log.LogService"
        cardinality="1..1"
        policy="static"
    /&gt;   
    &lt;reference name="HTTP"
        interface="org.osgi.service.http.HttpService"
        cardinality="0..1"
        policy="dynamic"
        bind="setHttp"
        unbind="unsetHttp"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component implementation code looks like:</para>

      <programlisting>public class Binding {
    LogService  log;
    HttpService http;

    private void setHttp(HttpService h) { 
        this.http = h; 
        // register servlet
    }
    private void unsetHttp(HttpService h){ 
        this.h = null;
        // unregister servlet 
    }
    private void activate(ComponentContext context ) {.
     log = (LogService) context.locateService("LOG");
    }
    private void deactivate(ComponentContext context ){...}
}</programlisting>

      <para>This example is depicted in a sequence diagram in <xref
      linkend="i1567615"/>. with the following scenario:</para>

      <orderedlist>
        <listitem>
          <para>A bundle with the <code>example.Binding</code> component is
          started. At that time there is a Log Service <code>l1</code> and a
          Http Service <code>h1</code> registered.</para>
        </listitem>

        <listitem>
          <para>The Http Service <code>h1</code> is unregistered</para>
        </listitem>

        <listitem>
          <para>A new Http Service <code>h2</code> is registered</para>
        </listitem>

        <listitem>
          <para>The Log Service <code>h1</code> is unregistered.</para>
        </listitem>
      </orderedlist>

      <figure xml:id="i1567615">
        <title>Sequence Diagram for binding</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="3.062in"
                       contentwidth="7.000in" fileref="binding-sequence.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section xml:id="i1407478">
    <title>Component Properties</title>

    <para>Each component configuration is associated with a set of component
    properties. The component properties are specified in the following places
    (in order of precedence):</para>

    <orderedlist>
      <listitem>
        <para>Properties specified in the argument of
        <code>ComponentFactory.newInstance</code> method. This is only
        applicable for factory components.</para>
      </listitem>

      <listitem>
        <para>Properties retrieved from the OSGi Configuration Admin service
        with a Configuration object that has a PID equal to the
        <emphasis>configuration PID</emphasis>. The configuration PID is the
        component name, or when specified, the <code>configuration-pid</code>
        attribute.</para>
      </listitem>

      <listitem>
        <para>Properties specified in the component description. Properties
        specified later in the component description override properties that
        have the same name specified earlier. Properties can be specified in
        the component description in the following ways:</para>

        <itemizedlist>
          <listitem>
            <para><code>target</code> attribute of <code>reference</code>
            elements - Sets a component property called the <emphasis>target
            property</emphasis> of the reference. The key of a target property
            is the name of the reference appended with <code>.target</code>.
            The value of a target property is the value of the
            <code>target</code> attribute. For example, a reference with the
            name <code>http</code> whose <code>target</code> attribute has the
            value "<code>(http.port=80)</code>" results in the component
            property having the name <code>http.target</code> and value
            "<code>(http.port=80)</code>". See <xref linkend="i1547893"/>. The
            target property can also be set wherever component properties can
            be set.</para>
          </listitem>

          <listitem>
            <para><code>property</code> and <code>properties</code> elements -
            See <xref linkend="i1544128"/>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </orderedlist>

    <para>The precedence behavior allows certain default values to be
    specified in the component description while allowing properties to be
    replaced and extended by:</para>

    <itemizedlist>
      <listitem>
        <para>A configuration in Configuration Admin</para>
      </listitem>

      <listitem>
        <para>The argument to <code>ComponentFactory.newInstance</code>
        method</para>
      </listitem>
    </itemizedlist>

    <para>SCR always adds the following component properties, which cannot be
    overridden:</para>

    <itemizedlist>
      <listitem>
        <para><code>component.name</code> - The component name.</para>
      </listitem>

      <listitem>
        <para><code>component.id</code> - A unique value ( <code>Long</code>)
        that is larger than all previously assigned values. These values are
        not persistent across restarts of SCR.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="i1629621">
      <title>Service Properties</title>

      <para>When SCR registers a service on behalf of a component
      configuration, SCR must follow the recommendations in <xref
      linkend="service.cm.propertypropagation"/> and must not propagate
      private configuration properties. That is, the service properties of the
      registered service must be all the component properties of the component
      configuration whose property names do not start with full stop
      (<code>'.' \u002E</code>).</para>

      <para>Component properties whose names start with full stop are
      available to the component instance but are not available as service
      properties of the registered service.</para>
    </section>
  </section>

  <section xml:id="i1479915">
    <title>Deployment</title>

    <para>A component description contains default information to select
    target services for each reference. However, when a component is deployed,
    it is often necessary to influence the target service selection in a way
    that suits the needs of the deployer. Therefore, SCR uses
    <code>Configuration</code> objects from Configuration Admin to replace and
    extend the component properties for a component configuration. That is,
    through Configuration Admin, a deployer can configure component
    properties.</para>

    <para>The configuration PID is used as the key for obtaining additional
    component properties from Configuration Admin. The following situations
    can arise:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>No Configuration</emphasis> - If the component's
        <code>configuration-policy</code> is set to <code>ignore</code> or
        there is no Configuration with a PID or factory PID equal to the
        configuration PID, then component configurations will not obtain
        component properties from Configuration Admin. Only component
        properties specified in the component description or via the
        <code>ComponentFactory.newInstance</code> method will be used.</para>
      </listitem>

      <listitem>
        <para><emphasis>Not Satisfied</emphasis> - If the component's
        <code>configuration-policy</code> is set to <code>require</code> and
        there is no Configuration with a PID or factory PID equal to the
        configuration PID, then the component configuration is not satisfied
        and will not be activated.</para>
      </listitem>

      <listitem>
        <para><emphasis>Single Configuration</emphasis> - If there exists a
        Configuration with a PID equal to the configuration PID, then
        component configurations will obtain additional component properties
        from Configuration Admin.</para>
      </listitem>

      <listitem>
        <para><emphasis>Factory Configuration</emphasis> - If a factory PID
        exists, with zero or more Configurations, that is equal to the
        configuration PID, then for each Configuration, a component
        configuration must be created that will obtain additional component
        properties from Configuration Admin.</para>
      </listitem>
    </itemizedlist>

    <para>A factory configuration must not be used if the component is a
    factory component. This is because SCR is not free to create component
    configurations as necessary to support multiple
    <code>Configuration</code>s. When SCR detects this condition, it must log
    an error message with the Log Service, if present, and ignore the
    component description.</para>

    <para>SCR must obtain the <code>Configuration</code> objects from the
    Configuration Admin service using the Bundle Context of the bundle
    containing the component.</para>

    <para>For example, there is a component named <code>com.acme.client</code>
    with a reference named <code>HTTP</code> that requires an Http Service
    which must be bound to a component <code>com.acme.httpserver</code> which
    provides an Http Service. A deployer can establish the following
    configuration:</para>

    <programlisting>[PID=com.acme.client, factoryPID=null]
HTTP.target = (component.name=com.acme.httpserver)</programlisting>

    <section xml:id="i1649746">
      <title>Configuration Changes</title>

      <para>SCR must track changes in the <code>Configuration</code> objects
      <emphasis>matching</emphasis> the configuration PID of the component
      description. Changes include the creating, updating and deleting of
      matching <code>Configuration</code> objects. The actions SCR must take
      when a configuration change for a component description occurs are based
      upon how the <code>configuration-policy</code> and <code>modified</code>
      attributes are specified in the component description, whether a
      component configuration becomes satisfied, remains satisfied or becomes
      unsatisfied and the type and number of matching
      <code>Configuration</code> objects.</para>

      <section>
        <title>Ignore Configuration Policy</title>

        <para>For <code>configuration-policy</code> of <code>ignore</code>,
        component configurations are unaffected by configuration changes since
        the component properties do not include properties from
        <code>Configuration</code> objects.</para>
      </section>

      <section>
        <title>Require Configuration Policy</title>

        <para>For <code>configuration-policy</code> of <code>require</code>,
        component configurations require a <code>Configuration</code> object.
        With a factory configuration, there can be zero or more matching
        <code>Configuration</code> objects which will result in a component
        configuration for each <code>Configuration</code> object. With a
        factory component, multiple component configurations can be created
        all using a single matching <code>Configuration</code> object.</para>

        <para>Deleting a <code>Configuration</code> object will cause the
        component configurations using it to become unsatisfied. Updating a
        <code>Configuration</code> object can cause the component
        configurations using it to become unsatisfied if any of the following
        occur:</para>

        <itemizedlist>
          <listitem>
            <para>A target property change results in a bound service of a
            static reference ceasing to be a target service.</para>
          </listitem>

          <listitem>
            <para>A target property change results in unbound target services
            for a static reference with the <code>greedy</code> policy
            option.</para>
          </listitem>

          <listitem>
            <para>A target property change results in there being zero target
            services for a mandatory dynamic reference.</para>
          </listitem>

          <listitem>
            <para>The component description does not specify the
            <code>modified</code> attribute.</para>
          </listitem>
        </itemizedlist>

        <para>If a component configuration becomes unsatisfied, SCR must
        deactivate the component configuration. If the component configuration
        was not created from a factory component, SCR must attempt to satisfy
        the component configuration with the updated component
        properties.</para>

        <para>If a component configuration remains satisfied and had been
        activated, the modified method is called. See <xref
        linkend="i1652198"/> for more information. If a component
        configuration remains satisfied but has not been activated, then, if
        the component configuration is registered as a service, SCR must
        modify the service properties.</para>
      </section>

      <section>
        <title>Optional Configuration Policy</title>

        <para>For <code>configuration-policy</code> of <code>optional</code>,
        component configurations do not require a <code>Configuration</code>
        object. Since a matching <code>Configuration</code> object is
        optional, component configurations can be satisfied when there is no
        matching <code>Configuration</code> object. If a matching
        <code>Configuration</code> object is then created, this is a
        configuration change for the component configurations that are not
        using a <code>Configuration</code> object. When there is only a single
        matching <code>Configuration</code> object which is then deleted, this
        is a configuration change for the component configurations using the
        deleted <code>Configuration</code> object.</para>

        <para>With a factory configuration, there can be zero or more matching
        <code>Configuration</code> objects which will result in a component
        configuration for each <code>Configuration</code> object as well as a
        single component configuration when there are zero matching
        <code>Configuration</code> objects. With a factory component, multiple
        component configurations can be created all using either a single
        matching <code>Configuration</code> object or no
        <code>Configuration</code> object when there is no matching
        <code>Configuration</code> object.</para>

        <para>A configuration change can cause a component configuration to
        become unsatisfied if any of the following occur:</para>

        <itemizedlist>
          <listitem>
            <para>A target property change results in a bound service of a
            static reference ceasing to be a target service.</para>
          </listitem>

          <listitem>
            <para>A target property change results in unbound target services
            for a static reference with the <code>greedy</code> policy
            option.</para>
          </listitem>

          <listitem>
            <para>A target property change results in there being zero target
            services for a mandatory dynamic reference.</para>
          </listitem>

          <listitem>
            <para>The component description does not specify the
            <code>modified</code> attribute.</para>
          </listitem>
        </itemizedlist>

        <para>If a component configuration becomes unsatisfied, SCR must
        deactivate the component configuration. If the component configuration
        was not created from a factory component, SCR must attempt to satisfy
        the component configuration with the updated component
        properties.</para>

        <para>If a component configuration remains satisfied and had been
        activated, the modified method is called. See <xref
        linkend="i1652198"/> for more information. If a component
        configuration remains satisfied but has not been activated, then, if
        the component configuration is registered as a service, SCR must
        modify the service properties.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Use of the Annotations</title>

    <para>The Declarative Services Annotations provide a convenient way to
    create the component description XML during build time. Since annotations
    are placed in the source file and can use types, fields, and methods they
    can significantly simplify the use of Declarative Services.</para>

    <para>The Declarative Services Annotations are build time annotations
    because one of the key aspect of Declarative Services is its laziness.
    Implementations can easily read the component description XML from the
    bundle, pre-process it, and cache the results between framework
    invocations. This is way it is unnecessary to create a class on the bundle
    when the bundle is started and/or scan the classes for annotations.</para>

    <para>The Declarative Services Annotations are not inherited, they can
    only be used on a given class, annotations on its super class hierarchy or
    interfaces are not taken into account.</para>

    <para>The primary annotation is the <xref
    linkend="org.osgi.service.component.annotations.Component"
    xrefstyle="hyperlink"/> annotation. It indicates that a class is a
    component. It's defaults create the easiest to use component:</para>

    <itemizedlist>
      <listitem>
        <para>Its name is the class name</para>
      </listitem>

      <listitem>
        <para>It registers all directly implemented interfaces as
        services</para>
      </listitem>

      <listitem>
        <para>The instance will be shared by all bundles</para>
      </listitem>

      <listitem>
        <para>It is enabled</para>
      </listitem>

      <listitem>
        <para>It is immediate if it has no services, otherwise it is
        delayed</para>
      </listitem>

      <listitem>
        <para>It has an optional configuration policy</para>
      </listitem>

      <listitem>
        <para>The configuration PID is the class name</para>
      </listitem>
    </itemizedlist>

    <para>For example, the following class registers a Speech service that can
    run on a Macintosh:</para>

    <programlisting>pubic interface Speech {
  void say(String what) throws Exception;
}

@Component
public class MacSpeech implements Speech {
    ScriptEngine engine = 
        new ScriptEngineManager().getEngineByName("AppleScript");
    
    public void say(String message) throws Exception {
        engine.eval("say \"" + message.replace('"','\'' + "\"");
    }
}</programlisting>

    <para>The previous example must generate the following XML:</para>

    <programlisting>&lt;scr:component name='com.example.MacSpeech'&gt;
  &lt;implementation class='com.example.MacSpeech'/&gt;
  &lt;service&gt;
    &lt;provide interface='com.example.service.speech.Speech'/&gt;
  &lt;/service&gt;
&lt;/component&gt;</programlisting>

    <para>It is possible to add activate and deactivate methods on the
    component with the <xref
    linkend="org.osgi.service.component.annotations.Activate"
    xrefstyle="hyperlink"/> and <xref
    linkend="org.osgi.service.component.annotations.Deactivate"
    xrefstyle="hyperlink"/> annotations. If the component wants to be updated
    for changes in the configuration properties than it can also indicated the
    modified method with the <xref
    linkend="org.osgi.service.component.annotations.Modified"
    xrefstyle="hyperlink"/> annotation. For example:</para>

    <programlisting>@Activate
void open(Map&lt;String,?&gt; properties) { ... }

@Deactivate
void close() { ... }

@Modified
void modified(Map&lt;String,?&gt; properties) { ... }</programlisting>

    <para>If a component has dependencies on other services then they can be
    referenced with the <xref
    linkend="org.osgi.service.component.annotations.Reference"
    xrefstyle="hyperlink"/> annotation that is applied to the bind method. The
    defaults for the reference annotations are:</para>

    <itemizedlist>
      <listitem>
        <para>The name of the bind method is used for the name of the
        reference.</para>
      </listitem>

      <listitem>
        <para>1:1 Cardinality.</para>
      </listitem>

      <listitem>
        <para>Static reluctant policy.</para>
      </listitem>

      <listitem>
        <para>The requested service is the type of the first argument of the
        method the <xref
        linkend="org.osgi.service.component.annotations.Reference"
        xrefstyle="hyperlink"/> annotation is applied to.</para>
      </listitem>

      <listitem>
        <para>It will infer a default unset method and updated method based on
        the method name it is applied to.</para>
      </listitem>
    </itemizedlist>

    <para>For example:</para>

    <programlisting>@Reference(cardinality=MULTIPLE, policy=DYNAMIC)
void setLogService( LogService log, Map&lt;String,?&gt; props) { ... }
void unsetLogService( LogService log ) {  ... }
void updatedLogService( Map&lt;String,?&gt; map ) { ...}</programlisting>
  </section>

  <section xml:id="i1578406">
    <title>Service Component Runtime</title>

    <section xml:id="i1616910">
      <title>Relationship to OSGi Framework</title>

      <para>The SCR must have access to the Bundle Context of any bundle that
      contains a component. The SCR needs access to the Bundle Context for the
      following reasons:</para>

      <itemizedlist>
        <listitem>
          <para>To be able to register and get services on behalf of a bundle
          with components.</para>
        </listitem>

        <listitem>
          <para>To interact with the Configuration Admin on behalf of a bundle
          with components.</para>
        </listitem>

        <listitem>
          <para>To provide a component its Bundle Context when the Component
          Context <code>getBundleContext</code> method is called.</para>
        </listitem>
      </itemizedlist>

      <para>The SCR should use the <code>Bundle.getBundleContext()</code>
      method to obtain the Bundle Context reference.</para>
    </section>

    <section>
      <title>Starting and Stopping SCR</title>

      <para>When SCR is implemented as a bundle, any component configurations
      activated by SCR must be deactivated when the SCR bundle is stopped.
      When the SCR bundle is started, it must process any components that are
      declared in bundles that are started. This includes bundles which are
      started and are awaiting lazy activation.</para>
    </section>

    <section>
      <title>Logging Error Messages</title>

      <para>When SCR must log an error message to the Log Service, it must use
      a Log Service obtained using the component's Bundle Context so that the
      resulting Log Entry is associated with the component's bundle.</para>

      <para>If SCR is unable to obtain, or use, a Log Service using the
      component's Bundle Context, then SCR must log the error message to a Log
      Service obtained using SCR's bundle context to ensure the error message
      is logged.</para>
    </section>

    <section xml:id="i1641644">
      <title>Locating Component Methods</title>

      <para>SCR will need to locate activate, deactivate, modified, bind,
      updated, and unbind methods for a component instance. These methods will
      be located, and called, using reflection. The declared methods of each
      class in the component implementation class' hierarchy are examined for
      a suitable method. If a suitable method is found in a class, and it is
      accessible to the component implementation class, then that method must
      be used. If suitable methods are found in a class but none of the
      suitable methods are accessible by the component implementation class,
      then the search for suitable methods terminates with no suitable method
      having been located. If no suitable methods are found in a class, the
      search continues in the superclass.</para>

      <para>Only methods that are accessible to the component implementation
      class will be used. If the method has the <code>public</code> or
      <code>protected</code> access modifier, then access is permitted.
      Otherwise, if the method has the <code>private</code> access modifier,
      then access is permitted only if the method is declared in the component
      implementation class. Otherwise, if the method has default access, also
      known as package private access, then access is permitted only if the
      method is declared in the component implementation class or if the
      method is declared in a superclass and all classes in the hierarchy from
      the component implementation class to the superclass, inclusive, are in
      the same package and loaded by the same class loader.</para>

      <para>It is recommended that these methods should not be declared with
      the <code>public</code> access modifier so that they do not appear as
      public methods on the component instance when it is used as a service
      object. Having these methods declared <code>public</code> allows any
      code to call the methods with reflection, even if a Security Manager is
      installed. These methods are generally intended to only be called by
      SCR.</para>
    </section>

    <section>
      <title>Bundle Activator Interaction</title>

      <para>A bundle containing components may also declare a Bundle
      Activator. Such a bundle may also be marked for lazy activation. Since
      components are activated by SCR and Bundle Activators are called by the
      OSGi Framework, a bundle using both components and a Bundle Activator
      must take care. The Bundle Activator's start method must not rely upon
      SCR having activated any of the bundle's components. However, the
      components can rely upon the Bundle Activator's start method having been
      called. That is, there is a <emphasis>happens-before</emphasis>
      relationship between the Bundle Activator's start method being run and
      the components being activated.</para>
    </section>
  </section>

  <section>
    <title>Security</title>

    <section>
      <title>Service Permissions</title>

      <para>Declarative services are built upon the existing OSGi service
      infrastructure. This means that Service Permission applies regarding the
      ability to publish, find or bind services.</para>

      <para>If a component specifies a service, then component configurations
      for the component cannot be satisfied unless the component's bundle has
      <code>ServicePermission[&lt;provides&gt;, REGISTER]</code> for each
      provided interface specified for the service.</para>

      <para>If a component's reference does not specify optional cardinality,
      the reference cannot be satisfied unless the component's bundle has
      <code>ServicePermission[&lt;interface&gt;, GET]</code> for the specified
      interface in the reference. If the reference specifies optional
      cardinality but the component's bundle does not have
      <code>ServicePermission[&lt;interface&gt;, GET]</code> for the specified
      interface in the reference, no service must be bound for this
      reference.</para>

      <para>If a component is a factory component, then the above Service
      Permission checks still apply. But the component's bundle is not
      required to have <code>ServicePermission[ComponentFactory,
      REGISTER]</code> as the Component Factory service is registered by
      SCR.</para>
    </section>

    <section xml:id="i1617328">
      <title>Required Admin Permission</title>

      <para>The SCR requires <code>AdminPermission[*,CONTEXT]</code> because
      it needs access to the bundle's Bundle Context object with the
      <code>Bundle.getBundleContext()</code> method.</para>
    </section>

    <section>
      <title>Using hasPermission</title>

      <para>SCR does all publishing, finding and binding of services on behalf
      of the component using the Bundle Context of the component's bundle.
      This means that normal stack-based permission checks will check SCR and
      not the component's bundle. Since SCR is registering and getting
      services on behalf of a component's bundle, SCR must call the
      <code>Bundle.hasPermission</code> method to validate that a component's
      bundle has the necessary permission to register or get a service.</para>
    </section>
  </section>

  <section xml:id="i1523991">
    <title>Component Description Schema</title>

    <para>This XML Schema defines the component description grammar.</para>

    <programlisting role="pgwide"><xi:include encoding="utf-8"
        href="../../generated/xmlns/scr/v1.2.0/scr.xsd" parse="text"/></programlisting>

    <para>SCR must not require component descriptions to specify the elements
    in the order required by the schema. SCR must allow other orderings since
    arbitrary orderings of these elements do not affect the meaning of the
    component description. Only the relative ordering of
    <code>property</code>, <code>properties</code> and <code>reference</code>
    elements have meaning for overriding previously set property
    values.</para>

    <para>The schema is also available in digital form from <xref
    linkend="i1655737"/>.</para>
  </section>

  <section>
    <title>Changes</title>

    <itemizedlist>
      <listitem>
        <para><xref linkend="i1649746"/> has been rewritten to more accurately
        state the effects of configuration changes on component
        configurations.</para>
      </listitem>
    </itemizedlist>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.component.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.component.annotations.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i1550732"><title>Automating Service Dependency
      Management in a Service-Oriented Component Model</title>Humberto
      Cervantes, Richard S. Hall, Proceedings of the Sixth Component-Based
      Software Engineering Workshop, May 2003, pp. 91-96<?line-break ?>http://www-adele.imag.fr/Les.Publications/intConferences/CBSE2003Cer.pdf</bibliomixed>

      <bibliomixed><title>Service Binder</title>Humberto Cervantes, Richard S.
      Hall<?line-break ?>http://gravity.sourceforge.net/servicebinder</bibliomixed>

      <bibliomixed xml:id="i1567926"><title>Java Properties
      File</title>http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Properties.html</bibliomixed>

      <bibliomixed xml:id="i1636361"><title>Extensible Markup Language (XML)
      1.0</title>http://www.w3.org/TR/REC-xml/</bibliomixed>

      <bibliomixed xml:id="i1655737"><title>OSGi XML
      Schemas</title>http://www.osgi.org/Specifications</bibliomixed>
    </bibliolist>
  </section>
</chapter>
