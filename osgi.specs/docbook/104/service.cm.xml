<?xml version="1.0" encoding="utf-8"?><chapter xmlns="http://docbook.org/ns/docbook" version="5" xml:id="i1858475"><title>
Configuration
Admin Service Specification</title>
<info xml:id="i1674043"><releaseinfo>
Version
1.5</releaseinfo></info>
<section><title>Introduction</title>
<para>The Configuration Admin service is an important aspect of
the deployment of an OSGi framework. It allows an Operator to configure
deployed bundles. Configuring is the process of defining the configuration
data for bundles and assuring that those bundles receive that data
when they are active in the OSGi framework.</para>
<figure><title>Configuration Admin Service Overview</title>
<mediaobject><imageobject><imagedata fileref="GRAPHIC1" align="center" contentwidth="4.917in" contentdepth="2.049in"/></imageobject></mediaobject></figure>
<section><title>Essentials</title>
<para>The following requirements and patterns are associated with
the Configuration Admin service specification:</para>
<itemizedlist><listitem><para><emphasis>Local Configuration</emphasis> –
The Configuration Admin service must support bundles that have their
own user interface to change their configurations.</para></listitem>
<listitem><para><emphasis>Reflection</emphasis> – The Configuration
Admin service must be able to deduce the names and types of the needed
configuration data.</para></listitem>
<listitem><para><emphasis>Legacy</emphasis> – The Configuration
Admin service must support configuration data of existing entities
(such as devices).</para></listitem>
<listitem><para><emphasis>Object Oriented </emphasis>– The Configuration
Admin service must support the creation and deletion of instances
of configuration information so that a bundle can create the appropriate
number of services under the control of the Configuration Admin
service.</para></listitem>
<listitem><para><emphasis>Embedded Devices</emphasis> – The Configuration
Admin service must be deployable on a wide range of platforms. This
requirement means that the interface should not assume file storage
on the platform. The choice to use file storage should be left to
the implementation of the Configuration Admin service.</para></listitem>
<listitem><para><emphasis>Remote versus Local Management</emphasis> –
The Configuration Admin service must allow for a remotely managed
OSGi framework, and must not assume that con-figuration information
is stored locally. Nor should it assume that the Configuration Admin
service is always done remotely. Both implementation approaches
should be viable.</para></listitem>
<listitem><para><emphasis>Availability</emphasis> – The OSGi environment
is a dynamic environment that must run continuously (24/7/365).
Configuration updates must happen dynamically and should not require
restarting of the system or bundles. </para></listitem>
<listitem><para><emphasis>Immediate Response</emphasis> – Changes
in configuration should be reflected immediately.</para></listitem>
<listitem><para><emphasis>Execution Environment </emphasis>– The
Configuration Admin service will not require more than an environment that
fulfills the minimal execution requirements.</para></listitem>
<listitem><para><emphasis>Communications</emphasis> – The Configuration
Admin service should not assume “always-on” connectivity, so the
API is also applicable for mobile applications in cars, phones,
or boats.</para></listitem>
<listitem><para><emphasis>Extendability</emphasis> – The Configuration
Admin service should expose the process of configuration to other bundles.
This exposure should at a minimum encompass initiating an update,
removing certain configuration properties, adding properties, and
modifying the value of properties potentially based on existing
property or service values.</para></listitem>
<listitem><para><emphasis>Complexity Trade-offs</emphasis> – Bundles
in need of configuration data should have a simple way of obtaining it.
Most bundles have this need and the code to accept this data. Additionally,
updates should be simple from the perspective of the receiver.</para>
<para>Trade-offs in simplicity should be made at the expense of
the bundle implementing the Configuration Admin service and in favor
of bundles that need configuration information. The reason for this choice
is that normal bundles will outnumber Configuration Admin bundles.</para></listitem>
<listitem><para><emphasis>Regions</emphasis> – It should be possible
to create groups of bundles and a manager in a single system that
share configuration data that is not accessible outside the region.</para></listitem>
<listitem><para><emphasis>Shared Information</emphasis> – It should
be possible to share configuration data between bundles.</para></listitem></itemizedlist></section>
<section><title>Entities</title>
<itemizedlist><listitem><para><emphasis>Configuration information </emphasis>–
<emphasis> </emphasis>The information needed by a bundle before
it can provide its intended functionality.</para></listitem>
<listitem><para><emphasis>Configuration dictionary</emphasis> –
The configuration information when it is passed to the target service.
It consists of a <code>Dictionary</code> object with a number of
properties and identifiers.</para></listitem>
<listitem><para><emphasis>Configuring Bundle</emphasis> – A bundle
that modifies the configuration information through the Configuration
Admin service. This bundle is either a management bundle or the
bundle for which the configuration information is intended.</para></listitem>
<listitem><para><emphasis>Configuration Target</emphasis> – The
target service that will receive the configuration information.
For services, there are two types of targets: <code>ManagedServiceFactory</code> or 
<code>ManagedService</code> objects.</para></listitem>
<listitem><para><emphasis>Configuration Admin Service</emphasis> –
This service is responsible for supplying configuration target bundles with
their configuration information. It maintains a database with configuration
information, keyed on the <code>service.pid</code> of configuration
target services. These services receive their configuration dictionary/dictionaries
when they are registered with the Framework. Configurations can
be modified or extended using Configuration Plugin services before
they reach the target bundle.</para></listitem>
<listitem><para><emphasis>Managed Service </emphasis>– A Managed
Service represents a client of the Configuration Admin service,
and is thus a configuration target. Bundles should register a Managed
Service to receive the configuration data from the Configuration
Admin service. A Managed Service adds one or more unique <code>service.pid</code> service
properties as a primary key for the configuration information.</para></listitem>
<listitem><para><emphasis>Managed Service Factory</emphasis> – A
Managed Service Factory can receive a number of configuration dictionaries
from the Configuration Admin service, and is thus also a configuration
target service. It should register with one or more <code>service.pid</code> strings
and receives zero or more configuration dictionaries. Each dictionary
has its own PID that is distinct from the factory PID.</para></listitem>
<listitem><para><emphasis>Configuration Object</emphasis> – Implements
the <code>Configuration</code> interface and contains the configuration
dictionary for a Managed Service or one of the configuration dictionaries
for a Managed Service Factory. These objects are manipulated by
configuring bundles.</para></listitem>
<listitem><para><emphasis>Configuration Plugin</emphasis> Services
– Configuration Plugin services are called before the configuration
dictionary is given to the configuration targets. The plug-in can
modify the configuration dictionary, which is passed to the Configuration
Target.</para></listitem></itemizedlist>
<figure xml:id="i1817860"><title>Overall Service Diagram</title><mediaobject><imageobject><imagedata fileref="GRAPHIC2" align="center" contentwidth="6.230in" contentdepth="1.962in"/></imageobject></mediaobject></figure></section>
<section><title>Synopsis</title>
<para>This specification is based on the concept of a Configuration
Admin service that manages the configuration of an OSGi framework.
It maintains a database of <code>Configuration</code> objects, locally
or remotely. This service monitors the service registry and provides
configuration information to services that are registered with a <code>service.pid</code> property,
the Persistent IDentity (PID), and implement one of the following interfaces: </para>
<itemizedlist><listitem><para><emphasis>Managed Service</emphasis> –
A service registered with this interface receives its <emphasis>configuration
dictionary</emphasis> from the database or receives <code>null</code> when
no such configuration exists. </para></listitem>
<listitem><para><emphasis>Managed Service Factory</emphasis> – Services
registered with this interface can receive several configuration
dictionaries when registered. The database contains zero or more
configuration dictionaries for this service. Each configuration
dictionary is given sequentially to the service.</para></listitem></itemizedlist>
<para>The database can be manipulated either by the Management Agent
or bundles that configure themselves. Other parties can provide
Configuration Plugin services. Such services participate in the
configuration process. They can inspect the configuration dictionary
and modify it before it reaches the target service.</para></section></section>
<section xml:id="i1358725"><title>
Configuration
Targets</title>
<para>One of the more complicated aspects of this specification
is the subtle distinction between the <code>ManagedService</code> and 
<code>ManagedServiceFactory</code> classes. Both receive configuration
information from the Configuration Admin service and are treated
similarly in most respects. Therefore, this specification refers to 
<emphasis>configuration targets</emphasis> or simply <emphasis>targets</emphasis> when
the distinction is irrelevant.</para>
<para>The difference between these types is related to the cardinality
of the configuration dictionary. A Managed Service is used when
an existing entity needs a configuration dictionary. Thus, a one-to-one relationship
always exists between the configuration dictionary and the configurable
entity in the Managed Service. There can be multiple Managed Service
targets registered with the same PID but a Managed Service can only
configure a single entity in each given Managed Service.</para>
<para>A Managed Service Factory is used when part of the configuration
is to define <emphasis>how many instances are required</emphasis> for
a given Managed Service Factory. A management bundle can create,
modify, and delete any number of instances for a Managed Service
Factory through the Configuration Admin service. Each instance is
configured by a single <code>Configuration</code> object. Therefore,
a Managed Service Factory can have multiple associated <code>Configuration</code> objects.</para>
<figure><title>Differentiation of ManagedService and ManagedServiceFactory
Classes</title>
<mediaobject><imageobject><imagedata fileref="GRAPHIC3" align="aright" contentwidth="4.917in" contentdepth="1.205in"/></imageobject></mediaobject></figure>
<para>A Configuration target updates the target when the underlying
Configuration object is created, updated, or deleted. However, it
is not called back when the Configuration Admin service is shutdown
or the service is ungotten.</para>
<para>To summarize:</para>
<itemizedlist><listitem><para>A <emphasis>Managed Service</emphasis> must
receive a single configuration dictionary when it is registered
or when its configuration is modified.</para></listitem>
<listitem><para>A <emphasis>Managed Service Factory</emphasis> must
receive from zero to <emphasis>n</emphasis> configuration dictionaries
when it registers, depending on the current configuration. The Managed
Service Factory is informed of configuration dictionary changes:
modifications, creations, and deletions.</para></listitem></itemizedlist></section>
<section xml:id="i1233800"><title>
The Persistent
Identity</title>
<para>A crucial concept in the Configuration Admin service specification
is the Persistent IDentity (PID) as defined in the Framework’s service
layer. Its purpose is to act as a primary key for objects that need
a configuration dictionary. The name of the service property for
PID is defined in the Framework in <code>org.osgi.framework.Constants.SERVICE_PID</code>.</para>
<para>The Configuration Admin service requires the use of one or
more PIDs with Managed Service and Managed Service Factory registrations
because it associates its configuration data with PIDs.</para>
<para>A service can register with multiple PIDs and PIDs can be
shared between multiple targets (both Managed Service and Managed
Service Factory targets) to receive the same information. If PIDs
are to be shared between Bundles then the location of the Configuration
must be a multi-location, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1573084"/></phrase>
.</para>
<para>The Configuration Admin must track the configuration targets
on their actual PID. That is, if the <code>service.pid</code> service
property is modified then the Configuration Admin must treat it
as if the service was unregistered and then re-registered with the
new PID.</para>
<section><title>PID Syntax</title>
<para>PIDs are intended for use by other bundles, not by people,
but sometimes the user is confronted with a PID. For example, when
installing an alarm system, the user needs to identify the different
components to a wiring application. This type of application exposes
the PID to end users.</para>
<para>PIDs should follow the symbolic-name syntax, which uses a
very restricted character set. The following sections define some
schemes for common cases. These schemes are not required, but bundle developers
are urged to use them to achieve consistency.</para>
<section><title>Local Bundle PIDs</title>
<para>As a convention, descriptions starting with the bundle identity
and a full stop (<code>’.’ \u002E</code>) are reserved for a bundle.
As an example, a PID of <code>"65.536"</code> would belong to the
bundle with a bundle identity of 65.</para></section>
<section><title>Software PIDs</title>
<para>Configuration target services that are singletons can use
a Java package name they own as the PID (the reverse domain name
scheme) as long as they do not use characters outside the basic
ASCII set. As an example, the PID named <code>com.acme.watchdog</code> would
represent a Watchdog service from the ACME company.</para></section>
<section><title>Devices</title>
<para>Devices are usually organized on buses or networks. The identity
of a device, such as a unique serial number or an address, is a
good component of a PID. The format of the serial number should
be the same as that printed on the housing or box, to aid in recognition.</para>
<table><title>Schemes for Device-Oriented PID Names</title><tgroup cols="4"><thead><row><entry>Bus</entry><entry>Example</entry><entry>Format</entry><entry>Description</entry></row></thead><tbody><row><entry><code>USB</code></entry><entry><code>USB.0123-0002-9909873</code></entry><entry><code>idVendor (hex 4)
idProduct (hex 4)
iSerialNumber (decimal)</code></entry><entry><code>Universal Serial Bus. Use the standard device descriptor.</code></entry></row><row><entry><code>IP</code></entry><entry><code>IP.172.16.28.21</code></entry><entry><code>IP nr (dotted decimal)</code></entry><entry><code>Internet Protocol</code></entry></row><row><entry><code>802</code></entry><entry><code>802-00:60:97:00:9A:56</code></entry><entry><code>MAC address with: separators</code></entry><entry><code>IEEE 802 MAC address (Token Ring, Ethernet,...)</code></entry></row><row><entry><code>ONE</code></entry><entry><code>ONE.06-00000021E461</code></entry><entry><code>Family (hex 2) and serial number including CRC (hex
6)</code></entry><entry><code>1-wire bus of Dallas Semiconductor</code></entry></row><row><entry><code>COM</code></entry><entry><code>COM.krups-brewer-12323</code></entry><entry><code>serial number or type name of device</code></entry><entry><code>Serial ports</code></entry></row></tbody></tgroup></table></section></section>
<section xml:id="i1891430"><title>
Targeted PIDs</title>
<para>PIDs are defined as primary keys for the configuration object;
any target that uses the PID in its service registration (and has
the proper permissions if security is on) will receive the configuration
associated with it, regardless of the bundle that registered the
target service. Though in general the PID is designed to ignore
the bundle, there are a number of cases where the bundle becomes
relevant. The most typical case is where a bundle is available in
different versions. Each version will request the same PID and will
get therefore configured identically.</para>
<para><emphasis>Targeted PIDs</emphasis> are specially formatted
PIDs that are interpreted by the Configuration Admin service. Targeted
PIDs work both as a normal Managed Service PID and as a Managed
Service Factory PID. In the case of factories, the targeted PID
is the Factory PID since the other PID is chosen by CM for each instance. </para>
<para>The target PID scopes the applicability of the PID to a limited
set of target bundles. The syntax of a target pid is:</para>
<programlisting>target-pid 			::=	 PID 
	( ’|’ symbolic-name ( ’|’ version ( ’|’ location )? )? )?</programlisting>
<para>Targets never register with a target PID, target PIDs should
only be used when creating, getting, or deleting a Configuration
through the Configuration Admin service. The target PID is still
the primary key of the Configuration and is thus in itself a PID.
The distinction is only made when the Configuration Admin must update
a target service. Instead of using the non-target PID as the primary
key it must first search if there exists a target PID in the Configuration
store that matches the requested target PID.</para>
<para>When a target registers and needs to be updated the Configuration
Admin must first find the Configuration with the <emphasis>best
matching</emphasis> PID. It must logically take the requested PID,
append it with the bundle symbolic name, the bundle version, and
the bundle location. The version must be formatted canonically,
that is, according to the <code>toString()</code> method of the <code>Version</code> class.
The rules for best matching are then as follows:</para>
<para>Look for a Configuration, in the given order, with a key of:</para>
<programlisting>	&lt;pid&gt;|&lt;bsn&gt;|&lt;version&gt;|&lt;location&gt;
	&lt;pid&gt;|&lt;bsn&gt;|&lt;version&gt;
	&lt;pid&gt;|&lt;bsn&gt;
	&lt;pid&gt;</programlisting>
<para>For example:</para>
<programlisting>    com.example.web.WebConf|com.acme.example|3.2.0|http://www.xyz.com/acme.jar
    com.example.web.WebConf|com.acme.example|3.2.0
    com.example.web.WebConf|com.acme.example
    com.example.web.WebConf</programlisting>
<para>If a registered target service has a PID that contains a vertical
line (<code>’|’ \u007c</code>) | then the value must be taken as
is and must not be interpreted as a targeted PID.</para>
<para>The <code>service.pid</code> configuration property for a
targeted PID configuration must always be set to the targeted PID.
That is, if the PID is <code>com.example.web.WebConf</code> and
the targeted PID <code>com.example.web.WebConf|com.acme.example|3.2.0</code> then
the property in the Configuration dictionary must be the targeted
PID.</para>
<para>If a Configuration with a targeted PID is deleted or a Configuration
with a new targeted PID is added then all targets that would be
stale must be reevaluated against the new situation and updated accordingly
if they are no longer bound against the best matching target PID.</para></section>
<section><title>Extenders and Targeted PIDs</title>
<para>Extenders like Blueprint and Declarative Services use Configurations
but bypass the general Managed Service or Managed Service Factory
method. It is the responsibility of these extenders to access the
Configurations using the targeted PIDs.</para>
<para>Since getting a Configuration tends to create that Configuration
it is necessary for these extenders to use the 
<phrase role="xref">listConfigurations(String)</phrase>
 method to find out if a more targeted Configuration exists. There
are many ways the extender can find the most targeted PID. For example,
the following code gets the most targeted PID for a given bundle.</para>
<programlisting>	String mostTargeted(String pid, Bundle bundle,String key) throws Exception {
		String p = escape(pid); // make sure does not control filter
		String bsn = bundle.getSymbolicName();
		String version = bundle.getVersion().toString();
		String location = bundle.getLocation();
		String f = String.format(
				"(|(%s=%s)(%s=%s|%s)(%s=%s|%s|%s)(%s=%s|%s|%s|%s))", //
				key, p, //
				key, p, bsn, //
				key, p, bsn, version, //
				key, p, bsn, version, location );

		Configuration[] configurations = cm.listConfigurations(f);
		if (configurations == null)
			return null;

		String largest = null;
		for (Configuration c : configurations) {
			String s = (String) c.getProperties().get(key);
			if (largest == null)
				largest = s;
			else
				if (largest.length() &lt; s.length())
					largest = s;
		}
		return largest;
	}</programlisting></section></section>
<section><title>The Configuration Object</title>
<para>A <code>Configuration</code> object contains the configuration
dictionary, which is a set of properties that configure an aspect
of a bundle. A bundle can receive <code>Configuration</code> objects
by registering a configuration target service with a PID service
property. See 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1233800"/></phrase>
 for more information about PIDs.</para>
<para>During registration, the Configuration Admin service must
detect these configuration target services and hand over their configuration
dictionary via a callback. If this configuration dictionary is subsequently
modified, the modified dictionary is handed over to the configuration
target with the same callback. </para>
<para>The <code>Configuration</code> object is primarily a set of
properties that can be updated by a Management Agent, user interfaces
on the OSGi framework, or other applications. Configuration changes
are first made persistent, and then passed to the target service
via a call to the <code>updated</code> method in the <code>ManagedServiceFactory</code> or 
<code>ManagedService</code> class.</para>
<para>A Configuration object must be uniquely bound to a Managed
Service or Managed Service Factory. This implies that a bundle must
not register a Managed Service Factory with a PID that is the same
as the PID given to a Managed Service.</para>
<section xml:id="i1573084"><title>
Location
Binding</title>
<para>When a 
<phrase role="xref">Configuration</phrase>
 object is created with either 
<phrase role="xref">getConfiguration(String)</phrase>
 or 
<phrase role="xref">createFactoryConfiguration(String)</phrase>
, it becomes <emphasis>bound</emphasis> to the location of the calling
bundle. This location is obtained with the 
<phrase role="xref">getBundleLocation()</phrase>
 method.</para>
<para>Location binding is a security feature that assures that only
management bundles can modify configuration data, and other bundles
can only modify their own configuration data. A Security Exception is
thrown if a bundle does not have <code>ConfigurationPermission[location,
CONFIGURE]</code>.</para>
<para>The two argument versions of 
<phrase role="xref">getConfiguration(String,String)</phrase>
 and 
<phrase role="xref">createFactoryConfiguration(String,String)</phrase>
 take a location <code>String</code> as their second argument. These
methods require the correct permission, and they create 
<phrase role="xref">Configuration</phrase>
 objects bound to the specified location. </para>
<para>Locations can be specified for a specific Bundle or use 
<emphasis>multi-locations</emphasis>. For a specific location the
Configuration location must exactly match the location of the target’s
Bundle. A multi-location is any location that has the following
syntax:</para>
<programlisting>multi-location ::= ’?’ symbolic-name?</programlisting>
<para>For example </para>
<programlisting>?com.acme</programlisting>
<para>The path after the question mark is the <emphasis>multi-location
name</emphasis>, the multi-location name can be empty if only a
question mark is specified. Configurations with a multi-location
are dispatched to any target that has <emphasis>visibility</emphasis> to
the Configuration. The visibility for a given Configuration <code>c</code> depends
on the following rules:</para>
<itemizedlist><listitem><para><emphasis>Single-Location – </emphasis>If 
<code>c.location</code> is not a multi-location then a Bundle only
has visibility if the Bundle’s location exactly matches <code>c.location</code>.
In this case there is never a security check.</para></listitem>
<listitem><para><emphasis>Multi-Location</emphasis> – If  <code>c.location</code> is
a multi-location (that is, starts with a question mark):</para>
<itemizedlist><listitem><para><emphasis>Security Off</emphasis> –
The Bundle always has visibility</para></listitem>
<listitem><para><emphasis>Security On</emphasis> – The target’s
Bundle must have <code>ConfigurationPermission[ c.location,</code>
<phrase role="xref">TARGET</phrase>
<code> ]</code> as defined by the Bundle’s <code>hasPermission</code> method.
The resource name of the permission must include the question mark.</para></listitem></itemizedlist></listitem></itemizedlist>
<para>The permission matches on the whole name, including any leading 
<code>?</code>. The 
<phrase role="xref">TARGET</phrase>
 action is only applicable in the multi-location scenario since
the security is not checked for a single-location. There is therefore
no point in granting a Bundle a permission with 
<phrase role="xref">TARGET</phrase>
 action for anything but a multi-location (starting with a <code>?</code>). </para>
<para>It is therefore possible to register services with the same
PID from different bundles. If a multi-location is used then each
bundle will be evaluated for a corresponding configuration update.
If the bundle has visibility then it is updated, otherwise it is
not.</para>
<para>If multiple targets must be updated then the order of updating
is the ranking order of their services.</para>
<para>If a target loses visibility because the Configuration’s location
changes then it must immediately be deleted from the perspective
of that target. That is, the target must see a deletion (Managed
Service Factory) or an update with <code>null</code> (Managed Service).
If a configuration target gains visibility then the target must
see a new update with the proper configuration dictionary. However,
the associated events must not be sent as the underlying Configuration
is not actually deleted nor modified.</para>
<para>Changes in the permissions must not initiate a recalculation
of the visibility. If the permissions are changed this will not
become visible until one of the other events happen that cause a
recalculation of the visibility.</para>
<para>If the location is changed then the Configuration Admin must
send a 
<phrase role="xref">CM_LOCATION_CHANGED</phrase>
 event to signal that the location has changed. It is up to the
Configuration Listeners to update their state appropriately.</para></section>
<section><title>Dynamic Binding</title>
<para>Dynamic binding is available for backward compatibility with
earlier versions. It is recommended that management agents explicitly
set the location to a <code>?</code> (a multi-location) to allow
multiple bundles to share PIDs and not use the dynamic binding facility.
If a management agent uses ?, it must at least have  <code>ConfigurationPermission[
?,</code>
<phrase role="xref">CONFIGURE</phrase>
<code> ]</code> when security is on, it is also possible to use <code>ConfigurationPermission[
?*,</code>
<phrase role="xref">CONFIGURE</phrase>
<code> ]</code> to not limit the management agent. See 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1848302"/></phrase>
 for some examples of using the locations in isolation scenarios.</para>
<para>A <code>null</code> location parameter can be used to create 
<code>Configuration</code> objects that are not yet bound. In this
case, the Configuration becomes bound to a specific location the
first time that it is compared to a Bundle’s location. If a bundle
becomes dynamically bound to a Configuration then a 
<phrase role="xref">CM_LOCATION_CHANGED</phrase>
 event must be dispatched.</para>
<para>When this <emphasis>dynamically bound</emphasis> Bundle is
subsequently uninstalled, configurations that are bound to this
bundle must be released. That means that for such <code>Configuration</code> object’s
the bundle location must be set to <code>null</code> again so it
can be bound again to another bundle. </para></section>
<section xml:id="i1308339"><title>
Configuration
Properties</title>
<para>A configuration dictionary contains a set of properties in
a <code>Dictionary</code> object. The value of the property must
be the same type as the set of types specified in the 
<phrase role="xref">OSGi Core Release 5</phrase>
 in 
<phrase role="xref">Figure 3.1 Primary property types</phrase>
. </para>
<para>The name or key of a property must always be a <code>String</code> object,
and is not case-sensitive during look up, but must preserve the
original case. The format of a property name should be:</para>
<programlisting>property-name ::= public | private
public					::= symbolic-name // See <phrase role="xref">1.3.2</phrase>
private					::= ’.’ symbolic-name</programlisting>
<para>Properties can be used in other subsystems that have restrictions
on the character set that can be used. The <code>symbolic-name</code> production
uses a very minimal character set.</para>
<para>Bundles must not use nested vectors or arrays, nor must they
use mixed types. Using mixed types or nesting makes it impossible
to use the meta typing specification. See 
<phrase role="xref">Metatype Service Specification on page 107</phrase>
.</para></section>
<section xml:id="i1775472"><title>
Property
Propagation</title>
<para>A configuration target should copy the public configuration
properties (properties whose name does not start with a <code>’.’</code> or 
<code>\u002E</code>) of the <code>Dictionary</code> object argument
in <code>updated(Dictionary)</code> into the service properties
on any resulting service registration.</para>
<para>This propagation allows the development of applications that
leverage the Framework service registry more extensively, so compliance
with this mechanism is advised.</para>
<para>A configuration target may ignore any configuration properties
it does not recognize, or it may change the values of the configuration
properties before these properties are registered as service properties.
Configuration properties in the Framework service registry are not
strictly related to the configuration information.</para>
<para>Bundles that follow this recommendation to propagate public
configuration properties can participate in horizontal applications.
For example, an application that maintains physical location information
in the Framework service registry could find out where a particular
device is located in the house or car. This service could use a
property dedicated to the physical location and provide functions
that leverage this property, such as a graphic user interface that
displays these locations.</para>
<para>Bundles performing service registrations on behalf of other
bundles (e.g. OSGi Declarative Services) should propagate all public
configuration properties and not propagate private configuration
properties.</para></section>
<section xml:id="i1374751"><title>
Automatic
Properties</title>
<para>The Configuration Admin service must automatically add a number
of properties to the configuration dictionary. If these properties
are also set by a configuring bundle or a plug-in, they must always be
overridden before they are given to the target service, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1459884"/></phrase>
. Therefore, the receiving bundle or plug-in can assume that the
following properties are defined by the Configuration Admin service
and not by the configuring bundle:</para>
<itemizedlist><listitem><para><code>service.pid</code> – Set to
the PID of the associated <code>Configuration</code> object. This
is the full the targeted PID if a targeted PID is used, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1891430"/></phrase>
. </para></listitem>
<listitem><para><code>service.factoryPid</code> – Only set for a
Managed Service Factory. It is then set to the PID of the associated
Managed Service Factory. This is the full the targeted PID if a
targeted PID is used.</para></listitem>
<listitem><para><code>service.bundleLocation</code> – Set to the
location of the  <code>Configuration</code> object. This property
can only be used for searching, it may not appear in the configuration
dictionary returned from the <code>getProperties</code> method due
to security reasons, nor may it be used when the target is updated.</para></listitem></itemizedlist>
<para>Constants for some of these properties can be found in <code>org.osgi.framework.Constants</code> and
the 
<phrase role="xref">ConfigurationAdmin</phrase>
 interface. These service properties are all of type <code>String</code>.</para></section>
<section xml:id="i1488808"><title>
Equality</title>
<para>Two different <code>Configuration</code> objects can actually
represent the same underlying configuration. This means that a <code>Configuration</code> object
must implement the <code>equals</code> and <code>hashCode</code> methods
in such a way that two <code>Configuration</code> objects are equal
when their PID is equal.</para></section></section>
<section><title>Managed Service</title>
<para>A Managed Service is used by a bundle that needs one or more
configuration dictionaries. It therefore registers the Managed Service
with one or more PIDs and is thus associated with one <code>Configuration</code> object
in the Configuration Admin service for each registered PID. A bundle
can register any number of <code>ManagedService</code> objects,
but each must be identified with its own PID or PIDs.</para>
<para>A bundle should use a Managed Service when it needs configuration
information for the following:</para>
<itemizedlist><listitem><para><emphasis>A Singleton</emphasis> –
A single entity in the bundle that needs to be configured.</para></listitem>
<listitem><para><emphasis>Externally Detected Devices</emphasis> –
Each device that is detected causes a registration of an associated 
<code>ManagedService</code> object. The PID of this object is related
to the identity of the device, such as the address or serial number.</para></listitem></itemizedlist>
<section><title>Singletons</title>
<para>When an object must be instantiated only once, it is called
a <emphasis>singleton</emphasis>. A singleton requires a single configuration
dictionary. Bundles may implement several different types of singletons
if necessary.</para>
<para>For example, a Watchdog service could watch the registry for
the status and presence of services in the Framework service registry.
Only one instance of a Watchdog service is needed, so only a single configuration
dictionary is required that contains the polling time and the list
of services to watch.</para></section>
<section><title>Networks</title>
<para>When a device in the external world needs to be represented
in the OSGi Environment, it must be detected in some manner. The
Configuration Admin service cannot know the identity and the number
of instances of the device without assistance. When a device is
detected, it still needs configuration information in order to play
a useful role.</para>
<para>For example, a 1-Wire network can automatically detect devices
that are attached and removed. When it detects a temperature sensor,
it could register a Sensor service with the Framework service registry.
This Sensor service needs configuration information specifically
for that sensor, such as which lamps should be turned on, at what
temperature the sensor is triggered, what timer should be started,
in what zone it resides, and so on. One bundle could potentially
have hundreds of these sensors and actuators, and each needs its
own configuration information.</para>
<para>Each of these Sensor services should be registered as a Managed
Service with a PID related to the physical sensor (such as the address)
to receive configuration information.</para>
<para>Other examples are services discovered on networks with protocols
like Jini, UPnP, and Salutation. They can usually be represented
in the Framework service registry. A network printer, for example, could
be detected via UPnP. Once in the service registry, these services
usually require local configuration information. A Printer service
needs to be configured for its local role: location, access list,
and so on.</para>
<para>This information needs to be available in the Framework service
registry whenever that particular Printer service is registered.
Therefore, the Configuration Admin service must remember the configuration
information for this Printer service.</para>
<para>This type of service should register with the Framework as
a Managed Service in order to receive appropriate configuration
information.</para></section>
<section xml:id="i1233865"><title>
Configuring
Managed Services</title>
<para>A bundle that needs configuration information should register
one or more <code>ManagedService</code> objects with a PID service
property. If it has a default set of properties for its configuration,
it may include them as service properties of the Managed Service.
These properties may be used as a configuration template when a <code>Configuration</code> object
is created for the first time. A Managed Service optionally implements
the <code>MetaTypeProvider</code> interface to provide information
about the property types. See 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1288153"/></phrase>
.</para>
<para>When this registration is detected by the Configuration Admin
service, the following steps must occur:</para>
<itemizedlist><listitem><para>The configuration stored for the registered
PID must be retrieved. If there is a <code>Configuration</code> object
for this PID and the configuration is visible for the associated
bundle then it is sent to the Managed Service with 
<phrase role="xref">updated(Dictionary)</phrase>
.</para></listitem>
<listitem><para>If a Managed Service is registered and no configuration
information is available or the configuration is not visible then
the Configuration Admin service must call <code>updated(Dictionary)</code> with
a <code>null</code> parameter. </para></listitem>
<listitem><para>If the Configuration Admin service starts <emphasis>after</emphasis> a
Managed Service is registered, it must call 
<phrase role="xref">updated(Dictionary)</phrase>
 on this service as soon as possible according to the prior rules.
For this reason, a Managed Service must always get a callback when
it registers <emphasis>and</emphasis> the Configuration Admin service
is started. </para></listitem></itemizedlist>
<para>Multiple Managed Services can register with the same PID,
they are all updated as long as they have visibility to the configuration
as defined by the location, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1573084"/></phrase>
.</para>
<para>The 
<phrase role="xref">updated(Dictionary)</phrase>
 callback from the Configuration Admin service to the Managed Service
must take place asynchronously. This requirement allows the Managed
Service to finish its initialization in a synchronized method without
interference from the Configuration Admin service callback. Care
should be taken not to cause deadlocks by calling the Framework
within a synchronized method.</para>
<figure><title>Managed Service Configuration Action Diagram</title>
<mediaobject><imageobject><imagedata fileref="GRAPHIC4" align="center" contentwidth="4.917in" contentdepth="2.028in"/></imageobject></mediaobject></figure>
<para>The <code>updated</code> method may throw a 
<phrase role="xref">ConfigurationException</phrase>
. This object must describe the problem and what property caused
the exception.</para></section>
<section><title>Race Conditions</title>
<para>When a Managed Service is registered, the default properties
may be visible in the service registry for a short period before
they are replaced by the properties of the actual configuration
dictionary. Care should be taken that this visibility does not cause
race conditions for other bundles.</para>
<para>In cases where race conditions could be harmful, the Managed
Service must be split into two pieces: an object performing the
actual service and a Managed Service. First, the Managed Service
is registered, the configuration is received, and the actual service
object is registered. In such cases, the use of a Managed Service
Factory that performs this function should be considered.</para></section>
<section><title>Examples of Managed Service </title>
<para><phrase role="xref">
<xref xrefstyle="FigureNumber" linkend="i1379376"/></phrase>
 shows a Managed Service configuration example. Two services are
registered under the <code>ManagedService</code> interface, each
with a different PID. </para>
<figure xml:id="i1379376"><title>
PIDs
and External Associations</title>
<mediaobject><imageobject><imagedata fileref="GRAPHIC5" align="aoutside" contentwidth="4.917in" contentdepth="2.111in"/></imageobject></mediaobject></figure>
<para>The Configuration Admin service has a database containing
a configuration record for each PID. When the Managed Service with 
<code>service.pid = com.acme</code> is registered, the Configuration
Admin service will retrieve the properties <code>name=Elmer</code> and 
<code>size=42</code> from its database. The properties are stored
in a <code>Dictionary</code> object and then given to the Managed
Service with the <code>updated(Dictionary)</code> method.</para>
<section><title>Configuring A Console Bundle</title>
<para>In this example, a bundle can run a single debugging console
over a Telnet connection. It is a singleton, so it uses a <code>ManagedService</code> object
to get its configuration information: the port and the network name
on which it should register.</para>
<programlisting>class SampleManagedService implements ManagedService{	Dictionary 		       							properties;	ServiceRegistration									registration;	Console									console;
	public void start( 
		BundleContext context ) throws Exception {		properties = new Hashtable();		properties.put( Constants.SERVICE_PID,
			"com.acme.console" );
		registration = context.registerService(
			ManagedService.class.getName(), 
			this,
			properties
		);	}
	public synchronized void updated( Dictionary np ) {		if ( np != null ) {			properties = np;			properties.put(
				Constants.SERVICE_PID, "com.acme.console" );		}
		if (console == null)			console = new Console();
		int port = ((Integer)properties.get("port"))
			.intValue();
		String network = (String) properties.get("network");		console.setPort(port, network);		registration.setProperties(properties);	}			... further methods
}</programlisting></section></section>
<section><title>Deletion</title>
<para>When a <code>Configuration</code> object for a Managed Service
is deleted, the Configuration Admin service must call <code>updated(Dictionary)</code> with
a <code>null</code> argument on a thread that is different from
that on which the <code>Configuration.delete</code> was executed.
This deletion must send out a Configuration Event 
<phrase role="xref">CM_DELETED</phrase>
 asynchronously to any registered Configuration Listener services
after the <code>updated</code> method is called with a <code>null</code>.</para></section></section>
<section xml:id="i1299227"><title>Managed Service Factory
</title>
<para>A Managed Service Factory is used when configuration information
is needed for a service that can be instantiated multiple times.
When a Managed Service Factory is registered with the Framework, the
Configuration Admin service consults its database and calls 
<phrase role="xref">updated(String,Dictionary)</phrase>
 for each associated and visible <code>Configuration</code> object
that matches the PIDs on the registration. It passes the identifier
of the Configuration instance, which can be used as a PID, as well
as a <code>Dictionary</code> object with the configuration properties.</para>
<para>A Managed Service Factory is useful when the bundle can provide
functionality a number of times, each time with different configuration
dictionaries. In this situation, the Managed Service Factory acts
like a <emphasis>class</emphasis> and the Configuration Admin service
can use this Managed Service Factory to <emphasis>instantiate instances</emphasis> for
that <emphasis>class</emphasis>.</para>
<para>In the next section, the word <emphasis>factory</emphasis> refers
to this concept of creating <emphasis>instances</emphasis> of a
function defined by a bundle that registers a Managed Service Factory. </para>
<section><title>When to Use a Managed Service Factory</title>
<para>A Managed Service Factory should be used when a bundle does
not have an internal or external entity associated with the configuration
information but can potentially be instantiated multiple times.</para>
<section><title>Example Email Fetcher</title>
<para>An email fetcher program displays the number of emails that
a user has – a function likely to be required for different users.
This function could be viewed as a <emphasis>class</emphasis> that
needs to be <emphasis>instantiated</emphasis> for each user. Each
instance requires different parameters, including password, host,
protocol, user id, and so on.</para>
<para>An implementation of the Email Fetcher service should register
a <code>ManagedServiceFactory</code> object. In this way, the Configuration
Admin service can define the configuration information for each
user separately. The Email Fetcher service will only receive a configuration
dictionary for each required instance (user).</para></section>
<section><title>Example Temperature Conversion Service</title>
<para>Assume a bundle has the code to implement a conversion service
that receives a temperature and, depending on settings, can turn
an actuator on and off. This service would need to be instantiated many
times depending on where it is needed. Each instance would require
its own configuration information for the following:</para>
<itemizedlist><listitem><para>Upper value</para></listitem>
<listitem><para>Lower value</para></listitem>
<listitem><para>Switch Identification</para></listitem>
<listitem><para>...</para></listitem></itemizedlist>
<para>Such a conversion service should register a service object
under a <code>ManagedServiceFactory</code> interface. A configuration
program can then use this Managed Service Factory to create instances
as needed. For example, this program could use a Graphic User Interface
(GUI) to create such a component and configure it.</para></section>
<section><title>Serial Ports</title>
<para>Serial ports cannot always be used by the OSGi Device Access
specification implementations. Some environments have no means to
identify available serial ports, and a device on a serial port cannot always
provide information about its type. </para>
<para>Therefore, each serial port requires a description of the
device that is connected. The bundle managing the serial ports would
need to instantiate a number of serial ports under the control of
the Configuration Admin service, with the appropriate <code>DEVICE_CATEGORY</code> property
to allow it to participate in the Device Access implementation.</para>
<para>If the bundle cannot detect the available serial ports automatically,
it should register a Managed Service Factory. The Configuration
Admin service can then, with the help of a configuration program, define
configuration information for each available serial port.</para></section></section>
<section><title>Registration</title>
<para>Similar to the Managed Service configuration dictionary, the
configuration dictionary for a Managed Service Factory is identified
by a PID. The Managed Service Factory, however, also has a <emphasis>factory </emphasis>PID, which
is the PID of the associated Managed Service Factory. It is used
to group all Managed Service Factory configuration dictionaries
together.</para>
<para>When a <code>Configuration</code> object for a Managed Service
Factory is created (<code>ConfigurationAdmin.</code>
<phrase role="xref">createFactoryConfiguration(String,String)</phrase>
 or 
<phrase role="xref">createFactoryConfiguration(String)</phrase>
), a new unique PID is created for this object by the Configuration
Admin service. The scheme used for this PID is defined by the Configuration
Admin service and is unrelated to the factory PID, which is chosen
by the registering bundle.</para>
<para>When the Configuration Admin service detects the registration
of a Managed Service Factory, it must find all visible configuration
dictionaries for this factory and must then sequentially call <code>ManagedServiceFactory.</code>
<phrase role="xref">updated(String,Dictionary)</phrase>
 for each configuration dictionary. The first argument is the PID
of the <code>Configuration</code> object (the one created by the
Configuration Admin service) and the second argument contains the
configuration properties.</para>
<para>The Managed Service Factory should then create any artifacts
associated with that factory. Using the PID given in the <code>Configuration</code> object,
the bundle may register new services (other than a Managed Service)
with the Framework, but this is not required. This may be necessary
when the PID is useful in contexts other than the Configuration
Admin service.</para>
<para>The receiver must <emphasis>not</emphasis> register a Managed
Service with this PID because this would force two Configuration
objects to have the same PID. If a bundle attempts to do this, the
Configuration Admin service should log an error and must ignore
the registration of the Managed Service.</para>
<para>The Configuration Admin service must guarantee that no race
conditions exist between initialization, updates, and deletions.</para>
<figure><title>Managed Service Factory Action Diagram</title>
<mediaobject><imageobject><imagedata fileref="GRAPHIC6" align="center" contentwidth="4.917in" contentdepth="1.910in"/></imageobject></mediaobject></figure>
<para>A Managed Service Factory has only one update method: 
<phrase role="xref">updated(String,Dictionary)</phrase>
. This method can be called any number of times as Configuration
objects are created or updated. </para>
<para>The Managed Service Factory must detect whether a PID is being
used for the first time, in which case it should create a new 
<emphasis>instance</emphasis>, or a subsequent time, in which case
it should update an existing instance. </para>
<para>The Configuration Admin service must call <code>updated(String,Dictionary)</code> on
a thread that is different from the one that executed the registration.
This requirement allows an implementation of a Managed Service Factory
to use a synchronized method to assure that the callbacks do not
interfere with the Managed Service Factory registration.</para>
<para>The 
<phrase role="xref">updated(String,Dictionary)</phrase>
 method may throw a 
<phrase role="xref">ConfigurationException</phrase>
 object. This object describes the problem and what property caused
the problem. These exceptions should be logged by a Configuration
Admin service.</para>
<para>Multiple Managed Service Factory services can be registered
with the same PID. Each of those services that have visibility to
the corresponding configuration will be updated in service ranking
order.</para></section>
<section><title>Deletion</title>
<para>If a configuring bundle deletes an instance of a Managed Service
Factory, the 
<phrase role="xref">deleted(String)</phrase>
 method is called. The argument is the PID for this instance. The
implementation of the Managed Service Factory must remove all information
and stop any behavior associated with that PID. If a service was
registered for this PID, it should be unregistered.</para>
<para>Deletion will asynchronously send out a Configuration Event 
<phrase role="xref">CM_DELETED</phrase>
 to all registered Configuration Listener services.</para></section>
<section><title>Managed Service Factory Example</title>
<para><phrase role="xref">
<xref xrefstyle="FigureNumber" linkend="i1318247"/></phrase>
 highlights the differences between a Managed Service and a Managed
Service Factory. It shows how a Managed Service Factory implementation
receives configuration information that was created before it was
registered. </para>
<itemizedlist><listitem><para>A bundle implements an EMail Fetcher
service. It registers a <code>ManagedServiceFactory</code> object
with PID=<code>com.acme.email</code>. </para></listitem>
<listitem><para>The Configuration Admin service notices the registration
and consults its database. It finds three <code>Configuration</code> objects
for which the factory PID is equal to <code>com.acme.email</code>.
It must call <code>updated(String,Dictionary)</code> for each of
these <code>Configuration</code> objects on the newly registered <code>ManagedServiceFactory</code> object. </para></listitem>
<listitem><para>For each configuration dictionary received, the
factory should create a new instance of a <code>EMailFetcher</code> object,
one for <code>erica</code> (PID=16.1), one for <code>anna</code> (PID=16.3),
and one for <code>elmer</code> (PID=16.2). </para></listitem>
<listitem><para>The <code>EMailFetcher</code> objects are registered
under the <code>Topic</code> interface so their results can be viewed
by an online display. </para>
<para>If the E<code>MailFetcher</code> object is registered, it
may safely use the PID of the <code>Configuration</code> object
because the Configuration Admin service must guarantee its suitability
for this purpose.</para></listitem></itemizedlist>
<figure xml:id="i1318247"><title>
Managed Service
Factory Example</title>
<mediaobject><imageobject><imagedata fileref="GRAPHIC7" align="center" contentwidth="4.940in" contentdepth="2.778in"/></imageobject></mediaobject></figure></section>
<section><title>Multiple Consoles Example</title>
<para>This example illustrates how multiple consoles, each of which
has its own port and interface can run simultaneously. This approach
is very similar to the example for the Managed Service, but highlights the
difference by allowing multiple consoles to be created.</para>
<programlisting>class ExampleFactory implements ManagedServiceFactory{	Hashtable		 consoles = new Hashtable();
	BundleContext	 context;	public void start( BundleContext context ) 
		throws Exception {
		this.context = context;		Hashtable local = new Hashtable();		local.put(Constants.SERVICE_PID,"com.acme.console");		context.registerService(
			ManagedServiceFactory.class.getName(),
			this, 
			local );	}
	public void updated( String pid, Dictionary config ){		Console console = (Console) consoles.get(pid);		if (console == null) {			console = new Console(context);			consoles.put(pid, console);		}
		int port = getInt(config, "port", 2011);		String network = getString(
			config, 
			"network", 			null /*all*/ 
		);		console.setPort(port, network);	}
	public void deleted(String pid) {		Console console = (Console) consoles.get(pid);		if (console != null) {			consoles.remove(pid);			console.close();		}	}
}</programlisting></section></section>
<section><title>Configuration Admin Service</title>
<para>The 
<phrase role="xref">ConfigurationAdmin</phrase>
 interface provides methods to maintain configuration data in an
OSGi environment. This configuration information is defined by a
number of <code>Configuration</code> objects associated with specific
configuration targets. <code>Configuration</code> objects can be
created, listed, modified, and deleted through this interface. Either
a remote management system or the bundles configuring their own
configuration information may perform these operations. </para>
<para>The <code>ConfigurationAdmin</code> interface has methods
for creating and accessing <code>Configuration</code> objects for
a Managed Service, as well as methods for managing new <code>Configuration</code> objects
for a Managed Service Factory. </para>
<section xml:id="i1374750"><title>
Creating
a Managed Service Configuration Object</title>
<para>A bundle can create a new Managed Service <code>Configuration</code> object
with <code>ConfigurationAdmin.getConfiguration</code>. No create
method is offered because doing so could introduce race conditions
between different bundles trying to create a <code>Configuration</code> object
for the same Managed Service. The <code>getConfiguration </code>method
must atomically create and persistently store an object if it does
not yet exist.</para>
<para>Two variants of this method are:</para>
<itemizedlist><listitem><para><phrase role="xref">getConfiguration(String)</phrase>
 – This method is used by a bundle with a given location to configure
its <emphasis>own</emphasis> <code>ManagedService</code> objects. The
argument specifies the PID of the targeted service.</para></listitem>
<listitem><para><phrase role="xref">getConfiguration(String,String)</phrase>
 – This method is used by a management bundle to configure <emphasis>another</emphasis> bundle.
Therefore, this management bundle needs the right permission. The
first argument is the PID and the second argument is the location
identifier of the targeted <code>ManagedService</code> object.</para></listitem></itemizedlist>
<para>All <code>Configuration</code> objects have a method, 
<phrase role="xref">getFactoryPid()</phrase>
, which in this case must return <code>null</code> because the <code>Configuration</code> object
is associated with a Managed Service.</para>
<para>Creating a new Configuration object must <emphasis>not</emphasis> initiate
a callback to the Managed Service <code>updated</code> method until
the properties are set in the Configuration with the <code>update</code> method.</para></section>
<section xml:id="i1761778"><title>
Creating
a Managed Service Factory Configuration Object</title>
<para>The <code>ConfigurationAdmin</code> class provides two methods
to create a new instance of a Managed Service Factory:</para>
<itemizedlist><listitem><para><phrase role="xref">createFactoryConfiguration(String)</phrase>
 – This method is used by a bundle with a given location to configure
its own <code>ManagedServiceFactory</code> objects. The argument
specifies the PID of the targeted <code>ManagedServiceFactory</code> object.
This <emphasis>factory PID</emphasis> can be obtained from the returned 
<code>Configuration</code> object with the <code>getFactoryPid()</code> method.</para></listitem>
<listitem><para><phrase role="xref">createFactoryConfiguration(String,String)</phrase>
– This method is used by a management bundle to configure another
bundle’s <code>ManagedServiceFactory</code> object. The first argument
is the PID and the second is the location identifier of the targeted 
<code>ManagedServiceFactory</code> object. The <emphasis>factory
PID</emphasis> can be obtained from the returned <code>Configuration</code> object
with <code>getFactoryPid</code> method.</para></listitem></itemizedlist>
<para>Creating a new factory configuration must <emphasis>not</emphasis> initiate
a callback to the Managed Service Factory <code>updated</code> method
until the properties are set in the <code>Configuration</code> object
with the <code>update</code> method.</para></section>
<section><title>Accessing Existing Configurations</title>
<para>The existing set of <code>Configuration</code> objects can
be listed with 
<phrase role="xref">listConfigurations(String)</phrase>
. The argument is a <code>String</code> object with a filter expression.
This filter expression has the same syntax as the Framework <code>Filter</code> class.
For example:</para>
<programlisting>(&amp;(size=42)(service.factoryPid=*osgi*))</programlisting>
<para>The Configuration Admin service must only return Configurations
that are visible to the calling bundle, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1573084"/></phrase>
.</para>
<para>A single <code>Configuration</code> object is identified with
a PID, and can be obtained with 
<phrase role="xref">listConfigurations(String)</phrase>
 if it is visible. <code>null</code> is returned in both cases when
there are no visible <code>Configuration</code> objects. </para>
<para>The PIDs that are filtered on can be targeted PIDs, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1891430"/></phrase>
.</para></section>
<section><title>Updating a Configuration</title>
<para>The process of updating a <code>Configuration</code> object
is the same for Managed Services and Managed Service Factories.
First, 
<phrase role="xref">listConfigurations(String)</phrase>
 or 
<phrase role="xref">getConfiguration(String)</phrase>
 should be used to get a <code>Configuration</code> object. The
properties can be obtained with <code>Configuration.getProperties</code>. When
no update has occurred since this object was created, <code>getProperties</code> returns 
<code>null</code>.</para>
<para>New properties can be set by calling <code>Configuration.update</code>.
The Configuration Admin service must first store the configuration
information and then call all configuration targets that have visibility
with the <code>updated</code> method: either the <code>ManagedService.</code>
<phrase role="xref">updated(Dictionary)</phrase>
 or <code>ManagedServiceFactory.</code>
<phrase role="xref">updated(String,Dictionary)</phrase>
 method. If a target service is not registered, the fresh configuration
information must be given to the target when the configuration target
service registers and it has visibility. Each update of the Configuration
properties must update a counter in the Configuration object after
the data has been persisted but before the target(s) have been updated
and any events are sent out. This counter is available from the 
<phrase role="xref">getChangeCount()</phrase>
 method.</para>
<para>The <code>update</code> method calls in <code>Configuration</code> objects
are not executed synchronously with the related target services <code>updated</code> method.
The <code>updated</code> method must be called asynchronously. The
Configuration Admin service, however, must have updated the persistent
storage before the <code>update</code> method returns.</para>
<para>The update method must also asynchronously send out a Configuration
Event 
<phrase role="xref">CM_UPDATED</phrase>
 to all registered Configuration Listeners.</para></section>
<section><title>Using Multi-Locations</title>
<para>Sharing configuration between different bundles can be done
using multi-locations, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1573084"/></phrase>
. A multi-location for a Configuration enables this Configuration
to be delivered to any bundle that has visibility to that configuration.
It is also possible that Bundles are interested in multiple PIDs
for one target service, for this reason they can register multiple
PIDs for one service.</para>
<para>For example, a number of bundles require access to the URL
of a remote host, associated with the PID <code>com.acme.host</code>.
A manager, aware that this PID is used by different bundles, would
need to specify a location for the Configuration that allows delivery
to any bundle. A multi-location, any location starting with a question
mark achieves this. The part after the question mark has only use
if the system runs with security, it allows the implementation of
regions, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1848302"/></phrase>
. In this example a single question mark is used because any Bundle
can receive this Configuration. The manager’s code could look like:</para>
<programlisting>Configuration c = admin.getConfiguration("com.acme.host", "?" );
Hashtable ht = new Hashtable();
ht.put( "host", hostURL);
c.update(ht);</programlisting>
<para>A Bundle interested in the host configuration would register
a Managed Service with the following properties:</para>
<programlisting>service.pid						= [ "com.acme.host", "com.acme.system"]</programlisting>
<para>The Bundle would be called back for both the com.acme.host
and com.acme.system PID and must therefore discriminate between
these two cases. This Managed Service therefore would have a callback
like:</para>
<programlisting>volatile URL url;
public void updated( Dictionary d ) {
  if ( d.get("service.pid").equals("com.acme.host"))
	  this.url = new URL( d.get("host"));
  if ( d.get("service.pid").equals("com.acme.system"))
		....
}</programlisting></section>
<section xml:id="i1848302"><title>
Regions</title>
<para>In certain cases it is necessary to isolate bundles from each
other. This will require that the configuration can be separated
in <emphasis>regions</emphasis>. Each region can then be configured
by a separate manager that is only allowed to manage bundles in
its own region. Bundles can then only see configurations from their
own region. Such a region based system can only be achieved with
Java security as this is the only way to place bundles in a sandbox.
This section describes how the Configuration’s location binding
can be used to implement regions if Java security is active.</para>
<para>Regions are groups of bundles that share location information
among each other but are not willing to share this information with
others. Using the multi-locations, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1573084"/></phrase>
, and security it is possible to limit access to a Configuration
by using a location name. A Bundle can only receive a Configuration
when it has 
<phrase role="xref">ConfigurationPermission</phrase>
<code>[location name,</code>
<phrase role="xref">TARGET</phrase>
<code>]</code>. It is therefore possible to create region by choosing
a region name for the location. A management agent then requires 
<phrase role="xref">ConfigurationPermission</phrase>
<code>[?region-name,</code>
<phrase role="xref">CONFIGURE</phrase>
<code>]</code> and a Bundle in the region requires<code> </code>
<phrase role="xref">ConfigurationPermission</phrase>
<code>[?region-name,</code>
<phrase role="xref">TARGET</phrase>
<code>]. </code></para>
<para>To implement regions, the management agent is required to
use multi-locations; without the question mark a Configuration is
only visible to a Bundle that has the exact location of the Configuration. With
a multi-location, the Configuration is delivered to any bundle that
has the appropriate permission. Therefore, if regions are used,
no manager should have <code>ConfigurationPermission[*,
<phrase role="xref">CONFIGURE</phrase>
]</code> because it would be able to configure anybody. This permission
would enable the manager to set the location to any region or set
the location to <code>null</code>. All managers must be restricted
to a permission like <code>ConfigurationPermission[?com.acme.region.*,CONFIGURE]. </code>The
resource name for a Configuration Permission uses substring matching
as in the OSGi Filter, this facility can be used to simplify the
administrative setup and implement more complex sharing schemes.</para>
<para>For example, a management agent works for the region <code>com.acme</code>.
It has the following permission:</para>
<programlisting><phrase role="xref">ConfigurationPermission</phrase>[?com.acme.*,<phrase role="xref">CONFIGURE</phrase>]</programlisting>
<para>The manager requires multi-location updates for <code>com.acme.* </code>(the
last full stop is required in this wildcarding). For the 
<phrase role="xref">CONFIGURE</phrase>
 action the question mark must be specified in the resource name.
The bundles in the region have the permission:</para>
<programlisting><phrase role="xref">ConfigurationPermission</phrase>["?com.acme.alpha",<phrase role="xref">TARGET</phrase>]</programlisting>
<para>The question mark must be specified for the 
<phrase role="xref">TARGET</phrase>
 permission. A management agent that needs to configure Bundles
in a region must then do this as follows:</para>
<programlisting>Configuration c = admin.getConfiguration("com.acme.host", "?com.acme.alpha" );
Hashtable ht = new Hashtable();
ht.put( "host", hostURL);
c.update(ht);</programlisting>
<para>Another, similar, example with two regions:</para>
<itemizedlist><listitem><para><code>system</code></para></listitem>
<listitem><para><code>application</code></para></listitem></itemizedlist>
<para>There is only one manager that manages all bundles. Its permissions
look like:</para>
<programlisting>ConfigurationPermission[?system,<code><phrase role="xref">CONFIGURE</phrase></code>]
ConfigurationPermission[?application,<code><phrase role="xref">CONFIGURE</phrase></code>]</programlisting>
<para>A Bundle in the <code>application</code> region can have the
following permissions:</para>
<programlisting>ConfigurationPermission[?application,<code><phrase role="xref">TARGET</phrase></code>]</programlisting>
<para>This managed bundle therefore has only visibility to configurations
in the <code>application</code> region.</para></section>
<section><title>Deletion</title>
<para>A <code>Configuration </code>object that is no longer needed
can be deleted with <code>Configuration.delete</code>, which removes
the <code>Configuration</code> object from the database. The database
must be updated before the target service’s <code>updated</code> or 
<code>deleted</code> method is called. Only services that have received
the configuration dictionary before must be called.</para>
<para>If the target service is a Managed Service Factory, the factory
is informed of the deleted <code>Configuration</code> object by
a call to <code>ManagedServiceFactory.</code>
<phrase role="xref">deleted(String)</phrase>
 method. It should then remove the associated <emphasis>instance</emphasis>.
The <code>ManagedServiceFactory.</code>
<phrase role="xref">deleted(String)</phrase>
 call must be done asynchronously with respect to <code>Configuration.</code>
<phrase role="xref">delete()</phrase>
.</para>
<para>When a <code>Configuration</code> object of a Managed Service
is deleted, <code>ManagedService.updated</code> is called with <code>null</code> for the 
<code>properties</code> argument. This method may be used for clean-up,
to revert to default values, or to unregister a service. This method
is called asynchronously from the <code>delete</code> method.</para>
<para>The update method must also asynchronously send out a Configuration
Event 
<phrase role="xref">CM_DELETED</phrase>
<code> </code>to all registered Configuration Listeners.</para></section>
<section><title>Updating a Bundle’s Own Configuration</title>
<para>The Configuration Admin service specification does not distinguish
between updates via a Management Agent and a bundle updating its
own configuration information (as defined by its location). Even
if a bundle updates its own configuration information, the Configuration
Admin service must callback the associated target service’s <code>updated</code> method.</para>
<para>As a rule, to update its own configuration, a bundle’s user
interface should <emphasis>only</emphasis> update the configuration
information and never its internal structures directly. This rule
has the advantage that the events, from the bundle implementation’s
perspective, appear similar for internal updates, remote management
updates, and initialization.</para></section></section>
<section xml:id="i1693263"><title>
Configuration
Events</title>
<para>Configuration Admin can update interested parties of changes
in its repository. The model is based on the white board pattern
where Configuration Listener services are registered with the service
registry. </para>
<para>There are two types of Configuration Listener services:</para>
<itemizedlist><listitem><para><phrase role="xref">ConfigurationListener</phrase>
 – The default Configuration Listener receives events asynchronously
from the method that initiated the event and on another thread.</para></listitem>
<listitem><para><phrase role="xref">SynchronousConfigurationListener</phrase>
 – A Synchronous Configuration Listener is guaranteed to be called
on the same thread as the method call that initiated the event.</para></listitem></itemizedlist>
<para>The Configuration Listener service will receive 
<phrase role="xref">ConfigurationEvent</phrase>
 objects if important changes take place. The Configuration Admin
service must call the 
<phrase role="xref">configurationEvent(ConfigurationEvent)</phrase>
 method with such an event. Configuration Events must be delivered
in order for each listener as they are generated. The way events
must be delivered is the same as described in 
<phrase role="xref">Section 4.7.2 “Delivering Events” on page ‑107</phrase>
 of the Core specification.</para>
<para>The <code>ConfigurationEvent</code> object carries a factory
PID (
<phrase role="xref">getFactoryPid()</phrase>
) and a PID (
<phrase role="xref">getPid()</phrase>
). If the factory PID is <code>null</code>, the event is related
to a Managed Service <code>Configuration</code> object, else the
event is related to a Managed Service <code>Factory</code> <code>Configuration</code> object.</para>
<para>The <code>ConfigurationEvent</code> object can deliver the
following events from the 
<phrase role="xref">getType()</phrase>
 method:</para>
<itemizedlist><listitem><para><phrase role="xref">CM_DELETED</phrase>
 – The <code>Configuration</code> object is deleted.</para></listitem>
<listitem><para><phrase role="xref">CM_UPDATED</phrase>
 – The <code>Configuration</code> object is updated.</para></listitem>
<listitem><para><phrase role="xref">CM_LOCATION_CHANGED</phrase>
 – The location of the <code>Configuration </code>object changed.</para></listitem></itemizedlist>
<para>The Configuration Event also carries the <code>ServiceReference</code> object
of the Configuration Admin service that generated the event.</para>
<section><title>Event Admin Service and Configuration Change Events</title>
<para>Configuration events must be delivered asynchronously by the
Configuration Admin implementation, if present. The topic of a configuration
event must be:</para>
<programlisting>org/osgi/service/cm/ConfigurationEvent/&lt;eventtype&gt;</programlisting>
<para>The &lt;event type&gt; can be any of the following:</para>
<programlisting><phrase role="xref">CM_DELETED</phrase>
<phrase role="xref">CM_UPDATED</phrase>
<phrase role="xref">CM_LOCATION_CHANGED</phrase></programlisting>
<para>The properties of a configuration event are:</para>
<itemizedlist><listitem><para><code>cm.factoryPid</code> – (<code>String</code>)
The factory PID of the associated <code>Configuration</code> object,
if the target is a Managed Service Factory. Otherwise not set.</para></listitem>
<listitem><para><code>cm.pid</code> – (<code>String</code>) The
PID of the associated <code>Configuration</code> object.</para></listitem>
<listitem><para><code>service</code> – (<code>ServiceReference</code>)
The Service Reference of the Configuration Admin service.</para></listitem>
<listitem><para><code>service.id</code> – (<code>Long</code>) The
Configuration Admin service's ID.</para></listitem>
<listitem><para><code>service.objectClass</code> – (<code>String[]</code>)
The Configuration Admin service's object class (which must include 
<code>org.osgi.service.cm.ConfigurationAdmin</code>)</para></listitem>
<listitem><para><code>service.pid</code> – (<code>String</code>)
The Configuration Admin service's persistent identity, if set.</para></listitem></itemizedlist></section></section>
<section xml:id="i1459884"><title>
Configuration
Plugin</title>
<para>The Configuration Admin service allows third-party applications
to participate in the configuration process. Bundles that register
a service object under a  <code>ConfigurationPlugin</code> interface
can process the configuration dictionary just before it reaches
the configuration target service.</para>
<para xml:id="i1490844">Plug-ins allow sufficiently 
privileged bundles
to intercept configuration dictionaries just <emphasis>before</emphasis> they must
be passed to the intended Managed Service or Managed Service Factory
but <emphasis>after</emphasis> the properties are stored. The changes
the plug-in makes are dynamic and must not be stored. The plug-in
must only be called when an update takes place while it is registered
and there is a valid dictionary. The plugin is not called when a
configuration is deleted.</para>
<para>The <code>ConfigurationPlugin</code> interface has only one
method: 
<phrase role="xref">modifyConfiguration(ServiceReference,Dictionary)</phrase>
. This method inspects or modifies configuration data.</para>
<para xml:id="i1490848">All plug-ins in the service registry must
be traversed and called
before the properties are passed to the configuration target service.
Each Configuration Plugin object gets a chance to inspect the existing data,
look at the target object, which can be a <code>ManagedService</code> object
or a <code>ManagedServiceFactory</code> object, and modify the properties
of the configuration dictionary. The changes made by a plug-in must
be visible to plugins that are called later.</para>
<para><code>ConfigurationPlugin</code> objects should not modify
properties that belong to the configuration properties of the target
service unless the implications are understood. This functionality
is mainly intended to provide functions that leverage the Framework
service registry. The changes made by the plugin should normally
not be validated. However, the Configuration Admin must ignore changes
to the automatic properties as described in 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1374751"/></phrase>
.</para>
<para>For example, a Configuration Plugin service may add a physical
location property to a service. This property can be leveraged by
applications that want to know where a service is physically located. This
scenario could be carried out without any further support of the
service itself, except for the general requirement that the service
should propagate the public properties it receives from the Configuration
Admin service to the service registry.</para>
<figure><title>Order of Configuration Plugin Services</title>
<mediaobject><imageobject><imagedata fileref="GRAPHIC8" align="center" contentwidth="7.000in" contentdepth="1.722in"/></imageobject></mediaobject></figure>
<section xml:id="i1490850"><title>
Limiting
The Targets</title>
<para xml:id="i1490849">A <code>ConfigurationPlugin</code> object
may optionally specify a <code>
cm.target</code> registration
property. This value is the PID of the configuration target whose
configuration updates the <code>ConfigurationPlugin</code> object
wants to intercept. </para>
<para>The <code>ConfigurationPlugin</code> object must then only
be called with updates for the configuration target service with
the specified PID. For a factory target service, the factory PID
is used and the plugin will see all instances of the factory. Omitting
the <code>cm.target</code> registration property means that it is
called for <emphasis>all</emphasis> configuration updates. </para></section>
<section><title>Example of Property Expansion</title>
<para>Consider a Managed Service that has a configuration property 
<code>service.to</code> with the value <code>(objectclass=com.acme.Alarm</code>).
When the Configuration Admin service sets this property on the target
service, a <code>ConfigurationPlugin</code> object may replace the 
<code>(objectclass=com.acme.Alarm)</code> filter with an array of
existing alarm systems' PIDs as follows:</para>
<programlisting>ID "service.to=[32434,232,12421,1212]"</programlisting>
<para>A new Alarm Service with <code>service.pid=343</code> is registered,
requiring that the list of the target service be updated. The bundle
which registered the Configuration Plugin service, therefore, wants
to set the <code>service.to</code> registration property on the
target service. It does <emphasis>not</emphasis> do this by calling 
<code>ManagedService.updated</code> directly for several reasons: </para>
<itemizedlist><listitem><para>In a securely configured system, it
should not have the permission to make this call or even obtain the
target service.</para></listitem>
<listitem><para>It could get into race conditions with the Configuration
Admin service if it had the permissions in the previous bullet.
Both services would compete for access simultaneously.</para></listitem></itemizedlist>
<para>Instead, it must get the <code>Configuration</code> object
from the Configuration Admin service and call the <code>update</code> method
on it.</para>
<para>The Configuration Admin service must schedule a new update
cycle on another thread, and sometime in the future must call <code>ConfigurationPlugin.modifyProperties</code>.
The <code>ConfigurationPlugin</code> object could then set the <code>service.to</code> property
to <code>[32434,232,12421,1212, 343]</code>. After that, the Configuration
Admin service must call <code>updated</code> on the target service
with the new <code>service.to</code> list.</para></section>
<section xml:id="i1490867"><title>

Configuration
Data Modifications</title>
<para>Modifications to the configuration dictionary are still under
the control of the Configuration Admin service, which must determine
whether to accept the changes, hide critical variables, or deny
the changes for other reasons.</para>
<para>The <code>ConfigurationPlugin</code> interface must also allow
plugins to detect configuration updates to the service via the callback.
This ability allows them to synchronize the configuration updates
with transient information. </para></section>
<section><title>Forcing a Callback</title>
<para>If a bundle needs to force a Configuration Plugin service
to be called again, it must fetch the appropriate <code>Configuration</code> object
from the Configuration Admin service and call the <code>update()</code> method
(the no parameter version) on this object. This call forces an update
with the current configuration dictionary so that all applicable
plug-ins get called again.</para></section>
<section><title>Calling Order</title>
<para>The order in which the <code>ConfigurationPlugin</code> objects
are called must depend on the <code>service.cmRanking</code> configuration
property of the <code>ConfigurationPlugin</code> object. 
<phrase role="xref">
<xref xrefstyle="TableNumber" linkend="i1624384"/></phrase>
 shows the usage of the <code>service.cmRanking</code> property
for the order of calling the Configuration Plugin services.</para>
<table><title><code xml:id="i1624384">
service.cmRanking</code> Usage
For Ordering</title><tgroup cols="2"><thead><row><entry>
service.cmRanking
value</entry><entry>Description</entry></row></thead><tbody><row><entry><code>&lt; 0</code></entry><entry><para>The Configuration Plugin service should not modify properties
and must be called before any modifications are made.</para></entry></row><row><entry><code>&gt;= 0 &amp;&amp; &lt;= 1000</code></entry><entry><para xml:id="i1624378">The Configuration Plugin service modifies
the configuration data. The 
calling order
should be based on the value of the <code>service.cmRanking</code> property.</para></entry></row><row><entry><code>&gt; 1000</code></entry><entry><para>The Configuration Plugin service should not modify data
and is called after all modifications are made.</para></entry></row></tbody></tgroup></table></section></section>
<section xml:id="i1288153"><title>
Meta
Typing</title>
<para>This section discusses how the Metatype specification is used
in the context of a Configuration Admin service.</para>
<para>When a Managed Service or Managed Service Factory is registered,
the service object may also implement the <code>MetaTypeProvider</code> interface. </para>
<para>If the Managed Service or Managed Service Factory object implements
the <code>MetaTypeProvider</code> interface, a management bundle
may assume that the associated <code>ObjectClassDefinition</code> object
can be used to configure the service.</para>
<para>The <code>ObjectClassDefinition</code> and <code>AttributeDefinition</code> objects
contain sufficient information to automatically build simple user
interfaces. They can also be used to augment dedicated interfaces
with accurate validations.</para>
<para>When the Metatype specification is used, care should be taken
to match the capabilities of the metatype package to the capabilities
of the Configuration Admin service specification. Specifically:</para>
<itemizedlist><listitem><para>The metatype specification cannot
describe nested arrays and vectors or arrays/vectors of mixed type.</para></listitem></itemizedlist>
<para>This specification does not address how the metatype is made
available to a management system due to the many open issues regarding
remote management.</para></section>
<section><title>Security</title>
<section xml:id="i1693439"><title>
Configuration
Permission</title>
<para>Every bundle has the implicit right to receive and configure
configurations with a location that exactly matches the Bundle’s
location or that is <code>null</code>. For all other situations
the Configuration Admin must verify that the configuring and to
be updated bundles have a Configuration Permission that matches
the Configuration’s location.</para>
<para>The resource name of this permission maps to the location
of the Configuration, the location can control the visibility of
a Configuration for a bundle. The resource name is compared with
the actual configuration location using the OSGi Filter sub-string
matching. The question mark for multi-locations is part of the given
resource name. The Configure Permission has the following actions:</para>
<itemizedlist><listitem><para><phrase role="xref">CONFIGURE</phrase>
 – Can manage matching configurations</para></listitem>
<listitem><para><phrase role="xref">TARGET</phrase>
 – Can be updated with a matching configuration</para></listitem></itemizedlist>
<para>To be able to set the location to <code>null</code> requires
a <code>ConfigurationPermission[*,</code>
<phrase role="xref">CONFIGURE</phrase>
<code>]</code>.</para>
<para>It is possible to deny bundles the use of multi-locations
by using Conditional Permission Admin’s deny model.</para></section>
<section><title>Permissions Summary</title>
<para>Configuration Admin service security is implemented using
Service Permission and Configuration Permission. The following table
summarizes the permissions needed by the Configuration Admin bundle
itself, as well as the typical permissions needed by the bundles
with which it interacts.</para>
<para>Configuration Admin:</para>
<programlisting>ServicePermission[ ..ConfigurationAdmin, REGISTER]
ServicePermission[ ..ManagedService, GET ]
ServicePermission[ ..ManagedServiceFactory, GET ]
ServicePermission[ ..ConfigurationPlugin, GET ]
ConfigurationPermission[ *, CONFIGURE ]
AdminPermission[ *, METADATA ]</programlisting>
<para>Managed Service:</para>
<programlisting>ServicePermission[ ..ConfigurationAdmin, GET]
ServicePermission[ ..ManagedService, REGISTER ]
ConfigurationPermission[ ... , TARGET ]</programlisting>
<para>Managed Service Factory:</para>
<programlisting>ServicePermission[ ..ConfigurationAdmin, GET]
ServicePermission[ ..ManagedServiceFactory, REGISTER ]
ConfigurationPermission[ ... , TARGET ]</programlisting>
<para>Configuration Plugin:</para>
<programlisting>ServicePermission[ ..ConfigurationPlugin,REGISTER ]</programlisting>
<para>Configuration Listener:</para>
<programlisting>ServicePermission[ ..ConfigurationListener,REGISTER ]</programlisting>
<para>The Configuration Admin service must have <code>ServicePermission[
ConfigurationAdmin, REGISTER]</code>. It will also be the only bundle
that needs the <code>ServicePermission[ManagedService | ManagedServiceFactory
|ConfigurationPlugin, GET]</code>. No other bundle should be allowed
to have <code>GET </code>permission for these interfaces. The Configuration Admin
bundle must also hold <code>ConfigurationPermission[*,CONFIGURE]</code>.</para>
<para>Bundles that can be configured must have the <code>ServicePermission[ManagedService
| ManagedServiceFactory, REGISTER]</code>. Bundles registering <code>ConfigurationPlugin</code> objects
must have <code>ServicePermission[ConfigurationPlugin, REGISTER]</code>.
The Configuration Admin service must trust all services registered
with the <code>ConfigurationPlugin</code> interface. Only the Configuration
Admin service should have <code>ServicePermission[ ConfigurationPlugin,
GET]</code>. </para>
<para>If a Managed Service or Managed Service Factory is implemented
by an object that is also registered under another interface, it
is possible, although inappropriate, for a bundle other than the
Configuration Admin service implementation to call the <code>updated</code> method.
Security-aware bundles can avoid this problem by having their updated
methods check that the caller has <code>ConfigurationPermission[*,CONFIGURE]</code>.</para>
<para>Bundles that want to change their own configuration need <code>ServicePermission[ConfigurationAdmin,
GET]</code>. A bundle with <code>ConfigurationPermission[*,CONFIGURE]</code>is
allowed to access and modify any <code>Configuration</code> object.</para>
<para>Pre-configuration of bundles requires <code>ConfigurationPermission[location,CONFIGURE]</code> (location
can use the sub-string matching rules of the Filter) because the
methods that specify a location require this permission.</para></section>
<section><title>Configuration and Permission Administration</title>
<para>Configuration information has a direct influence on the permissions
needed by a bundle. For example, when the Configuration Admin Bundle
orders a bundle to use port 2011 for a console, that bundle also
needs permission for listening to incoming connections on that port.</para>
<para>Both a simple and a complex solution exist for this situation. </para>
<para>The simple solution for this situation provides the bundle
with a set of permissions that do not define specific values but
allow a range of values. For example, a bundle could listen to ports
above 1024 freely. All these ports could then be used for configuration.</para>
<para>The other solution is more complicated. In an environment
where there is very strong security, the bundle would only be allowed
access to a specific port. This situation requires an atomic update
of both the configuration data and the permissions. If this update
was not atomic, a potential security hole would exist during the
period of time that the set of permissions did not match the configuration. </para>
<para>The following scenario can be used to update a configuration
and the security permissions:</para>
<orderedlist><listitem><para>Stop the bundle.</para></listitem>
<listitem><para>Update the appropriate <code>Configuration</code> object
via the Configuration Admin service.</para></listitem>
<listitem><para>Update the permissions in the Framework.</para></listitem>
<listitem><para>Start the bundle.</para></listitem></orderedlist>
<para>This scenario would achieve atomicity from the point of view
of the bundle.</para></section></section>
<section><title>Changes</title>
<itemizedlist><listitem><para>Added targeted PIDs, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1891430"/></phrase>
.</para></listitem>
<listitem><para>Added a persistent change count method on Configurable
to make it easier to detect changes.</para></listitem>
<listitem><para>Added a Synchronous Configuration Listener to be
able to detect thread based systems like the Coordinator, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1693263"/></phrase>
.</para></listitem></itemizedlist></section>
<INSET xml:id="i1938008">org.osgi.service.cm<?FM MARKER [Cross-Ref] org.osgi.service.cm?>
<?FM MARKER [Index] org.osgi.service.cm?>
<?FM MARKER [Cross-Ref] package:org.osgi.service.cm?>

Configuration Admin Package Version 1.5.  
Bundles wishing to use this package must list the package in the
Import-Package header of the bundle’s manifest. This package has
two types of users: the consumers that use the API in this package and
the providers that implement the API in this package. 
Example import for consumers using the API in this package: 
Import-Package: org.osgi.service.cm; version=”[1.5,2.0)”
Example import for providers implementing the API in this package: 
Import-Package: org.osgi.service.cm; version=”[1.5,1.6)”
Summary
Configuration –  The configuration information for a ManagedService
or ManagedServiceFactory object. 
ConfigurationAdmin –  Service for administering configuration data. 
ConfigurationEvent –  A Configuration Event. 
ConfigurationException –  An Exception class to inform the Configuration
Admin service of problems with configuration data. 
ConfigurationListener –  Listener for Configuration Events. 
ConfigurationPermission –  Indicates a bundle’s authority to configure
bundles or be updated by Configuration Admin. 
ConfigurationPlugin –  A service interface for processing configuration
dictionary before the update. 
ManagedService –  A service that can receive configuration data
from a Configuration Admin service. 
ManagedServiceFactory –  Manage multiple service instances. 
SynchronousConfigurationListener –  Synchronous Listener for Configuration
Events. 
Permissions
ManagedServiceFactory
updated(String,Dictionary)
ConfigurationPermission[c.location,TARGET] – Required by the bundle
that registered this service
ManagedService
updated(Dictionary)
ConfigurationPermission[c.location,TARGET] – Required by the bundle
that registered this service
ConfigurationAdmin
createFactoryConfiguration(String,String)
ConfigurationPermission[location,CONFIGURE] – if location is not
null
ConfigurationPermission[”*”,CONFIGURE] – if location is null
getConfiguration(String,String)
ConfigurationPermission[*,CONFIGURE] – if location is null or if
the returned configuration c already exists and c.location is null
ConfigurationPermission[location,CONFIGURE] – if location is not
null
ConfigurationPermission[c.location,CONFIGURE] – if the returned
configuration c already exists and c.location is not null
getConfiguration(String)
ConfigurationPermission[c.location,CONFIGURE] – If the configuration
c already exists and c.location is not null
listConfigurations(String)
ConfigurationPermission[c.location,CONFIGURE] – Only configurations
c are returned for which the caller has this permission
Configuration
setBundleLocation(String)
ConfigurationPermission[this.location,CONFIGURE] – if this.location
is not null
ConfigurationPermission[location,CONFIGURE] – if location is not
null
ConfigurationPermission[”*”,CONFIGURE] – if this.location is null
or if location is null
getBundleLocation()
ConfigurationPermission[this.location,CONFIGURE] – if this.location
is not null
ConfigurationPermission[”*”,CONFIGURE] – if this.location is null
<?FM MARKER [Cross-Ref] Configuration?>
<?FM MARKER [Index] Configuration?>
<?FM MARKER [Index] interface:Configuration?>
Configuration
public interface Configuration
The configuration information for a ManagedService or ManagedServiceFactory
object.  The Configuration Admin service uses this interface to
represent the configuration information for a ManagedService or
for a service instance of a ManagedServiceFactory.  
A Configuration object contains a configuration dictionary and allows
the properties to be updated via this object. Bundles wishing to
receive configuration dictionaries do not need to use this class
- they register a ManagedService or ManagedServiceFactory. Only
administrative bundles, and bundles wishing to update their own
configurations need to use this class.  
The properties handled in this configuration have case insensitive
String objects as keys. However, case must be preserved from the
last set key/value. 
A configuration can be bound to a specific bundle or to a region
of bundles using the location. In its simplest form the location
is the location of the target bundle that registered a Managed Service
or a Managed Service Factory. However, if the location starts with
? then the location indicates multiple delivery. In such a case
the configuration must be delivered to all targets.  If security
is on, the Configuration Permission can be used to restrict the
targets that receive updates. The Configuration Admin must only
update a target when the configuration location matches the location
of the target’s bundle or the target bundle has a Configuration
Permission with the action ConfigurationPermission.TARGET and a
name that matches the configuration location. The name in the permission
may contain wildcards ( ‘*’) to match the location using the same
substring matching rules as Filter.  Bundles can always create,
manipulate, and be updated from configurations that have a location
that matches their bundle location. 
If a configuration’s location is null, it is not yet bound to a
location. It will become bound to the location of the first bundle
that registers a ManagedService or ManagedServiceFactory object
with the corresponding PID. 
The same Configuration object is used for configuring both a Managed
Service Factory and a Managed Service. When it is important to differentiate
between these two the term “factory configuration” is used.
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] Configuration.delete()?>
<?FM MARKER [Index] Configuration:delete?>
<?FM MARKER [Index] delete?>
delete()
public void delete ( ) throws IOException
	
Delete this Configuration object.  Removes this configuration object
from the persistent store. Notify asynchronously the corresponding
Managed Service or Managed Service Factory. A ManagedService object
is notified by a call to its updated method with a null properties
argument. A ManagedServiceFactory object is notified by a call to
its deleted method.  
Also initiates an asynchronous call to all ConfigurationListeners
with a ConfigurationEvent.CM_DELETED event.
	Throws	IOException –  If delete fails. 
		IllegalStateException –  If this configuration has been deleted. 
<?FM MARKER [Cross-Ref] Configuration.equals(Object)?>
<?FM MARKER [Index] Configuration:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object other ) 
	other	Configuration object to compare against
	
Equality is defined to have equal PIDs  Two Configuration objects
are equal when their PIDs are equal. 
	Returns	true if equal, false if not a Configuration object or one
with a different PID.
<?FM MARKER [Cross-Ref] Configuration.getBundleLocation()?>
<?FM MARKER [Index] Configuration:getBundleLocation?>
<?FM MARKER [Index] getBundleLocation?>
getBundleLocation()
public String getBundleLocation ( ) 
	
Get the bundle location.  Returns the bundle location or region
to which this configuration is bound, or null if it is not yet bound
to a bundle location or region. If the location starts with ? then
the configuration is delivered to all targets and not restricted
to a single bundle. 
	Returns	location to which this configuration is bound, or null.
	Throws	IllegalStateException –  If this configuration has been
deleted. 
		SecurityException –  when the required permissions are not available 
	Security	ConfigurationPermission[this.location,CONFIGURE] –  if
this.location is not null
		ConfigurationPermission[”*”,CONFIGURE] –  if this.location is
null
<?FM MARKER [Cross-Ref] Configuration.getChangeCount()?>
<?FM MARKER [Index] Configuration:getChangeCount?>
<?FM MARKER [Index] getChangeCount?>
getChangeCount()
public long getChangeCount ( ) 
	
Get the change count.  The Configuration must maintain a change
counter that every time when this configuration is updated and its
properties are stored is incremented with a positive value. The counter
must be changed after the properties are persisted but before the
targets are updated and events are sent out. 
	Returns	A monotonously increasing value reflecting changes in this
Configuration
	Since	1.5
<?FM MARKER [Cross-Ref] Configuration.getFactoryPid()?>
<?FM MARKER [Index] Configuration:getFactoryPid?>
<?FM MARKER [Index] getFactoryPid?>
getFactoryPid()
public String getFactoryPid ( ) 
	
For a factory configuration return the PID of the corresponding
Managed Service Factory, else return null. 
	Returns	factory PID or null
	Throws	IllegalStateException –  If this configuration has been
deleted. 
<?FM MARKER [Cross-Ref] Configuration.getPid()?>
<?FM MARKER [Index] Configuration:getPid?>
<?FM MARKER [Index] getPid?>
getPid()
public String getPid ( ) 
	
Get the PID for this Configuration object. 
	Returns	the PID for this Configuration object.
	Throws	IllegalStateException –  if this configuration has been
deleted 
<?FM MARKER [Cross-Ref] Configuration.getProperties()?>
<?FM MARKER [Index] Configuration:getProperties?>
<?FM MARKER [Index] getProperties?>
getProperties()
public Dictionary&lt;String,Object&gt; getProperties ( ) 
	
Return the properties of this Configuration object.  The Dictionary
object returned is a private copy for the caller and may be changed
without influencing the stored configuration. The keys in the returned
dictionary are case insensitive and are always of type String.  
If called just after the configuration is created and before update
has been called, this method returns null.
	Returns	A private copy of the properties for the caller or null.
These properties must not contain the “service.bundleLocation” property.
The value of this property may be obtained from the getBundleLocation()
method.
	Throws	IllegalStateException –  If this configuration has been
deleted. 
<?FM MARKER [Cross-Ref] Configuration.hashCode()?>
<?FM MARKER [Index] Configuration:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Hash code is based on PID.  The hash code for two Configuration
objects must be the same when the Configuration PID’s are the same. 
	Returns	hash code for this Configuration object
<?FM MARKER [Cross-Ref] Configuration.setBundleLocation(String)?>
<?FM MARKER [Index] Configuration:setBundleLocation?>
<?FM MARKER [Index] setBundleLocation?>
setBundleLocation(String)
public void setBundleLocation ( String location ) 
	location	a location, region, or null
	
Bind this Configuration object to the specified location.  If the
location parameter is null then the Configuration object will not
be bound to a location/region. It will be set to the bundle’s location before
the first time a Managed Service/Managed Service Factory receives
this Configuration object via the updated method and before any
plugins are called. The bundle location or region will be set persistently.
 
If the location starts with ? then all targets registered with the
given PID must be updated. 
If the location is changed then existing targets must be informed.
If they can no longer see this configuration, the configuration
must be deleted or updated with null. If this configuration becomes
visible then they must be updated with this configuration. 
Also initiates an asynchronous call to all ConfigurationListeners
with a ConfigurationEvent.CM_LOCATION_CHANGED event.
	Throws	IllegalStateException –  If this configuration has been
deleted. 
		SecurityException –  when the required permissions are not available 
		SecurityException –  when the required permissions are not available 
	Security	ConfigurationPermission[this.location,CONFIGURE] –  if
this.location is not null
		ConfigurationPermission[location,CONFIGURE] –  if location is
not null
		ConfigurationPermission[”*”,CONFIGURE] –  if this.location is
null or if location is null
<?FM MARKER [Cross-Ref] Configuration.update(Dictionary)?>
<?FM MARKER [Index] Configuration:update?>
<?FM MARKER [Index] update?>
update(Dictionary)
public void update ( Dictionary&lt;String,?&gt; properties ) throws
IOException
	properties	the new set of properties for this configuration
	
Update the properties of this Configuration object.  Stores the
properties in persistent storage after adding or overwriting the
following properties: 
“service.pid” : is set to be the PID of this configuration.
“service.factoryPid” : if this is a factory configuration it is
set to the factory PID else it is not set.
These system properties are all of type String.  
If the corresponding Managed Service/Managed Service Factory is
registered, its updated method must be called asynchronously. Else,
this callback is delayed until aforementioned registration occurs.
 
Also initiates an asynchronous call to all ConfigurationListeners
with a ConfigurationEvent.CM_UPDATED event.
	Throws	IOException –  if update cannot be made persistent 
		IllegalArgumentException –  if the Dictionary object contains
invalid configuration types or contains case variants of the same
key name. 
		IllegalStateException –  If this configuration has been deleted. 
<?FM MARKER [Cross-Ref] Configuration.update()?>
<?FM MARKER [Index] Configuration:update?>
<?FM MARKER [Index] update?>
update()
public void update ( ) throws IOException
	
Update the Configuration object with the current properties.  Initiate
the updated callback to the Managed Service or Managed Service Factory
with the current properties asynchronously. 
This is the only way for a bundle that uses a Configuration Plugin
service to initiate a callback. For example, when that bundle detects
a change that requires an update of the Managed Service or Managed
Service Factory via its ConfigurationPlugin object.
	Throws	IOException –  if update cannot access the properties in
persistent storage 
		IllegalStateException –  If this configuration has been deleted. 
	See Also	ConfigurationPlugin
<?FM MARKER [Cross-Ref] ConfigurationAdmin?>
<?FM MARKER [Index] ConfigurationAdmin?>
<?FM MARKER [Index] interface:ConfigurationAdmin?>
ConfigurationAdmin
public interface ConfigurationAdmin
Service for administering configuration data.  
The main purpose of this interface is to store bundle configuration
data persistently. This information is represented in Configuration
objects. The actual configuration data is a Dictionary of properties
inside a Configuration object.  
There are two principally different ways to manage configurations.
First there is the concept of a Managed Service, where configuration
data is uniquely associated with an object registered with the service
registry.  
Next, there is the concept of a factory where the Configuration
Admin service will maintain 0 or more Configuration objects for
a Managed Service Factory that is registered with the Framework. 
The first concept is intended for configuration data about “things/services”
whose existence is defined externally, e.g. a specific printer.
Factories are intended for “things/services” that can be created
any number of times, e.g. a configuration for a DHCP server for
different networks. 
Bundles that require configuration should register a Managed Service
or a Managed Service Factory in the service registry. A registration
property named service.pid (persistent identifier or PID) must be
used to identify this Managed Service or Managed Service Factory
to the Configuration Admin service.  
When the ConfigurationAdmin detects the registration of a Managed
Service, it checks its persistent storage for a configuration object
whose service.pid property matches the PID service property ( service.pid)
of the Managed Service. If found, it calls ManagedService.updated(Dictionary)
method with the new properties. The implementation of a Configuration
Admin service must run these call-backs asynchronously to allow
proper synchronization.  
When the Configuration Admin service detects a Managed Service Factory
registration, it checks its storage for configuration objects whose
service.factoryPid property matches the PID service property of
the Managed Service Factory. For each such Configuration objects,
it calls the ManagedServiceFactory.updated method asynchronously
with the new properties. The calls to the updated method of a ManagedServiceFactory
must be executed sequentially and not overlap in time. 
In general, bundles having permission to use the Configuration Admin
service can only access and modify their own configuration information.
Accessing or modifying the configuration of other bundles requires
ConfigurationPermission[location,CONFIGURE], where location is the
configuration location. 
Configuration objects can be bound to a specified bundle location
or to a region (configuration location starts with ?). If a location
is not set, it will be learned the first time a target is registered.
If the location is learned this way, the Configuration Admin service
must detect if the bundle corresponding to the location is uninstalled.
If this occurs, the Configuration object must be unbound, that is
its location field is set back to null.  
If target’s bundle location matches the configuration location it
is always updated. 
If the configuration location starts with ?, that is, the location
is a region, then the configuration must be delivered to all targets
registered with the given PID. If security is on, the target bundle
must have Configuration Permission[location,TARGET], where location
matches given the configuration location with wildcards as in the
Filter substring match. The security must be verified using the org.osgi.framework.Bundle.hasPermission(Object)
method on the target bundle. 
If a target cannot be updated because the location does not match
or it has no permission and security is active then the Configuration
Admin service must not do the normal callback.  
The method descriptions of this class refer to a concept of “the
calling bundle”. This is a loose way of referring to the bundle
which obtained the Configuration Admin service from the service
registry. Implementations of ConfigurationAdmin must use a org.osgi.framework.ServiceFactory
to support this concept.
	No Implement	Consumers of this API must not implement this interface 
<?FM MARKER [Cross-Ref] ConfigurationAdmin.SERVICE_BUNDLELOCATION?>
<?FM MARKER [Index] ConfigurationAdmin:SERVICE_BUNDLELOCATION?>
<?FM MARKER [Index] SERVICE_BUNDLELOCATION?>
SERVICE_BUNDLELOCATION
public static final String SERVICE_BUNDLELOCATION = “service.bundleLocation”<?FM MARKER [Index] service.bundleLocation?>

Configuration property naming the location of the bundle that is
associated with a a Configuration object. This property can be searched
for but must not appear in the configuration dictionary for security
reason. The property’s value is of type String. 
	Since	1.1
<?FM MARKER [Cross-Ref] ConfigurationAdmin.SERVICE_FACTORYPID?>
<?FM MARKER [Index] ConfigurationAdmin:SERVICE_FACTORYPID?>
<?FM MARKER [Index] SERVICE_FACTORYPID?>
SERVICE_FACTORYPID
public static final String SERVICE_FACTORYPID = “service.factoryPid”<?FM MARKER [Index] service.factoryPid?>

Configuration property naming the Factory PID in the configuration
dictionary. The property’s value is of type String. 
	Since	1.1
<?FM MARKER [Cross-Ref] ConfigurationAdmin.createFactoryConfiguration(String)?>
<?FM MARKER [Index] ConfigurationAdmin:createFactoryConfiguration?>
<?FM MARKER [Index] createFactoryConfiguration?>
createFactoryConfiguration(String)
public Configuration createFactoryConfiguration ( String factoryPid
) throws IOException
	factoryPid	PID of factory (not null).
	
Create a new factory Configuration object with a new PID.  The properties
of the new Configuration object are null until the first time that
its Configuration.update(Dictionary) method is called.  
It is not required that the factoryPid maps to a registered Managed
Service Factory. 
The Configuration object is bound to the location of the calling
bundle. It is possible that the same factoryPid has associated configurations
that are bound to different bundles. Bundles should only see the
factory configurations that they are bound to or have the proper
permission.
	Returns	A new Configuration object.
	Throws	IOException –  if access to persistent storage fails. 
<?FM MARKER [Cross-Ref] ConfigurationAdmin.createFactoryConfiguration(String,String)?>
<?FM MARKER [Index] ConfigurationAdmin:createFactoryConfiguration?>
<?FM MARKER [Index] createFactoryConfiguration?>
createFactoryConfiguration(String,String)
public Configuration createFactoryConfiguration ( String factoryPid
, String location ) throws IOException
	factoryPid	PID of factory (not null).
	location	A bundle location string, or null.
	
Create a new factory Configuration object with a new PID.  The properties
of the new Configuration object are null until the first time that
its Configuration.update(Dictionary) method is called.  
It is not required that the factoryPid maps to a registered Managed
Service Factory. 
The Configuration is bound to the location specified. If this location
is null it will be bound to the location of the first bundle that
registers a Managed Service Factory with a corresponding PID. It
is possible that the same factoryPid has associated configurations
that are bound to different bundles. Bundles should only see the
factory configurations that they are bound to or have the proper
permission.  
If the location starts with ? then the configuration must be delivered
to all targets with the corresponding PID.
	Returns	a new Configuration object.
	Throws	IOException –  if access to persistent storage fails. 
		SecurityException –  when the require permissions are not available 
	Security	ConfigurationPermission[location,CONFIGURE] –  if location
is not null
		ConfigurationPermission[”*”,CONFIGURE] –  if location is null
<?FM MARKER [Cross-Ref] ConfigurationAdmin.getConfiguration(String,String)?>
<?FM MARKER [Index] ConfigurationAdmin:getConfiguration?>
<?FM MARKER [Index] getConfiguration?>
getConfiguration(String,String)
public Configuration getConfiguration ( String pid , String location
) throws IOException
	pid	Persistent identifier.
	location	The bundle location string, or null.
	
Get an existing Configuration object from the persistent store,
or create a new Configuration object.  
If a Configuration with this PID already exists in Configuration
Admin service return it. The location parameter is ignored in this
case though it is still used for a security check.  
Else, return a new Configuration object. This new object is bound
to the location and the properties are set to null. If the location
parameter is null, it will be set when a Managed Service with the
corresponding PID is registered for the first time. If the location
starts with ? then the configuration is bound to all targets that
are registered with the corresponding PID.
	Returns	An existing or new Configuration object.
	Throws	IOException –  if access to persistent storage fails. 
		SecurityException –  when the require permissions are not available 
	Security	ConfigurationPermission[*,CONFIGURE] –  if location is
null or if the returned configuration c already exists and c.location
is null
		ConfigurationPermission[location,CONFIGURE] –  if location is
not null
		ConfigurationPermission[c.location,CONFIGURE] –  if the returned
configuration c already exists and c.location is not null
<?FM MARKER [Cross-Ref] ConfigurationAdmin.getConfiguration(String)?>
<?FM MARKER [Index] ConfigurationAdmin:getConfiguration?>
<?FM MARKER [Index] getConfiguration?>
getConfiguration(String)
public Configuration getConfiguration ( String pid ) throws IOException
	pid	persistent identifier.
	
Get an existing or new Configuration object from the persistent
store. If the Configuration object for this PID does not exist,
create a new Configuration object for that PID, where properties
are null. Bind its location to the calling bundle’s location.  
Otherwise, if the location of the existing Configuration object
is null, set it to the calling bundle’s location.
	Returns	an existing or new Configuration matching the PID.
	Throws	IOException –  if access to persistent storage fails. 
		SecurityException –  when the required permission is not available 
	Security	ConfigurationPermission[c.location,CONFIGURE] –  If the
configuration c already exists and c.location is not null
<?FM MARKER [Cross-Ref] ConfigurationAdmin.listConfigurations(String)?>
<?FM MARKER [Index] ConfigurationAdmin:listConfigurations?>
<?FM MARKER [Index] listConfigurations?>
listConfigurations(String)
public Configuration[] listConfigurations ( String filter )  throws
IOException , InvalidSyntaxException
	filter	A filter string, or null to retrieve all Configuration objects.
	
List the current Configuration objects which match the filter.  
Only Configuration objects with non- null properties are considered
current. That is, Configuration.getProperties() is guaranteed not
to return null for each of the returned Configuration objects.  
When there is no security on then all configurations can be returned.
If security is on, the caller must have ConfigurationPermission[location,CONFIGURE].
 
The syntax of the filter string is as defined in the Filter class.
The filter can test any configuration properties including the following: 
service.pid - the persistent identity
service.factoryPid - the factory PID, if applicable
service.bundleLocation - the bundle location
The filter can also be null, meaning that all Configuration objects
should be returned. 
	Returns	All matching Configuration objects, or null if there aren’t
any.
	Throws	IOException –  if access to persistent storage fails 
		InvalidSyntaxException –  if the filter string is invalid 
	Security	ConfigurationPermission[c.location,CONFIGURE] –  Only
configurations c are returned for which the caller has this permission
<?FM MARKER [Cross-Ref] ConfigurationEvent?>
<?FM MARKER [Index] ConfigurationEvent?>
<?FM MARKER [Index] class:ConfigurationEvent?>
ConfigurationEvent
public class ConfigurationEvent
A Configuration Event.  
ConfigurationEvent objects are delivered to all registered ConfigurationListener
service objects. ConfigurationEvents must be asynchronously delivered
in chronological order with respect to each listener.  
A type code is used to identify the type of event. The following
event types are defined: 
CM_UPDATED
CM_DELETED
CM_LOCATION_CHANGED
Additional event types may be defined in the future.  
Security Considerations. ConfigurationEvent objects do not provide
Configuration objects, so no sensitive configuration information
is available from the event. If the listener wants to locate the
Configuration object for the specified pid, it must use ConfigurationAdmin.
	See Also	ConfigurationListener
	Since	1.2
	Concurrency	Immutable 
<?FM MARKER [Cross-Ref] ConfigurationEvent.CM_DELETED?>
<?FM MARKER [Index] ConfigurationEvent:CM_DELETED?>
<?FM MARKER [Index] CM_DELETED?>
CM_DELETED
public static final int CM_DELETED = 2
A Configuration has been deleted.  
This ConfigurationEvent type that indicates that a Configuration
object has been deleted.  An event is fired when a call to Configuration.delete()
successfully deletes a configuration.
<?FM MARKER [Cross-Ref] ConfigurationEvent.CM_LOCATION_CHANGED?>
<?FM MARKER [Index] ConfigurationEvent:CM_LOCATION_CHANGED?>
<?FM MARKER [Index] CM_LOCATION_CHANGED?>
CM_LOCATION_CHANGED
public static final int CM_LOCATION_CHANGED = 3
The location of a Configuration has been changed.  
This ConfigurationEvent type that indicates that the location of
a Configuration object has been changed.  An event is fired when
a call to Configuration.setBundleLocation(String) successfully changes
the location.
	Since	1.4
<?FM MARKER [Cross-Ref] ConfigurationEvent.CM_UPDATED?>
<?FM MARKER [Index] ConfigurationEvent:CM_UPDATED?>
<?FM MARKER [Index] CM_UPDATED?>
CM_UPDATED
public static final int CM_UPDATED = 1
A Configuration has been updated.  
This ConfigurationEvent type that indicates that a Configuration
object has been updated with new properties.  An event is fired
when a call to Configuration.update(Dictionary) successfully changes
a configuration.
<?FM MARKER [Cross-Ref] ConfigurationEvent.ConfigurationEvent(ServiceReference,int,String,String)?>
<?FM MARKER [Index] ConfigurationEvent:ConfigurationEvent?>
<?FM MARKER [Index] ConfigurationEvent?>
ConfigurationEvent(ServiceReference,int,String,String)
public ConfigurationEvent ( ServiceReference&lt;ConfigurationAdmin&gt;
reference , int type , String factoryPid , String pid ) 
	reference	The ServiceReference object of the Configuration Admin
service that created this event.
	type	The event type. See getType().
	factoryPid	The factory pid of the associated configuration if the
target of the configuration is a ManagedServiceFactory. Otherwise
null if the target of the configuration is a ManagedService.
	pid	The pid of the associated configuration.
	
Constructs a ConfigurationEvent object from the given ServiceReference
object, event type, and pids. 
<?FM MARKER [Cross-Ref] ConfigurationEvent.getFactoryPid()?>
<?FM MARKER [Index] ConfigurationEvent:getFactoryPid?>
<?FM MARKER [Index] getFactoryPid?>
getFactoryPid()
public String getFactoryPid ( ) 
	
Returns the factory pid of the associated configuration. 
	Returns	Returns the factory pid of the associated configuration
if the target of the configuration is a ManagedServiceFactory. Otherwise
null if the target of the configuration is a ManagedService.
<?FM MARKER [Cross-Ref] ConfigurationEvent.getPid()?>
<?FM MARKER [Index] ConfigurationEvent:getPid?>
<?FM MARKER [Index] getPid?>
getPid()
public String getPid ( ) 
	
Returns the pid of the associated configuration. 
	Returns	Returns the pid of the associated configuration.
<?FM MARKER [Cross-Ref] ConfigurationEvent.getReference()?>
<?FM MARKER [Index] ConfigurationEvent:getReference?>
<?FM MARKER [Index] getReference?>
getReference()
public ServiceReference&lt;ConfigurationAdmin&gt; getReference ( ) 
	
Return the ServiceReference object of the Configuration Admin service
that created this event. 
	Returns	The ServiceReference object for the Configuration Admin
service that created this event.
<?FM MARKER [Cross-Ref] ConfigurationEvent.getType()?>
<?FM MARKER [Index] ConfigurationEvent:getType?>
<?FM MARKER [Index] getType?>
getType()
public int getType ( ) 
	
Return the type of this event. 
The type values are: 
CM_UPDATED
CM_DELETED
CM_LOCATION_CHANGED
	Returns	The type of this event.
<?FM MARKER [Cross-Ref] ConfigurationException?>
<?FM MARKER [Index] ConfigurationException?>
<?FM MARKER [Index] class:ConfigurationException?>
ConfigurationException
public class ConfigurationException
	extends Exception
An Exception class to inform the Configuration Admin service of
problems with configuration data. 
<?FM MARKER [Cross-Ref] ConfigurationException.ConfigurationException(String,String)?>
<?FM MARKER [Index] ConfigurationException:ConfigurationException?>
<?FM MARKER [Index] ConfigurationException?>
ConfigurationException(String,String)
public ConfigurationException ( String property , String reason
) 
	property	name of the property that caused the problem, null if
no specific property was the cause
	reason	reason for failure
	
Create a ConfigurationException object. 
<?FM MARKER [Cross-Ref] ConfigurationException.ConfigurationException(String,String,Throwable)?>
<?FM MARKER [Index] ConfigurationException:ConfigurationException?>
<?FM MARKER [Index] ConfigurationException?>
ConfigurationException(String,String,Throwable)
public ConfigurationException ( String property , String reason
, Throwable cause ) 
	property	name of the property that caused the problem, null if
no specific property was the cause
	reason	reason for failure
	cause	The cause of this exception.
	
Create a ConfigurationException object. 
	Since	1.2
<?FM MARKER [Cross-Ref] ConfigurationException.getCause()?>
<?FM MARKER [Index] ConfigurationException:getCause?>
<?FM MARKER [Index] getCause?>
getCause()
public Throwable getCause ( ) 
	
Returns the cause of this exception or null if no cause was set. 
	Returns	The cause of this exception or null if no cause was set.
	Since	1.2
<?FM MARKER [Cross-Ref] ConfigurationException.getProperty()?>
<?FM MARKER [Index] ConfigurationException:getProperty?>
<?FM MARKER [Index] getProperty?>
getProperty()
public String getProperty (  ) 
	
Return the property name that caused the failure or null. 
	Returns	name of property or null if no specific property caused
the problem
<?FM MARKER [Cross-Ref] ConfigurationException.getReason()?>
<?FM MARKER [Index] ConfigurationException:getReason?>
<?FM MARKER [Index] getReason?>
getReason()
public String getReason ( ) 
	
Return the reason for this exception. 
	Returns	reason of the failure
<?FM MARKER [Cross-Ref] ConfigurationException.initCause(Throwable)?>
<?FM MARKER [Index] ConfigurationException:initCause?>
<?FM MARKER [Index] initCause?>
initCause(Throwable)
public Throwable initCause ( Throwable cause ) 
	cause	The cause of this exception.
	
Initializes the cause of this exception to the specified value. 
	Returns	This exception.
	Throws	IllegalArgumentException –  If the specified cause is this
exception. 
		IllegalStateException –  If the cause of this exception has already
been set. 
	Since	1.2
<?FM MARKER [Cross-Ref] ConfigurationListener?>
<?FM MARKER [Index] ConfigurationListener?>
<?FM MARKER [Index] interface:ConfigurationListener?>
ConfigurationListener
public interface ConfigurationListener
Listener for Configuration Events. When a ConfigurationEvent is
fired, it is asynchronously delivered to a ConfigurationListener.
 
ConfigurationListener objects are registered with the Framework
service registry and are notified with a ConfigurationEvent object
when an event is fired. 
ConfigurationListener objects can inspect the received ConfigurationEvent
object to determine its type, the pid of the Configuration object
with which it is associated, and the Configuration Admin service
that fired the event. 
Security Considerations. Bundles wishing to monitor configuration
events will require ServicePermission[ConfigurationListener,REGISTER]
to register a ConfigurationListener service.
	Since	1.2
<?FM MARKER [Cross-Ref] ConfigurationListener.configurationEvent(ConfigurationEvent)?>
<?FM MARKER [Index] ConfigurationListener:configurationEvent?>
<?FM MARKER [Index] configurationEvent?>
configurationEvent(ConfigurationEvent)
public void configurationEvent ( ConfigurationEvent event ) 
	event	The ConfigurationEvent.
	
Receives notification of a Configuration that has changed. 
<?FM MARKER [Cross-Ref] ConfigurationPermission?>
<?FM MARKER [Index] ConfigurationPermission?>
<?FM MARKER [Index] class:ConfigurationPermission?>
ConfigurationPermission
public final class ConfigurationPermission
	extends BasicPermission
Indicates a bundle’s authority to configure bundles or be updated
by Configuration Admin. 
	Since	1.2
	Concurrency	Thread-safe 
<?FM MARKER [Cross-Ref] ConfigurationPermission.CONFIGURE?>
<?FM MARKER [Index] ConfigurationPermission:CONFIGURE?>
<?FM MARKER [Index] CONFIGURE?>
CONFIGURE
public static final String CONFIGURE = “configure”<?FM MARKER [Index] configure?>

Provides permission to create new configurations for other bundles
as well as manipulate them. The action string configure. 
<?FM MARKER [Cross-Ref] ConfigurationPermission.TARGET?>
<?FM MARKER [Index] ConfigurationPermission:TARGET?>
<?FM MARKER [Index] TARGET?>
TARGET
public static final String TARGET = “target”<?FM MARKER [Index] target?>

The permission to be updated, that is, act as a Managed Service
or Managed Service Factory. The action string target. 
	Since	1.4
<?FM MARKER [Cross-Ref] ConfigurationPermission.ConfigurationPermission(String,String)?>
<?FM MARKER [Index] ConfigurationPermission:ConfigurationPermission?>
<?FM MARKER [Index] ConfigurationPermission?>
ConfigurationPermission(String,String)
public ConfigurationPermission ( String name , String actions ) 
	name	Name of the permission. Wildcards (‘*’) are allowed in the
name. During implies(Permission), the name is matched to the requested
permission using the substring matching rules used by Filters.
	actions	Comma separated list of CONFIGURE, TARGET (case insensitive).
	
Create a new ConfigurationPermission. 
<?FM MARKER [Cross-Ref] ConfigurationPermission.equals(Object)?>
<?FM MARKER [Index] ConfigurationPermission:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object obj ) 
	obj	The object being compared for equality with this object.
	
Determines the equality of two ConfigurationPermission objects. 
Two ConfigurationPermission objects are equal.
	Returns	true if obj is equivalent to this ConfigurationPermission;
false otherwise.
<?FM MARKER [Cross-Ref] ConfigurationPermission.getActions()?>
<?FM MARKER [Index] ConfigurationPermission:getActions?>
<?FM MARKER [Index] getActions?>
getActions()
public String getActions ( ) 
	
Returns the canonical string representation of the ConfigurationPermission
actions.  
Always returns present ConfigurationPermission actions in the following
order: configure, target
	Returns	Canonical string representation of the ConfigurationPermission
actions.
<?FM MARKER [Cross-Ref] ConfigurationPermission.hashCode()?>
<?FM MARKER [Index] ConfigurationPermission:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
	
Returns the hash code value for this object. 
	Returns	Hash code value for this object.
<?FM MARKER [Cross-Ref] ConfigurationPermission.implies(Permission)?>
<?FM MARKER [Index] ConfigurationPermission:implies?>
<?FM MARKER [Index] implies?>
implies(Permission)
public boolean implies ( Permission p ) 
	p	The target permission to check.
	
Determines if a ConfigurationPermission object “implies” the specified
permission. 
	Returns	true if the specified permission is implied by this object;
false otherwise.
<?FM MARKER [Cross-Ref] ConfigurationPermission.newPermissionCollection()?>
<?FM MARKER [Index] ConfigurationPermission:newPermissionCollection?>
<?FM MARKER [Index] newPermissionCollection?>
newPermissionCollection()
public PermissionCollection newPermissionCollection ( ) 
	
Returns a new PermissionCollection object suitable for storing ConfigurationPermissions. 
	Returns	A new PermissionCollection object.
<?FM MARKER [Cross-Ref] ConfigurationPlugin?>
<?FM MARKER [Index] ConfigurationPlugin?>
<?FM MARKER [Index] interface:ConfigurationPlugin?>
ConfigurationPlugin
public interface ConfigurationPlugin
A service interface for processing configuration dictionary before
the update. 
A bundle registers a ConfigurationPlugin object in order to process
configuration updates before they reach the Managed Service or Managed
Service Factory. The Configuration Admin service will detect registrations
of Configuration Plugin services and must call these services every
time before it calls the ManagedService or ManagedServiceFactoryupdated
method. The Configuration Plugin service thus has the opportunity
to view and modify the properties before they are passed to the
Managed Service or Managed Service Factory.  
Configuration Plugin (plugin) services have full read/write access
to all configuration information that passes through them. 
The Integerservice.cmRanking registration property may be specified.
Not specifying this registration property, or setting it to something
other than an Integer, is the same as setting it to the Integer zero.
The service.cmRanking property determines the order in which plugins
are invoked. Lower ranked plugins are called before higher ranked
ones. In the event of more than one plugin having the same value
of service.cmRanking, then the Configuration Admin service arbitrarily
chooses the order in which they are called. 
By convention, plugins with service.cmRanking&amp;lt; 0 or service.cmRanking
&amp;gt; 1000 should not make modifications to the properties. 
The Configuration Admin service has the right to hide properties
from plugins, or to ignore some or all the changes that they make.
This might be done for security reasons. Any such behavior is entirely implementation
defined. 
A plugin may optionally specify a cm.target registration property
whose value is the PID of the Managed Service or Managed Service
Factory whose configuration updates the plugin is intended to intercept.
The plugin will then only be called with configuration updates that
are targeted at the Managed Service or Managed Service Factory with
the specified PID. Omitting the cm.target registration property
means that the plugin is called for all configuration updates.
<?FM MARKER [Cross-Ref] ConfigurationPlugin.CM_RANKING?>
<?FM MARKER [Index] ConfigurationPlugin:CM_RANKING?>
<?FM MARKER [Index] CM_RANKING?>
CM_RANKING
public static final String CM_RANKING = “service.cmRanking”<?FM MARKER [Index] service.cmRanking?>

A service property to specify the order in which plugins are invoked.
 This property contains an Integer ranking of the plugin. Not specifying
this registration property, or setting it to something other than
an Integer, is the same as setting it to the Integer zero. This
property determines the order in which plugins are invoked. Lower
ranked plugins are called before higher ranked ones. 
	Since	1.2
<?FM MARKER [Cross-Ref] ConfigurationPlugin.CM_TARGET?>
<?FM MARKER [Index] ConfigurationPlugin:CM_TARGET?>
<?FM MARKER [Index] CM_TARGET?>
CM_TARGET
public static final String CM_TARGET = “cm.target”<?FM MARKER [Index] cm.target?>

A service property to limit the Managed Service or Managed Service
Factory configuration dictionaries a Configuration Plugin service
receives.  This property contains a String[] of PIDs. A Configuration Admin
service must call a Configuration Plugin service only when this
property is not set, or the target service’s PID is listed in this
property. 
<?FM MARKER [Cross-Ref] ConfigurationPlugin.modifyConfiguration(ServiceReference,Dictionary)?>
<?FM MARKER [Index] ConfigurationPlugin:modifyConfiguration?>
<?FM MARKER [Index] modifyConfiguration?>
modifyConfiguration(ServiceReference,Dictionary)
public void modifyConfiguration ( ServiceReference&lt;?&gt; reference
, Dictionary&lt;String,Object&gt; properties ) 
	reference	reference to the Managed Service or Managed Service Factory
	properties	The configuration properties. This argument must not
contain the “service.bundleLocation” property. The value of this
property may be obtained from the Configuration.getBundleLocation
method.
	
View and possibly modify the a set of configuration properties before
they are sent to the Managed Service or the Managed Service Factory.
The Configuration Plugin services are called in increasing order
of their service.cmRanking property. If this property is undefined
or is a non- Integer type, 0 is used.  
This method should not modify the properties unless the service.cmRanking
of this plugin is in the range 0 &amp;lt;= service.cmRanking &amp;lt;=
1000. 
If this method throws any Exception, the Configuration Admin service
must catch it and should log it. 
A Configuration Plugin will only be called for properties from configurations
that have a location for which the Configuration Plugin has permission
when security is active. When security is not active, no filtering
is done.
<?FM MARKER [Cross-Ref] ManagedService?>
<?FM MARKER [Index] ManagedService?>
<?FM MARKER [Index] interface:ManagedService?>
ManagedService
public interface ManagedService
A service that can receive configuration data from a Configuration
Admin service. 
A Managed Service is a service that needs configuration data. Such
an object should be registered with the Framework registry with
the service.pid property set to some unique identifier called a
PID.  
If the Configuration Admin service has a Configuration object corresponding
to this PID, it will callback the updated() method of the ManagedService
object, passing the properties of that Configuration object.  
If it has no such Configuration object, then it calls back with
a null properties argument. Registering a Managed Service will always
result in a callback to the updated() method provided the Configuration
Admin service is, or becomes active. This callback must always be
done asynchronously.  
Else, every time that either of the updated() methods is called
on that Configuration object, the ManagedService.updated() method
with the new properties is called. If the delete() method is called
on that Configuration object, ManagedService.updated() is called
with a null for the properties parameter. All these callbacks must
be done asynchronously. 
The following example shows the code of a serial port that will
create a port depending on configuration information. 
 
   class SerialPort implements ManagedService {
    
     ServiceRegistration registration;
     Hashtable configuration;
     CommPortIdentifier id;
    
     synchronized void open(CommPortIdentifier id,
     BundleContext context) {
       this.id = id;
       registration = context.registerService(
         ManagedService.class.getName(),
         this,
         getDefaults()
       );
     }
    
     Hashtable getDefaults() {
       Hashtable defaults = new Hashtable();
       defaults.put( “port”, id.getName() );
       defaults.put( “product”, “unknown” );
       defaults.put( “baud”, “9600” );
       defaults.put( Constants.SERVICE_PID,
         “com.acme.serialport.” + id.getName() );
       return defaults;
     }
    
     public synchronized void updated(
       Dictionary configuration  ) {
       if ( configuration == null )
         registration.setProperties( getDefaults() );
       else {
         setSpeed( configuration.get(”baud”) );
         registration.setProperties( configuration );
       }
     }
     ...
   }
As a convention, it is recommended that when a Managed Service is
updated, it should copy all the properties it does not recognize
into the service registration properties. This will allow the Configuration
Admin service to set properties on services which can then be used
by other applications. 
Normally, a single Managed Service for a given PID is given the
configuration dictionary, this is the configuration that is bound
to the location of the registering bundle. However, when security
is on, a Managed Service can have Configuration Permission to also
be updated for other locations.
<?FM MARKER [Cross-Ref] ManagedService.updated(Dictionary)?>
<?FM MARKER [Index] ManagedService:updated?>
<?FM MARKER [Index] updated?>
updated(Dictionary)
public void updated ( Dictionary&lt;String,?&gt; properties ) throws
ConfigurationException
	properties	A copy of the Configuration properties, or null . This
argument must not contain the “service.bundleLocation” property.
The value of this property may be obtained from the Configuration.getBundleLocation
method.
	
Update the configuration for a Managed Service.  
When the implementation of updated(Dictionary) detects any kind
of error in the configuration properties, it should create a new
ConfigurationException which describes the problem. This can allow
a management system to provide useful information to a human administrator.
 
If this method throws any other Exception, the Configuration Admin
service must catch it and should log it. 
The Configuration Admin service must call this method asynchronously
with the method that initiated the callback. This implies that implementors
of Managed Service can be assured that the callback will not take
place during registration when they execute the registration in
a synchronized method.  
If the the location allows multiple managed services to be called
back for a single configuration then the callbacks must occur in
service ranking order. Changes in the location must be reflected
by deleting the configuration if the configuration is no longer
visible and updating when it becomes visible.  
If no configuration exists for the corresponding PID, or the bundle
has no access to the configuration, then the bundle must be called
back with a null to signal that CM is active but there is no data.
	Throws	ConfigurationException –  when the update fails 
	Security	ConfigurationPermission[c.location,TARGET] –  Required
by the bundle that registered this service
<?FM MARKER [Cross-Ref] ManagedServiceFactory?>
<?FM MARKER [Index] ManagedServiceFactory?>
<?FM MARKER [Index] interface:ManagedServiceFactory?>
ManagedServiceFactory
public interface ManagedServiceFactory
Manage multiple service instances.  Bundles registering this interface
are giving the Configuration Admin service the ability to create
and configure a number of instances of a service that the implementing
bundle can provide. For example, a bundle implementing a DHCP server
could be instantiated multiple times for different interfaces using
a factory. 
Each of these service instances  is represented, in the persistent
storage of the Configuration Admin service, by a factory Configuration
object that has a PID. When such a Configuration is updated, the Configuration
Admin service calls the ManagedServiceFactory updated method with
the new properties. When updated is called with a new PID, the Managed
Service Factory should create a new factory instance based on these
configuration properties. When called with a PID that it has seen
before, it should update that existing service instance with the
new configuration information. 
In general it is expected that the implementation of this interface
will maintain a data structure that maps PIDs to the factory instances
that it has created. The semantics of a factory instance are defined by
the Managed Service Factory. However, if the factory instance is
registered as a service object with the service registry, its PID
should match the PID of the corresponding Configuration object (but
it should not  be registered as a Managed Service!). 
An example that demonstrates the use of a factory. It will create
serial ports under command of the Configuration Admin service. 
 
   class SerialPortFactory
     implements ManagedServiceFactory {
     ServiceRegistration registration;
     Hashtable ports;
     void start(BundleContext context) {
       Hashtable properties = new Hashtable();
       properties.put( Constants.SERVICE_PID,
         “com.acme.serialportfactory” );
       registration = context.registerService(
         ManagedServiceFactory.class.getName(),
         this,
         properties
       );
     }
     public void updated( String pid,
       Dictionary properties  ) {
       String portName = (String) properties.get(”port”);
       SerialPortService port =
         (SerialPort) ports.get( pid );
       if ( port == null ) {
         port = new SerialPortService();
         ports.put( pid, port );
         port.open();
       }
       if ( port.getPortName().equals(portName) )
         return;
       port.setPortName( portName );
     }
     public void deleted( String pid ) {
       SerialPortService port =
         (SerialPort) ports.get( pid );
       port.close();
       ports.remove( pid );
     }
     ...
   }
<?FM MARKER [Cross-Ref] ManagedServiceFactory.deleted(String)?>
<?FM MARKER [Index] ManagedServiceFactory:deleted?>
<?FM MARKER [Index] deleted?>
deleted(String)
public void deleted ( String pid ) 
	pid	the PID of the service to be removed
	
Remove a factory instance.  Remove the factory instance associated
with the PID. If the instance was registered with the service registry,
it should be unregistered. The Configuration Admin must call deleted
for each instance it received in updated(String, Dictionary).  
If this method throws any Exception, the Configuration Admin service
must catch it and should log it. 
The Configuration Admin service must call this method asynchronously.
<?FM MARKER [Cross-Ref] ManagedServiceFactory.getName()?>
<?FM MARKER [Index] ManagedServiceFactory:getName?>
<?FM MARKER [Index] getName?>
getName()
public String getName ( ) 
	
Return a descriptive name of this factory. 
	Returns	the name for the factory, which might be localized
<?FM MARKER [Cross-Ref] ManagedServiceFactory.updated(String,Dictionary)?>
<?FM MARKER [Index] ManagedServiceFactory:updated?>
<?FM MARKER [Index] updated?>
updated(String,Dictionary)
public void updated ( String pid , Dictionary&lt;String,?&gt; properties
) throws ConfigurationException
	pid	The PID for this configuration.
	properties	A copy of the configuration properties. This argument
must not contain the service.bundleLocation” property. The value
of this property may be obtained from the Configuration.getBundleLocation
method.
	
Create a new instance, or update the configuration of an existing
instance. If the PID of the Configuration object is new for the
Managed Service Factory, then create a new factory instance, using
the configuration properties provided. Else, update the service
instance with the provided properties.  
If the factory instance is registered with the Framework, then the
configuration properties should be copied to its registry properties.
This is not mandatory and security sensitive properties should obviously
not be copied.  
If this method throws any Exception, the Configuration Admin service
must catch it and should log it. 
When the implementation of updated detects any kind of error in
the configuration properties, it should create a new ConfigurationException
which describes the problem.  
The Configuration Admin service must call this method asynchronously.
This implies that implementors of the ManagedServiceFactory class
can be assured that the callback will not take place during registration
when they execute the registration in a synchronized method.  
If the security allows multiple managed service factories to be
called back for a single configuration then the callbacks must occur
in service ranking order.  
It is valid to create multiple factory instances that are bound
to different locations. Managed Service Factory services must only
be updated with configurations that are bound to their location
or that start with the ? prefix and for which they have permission.
Changes in the location must be reflected by deleting the corresponding
configuration if the configuration is no longer visible or updating when
it becomes visible.
	Throws	ConfigurationException –  when the configuration properties
are invalid. 
	Security	ConfigurationPermission[c.location,TARGET] –  Required
by the bundle that registered this service
<?FM MARKER [Cross-Ref] SynchronousConfigurationListener?>
<?FM MARKER [Index] SynchronousConfigurationListener?>
<?FM MARKER [Index] interface:SynchronousConfigurationListener?>
SynchronousConfigurationListener
public interface SynchronousConfigurationListener
	extends ConfigurationListener
Synchronous Listener for Configuration Events. When a ConfigurationEvent
is fired, it is synchronously delivered to a SynchronousConfigurationListener.
 
SynchronousConfigurationListener objects are registered with the
Framework service registry and are synchronously notified with a
ConfigurationEvent object when an event is fired. 
SynchronousConfigurationListener objects can inspect the received
ConfigurationEvent object to determine its type, the PID of the
Configuration object with which it is associated, and the Configuration
Admin service that fired the event. 
Security Considerations. Bundles wishing to synchronously monitor
configuration events will require ServicePermission[SynchronousConfigurationListener,REGISTER]
to register a SynchronousConfigurationListener service.
	Since	1.5

</INSET>
<para>                  </para>
<para xml:id="i1235186">
</para></chapter>