<?xml version="1.0" encoding="utf-8"?>
<chapter label="150"
         revision="$Id$"
         version="5" xml:id="service.configurator"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Configurator Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.configurator-version"
    linkend="org.osgi.configurator"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>
    
    <para>OSGi provides a standardized model to provide bundles with configurations. This is specified in 
      the Configuration Admin specification. In this specification, A configuration is identified by a 
      persistent identity (PID). A PID is a unique token, recommended to be conforming to the symbolic 
      name syntax. A configuration consists of a set of properties, where a property consists of a 
      string key and a corresponding value. The type of the value is limited to the primitive types and
      their wrappers, Strings, or Java Arrays/List/Vector of these.
    </para>

    <para>
      Sometimes it is necessary to store binary large objects (BLOB) in configuration. For example, a keystore 
      with certificates. Since configuration admin is not suitable for this, these BLOBs are often stored on
      the files system. The application developers then must manage the life cycles of these files.
    </para>
      
    <para>
      Configurations can be grouped with a factory PID. Configurations with a factory PID are called 
      factory configurations and without it they are called singleton configurations.
    </para>
      
    <para>
      The original specification specified that the configurations were sent to a Managed Service for 
      the singletons and Managed Service Factory services for the factory instances. However, over time 
      component models became popular and a component can rely on configuration. For example, Declarative 
      Services is tightly integrated with Configuration Admin. For these heavy users of configurations 
      a Configuration Listener whiteboard service was added. Configuration update, delete, and bundle 
      location change events are forwarded to this whiteboard service on a background thread.
    </para>

    <para>
      This specification defines a mechanism to feed configurations into the system
      through configuration resources. A single configuration resource can feed multiple PIDs with configuration
      and multiple configuration resources can be provided in a running system.
    </para>

    <para>
      Configuration resources can define configurations for more than one environment, allowing a single set 
      of resources to be used in multiple contexts, such as development, test and production, each of which may 
      have different configuration values.
    </para>
  </section> 
  
  <section>
    <title>Entities</title>
    
    <para>The following entities are used in this specification</para>
    
    <itemizedlist>
      <listitem>
        <para><emphasis>Configuration Admin Service</emphasis> - yyy.</para>
      </listitem>
    
      <listitem>
          <para><emphasis>Configuration Resource</emphasis> - A YAML resource containing
              configuration.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Configurator</emphasis> - yyy.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Coordinator Service</emphasis> - yyy.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Persistent Identity (PID)</emphasis> - yyy.</para>
      </listitem>
    
    </itemizedlist>
    <remark>Add entity diagram</remark>
  </section> 

  <section>
    <title>Configurator Resources</title>
    
    <para>
      The configurator follows the OSGi extender model and looks for JSON configuration files in
      installed bundles, if the bundle has opted-in to be processed.
      In order to get processed, a bundle must require the configurator implementation:
      
      <programlisting>Require-Capability: osgi.implementation;
  filter := (&amp;(osgi.implementation="osgi.configurator"))
              (version&gt;=1.0)(!(version&gt;=2.0)))
      </programlisting>
      
      By default the configuration resources are in the <code>OSGI-INF/configurations</code>
      directory in the bundle.
    </para>
      
    <para>Configuration files are in UTF-8 encoded and have the <code>.json</code> file extension.
      An example configuration resource has the following structure:
      
    <programlisting>{
    // Global Settings
    ":configurator:version" : 1,
    
    // Configurations
    "configurations": [
      {
           "service.pid": "pid.a",
           "key": "val",
           "some_number": 123,
           ":configurator:environments": ["dev","demo"]
      },
      {
           "service.pid": "pid.b",
           "a_boolean" : true
           // No environments specified, always enabled
      }
    ]
}</programlisting>

      Configuration resources provide an array of configurations with the <code>configurations</code> key. 
      Each configuration has a <code>service.pid</code> to target a specific PID in the Configuration Admin
      Service and zero or more configuration values for this PID. Comments in the form of JSMin comments are 
      supported, i.e. any text after <code>//</code> is ignored and any text between <code>/* */</code> is
      ignored. 
    </para>
      
    <para>Configuration objects can define one or more environments by specifying the special key
      <code>:configurator:environments</code>. These configurations are only applied if one or more of these
      environments are active. For more information see <xref linkend="service.configurator.environments"/>. 
    </para>

    <para>This Configurator specification supports configuration resources in version 1. This is specified 
      as <code>":configurator:version": 1</code>. If the configurator version is ommitted, 1 is assumed.
      <remark>This is a bit misleading as we are specifying the configuration resource version. The configurator
      itself might be version 10, but still support configuration resource version 1!</remark>
    </para>
    
    <para>The configurator visits all files in the locations defined with the <code>configurations</code>
      attribute on the <code>osgi.configurator</code> implementation requirement when a bundle that has 
      opted in to be extended by the configurator is <emphasis>installed</emphasis>. By default this directory
      if <code>OSGI-INF/configurations</code>. The files are processed in lexical order.
    </para> 
      
    <para>
      If multiple bundles provide configuration for the same PID ranking rules are used to decide which configuration
      gets applied <remark>see ranking</remark>.   
      The configurator removes the <code>service.pid</code>, any comments and the special 
   	  <code>:configurator:</code> keys from the configuration before providing it to the Configuration Admin Service.
   	  The configurator uses the <code>Configuration.updateIfDifferent()</code> method on the Configuration object
   	  to avoid any volatility in the system if the configuration applied has not been changed.
    </para>
    
    <para>The configurator defines the following special keys in the configuration resources:
    </para>
      <table pgwide="1">
          <title>Configurator keys</title>
          <tgroup cols="4">
            <colspec colnum="1" colwidth="1*"/>
            <colspec colnum="2" colwidth="0.75*"/>
            <colspec colnum="3" colwidth="0.75*"/>
            <colspec colnum="4" colwidth="2*"/>
            <thead>
              <row>
                <entry>Key</entry>
                <entry>Value type</entry>
                <entry>Scope</entry>
                <entry>Description</entry>
              </row>
            </thead>         
            <tbody>              
              <row>
                <entry><code>:configurator:environments</code></entry>
                <entry>Array of String</entry>
                <entry>Configuration</entry>
                <entry>Environments that this configuration applies to. See <xref linkend="service.configurator.environments"/>.</entry>
              </row>
              
              <row>
                <entry><code>:configurator:policy</code></entry>
                <entry>String</entry>
                <entry>Configuration</entry>
                <entry>Specifies the overwrite policy on configurations set through non-configurator sources.
                See <xref linkend="service.configurator.policy"/>.</entry>
              </row>
              
              <row>
                <entry><code>:configurator:ranking</code></entry>
                <entry>Number</entry>
                <entry>Configuration</entry>
                <entry>The ranking for this configuration. See <xref linkend="service.configurator.ranking"/>.</entry>
              </row>

              <row>
                <entry><code>:configurator:version</code></entry>
                <entry>Number</entry>
                <entry>Resource</entry>
                <entry>The version of the configuration resource format. This specification only supports version 1. If
                this entry is ommitted then version 1 is assumed.</entry>
              </row>
            </tbody>
         </tgroup>
      </table>
  </section> 
  
  <section>
    <title>Factory Configurations</title>
    <para>Factory configurations can be addressed in the configuration PID using 
      <code>PID#name</code> structure. This ensures a well-known name for the 
      factory configuration instance. The configurator must use the 
      <code>getFactoryConfiguration()</code> methods on Configuration Admin to 
      create or obtain configurations with the given PID and name.</para>
  </section>

  <section>
    <title>Datatypes</title>
    <para>Configurations values support the datatypes as specified with the 
      <emphasis>Filter Syntax</emphasis> in the OSGi Core Specification.
      Configuration resources are specified in JSON, which supports a more 
      basic set of data types. The following table describes how values are 
      converted between configuration values and JSON values.
      <table>
        <title>JSON Conversions</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>From Java type</entry>
              <entry>JSON type</entry>
              <entry>To Java type</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><code>Boolean</code></entry>
              <entry>Boolean</entry>
              <entry><code>Boolean</code></entry>
            </row>
            <row>
              <entry><code>Number</code> or subclass</entry>
              <entry>Number</entry>
              <entry>If the number is a whole number an <code>Integer</code> is created. 
                If the number is too large
                for an <code>Integer</code> a <code>Long</code> is used. 
                If the number is a floating point number a 
                <code>Double</code> is used.</entry>
            </row>
            <row>
              <entry><code>String</code></entry>
              <entry>String</entry>
              <entry><code>String</code></entry>
            </row>
            <row>
              <entry>Array</entry>
              <entry>Array</entry>
              <entry>Array, contents are boxed</entry>
            </row>
            <row>
              <entry><code>Collection</code> or subclass</entry>
              <entry>Array</entry>
              <entry>Array, contents are boxed</entry>
            </row>
            <row>
              <entry><emphasis>other</emphasis></entry>
              <entry>String (via <code>object.toString()</code>)</entry>
              <entry>String</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      
      Because of the conversions between Java and JSON the configuration object produced by the Configurator
      may not have the desired data type for the application. Consumers of configuration should convert
      the configuration values to the desired type. A convenient way to achieve this is by converting the 
      configuration map to an annotation instance with the Converter <remark>xref</remark>, or by using 
      Declarative Service configuration property type.  
      
    </para>

    <section>
      <title>Binary Data</title>
      <para>...</para>
    </section>
  </section>

  <section xml:id="service.configurator.environments">
    <title>Environments</title>
    <para>...</para>
  </section>
    
  <section xml:id="service.configurator.ranking">
    <title>Ranking</title>
    <para>...</para>

  </section>
  
  <section xml:id="service.configurator.policy">
    <title>Overwrite Policies</title>
    <para>...</para>
  </section>
    
  <section>
    <title>Runtime Environment</title>
    <para>...</para>
  </section>
    
  <section>
    <title>Lifecycle</title>
    
    <para>...</para>
  </section> 

  <section>
    <title>Grouping and Coordinations</title>
    <para>...</para>
  </section>
    
  <section>
    <title>Security</title>
    <para>...</para>
  </section> 

  <section>
    <title>Capabilities</title>
    <para>...</para>
  </section>
  
  <section>
    <title>Standalone Configurations</title>
    <para>...</para>
  </section>
    
  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
