<?xml version="1.0" encoding="utf-8"?><chapter xmlns="http://docbook.org/ns/docbook" version="5" xml:id="i1560776"><title>
Application
Admin Specification</title>
<info xml:id="i1485541"><releaseinfo>
Version
1.1</releaseinfo></info>
<section><title>Introduction</title>
<para>The OSGi Application Admin specification is intended to simplify
the management of an environment with many different <emphasis>types</emphasis> of
applications that are simultaneously available. A diverse set of application
types are a fact of life because backward compatibility and normal
evolution require modern devices to be able to support novel as
well as legacy applications. End users do not care if an application
is an Applet, a Midlet, a bundle, a Symbian, or a BREW application.
This specification enables applications that manage other applications,
regardless of application type. These applications are called 
<emphasis>application managers</emphasis>. This specification supports
enumerating, launching, stopping and locking applications. This
specification does not specify a user interface or end-user interactions.</para>
<para>The OSGi Service Platform is an excellent platform on which
to host different Application Containers. The class loading and
code sharing mechanisms available in the OSGi Service Platform can
be used to implement powerful and extendable containers for Java
based application models with relative ease. Native code based application
models like Symbian and BREW can be supported with proxies.</para>
<section><title>Essentials</title>
<itemizedlist><listitem><para><emphasis>Generic Model</emphasis> -
The Application Admin specification defines how all applications,
regardless of type, can be launched and destroyed. This application-type
neutral model allows a screen or desktop manager access to all executable
content in a uniform manner.</para></listitem>
<listitem><para><emphasis>Schedule</emphasis> - A mechanism that
allows the launching of applications at a pre-defined time, interval,
or event.</para></listitem>
<listitem><para><emphasis>Dynamic</emphasis> - Detects installations
and un-installations of applications in real time.</para></listitem>
<listitem><para><emphasis>Locking</emphasis> - Allows applications
to be persistently locked so that they cannot be launched.</para></listitem>
<listitem><para><emphasis>Exit Value</emphasis> – Provide a return
value for an application that has exited.</para></listitem></itemizedlist></section>
<section><title>Entities</title>
<itemizedlist><listitem><para><emphasis>Application</emphasis> -
A software component, which has well-defined entry and exit criteria.
Applications can be started and destroyed, and usually are designed
for user interaction. Applications may be of various types, each
having their own specification. Applications and application instances
are visible through the their Application Descriptor services and
Application Handle services.</para></listitem>
<listitem><para><emphasis>Application Container</emphasis> - An
implementation of a runtime environment for one or more application types.
It provides specialized Application Descriptor and Application Handle
services that correspond to the supported application type and their
instances. The design of a particular Application Container is defined
by other specifications. For example, an Application Container which
implements MIDlets must follow the appropriate JSR specifications
for MIDP.</para></listitem>
<listitem><para><emphasis>Application Handle</emphasis> - A service
that represents an <emphasis>instance</emphasis> of an application.
This service is available in the OSGi service registry as long as
the application instance exists. </para></listitem>
<listitem><para><emphasis>Application Instance</emphasis> – The
actual application that has been launched. Registered in the service
registry as long as the application is running.</para></listitem>
<listitem><para><emphasis>Application Descriptor</emphasis> - A
service that represents an installed Application and provides information about
the application as well as launching, scheduling and locking features.
An Application Descriptor must be registered for each application
as long as the Application is installed</para></listitem>
<listitem><para><emphasis>Application Manager</emphasis> – A bundle
that manages a number of applications.</para></listitem>
<listitem><para><emphasis>Scheduled Application</emphasis> – An
information record for a scheduled application.</para></listitem></itemizedlist>
<figure><title>Application Management Diagram org.osgi.service.application
package</title>
<mediaobject><imageobject><imagedata fileref="GRAPHIC1" align="center" contentwidth="7.000in" contentdepth="2.340in"/></imageobject></mediaobject></figure></section>
<section><title>Synopsis</title>
<para>Different types of applications can be accommodated in the
Application Admin specification using a model of Application Containers.
An Application Container typically follows an external specification,
for example, the MIDP specification. In an OSGi environment, the
implementer of such a specification can allow its applications (MIDlets
in the previous example) to participate in the OSGi Application
Model by registering an Application Descriptor service for each
of its installed applications, and an Application Handle service
for each of its running instances.</para>
<para>This model leverages the capabilities of the OSGi service
registry. Installed applications and running applications can be
found by enumerating the appropriate services, possibly using a
filter if a specific application is sought.The service registry
provides necessary isolation of the clients of the applications
and their implementers. Typical clients of this specification are
desktop/screen managers that provide the end user access to the
installed applications.</para></section></section>
<section><title>Application Managers</title>
<para>An application manager (a bundle or application that manages
other applications) must be able to discover the available applications,
present them to an end user and launch applications on demand. A
bundle that maintains the display of a mobile phone is a typical
client of this specification.</para>
<section xml:id="i1416836"><title>
Discovery</title>
<para>The primary means of discovery is the Application Descriptor
service. An Application Container must register an Application Descriptor
service for each of its applications. An application manager can
detect the installation and uninstallation of applications by listening
to service events. </para>
<para>Service properties on the Application Descriptor carry most
of the information that an application manager requires to present
the application to the end user. The properties as defined in 
<phrase role="xref">Table 116.1</phrase>
.</para><table><title>
Service
Properties for an Application Descriptor</title><tgroup cols="4"><thead><row><entry><para>Key Name</para></entry><entry><para>Type</para></entry><entry><para>Default</para></entry><entry><para>Description</para></entry></row></thead><tbody><row><entry><para><code>service.pid</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>must be set</emphasis></para></entry><entry><para>Unique identifier of the application. It is recommended
to set a value generated from the vendor's reverse domain name, e.g. 
<code>com.acme.application.chess</code>. The <code>service.pid</code> service
property is a standard Framework property.</para></entry></row><row><entry><para><code>application.version</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>empty string</emphasis></para></entry><entry><para>Specifies the version of the application. The default
value is an empty string</para></entry></row><row><entry><para><code>service.vendor</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>empty string</emphasis></para></entry><entry><para>Specifies the vendor of the application.</para></entry></row><row><entry><para><code>application.container</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>must be set</emphasis></para></entry><entry><para>A unique identifier (like a PID) of the container implementation
that registered this application descriptor.</para></entry></row><row><entry><para><code>application.location</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>must be set</emphasis></para></entry><entry><para>The identifier of package that contains the application
corresponding to this descriptor. It represents the installation
unit that contains the corresponding application. It should be a
URL. For applications installed as bundles, it should be the location
of the bundle. For others, it is defined by the container implementation.</para></entry></row><row><entry><para><code>application.visible</code></para></entry><entry><para><code>Boolean</code></para></entry><entry><para><code>true</code></para></entry><entry><para>Specifies whether the application should be visible
for the user. For example, some applications may provide features
to other applications but nothing directly to the user. In this
case the application should not be revealed to the user to start
it individually.</para></entry></row><row><entry><para><code>application.launchable</code></para></entry><entry><para><code>Boolean</code></para></entry><entry><para><code>false</code></para></entry><entry><para>Specifies whether the application is ready to be launched.
If the value is <code>true</code>, it means that all the requirements
of the application are fulfilled.</para></entry></row><row><entry><para><code>application.locked</code></para></entry><entry><para><code>Boolean</code></para></entry><entry><para><code>false</code></para></entry><entry><para>Specifies whether the represented application is locked
to prevent launching it. </para></entry></row></tbody></tgroup></table>
<para>Specialized application descriptors can offer further service
properties and method. For example, a MIDP container can register
a property that describes that the MIDLet comes from a specific
JAD file, thereby allowing a MIDLet aware Application Manager to
group these MIDLets.</para>
<para>Application Descriptor services must not be declarative. That
is. they can be obtained from the service registry at any time without
accidentally initializing a class loader.</para>
<para>The following example shows how to track all visible, launchable,
and unlocked applications. These tracked applications are the ones
that can be started.</para>
<programlisting>public class TrackLaunchables {
	final static String filter=
		"(&amp;(objectclass="
	+	ApplicationDescriptor.class.getName()
	+ ")(application.launchable=true)"
	+ "(application.visible=true)"
	+ "(application.locked=false))";
	static ApplicationDescriptor[] EMPTY = 
		new ApplicationDescriptor[0];  
	ServiceTracker tracker;

	public void init(BundleContext cntxt) throws Exception {
		tracker = new ServiceTracker(cntxt, 
			cntxt.createFilter(filter), null);
		tracker.open();
	}

	public ApplicationDescriptor[] getActive() {
		Object [] result = tracker.getServices();
		List list = Arrays.asList(result);
		return (ApplicationDescriptor[]) list.toArray(EMPTY);
	}
}</programlisting>
<para>The code is quite simple because the Service Tracker does
the actual tracking. The most important part is therefore the filter.
The filter selects all the Application Descriptor services that
are visible, launchable, and not locked. The <code>getActive</code> method
converts the <code>Object[]</code> that the Service Tracker maintains
into an array of Application Descriptors.</para></section>
<section xml:id="i1416861"><title>
Application
Descriptor Properties</title>
<para>The Application Descriptor object has an additional number
of properties that are not available as service properties. These
descriptor properties can be localized. The 
<phrase role="xref">getProperties(String)</phrase>
 method therefore takes a <emphasis>locale</emphasis> <code>String</code> object.
This is a standard locale string as defined by the <code>java.util.Locale</code> class.
The order for the locale constituents is:</para>
<itemizedlist><listitem><para>language</para></listitem>
<listitem><para>country</para></listitem>
<listitem><para>variant</para></listitem></itemizedlist>
<para>For example, the following files provide manifest translations
for English, Dutch (Belgium and the Netherlands) and Swedish.</para>
<programlisting>en				nl_BE			
nl_NL				sv</programlisting>
<para>It returns a <code>Map</code> object containing localized
versions of the properties. This is a copy of the original objects
so changes to this <code>Map</code> object are not reflected in
the Application Descriptor properties.</para>
<para>If the locale string is <code>null</code>, the localization
will be based on the default locale, as specified by the <code>java.util.Locale.getDefault</code> method.
If the locale is the empty <code>String</code> object (<code>""</code>),
no localization must be used. This will contain the raw values that
are usually used as keys. If a specific locale has no appropriate translations,
a less specific locale must be used, as described in the <code>Locale</code> class.
As last resort, the raw values must be returned.</para>
<para>The key names in the Map object are case-sensitive. Application
Containers can add additional properties to this Map object, however,
they must avoid key names starting with <code>application</code>.
They should use key names that have a prefix that does not collide
with other Application Containers.</para>
<para>If no locale specific value of an application property is
available then the default one must be returned. The following case-sensitive
key names are treated as standard for locale specific values in the 
<code>Map</code> object. Additional elements may also be stored
in the <code>Map</code> object. The specified properties are explained
in 
<phrase role="xref">Table 116.2</phrase>
. </para><table><title>
Descriptor
localized properties</title><tgroup cols="4"><thead><row><entry><para>Key Name</para></entry><entry><para>Type</para></entry><entry><para>Default</para></entry><entry><para>Description</para></entry></row></thead><tbody><row><entry><para><code>application.name</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>must be set</emphasis></para></entry><entry><para>The name of the application.</para></entry></row><row><entry><para><code>application.icon</code></para></entry><entry><para><code>URL</code></para></entry><entry><para><emphasis>No Icon</emphasis></para></entry><entry><para>A URL an icon's image resource. A compliant implementation
of this specification must support the 
<phrase role="xref">
<xref xrefstyle="Reference" linkend="i1519349"/></phrase>
.</para></entry></row><row><entry><para>	application.version</para>
<para/></entry><entry><para>String</para></entry><entry><para>0.0.0</para></entry><entry><para>The version of the application</para></entry></row><row><entry><para>service.vendor</para></entry><entry><para>String</para></entry><entry><para/></entry><entry><para>The vendor of the application</para></entry></row><row><entry><para>application.visible</para></entry><entry><para>Boolean</para></entry><entry><para><code>true</code></para></entry><entry><para/></entry></row><row><entry><para>application.launchable</para></entry><entry><para>Boolean</para></entry><entry><para><code>true</code></para></entry><entry><para>If the application can be launched</para></entry></row><row><entry><para>application.locked</para></entry><entry><para>Boolean</para></entry><entry><para><code>true</code></para></entry><entry><para>If the application is locked</para></entry></row><row><entry><para>application.description</para></entry><entry><para>String</para></entry><entry><para/></entry><entry><para>A description of the application</para></entry></row><row><entry><para>application.documentation</para></entry><entry><para>String</para></entry><entry><para/></entry><entry><para>Document </para></entry></row><row><entry><para>application.copyright</para></entry><entry><para>String</para></entry><entry><para/></entry><entry><para>A Copyright statement</para></entry></row><row><entry><para>application.license</para></entry><entry><para>String</para></entry><entry><para/></entry><entry><para>A URL to the license related to the application</para></entry></row><row><entry><para>application.container</para></entry><entry><para>String</para></entry><entry><para>must be set</para></entry><entry><para>The PID of the associated container</para></entry></row><row><entry><para>application.location</para></entry><entry><para>String</para></entry><entry><para/></entry><entry><para>The URL of the location of the corresponding JAR file
of the application, if exists.</para></entry></row></tbody></tgroup></table></section>
<section><title>Launching</title>
<para>The Application Descriptor provides the 
<phrase role="xref">launch(Map)</phrase>
 methods for application managers to launch an application. Launching
consists of creating the specific application object, starting it,
registering an Application Handle service that represents that instance
and return the Application Handle service.</para>
<para>The <code>Map</code> object parameter is application specific.
Applications should use unique names for the keys in this map, for
example <code>com.acme.ringsignal</code>. This specification does
not specify any keys for this map except for:</para>
<itemizedlist><listitem><para><code>org.osgi.triggeringevent</code> –
 This property is set to the Event object that cause the application
to be launched (if any).</para></listitem></itemizedlist>
<para>When an application is started successfully the corresponding
Application Handle service will be registered with the service registry.</para></section>
<section xml:id="i1460622"><title>
Application
States</title>
<para>An Application Handle service represents an instance of an
application. The application handle is registered by the Application
Container after successfully launching a new application instance.</para>
<para>An Application Handle service can be used to query the state
and manipulate the application instance. It is the responsibility
of the Application Handle service to maintain the application instance
life cycle state by interacting with the implementation object of
the application. </para>
<para>A running instance can have the following state according
to this specification:</para>
<itemizedlist><listitem><para><phrase role="xref">RUNNING</phrase>
 – This is the state of the Application Handle when it gets registered.
It indicates that the application instance is active.</para></listitem>
<listitem><para><phrase role="xref">STOPPING</phrase>
 – The application is stopping. This is a transient state.</para></listitem></itemizedlist>
<para>Application Containers can extend the number of states.</para>
<para>The Application Handle service maintains the service properties
as listed in 
<phrase role="xref">Table 116.2</phrase>
. Specialized application handles may offer further service properties,
but the key names specified in the table below must not be used
for other purposes.</para><table><title>
Application
Handle service properties</title><tgroup cols="4"><thead><row><entry><para>Key Name</para></entry><entry><para>Type</para></entry><entry><para>Default</para></entry><entry><para>Description</para></entry></row></thead><tbody><row><entry><para><code>service.pid</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>must be set</emphasis></para></entry><entry><para>The Application Instance ID as returned by the <code>getInstanceId</code> method.</para></entry></row><row><entry><para><code>application.state</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>must be set</emphasis></para></entry><entry><para>Contains the current state of the application instance
represented by this application handle. These states can be application
model specific. </para></entry></row><row><entry><para><code>application.descriptor</code></para></entry><entry><para><code>String</code></para></entry><entry><para><emphasis>must be set</emphasis></para></entry><entry><para>The PID of the associated Application Descriptor service</para></entry></row></tbody></tgroup></table>
<para>Specialized application handles may offer further application
states. The name of additional states must be qualified names (dotted);
non-qualified names are reserved for future specifications.</para></section>
<section><title>Destroying an Application Instance</title>
<para>An application instance can be stopped with its associated
Application Handle using the 
<phrase role="xref">destroy()</phrase>
 method. This first turns the state of the Application to 
<phrase role="xref">STOPPING</phrase>
. The application instance may save its persistent data before termination
and it must release all the used resources. The application instance's
artifacts should not be reused any more. The Application Admin implementation
and the application container should ensure (even forcefully) that
all allocated resources are cleaned up.</para>
<para>If the application instance has completely stopped, then its
Application Handle must be unregistered.</para></section>
<section><title>Getting the Exit Value of an Application</title>
<para>Many application containers allow an application to specify
a value when the application is stopped. This value is called the 
<emphasis>exit value</emphasis>. The Application Handle can therefore
return the exit value when this is supported by the underlying application
model. It is possible to find out if the underlying container support
exit values because not all application containers support exit
values.</para>
<para>The Application Descriptor has a special service property
that it must set when it supports exit values. This service property
name is defined on the <code>ApplicationHandle</code> class as 
<phrase role="xref">APPLICATION_SUPPORTS_EXITVALUE</phrase>
. Setting this property to any value signals that the application
instance supports an exit value return.</para>
<para>The 
<phrase role="xref">getExitValue(long)</phrase>
 method on the <code>ApplicationHandle</code> class returns the
exit value object from the underlying application container. If
the application container does not support exit values, then this
method must always throw an Unsupported Operation Exception.</para>
<para>The method takes a time out value which allows it to wait
for the application instance to finish. This time-out can take the
following values:</para>
<itemizedlist><listitem><para><emphasis>negative</emphasis> – When
the time-out is negative, there is no waiting. If the application
instance has finished, the exit value will be returned. Otherwise
an Application Exception must be thrown with the error code set
to 
<phrase role="xref">APPLICATION_EXITVALUE_NOT_AVAILABLE</phrase>
.</para></listitem>
<listitem><para><emphasis>zero –</emphasis> The method will wait
indefinitely until the application is finished.</para></listitem>
<listitem><para><emphasis>positive </emphasis>– The method will
wait for the application to finish the given number of milliseconds.
If after that time the application instance is still not finished,
an Application Exception must be thrown with the error code set
to 
<phrase role="xref">APPLICATION_EXITVALUE_NOT_AVAILABLE</phrase>
.</para></listitem></itemizedlist>
<para>The type of the exit value is undefined, it is a generic Java
object. It is up to the application container to define the actual
type for this Object.</para></section>
<section><title>Locking an Application</title>
<para>Applications represented by the application descriptors can
be locked. If an application is locked then no new instance of the
represented application can be started until it is unlocked. The
locking state of the application has no effect on the already launched
instance(s). The Application Descriptor provides the methods <code>lock</code> and 
<code>unlock</code> to set, unset the locking state. Locking and
unlocking an application represented by an Application Descriptor
requires the proper Application Admin Permission. The methods to
lock, unlock, and query the locked status of an application are
implemented as final methods of the abstract application descriptor
class to ensure that an application container implementation will
not be able to circumvent this security policy.</para></section>
<section xml:id="i1427444"><title>
Scheduling</title>
<para>Scheduling can be used to launch an a new application instance
in the future when a specific event occurs, if needed on a recurring
basis.</para>
<para>The Application Descriptor service provides the 
<phrase role="xref">schedule(String,Map,String,String,boolean)</phrase>
 method to schedule an application to be launched when an specific
event occurs. The parameters to this method are:</para>
<itemizedlist><listitem><para><emphasis>Schedule Id – </emphasis>(
<code>String</code>) An id for this application that identifies
the schedule, even over system restarts. Ids must be unique for
one application. This id will be registered as service property
on the Scheduled Application service under the name of 
<phrase role="xref">SCHEDULE_ID</phrase>
. The name must match the following format:</para></listitem></itemizedlist>
<programlisting>
	scheduleId ::= symbolic-name 
					// Core <phrase role="xref">1.3.2 General Syntax Definitions</phrase>
</programlisting>
<itemizedlist><listitem><para><emphasis>Arguments</emphasis> – (<code>Map)</code> These
arguments will be passed to the application in the <code>launch</code> method.
The keys in this map must not be null or the empty string.</para></listitem>
<listitem><para><emphasis>Topic</emphasis> – (<code>String</code>)
The topic of the event that must trigger the launch of the application.</para></listitem>
<listitem><para><emphasis>Filter</emphasis> – (<code>String</code>)
A filter that is passed to the Event Admin for subscribing to specific
events, can be <code>null</code>. The syntax of the string is the
same as an OSGi Framework filter.</para></listitem>
<listitem><para><emphasis>Recurring</emphasis> – (<code>boolean</code>)
Repeatedly launch the application when the specified events occur
until the schedule is canceled.</para></listitem></itemizedlist>
<para>The  <code>schedule</code> method must register a Scheduled
Application service with the service registry and return the Schedule
Application service object. </para>
<para>For example, the invocation</para>
<programlisting>appDesc.schedule(
	null,				// System generates schedule id
	null,				// No arguments
 	"org/osgi/application/timer",
 	"(&amp;(hour_of_day=0)(minute=0))",
 	true) </programlisting>
<para>Schedules the application to be launched when a timer event
is received and the <code>hour_of_day</code> and <code>minute</code> properties
are zero.</para>
<para>The Scheduled Application service must have the following
properties:</para>
<itemizedlist><listitem><para><phrase role="xref">APPLICATION_PID</phrase>
 - (<code>String</code>) The PID of the Application Descriptor service.</para></listitem>
<listitem><para><phrase role="xref">SCHEDULE_ID</phrase>
- (<code>String</code>) a unique id (within the schedules for one
application).</para></listitem></itemizedlist>
<para>The list of active Scheduled Application services can be obtained
from the service registry. A non-recurrent Scheduled Application
service is unregistered once the application is successfully launched.</para>
<para>The timer used to start an application from a schedule has
a resolution of one minute. It is therefore possible that an application
is delayed up to a minute before it is started.</para></section>
<section><title>Application Exceptions</title>
<para>Exceptional conditions that arise during processing of application
requests. The Exception identifies the actual error with an integer
code. The following codes are supported:</para>
<itemizedlist><listitem><para><phrase role="xref">APPLICATION_INTERNAL_ERROR</phrase>
 – An internal error occurred.</para></listitem>
<listitem><para><phrase role="xref">APPLICATION_LOCKED</phrase>
 – The application is locked and can therefore not be launched.</para></listitem>
<listitem><para><phrase role="xref">APPLICATION_NOT_LAUNCHABLE</phrase>
 – The application could not be launched.</para></listitem>
<listitem><para><phrase role="xref">APPLICATION_SCHEDULING_FAILED</phrase>
 – The application scheduling could not be created due to some internal
error. This entails that the scheduling information is not persisted.</para></listitem>
<listitem><para><phrase role="xref">APPLICATION_DUPLICATE_SCHEDULE_ID</phrase>
 – The application scheduling failed because the specified identifier
is already in use.</para></listitem></itemizedlist></section>
<section><title>Application Events</title>
<para>The event mechanism of the Application Admin specification
is based on the OSGi service registry event model. Both Application
Descriptor and Application Handle are services. Bundles can listen
to these events registering a <code>ServiceListener</code> object
with a Bundle Context or they can listen to events from the Event
Admin, see for more information 
<phrase role="xref">Service Event on page 368</phrase>
.</para>
<itemizedlist><listitem><para>Application Descriptor service</para>
<itemizedlist><listitem><para><code>REGISTERED</code> – A new application
has become available. Depending on its properties, this application could
be launched.</para></listitem>
<listitem><para><code>MODIFIED</code> – The visibility, launchable
or locked status is changed.</para></listitem>
<listitem><para><code>UNREGISTERING</code> – The application is
no longer available. All running instances of this application must be
destroyed before this event is delivered.</para></listitem></itemizedlist></listitem>
<listitem><para>Application Handle service</para>
<itemizedlist><listitem><para><code>REGISTERED</code> – A new instance
is created and started running.</para></listitem>
<listitem><para><code>MODIFIED</code> –  The application instance
is changed its state. This specification only specifies the <code>STOPPING</code> state
but application containers are free to add additional states. Transitions
between all these states must be signalled with the <code>MODIFIED</code> service
event.</para></listitem>
<listitem><para><code>UNREGISTERING</code> – The application instance
is no longer running.</para></listitem></itemizedlist></listitem></itemizedlist></section></section>
<section><title>Application Containers</title>
<para>Application Containers provide the implementation of a specific
application model like MIDP, BREW,.NET, or Symbian. Application
Containers can be implemented inside the OSGi environment or run
externally, in another VM or as native code. When the container
runs externally, it is necessary to run a proxy inside the OSGi
environment that communicates with the external container. This
is shown in 
<phrase role="xref">
<xref xrefstyle="FigureNumber" linkend="i1416477"/></phrase>
.</para>
<figure xml:id="i1416477"><title> with Proxy</title><mediaobject><imageobject><imagedata fileref="GRAPHIC2" align="center" contentwidth="7.000in" contentdepth="3.109in"/></imageobject></mediaobject></figure>
<section><title>The Application Descriptor</title>
<para>The first responsibility of the Application Container is to
register an Application Descriptor for each available application.
The Application Container must therefore extend the <code>ApplicationDescriptor</code> base class
that is provided by the Application Admin implementer and provided
in the <code>org.osgi.service.application</code> package. The base
class is defined as an abstract class in this specification with only
minimal implementation code. Implementers of the Application Admin
implementation can replace this class with an implementation that
enforces their desired policies.</para>
<para>The Application Container must override the methods that have
a <code>Specific</code> suffix. These methods are:</para>
<itemizedlist><listitem><para><phrase role="xref">ApplicationDescriptor(String)</phrase>
 – The Base class Application Descriptor takes the PID of the Application
Descriptor as argument.</para></listitem>
<listitem><para><phrase role="xref">getPropertiesSpecific(String)</phrase>
 – Return the properties (including service properties) based on
a specific locale. See the locale rules at 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1416861"/></phrase>
. The Application Container must fill the returned <code>Map</code> object
with the properties listed in 
<phrase role="xref">Table 116.2 on page 510</phrase>
 as well as other service properties. Non-localized data is returned
if the corresponding application container doesn't support the localization
of application properties. Changes in the <code>Map</code> object
must not be reflected in Application Descriptor properties.</para></listitem>
<listitem><para><phrase role="xref">launchSpecific(Map)</phrase>
 – Launch a new instance and return its handle. The container must
ensure that the application is started in a <code>doPrivileged</code> block
I.e. the permissions of the caller must not influence the capabilities
of the started application.</para></listitem>
<listitem><para><phrase role="xref">lockSpecific()</phrase>
 – Do the specific locking of the Application Descriptor.</para></listitem>
<listitem><para><phrase role="xref">unlockSpecific()</phrase>
 – Do the specific unlocking of the Application Descriptor.</para></listitem>
<listitem><para><phrase role="xref">isLaunchableSpecific()</phrase>
 – This method must return <code>true</code> when the application
can be launched. This method can be called by the Application Descriptor
implementation to find out if an application can be launched according to
the container.</para></listitem></itemizedlist>
<para>The specific methods must be made <code>protected</code> because
the specific Application Descriptor is registered as a service and
is intended to be used by a wide array of clients. These clients
can call public methods so care should be taken to ensure that no
intrusion can take place this way. The Application Admin implementer
must provide the implementation for the <code>public</code> methods
and perform the appropriate security checks.</para>
<para>The specific Application Descriptor must be registered for
each possible application with the set of service properties listed
in 
<phrase role="xref">Table 116.1 on page 509</phrase>
.</para>
<para>An application is launched with the <code>launchSpecific</code> method.
This method is called by the Application Admin implementation, as
implemented in the <code>ApplicationDescriptor</code> base class.
The implementation of the <code>launchSpecific</code> method must
return expediently. The Application Descriptor must perform the
following steps (in the given order):</para>
<orderedlist><listitem><para>Create a new instance of the associated
application</para></listitem>
<listitem><para>Start the application in another process or thread.</para></listitem>
<listitem><para>If the application cannot be started, an appropriate
Exception must be thrown.</para></listitem>
<listitem><para>Register an Application Handle for this running
application. The registration of the Application Handle must be
accompanied by the service properties from 
<phrase role="xref">Table 116.3 on page 511</phrase>
.</para></listitem>
<listitem><para>Return the new Application Handle.</para></listitem></orderedlist></section>
<section><title>The Application Handle</title>
<para>The Application Handle represents the running instance. The
Application Container must extend the provided base class and implement
the following methods:</para>
<itemizedlist><listitem><para><phrase role="xref">ApplicationHandle(String,ApplicationDescriptor)</phrase>
 – The constructor of the base class takes the executable id and
the Application Descriptor as parameter.</para></listitem>
<listitem><para><phrase role="xref">destroySpecific()</phrase>
 – Clients of the Application Admin specification use the <code>destroy</code> method
on the Application Handle service to make an application instance
quit. The Application Admin implementer must at an appropriate time
call the <code>destroySpecific</code> method. The Application Container
must destroy the application instance (if it had not destroyed already)
and clean up.</para></listitem>
<listitem><para><phrase role="xref">getApplicationDescriptor()</phrase>
 – Return the Application Descriptor that belongs to this Application
Handle.</para></listitem>
<listitem><para><phrase role="xref">getInstanceId()</phrase>
 – A unique id for this instance.</para></listitem>
<listitem><para><phrase role="xref">getState()</phrase>
 – Returns the state for the instance. The Application Admin specification
only specifies two states: <code>RUNNING</code> and <code>STOPPING</code>.
Application Containers can add new states to represent for example 
<code>PAUSED</code>. States are strings and must be qualified to
prevent conflicts. For example, the Midlet state for paused could
be <code>MIDLET.PAUSED</code>.</para></listitem></itemizedlist>
<para>The most important method is <code>destroySpecific</code>.
This method must perform the following actions in the given order:</para>
<orderedlist><listitem><para>Set the state to <code>STOPPING</code></para></listitem>
<listitem><para>Modify the service properties of the Service Handle
to reflect the new state. This sends out a service event.</para></listitem>
<listitem><para>If the application instance is active, use any proprietary
mechanism to stop it. Any errors and problems should be logged.</para></listitem>
<listitem><para>Using proprietary means, clean up any resources
on the system that were used by the application: locks, open files,
etc.</para></listitem>
<listitem><para>Unregister the Application Handle service. </para></listitem></orderedlist>
<para>The Application container should monitor the progress of its
instances. If an instance stops, for example due an exception or
it quits voluntarily, the Application Container must call the destroy method
on the Application Handle itself and handle the fact correctly that
the instance is already stopped in the <code>destroySpecific</code> method.</para></section>
<section><title>Certificates</title>
<para>The following method on the Application Descriptor provides
access to the certificate chain that was used to sign the application.
This method is used by the Application Permission.</para>
<itemizedlist><listitem><para><phrase role="xref">matchDNChain(String)</phrase>
 – Verifies that the given pattern matches one or more of the certificates
that were used to sign the application. This method is primarily
used by the Application Admin Permission to verify permissions.
Matching certificates is described in 
<phrase role="xref">Certificate Matching on page 17</phrase>
 of the OSGi Release 4 Core Specification.</para></listitem></itemizedlist></section>
<section><title>Application Descriptor Example</title>
<para>This is an Application Container that scans a directory for
executables. Each executable is registered as an Application Descriptor.
The example assumes that there is a bundle activator that creates
the Application Descriptor services. This activator must also ensure
that when it is stopped no handles remain.</para>
<para>The example is not an robust implementation, its only intention
is to show the concepts of the Application Admin specification in
practice.</para>
<para>The (simple) Application Descriptor could look like:</para>
<programlisting>public class SimpleDescriptor extends ApplicationDescriptor{
	ServiceRegistration								registration;
	File								executable;
	SimpleModel								model;
	boolean								locked;
	static URL			genericIcon	= SimpleDescriptor.class
											.getResource("icon.png");

	SimpleDescriptor(SimpleModel model, File executable) {
		super("com.acme." + executable.getName());
		this.model = model;
		this.executable = executable;
	}

	public Map getPropertiesSpecific(String locale) {
		Map map = new Hashtable();
		map.put(APPLICATION_ICON, genericIcon);
		map.put(APPLICATION_NAME, executable.getName());
		return map;
	}

	protected ApplicationHandle launchSpecific(
		final Map args) throws Exception {
		final SimpleDescriptor descriptor = this;

		return (ApplicationHandle) AccessController
				.doPrivileged(new PrivilegedExceptionAction() {
					public Object run() throws Exception {
						SimpleHandle handle = 
							new SimpleHandle(descriptor, args);
						handle.registration =
 							model.register(handle);
						return handle;
					}
				});
	}

	Dictionary getServiceProperties() {
		Hashtable p = new Hashtable();
		p.put(APPLICATION_LAUNCHABLE, Boolean.TRUE);
		p.put(APPLICATION_LOCKED, Boolean.valueOf(locked));
		p.put(Constants.SERVICE_PID, getApplicationId());
		return p;
	}

	protected void lockSpecific() {		locked = true; }
	protected void unlockSpecific() { locked = false; }
	public boolean matchDNChain(String arg) { return false; }
	protected boolean isLaunchableSpecific() { return true; }
}</programlisting>
<para>The associated Application Handle must launch the external
executable and track its process. If the process dies autonomously
or is stopped via the <code>destroy</code> method, it must unregister
the Application Handle service. The class could be implemented like:</para>
<programlisting>public class SimpleHandle extends 
	ApplicationHandle implements Runnable {

	ServiceRegistration								registration;
	Process								process;
	int								instance;
	String								state		= RUNNING;
	static int								INSTANCE	= 0;
	Thread								thread;

	public SimpleHandle(SimpleDescriptor descriptor, 
		Map arguments) throws IOException {
		super(descriptor.getApplicationId() 
			+ ":" + (INSTANCE++), descriptor);
		String path = descriptor.executable.getAbsolutePath();
		process = Runtime.getRuntime().exec(path);
		thread = new Thread(this, getInstanceId());
		thread.start();
	}

	public String getState() {	return state; }

	protected void destroySpecific() throws Exception {
		state = STOPPING;
		registration.setProperties(getServiceProperties());
		thread.interrupt();
	}

	// Wait until process finishes or when
	// interrupted
	public void run() {
		try {
			process.waitFor();
			destroy();
		}
		catch (InterruptedException ie) {
			process.destroy();
			try {
				process.waitFor();
			}
			catch (InterruptedException iee) {
				// Ignore
			}
		}
		catch( Exception e ) {
			.. logging
		}
		registration.unregister();
	}

	Dictionary getServiceProperties() {
		Hashtable p = new Hashtable();
		p.put(APPLICATION_PID, getInstanceId());
		p.put(APPLICATION_STATE, state);
		p.put(APPLICATION_DESCRIPTOR,
 			getApplicationDescriptor().getApplicationId());
		return p;
	}
}</programlisting>
<para>The Application Container must create the Application Descriptor
services from some source. Care should be taken to optimize this
scanning so that the initialization time is not significantly increased.
Running application instances should be stopped if the Application
Container is stopped. The following code shows a possible implementation:</para>
<programlisting>public class SimpleModel implements BundleActivator{
	BundleContext								context;
	Set								handles	= new HashSet();

	public ServiceRegistration register(SimpleHandle handle){
		handles.add(handle);
		return context.registerService(
			ApplicationHandle.class.getName(),
			handle, handle.getServiceProperties());
	}

	public void start(BundleContext context) throws Exception 
	{
		this.context = context; 

		File file = new File("c:/windows");
		final SimpleModel me = this;

		file.list(new FilenameFilter() {
			public boolean accept(File dir, String name) {
				if (name.endsWith(".exe")) {
					SimpleDescriptor sd = new SimpleDescriptor(me,
 						new File(dir, name));
					sd.registration = me.context.registerService(
							ApplicationDescriptor.class.getName(),
 								sd, sd.getServiceProperties());
				}
				// We ignore the return anyway
				return false;
	}});}

	public void stop(BundleContext context) throws Exception{
		for (Iterator handle = handles.iterator();
 			handle.hasNext();) {
			SimpleHandle sh = (SimpleHandle) handle.next();
			try {
				sh.destroy();
			}
			catch (Exception e) {
				// We are cleaning up ...
			}
}}}</programlisting></section></section>
<section><title>Application Admin Implementations</title>
<section><title>Implementing the Base Classes</title>
<para>The OSGi specified <code>org.osgi.service.application</code> package
that is delivered with the specification in a JAR file is a dummy
implementation. The intention of this package is to be replaced
by an Application Admin implementation. This implementation can
then enforce policies by intercepting the calls from any Application
Managers to the Application Containers.</para>
<para>The Application Admin implementer must re-implement the following
methods in the <code>ApplicationDescriptor</code> class:</para>
<itemizedlist><listitem><para><phrase role="xref">launch(Map)</phrase>
 – The method can perform any checks before it must call the 
<phrase role="xref">launchSpecific(Map)</phrase>
 method. This must be a protected method. The implementation must
perform any security checks. If these succeed, the <code>launchSpecific</code> method
must not be called in a <code>doPrivileged</code> block.</para></listitem>
<listitem><para><phrase role="xref">lock()</phrase>
 – Must call the <code>lockSpecific</code> method.</para></listitem>
<listitem><para><phrase role="xref">unlock()</phrase>
 – Must call the <code>unlockSpecific</code> method.</para></listitem>
<listitem><para><phrase role="xref">schedule(String,Map,String,String,boolean)</phrase>
 – Register a new Scheduled Application service with the given arguments,
thereby scheduling the application for launching when the topic
and filter match an event. A virtual event is defined for timer
based scheduling, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1508317"/></phrase>
.</para></listitem></itemizedlist>
<para>The Application Admin implementer must also implement the
following method in the <code>ApplicationHandle</code> class:</para>
<itemizedlist><listitem><para><phrase role="xref">destroy()</phrase>
 – The Application Admin implementer should call the protected 
<phrase role="xref">destroySpecific()</phrase>
 method after which it should perform any possible cleanup operations.</para></listitem></itemizedlist>
<para>Implementers must not change the signature of the <code>public</code> and 
<code>protected</code> parts of the <code>ApplicationDescriptor</code> and 
<code>ApplicationHandle</code> classes. Adding fields or methods,
either public or protected is explicitly forbidden.</para></section>
<section><title>Exception Handling</title>
<para>The implementation of the container must ensure that Security
Exceptions are only thrown during the invocation of any of the Application
Descriptor methods when the required permissions are lacking. If
the Application Descriptor is not valid, an Illegal State Exception
must be thrown and never a Security Exception.</para></section>
<section><title>Launching</title>
<para>The <code>launch</code> method of the Application Descriptor
must be implemented by the Application Admin implementer. Launching
must be performed in the following steps:</para>
<orderedlist><listitem><para>Verify that the caller has the appropriate
permissions, see 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1470141"/></phrase>
.</para></listitem>
<listitem><para>Verify that the Application Descriptor is not locked
and launchable</para></listitem>
<listitem><para>Perform any policy actions that are deemed necessary
before the application is really launched.</para></listitem>
<listitem><para>Call the protected <code>launchSpecific</code> method.
If the method throws an Exception, then this exception should be
logged, and must be re-thrown.</para></listitem>
<listitem><para>Otherwise, return the received Application Handle</para></listitem></orderedlist></section>
<section><title>Destroying</title>
<para>The implementation of the <code>ApplicationHandle</code> <code>destroy</code> method
must follow the following steps:</para>
<orderedlist><listitem><para>Verify that the caller has the appropriate
permissions, see
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1470141"/></phrase>
.</para></listitem>
<listitem><para>Call the <code>destroySpecific</code> method. If
an Exception is thrown, then this should be logged but must be further
ignored.</para></listitem>
<listitem><para>Perform any cleanup deemed necessary.</para></listitem></orderedlist></section>
<section><title>Scheduling</title>
<para>Application Descriptor services can be scheduled by calling
the <code>schedule</code> method, as described in 
<phrase role="xref">
<xref xrefstyle="seeHeadingPage" linkend="i1427444"/></phrase>
. This method must be implemented by the Application Admin implementer.</para>
<para>Application Admin implementations must make a reasonable effort
to launch scheduled applications in a timely manner. However, launching
is not guaranteed, implementations can drop and forget events if
it is necessary in order to preserve the stability and integrity
of the device. The granularity of the timer should also be taken
into account, this granularity is one minute so the actual time
an application will be launched can be shifted up to 60 seconds.</para>
<para>If an event would launch multiple applications then the order
of launching is not defined, it is implementation specific.</para>
<para>Launching a scheduled application is constrained by the same
rules as application launching. Thus, attempting to launch a locked
application on the specified event must fail to launch. Launching
can only succeed when the application is unlocked.</para>
<para>If the scheduling is non-recurring and launching a new instance
fails then when the specified event occurs again launching the application
must be attempted again until it succeeds. Non recurring schedules
must be removed once the launch succeeds.</para>
<para>The triggering event will be delivered to the starting application
instance as an additional item identified by the <code>org.osgi.triggeringevent</code> argument
in its startup parameters. This property must not be used for other
purposes in the startup parameters. To ensure that no events are
leaked to applications without the appropriate permission, the event
is delivered in a <code>java.security.GuardedObject</code>, where
the guarding permission is the Topic Permission for the topic to
which the event was posted.</para>
<para>Scheduling and unscheduling an application, or retrieving
information about scheduled applications requires the Application
Admin Permission for the target application to be scheduled. If
the target is the unique identifier of the scheduling application
itself then it can schedule itself. In addition, the scheduling
entity must have Topic Permission for the specified topic.</para></section>
<section xml:id="i1508317"><title>
Virtual
Timer Event</title>
<para>The application scheduler can use a virtual timer event for
time scheduled applications. This event is not actually sent out
by the Event Admin; this virtual event is only used for the syntax
to specify a recurring launch.</para>
<para>The topic name of this virtual timer event is:</para>
<programlisting>org/osgi/application/timer</programlisting>
<para>The properties of the virtual timer event are:</para>
<itemizedlist><listitem><para><code>year</code> – (<code>Integer</code>)
	The year of the specified date. The value is defined by <code>Calendar.YEAR</code> field.</para></listitem>
<listitem><para><code>month</code> - (Integer) 	The month of the
year. The value is defined by <code>Calendar.MONTH</code> field.</para></listitem>
<listitem><para><code>day_of_month</code> – (<code>Integer</code>)
The day of the month. The value is defined by the <code>Calendar.DAY_OF_MONTH</code> field.</para></listitem>
<listitem><para><code>day_of_week</code> – (	<code>Integer</code>)
The day of the week. The value is defined by the <code>Calendar.DAY_OF_WEEK</code> field.</para></listitem>
<listitem><para><code>hour</code>_of_day – (<code>Integer</code>)
The hour of the day. The value is defined by the <code>Calendar.HOUR_OF_DAY</code> field.</para></listitem>
<listitem><para><code>minute</code> – (<code>Integer</code>) The
minute of the hour. The value is defined by the <code>Calendar.MINUTE</code> field.</para></listitem></itemizedlist>
<para>The timer has a resolution of a minute. That is, it is not
possible to schedule per second.</para>
<para>A property that is not included into the filter matches any
value. Not including a field implies that it always matches. For
example, if the <code>minute=0</code> clause from the filter is
missing, the timer event will be fired every minute.</para>
<para>The following examples are filters for the timer event to
specify certain time in the device local time. The topic is always 
<code>org/osgi/application/timer</code>. </para>
<para>Noon every day:</para>
<programlisting>(&amp;(hour_of_day=12)(minute=0))</programlisting>
<para>Every whole hour, on every sunday:</para>
<programlisting>(&amp;(day_of_week=0)(minute=0))</programlisting>
<para>Every whole hour:</para>
<programlisting>(minute=0)</programlisting></section></section>
<section><title>Interaction</title>
<section><title>Application Installation</title>
<para><phrase role="xref">
<xref xrefstyle="FigureNumber" linkend="i1515497"/></phrase>
 shows how an application manager can be notified about the installation
of a new application. The actual installation may be done prior
to the notification or may be done by the application container. At
the end of the successful installation the application container
must register a specialized Application Descriptor service which
properly represents the installed application. If the installed
application's dependencies are fulfilled (which are container specific)
then the application descriptor's <code>application.visible</code> and 
<code>application.launchable</code> properties should be set to <code>true</code>.</para>
<figure xml:id="i1515497"><title>Installing a bundle that is managed by an Application Container</title><mediaobject><imageobject><imagedata fileref="GRAPHIC3" align="center" contentwidth="4.963in" contentdepth="1.586in"/></imageobject></mediaobject></figure></section>
<section><title>Launching an Application</title>
<para>Firstly the appropriate Application Descriptor service on
which the operation will be made is fetched from the service registry.
This Application Descriptor is a container specific sub-class of
the Application Descriptor class. Its <code>launch</code> method
is called which is in the base class. </para>
<para>The application instance may not receive the startup arguments
if its application container does not support startup arguments.
The <code>launch</code> method checks if the a new application instance
can be launched, for example, that the necessary rights are granted,
the application is not locked and the application is not a singleton
that already has an instance.</para>
<para>If the application can be launched then the <code>launchSpecific</code> method,
which is in the subclass, will create and start a new application
instance according to its application container. It will create
a specific application handle and associate the newly created application
instance to it. The <code>launchSpecific</code> method will register
the application handle with proper service properties. The value
of <code>application.state</code> service property must be <code>RUNNING</code>.
The call chain returns the application handle.</para>
<figure><title>Launching an application</title><mediaobject><imageobject><imagedata fileref="GRAPHIC4" align="center" contentwidth="4.963in" contentdepth="2.176in"/></imageobject></mediaobject></figure></section>
<section><title>Destroying an Application Instance</title>
<para>To destroy an application, the proper application handle has
to be fetched from the service registry to call its <code>destroy()</code> method.
It checks if the instance can be destroyed, for example that the
necessary permissions are granted, it then calls the <code>destroySpecific</code> method
to let its implementation destroy the instance in an application
container specific way. First, it sets the <code>application.state</code> service
property to <code>STOPPING</code> then stops the application instance.
Finally it unregisters the application handle.</para></section></section>
<section xml:id="i1470141"><title>
Security</title>
<para>The Application Admin specification is an interaction of the:</para>
<itemizedlist><listitem><para><emphasis>Application Container implementers</emphasis></para></listitem>
<listitem><para><emphasis>Applications</emphasis></para></listitem>
<listitem><para>Application Managers</para></listitem></itemizedlist>
<para>There are two permissions used in the security model of the
Application Admin specification. The first is the Service Permission
that grants access to getting or registering the Application Descriptor and
Application Handle services. The second security is specific for
the Application Admin specification and is the Application Permission.</para>
<para>The Application Container must be very powerful because it
starts the application code, which should be able to perform almost
any function. </para>
<para>The security checks are performed in the <code>ApplicationDescriptor</code> and 
<code>ApplicationHandle</code> base classes.</para>
<section><title>Application Admin Permissions </title>
<para> This <code>ApplicationAdminPermission</code> class implements
permissions for manipulating applications and their instances. The
permission must be held by any bundle that manipulates application
descriptors or application handles.</para>
<para>The target of the Application Admin Permission is an OSGi
filter that matches a number of properties. This is similar to the
Admin Permission in the Framework. Alternatively, instead of the
filter the pseudo target &lt;<code>&lt;SELF&gt;&gt;</code> can be used.</para>
<para>The following properties can be tested in the filter:</para>
<itemizedlist><listitem><para><emphasis>signer</emphasis> – A Distinguished
Name chain that is used to sign the application. The matching of
this property must be done according to the rules described for
DN matching in the OSGi Core Service Platform specification. The
Application Admin Permission must use the <code>ApplicationDescrptor</code> class’ 
<code>matchDNChain</code> method. Matching DN’s is described in 
<phrase role="xref">Certificate Matching on page 17</phrase>
 of the OSGi Service Platform Core specification.</para></listitem>
<listitem><para><emphasis>pid</emphasis> – The PID of the target
application.</para></listitem></itemizedlist>
<para>The pseudo target <code>&lt;&lt;SELF&gt;&gt;</code> indicates that
the calling application is allowed to manipulate its own descriptors
and handlers. </para>
<para>The following actions can be granted:</para>
<itemizedlist><listitem><para><phrase role="xref">SCHEDULE_ACTION</phrase>
 – The caller is allowed to schedule an application., i.e. call
the <code>ApplicationDescriptor</code> <code>schedule</code> method.
This action implies 
<phrase role="xref">LIFECYCLE_ACTION</phrase>
.</para></listitem>
<listitem><para><phrase role="xref">LIFECYCLE_ACTION</phrase>
 – The caller is allowed to manipulate the life cycle state of an
application instance: launch and destroy. </para></listitem>
<listitem><para><phrase role="xref">LOCK_ACTION</phrase>
 – The caller is allowed to the <code>lock</code> and <code>unlock</code> methods. </para></listitem></itemizedlist></section>
<section><title>Service and Package Permissions</title>
<section><title>Application Admin Implementation</title>
<para>The Application Admin implementation must have the following
permissions:</para>
<programlisting>ServicePermission  ..ScheduledApplication         REGISTER
ServicePermission  ..ApplicationDescriptor         GET
ServicePermission  ..ApplicationHandle             GET
PackagePermission  org.osgi.service.application   EXPORTONLY
ServicePermission  ..ApplicationDescriptor         GET
ServicePermission  ..ApplicationHandle             GET
ApplicationAdminPermission *                       *</programlisting></section>
<section><title>Application Container</title>
<programlisting>ServicePermission  ..ApplicationDescriptor        REGISTER
ServicePermission  ..ApplicationHandle             REGISTER
PackagePermission  org.osgi.service.application    IMPORT</programlisting>
<para>Additionally, an Application Container requires all the permissions
that are needed to run the applications. This is likely to be All
Permission.</para></section></section></section>
<section><title>Changes</title>
<itemizedlist><listitem><para>Added an exit value for applications</para></listitem>
<listitem><para>Minor updates</para></listitem></itemizedlist></section>
<INSET xml:id="i1636669"><phrase>org.osgi.service.application<?FM MARKER [Cross-Ref] org.osgi.service.application?>
<?FM MARKER [Index] org.osgi.service.application?>
<?FM MARKER [Cross-Ref] package:org.osgi.service.application?>

Application Package Version 1.1.  
Bundles wishing to use this package must list the package in the
Import-Package header of the bundle’s manifest. This package has
two types of users: the consumers that use the API in this package and
the providers that implement the API in this package. 
Example import for consumers using the API in this package: 
Import-Package: org.osgi.service.application; version=”[1.1,2.0)”
Example import for providers implementing the API in this package: 
Import-Package: org.osgi.service.application; version=”[1.1,1.2)”
Summary
ApplicationAdminPermission –  This class implements permissions
for manipulating applications and their instances. 
ApplicationDescriptor –  An OSGi service that represents an installed
application and stores information about it. 
ApplicationException –  This exception is used to indicate problems
related to application lifecycle management. 
ApplicationHandle –  ApplicationHandle is an OSGi service interface
which represents an instance of an application. 
ScheduledApplication –  It is allowed to schedule an application
based on a specific event. 
Permissions
<?FM MARKER [Cross-Ref] ApplicationAdminPermission?>
<?FM MARKER [Index] ApplicationAdminPermission?>
<?FM MARKER [Index] class:ApplicationAdminPermission?>
ApplicationAdminPermission
public class ApplicationAdminPermission
	extends Permission
This class implements permissions for manipulating applications
and their instances. 
ApplicationAdminPermission can be targeted to applications that
matches the specified filter. 
ApplicationAdminPermission may be granted for different actions:
lifecycle, schedule and lock. The permission schedule implies the
permission lifecycle.
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.LIFECYCLE_ACTION?>
<?FM MARKER [Index] ApplicationAdminPermission:LIFECYCLE_ACTION?>
<?FM MARKER [Index] LIFECYCLE_ACTION?>
LIFECYCLE_ACTION
public static final String LIFECYCLE_ACTION = “lifecycle”<?FM MARKER [Index] lifecycle?>

Allows the lifecycle management of the target applications. 
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.LOCK_ACTION?>
<?FM MARKER [Index] ApplicationAdminPermission:LOCK_ACTION?>
<?FM MARKER [Index] LOCK_ACTION?>
LOCK_ACTION
public static final String LOCK_ACTION = “lock”<?FM MARKER [Index] lock?>

Allows setting/unsetting the locking state of the target applications. 
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.SCHEDULE_ACTION?>
<?FM MARKER [Index] ApplicationAdminPermission:SCHEDULE_ACTION?>
<?FM MARKER [Index] SCHEDULE_ACTION?>
SCHEDULE_ACTION
public static final String SCHEDULE_ACTION = “schedule”<?FM MARKER [Index] schedule?>

Allows scheduling of the target applications. The permission to
schedule an application implies that the scheduler can also manage
the lifecycle of that application i.e. schedule implies lifecycle
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.ApplicationAdminPermission(String,String)?>
<?FM MARKER [Index] ApplicationAdminPermission:ApplicationAdminPermission?>
<?FM MARKER [Index] ApplicationAdminPermission?>
ApplicationAdminPermission(String,String)
public ApplicationAdminPermission ( String filter , String actions
) throws InvalidSyntaxException
	filter	filter to identify application. The value null is equivalent
to “*” and it indicates “all application”.
	actions	comma-separated list of the desired actions granted on
the applications or “*” means all the actions. It must not be null.
The order of the actions in the list is not significant.
	
Constructs an ApplicationAdminPermission. The filter specifies the
target application. The filter is an LDAP-style filter, the recognized
properties are signer and pid. The pattern specified in the signer is
matched with the Distinguished Name chain used to sign the application.
Wildcards in a DN are not matched according to the filter string
rules, but according to the rules defined for a DN chain. The attribute
pid is matched with the PID of the application according to the
filter string rules. 
If the filter is null then it matches “*”. If actions is “*” then
it identifies all the possible actions.
	Throws	InvalidSyntaxException –  is thrown if the specified filter
is not syntactically correct. 
		NullPointerException –  is thrown if the actions parameter is
null
	See Also	ApplicationDescriptor , org.osgi.framework.AdminPermission
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.ApplicationAdminPermission(ApplicationDescriptor,String)?>
<?FM MARKER [Index] ApplicationAdminPermission:ApplicationAdminPermission?>
<?FM MARKER [Index] ApplicationAdminPermission?>
ApplicationAdminPermission(ApplicationDescriptor,String)
public ApplicationAdminPermission ( ApplicationDescriptor application
, String actions ) 
	application	the tareget of the operation, it must not be null
	actions	the required operation. it must not be null
	
This contructor should be used when creating ApplicationAdminPermission
instance for checkPermission call. 
	Throws	NullPointerException –  if any of the arguments is null. 
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.equals(Object)?>
<?FM MARKER [Index] ApplicationAdminPermission:equals?>
<?FM MARKER [Index] equals?>
equals(Object)
public boolean equals ( Object with ) 
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.getActions()?>
<?FM MARKER [Index] ApplicationAdminPermission:getActions?>
<?FM MARKER [Index] getActions?>
getActions()
public String getActions ( ) 
	
Returns the actions of this permission. 
	Returns	the actions specified when this permission was created
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.hashCode()?>
<?FM MARKER [Index] ApplicationAdminPermission:hashCode?>
<?FM MARKER [Index] hashCode?>
hashCode()
public int hashCode ( ) 
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.implies(Permission)?>
<?FM MARKER [Index] ApplicationAdminPermission:implies?>
<?FM MARKER [Index] implies?>
implies(Permission)
public boolean implies ( Permission otherPermission ) 
	otherPermission	the implied permission
	
Checks if the specified permission is implied by this permission.
The method returns true under the following conditions: 
This permission was created by specifying a filter (see ApplicationAdminPermission(String,
String))
The implied otherPermission was created for a particular ApplicationDescriptor
(see ApplicationAdminPermission(ApplicationDescriptor, String))
The filter of this permission mathes the ApplicationDescriptor specified
in the otherPermission. If the filter in this permission is the
&amp;lt;&amp;lt;SELF&amp;gt;&amp;gt; pseudo target, then the currentApplicationId set
in the otherPermission is compared to the application Id of the
target ApplicationDescriptor.
The list of permitted actions in this permission contains all actions
required in the otherPermission
Otherwise the method returns false. 
	Returns	true if this permission implies the otherPermission, false
otherwise.
<?FM MARKER [Cross-Ref] ApplicationAdminPermission.setCurrentApplicationId(String)?>
<?FM MARKER [Index] ApplicationAdminPermission:setCurrentApplicationId?>
<?FM MARKER [Index] setCurrentApplicationId?>
setCurrentApplicationId(String)
public ApplicationAdminPermission setCurrentApplicationId ( String
applicationId ) 
	applicationId	the ID of the current application.
	
This method can be used in the java.security.ProtectionDomain implementation
in the implies method to insert the application ID of the current
application into the permission being checked. This enables the
evaluation of the &amp;lt;&amp;lt;SELF&amp;gt;&amp;gt; pseudo targets. 
	Returns	the permission updated with the ID of the current application
<?FM MARKER [Cross-Ref] ApplicationDescriptor?>
<?FM MARKER [Index] ApplicationDescriptor?>
<?FM MARKER [Index] class:ApplicationDescriptor?>
ApplicationDescriptor
public abstract class ApplicationDescriptor
An OSGi service that represents an installed application and stores
information about it. The application descriptor can be used for
instance creation. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_CONTAINER?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_CONTAINER?>
<?FM MARKER [Index] APPLICATION_CONTAINER?>
APPLICATION_CONTAINER
public static final String APPLICATION_CONTAINER = “application.container”<?FM MARKER [Index] application.container?>

The property key for the application container of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_COPYRIGHT?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_COPYRIGHT?>
<?FM MARKER [Index] APPLICATION_COPYRIGHT?>
APPLICATION_COPYRIGHT
public static final String APPLICATION_COPYRIGHT = “application.copyright”<?FM MARKER [Index] application.copyright?>

The property key for the localized copyright notice of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_DESCRIPTION?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_DESCRIPTION?>
<?FM MARKER [Index] APPLICATION_DESCRIPTION?>
APPLICATION_DESCRIPTION
public static final String APPLICATION_DESCRIPTION = “application.description”<?FM MARKER [Index] application.description?>

The property key for the localized description of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_DOCUMENTATION?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_DOCUMENTATION?>
<?FM MARKER [Index] APPLICATION_DOCUMENTATION?>
APPLICATION_DOCUMENTATION
public static final String APPLICATION_DOCUMENTATION = “application.documentation”<?FM MARKER [Index] application.documentation?>

The property key for the localized documentation of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_ICON?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_ICON?>
<?FM MARKER [Index] APPLICATION_ICON?>
APPLICATION_ICON
public static final String APPLICATION_ICON = “application.icon”<?FM MARKER [Index] application.icon?>

The property key for the localized icon of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_LAUNCHABLE?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_LAUNCHABLE?>
<?FM MARKER [Index] APPLICATION_LAUNCHABLE?>
APPLICATION_LAUNCHABLE
public static final String APPLICATION_LAUNCHABLE = “application.launchable”<?FM MARKER [Index] application.launchable?>

The property key for the launchable property of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_LICENSE?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_LICENSE?>
<?FM MARKER [Index] APPLICATION_LICENSE?>
APPLICATION_LICENSE
public static final String APPLICATION_LICENSE = “application.license”<?FM MARKER [Index] application.license?>

The property key for the localized license of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_LOCATION?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_LOCATION?>
<?FM MARKER [Index] APPLICATION_LOCATION?>
APPLICATION_LOCATION
public static final String APPLICATION_LOCATION = “application.location”<?FM MARKER [Index] application.location?>

The property key for the location of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_LOCKED?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_LOCKED?>
<?FM MARKER [Index] APPLICATION_LOCKED?>
APPLICATION_LOCKED
public static final String APPLICATION_LOCKED = “application.locked”<?FM MARKER [Index] application.locked?>

The property key for the locked property of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_NAME?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_NAME?>
<?FM MARKER [Index] APPLICATION_NAME?>
APPLICATION_NAME
public static final String APPLICATION_NAME = “application.name”<?FM MARKER [Index] application.name?>

The property key for the localized name of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_PID?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_PID?>
<?FM MARKER [Index] APPLICATION_PID?>
APPLICATION_PID
public static final String APPLICATION_PID = “service.pid”<?FM MARKER [Index] service.pid?>

The property key for the unique identifier (PID) of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_VENDOR?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_VENDOR?>
<?FM MARKER [Index] APPLICATION_VENDOR?>
APPLICATION_VENDOR
public static final String APPLICATION_VENDOR = “service.vendor”<?FM MARKER [Index] service.vendor?>

The property key for the name of the application vendor. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_VERSION?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_VERSION?>
<?FM MARKER [Index] APPLICATION_VERSION?>
APPLICATION_VERSION
public static final String APPLICATION_VERSION = “application.version”<?FM MARKER [Index] application.version?>

The property key for the version of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.APPLICATION_VISIBLE?>
<?FM MARKER [Index] ApplicationDescriptor:APPLICATION_VISIBLE?>
<?FM MARKER [Index] APPLICATION_VISIBLE?>
APPLICATION_VISIBLE
public static final String APPLICATION_VISIBLE = “application.visible”<?FM MARKER [Index] application.visible?>

The property key for the visibility property of the application. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.ApplicationDescriptor(String)?>
<?FM MARKER [Index] ApplicationDescriptor:ApplicationDescriptor?>
<?FM MARKER [Index] ApplicationDescriptor?>
ApplicationDescriptor(String)
protected ApplicationDescriptor ( String applicationId ) 
	applicationId	The identifier of the application. Its value is also
available as the service.pid service property of this ApplicationDescriptor
service. This parameter must not be null.
	
Constructs the ApplicationDescriptor. 
	Throws	NullPointerException –  if the specified applicationId is
null. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.getApplicationId()?>
<?FM MARKER [Index] ApplicationDescriptor:getApplicationId?>
<?FM MARKER [Index] getApplicationId?>
getApplicationId()
public final String getApplicationId ( ) 
	
Returns the identifier of the represented application. 
	Returns	the identifier of the represented application
<?FM MARKER [Cross-Ref] ApplicationDescriptor.getProperties(String)?>
<?FM MARKER [Index] ApplicationDescriptor:getProperties?>
<?FM MARKER [Index] getProperties?>
getProperties(String)
public final Map getProperties ( String locale ) 
	locale	the locale string, it may be null, the value null means
the default locale. If the provided locale is the empty String (
“”)then raw (non-localized) values are returned.
	
Returns the properties of the application descriptor as key-value
pairs. The return value contains the locale aware and unaware properties
as well. The returned Map will include the service properties of this
ApplicationDescriptor as well. 
This method will call the getPropertiesSpecific method to enable
the container implementation to insert application model and/or
container implementation specific properties. 
The returned java.util.Map will contain the standard OSGi service
properties as well (e.g. service.id, service.vendor etc.) and specialized
application descriptors may offer further service properties. The returned
Map contains a snapshot of the properties. It will not reflect further
changes in the property values nor will the update of the Map change
the corresponding service property.
	Returns	copy of the service properties of this application descriptor
service, according to the specified locale. If locale is null then
the default locale’s properties will be returned. (Since service properties
are always exist it cannot return null.)
	Throws	IllegalStateException –  if the application descriptor is
unregistered 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.getPropertiesSpecific(String)?>
<?FM MARKER [Index] ApplicationDescriptor:getPropertiesSpecific?>
<?FM MARKER [Index] getPropertiesSpecific?>
getPropertiesSpecific(String)
protected abstract Map getPropertiesSpecific ( String locale ) 
	locale	the locale to be used for localizing the properties. If
null the default locale should be used. If it is the empty String
(“”) then raw (non-localized) values should be returned.
	
Container implementations can provide application model specific
and/or container implementation specific properties via this method.
Localizable properties must be returned localized if the provided
locale argument is not the empty String. The value null indicates
to use the default locale, for other values the specified locale
should be used. The returned java.util.Map must contain the standard
OSGi service properties as well (e.g. service.id, service.vendor
etc.) and specialized application descriptors may offer further
service properties. The returned Map contains a snapshot of the
properties. It will not reflect further changes in the property
values nor will the update of the Map change the corresponding service
property. 
	Returns	the application model specific and/or container implementation
specific properties of this application descriptor.
	Throws	IllegalStateException –  if the application descriptor is
unregistered 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.isLaunchableSpecific()?>
<?FM MARKER [Index] ApplicationDescriptor:isLaunchableSpecific?>
<?FM MARKER [Index] isLaunchableSpecific?>
isLaunchableSpecific()
protected abstract boolean isLaunchableSpecific ( ) 
	
This method is called by launch() to verify that according to the
container, the application is launchable. 
	Returns	true, if the application is launchable according to the
container, false otherwise.
	Throws	IllegalStateException –  if the application descriptor is
unregistered 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.launch(Map)?>
<?FM MARKER [Index] ApplicationDescriptor:launch?>
<?FM MARKER [Index] launch?>
launch(Map)
public final ApplicationHandle launch ( Map arguments ) throws ApplicationException
	arguments	Arguments for the newly launched application, may be
null
	
Launches a new instance of an application. The args parameter specifies
the startup parameters for the instance to be launched, it may be
null. 
The following steps are made: 
Check for the appropriate permission.
Check the locking state of the application. If locked then throw
an ApplicationException with the reason code ApplicationException.APPLICATION_LOCKED.
Calls the launchSpecific() method to create and start an application
instance.
Returns the ApplicationHandle returned by the launchSpecific()
The caller has to have ApplicationAdminPermission(applicationPID,
“launch”) in order to be able to perform this operation. 
The Map argument of the launch method contains startup arguments
for the application. The keys used in the Map must be non-null,
non-empty String objects. They can be standard or application specific.
OSGi defines the org.osgi.triggeringevent key to be used to pass
the triggering event to a scheduled application, however in the
future it is possible that other well-known keys will be defined.
To avoid unwanted clashes of keys, the following rules should be
applied: 
The keys starting with the dash (-) character are application specific,
no well-known meaning should be associated with them.
Well-known keys should follow the reverse domain name based naming.
In particular, the keys standardized in OSGi should start with org.osgi..
The method is synchronous, it return only when the application instance
was successfully started or the attempt to start it failed. 
This method never returns null. If launching an application fails,
the appropriate exception is thrown.
	Returns	the registered ApplicationHandle, which represents the
newly launched application instance. Never returns null.
	Throws	SecurityException –  if the caller doesn’t have “lifecycle”
ApplicationAdminPermission for the application. 
		ApplicationException –  if starting the application failed 
		IllegalStateException –  if the application descriptor is unregistered 
		IllegalArgumentException –  if the specified Map contains invalid
keys (null objects, empty String or a key that is not String) 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.launchSpecific(Map)?>
<?FM MARKER [Index] ApplicationDescriptor:launchSpecific?>
<?FM MARKER [Index] launchSpecific?>
launchSpecific(Map)
protected abstract ApplicationHandle launchSpecific ( Map arguments
) throws Exception
	arguments	the startup parameters of the new application instance,
may be null
	
Called by launch() to create and start a new instance in an application
model specific way. It also creates and registeres the application
handle to represent the newly created and started instance and registeres
it. The method is synchronous, it return only when the application
instance was successfully started or the attempt to start it failed. 
This method must not return null. If launching the application failed,
and exception must be thrown.
	Returns	the registered application model specific application handle
for the newly created and started instance.
	Throws	IllegalStateException –  if the application descriptor is
unregistered 
		Exception –  if any problem occurs. 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.lock()?>
<?FM MARKER [Index] ApplicationDescriptor:lock?>
<?FM MARKER [Index] lock?>
lock()
public final void lock ( ) 
	
Sets the lock state of the application. If an application is locked
then launching a new instance is not possible. It does not affect
the already launched instances. 
	Throws	SecurityException –  if the caller doesn’t have “lock” ApplicationAdminPermission
for the application. 
		IllegalStateException –  if the application descriptor is unregistered 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.lockSpecific()?>
<?FM MARKER [Index] ApplicationDescriptor:lockSpecific?>
<?FM MARKER [Index] lockSpecific?>
lockSpecific()
protected abstract void lockSpecific ( ) 
	
This method is used to notify the container implementation that
the corresponding application has been locked and it should update
the application.locked service property accordingly. 
	Throws	IllegalStateException –  if the application descriptor is
unregistered 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.matchDNChain(String)?>
<?FM MARKER [Index] ApplicationDescriptor:matchDNChain?>
<?FM MARKER [Index] matchDNChain?>
matchDNChain(String)
public abstract boolean matchDNChain ( String pattern ) 
	pattern	a pattern for a chain of Distinguished Names. It must not
be null.
	
This method verifies whether the specified pattern matches the Distinguished
Names of any of the certificate chains used to authenticate this
application. 
The pattern must adhere to the syntax defined in org.osgi.service.application.ApplicationAdminPermission
for signer attributes. 
This method is used by ApplicationAdminPermission.implies(java.security.Permission)
method to match target ApplicationDescriptor and filter.
	Returns	true if the specified pattern matches at least one of the
certificate chains used to authenticate this application
	Throws	NullPointerException –  if the specified pattern is null. 
		IllegalStateException –  if the application descriptor was unregistered 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.schedule(String,Map,String,String,boolean)?>
<?FM MARKER [Index] ApplicationDescriptor:schedule?>
<?FM MARKER [Index] schedule?>
schedule(String,Map,String,String,boolean)
public final ScheduledApplication schedule ( String scheduleId ,
Map arguments , String topic , String eventFilter , boolean recurring
) throws InvalidSyntaxException , ApplicationException
	scheduleId	the identifier of the created schedule. It can be null,
in this case the identifier is automatically generated.
	arguments	the startup arguments for the scheduled application,
may be null
	topic	specifies the topic of the triggering event, it may contain
a trailing asterisk as wildcard, the empty string is treated as
“*”, must not be null
	eventFilter	specifies and LDAP filter to filter on the properties
of the triggering event, may be null
	recurring	if the recurring parameter is false then the application
will be launched only once, when the event firstly occurs. If the
parameter is true then scheduling will take place for every event
occurrence; i.e. it is a recurring schedule
	
Schedules the application at a specified event. Schedule information
should not get lost even if the framework or the device restarts
so it should be stored in a persistent storage. The method registers
a ScheduledApplication service in Service Registry, representing
the created schedule. 
The Map argument of the method contains startup arguments for the
application. The keys used in the Map must be non-null, non-empty
String objects. The argument values must be of primitive types,
wrapper classes of primitive types, String or arrays or collections
of these. 
The created schedules have a unique identifier within the scope
of this ApplicationDescriptor. This identifier can be specified
in the scheduleId argument. If this argument is null, the identifier
is automatically generated.
	Returns	the registered scheduled application service
	Throws	NullPointerException –  if the topic is null
		InvalidSyntaxException –  if the specified eventFilter is not
syntactically correct 
		ApplicationException –  if the schedule couldn’t be created. The
possible error codes are 
ApplicationException.APPLICATION_DUPLICATE_SCHEDULE_ID if the specified
scheduleId is already used for this ApplicationDescriptor
ApplicationException.APPLICATION_SCHEDULING_FAILED if the scheduling
failed due to some internal reason (e.g. persistent storage error).
ApplicationException.APPLICATION_INVALID_STARTUP_ARGUMENT if the
specified startup argument doesn’t satisfy the type or value constraints
of startup arguments.
		SecurityException –  if the caller doesn’t have “schedule” ApplicationAdminPermission
for the application. 
		IllegalStateException –  if the application descriptor is unregistered 
		IllegalArgumentException –  if the specified Map contains invalid
keys (null objects, empty String or a key that is not String) 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.unlock()?>
<?FM MARKER [Index] ApplicationDescriptor:unlock?>
<?FM MARKER [Index] unlock?>
unlock()
public final void unlock ( ) 
	
Unsets the lock state of the application. 
	Throws	SecurityException –  if the caller doesn’t have “lock” ApplicationAdminPermission
for the application. 
		IllegalStateException –  if the application descriptor is unregistered 
<?FM MARKER [Cross-Ref] ApplicationDescriptor.unlockSpecific()?>
<?FM MARKER [Index] ApplicationDescriptor:unlockSpecific?>
<?FM MARKER [Index] unlockSpecific?>
unlockSpecific()
protected abstract void unlockSpecific ( ) 
	
This method is used to notify the container implementation that
the corresponding application has been unlocked and it should update
the application.locked service property accordingly. 
	Throws	IllegalStateException –  if the application descriptor is
unregistered 
<?FM MARKER [Cross-Ref] ApplicationException?>
<?FM MARKER [Index] ApplicationException?>
<?FM MARKER [Index] class:ApplicationException?>
ApplicationException
public class ApplicationException
	extends Exception
This exception is used to indicate problems related to application
lifecycle management. ApplicationException object is created by
the Application Admin to denote an exception condition in the lifecycle
of an application. ApplicationExceptions should not be created by
developers. 
ApplicationExceptions are associated with an error code. This code
describes the type of problem reported in this exception. The possible
codes are: 
APPLICATION_LOCKED - The application couldn’t be launched because
it is locked.
APPLICATION_NOT_LAUNCHABLE - The application is not in launchable
state.
APPLICATION_INTERNAL_ERROR - An exception was thrown by the application
or its container during launch.
APPLICATION_SCHEDULING_FAILED - The scheduling of an application
failed. 
APPLICATION_DUPLICATE_SCHEDULE_ID - The application scheduling failed
because the specified identifier is already in use. 
APPLICATION_EXITVALUE_NOT_AVAILABLE - The exit value is not available
for an application instance because the instance has not terminated. 
APPLICATION_INVALID_STARTUP_ARGUMENT - One of the specified startup
arguments is invalid, for example its type is not permitted. 
<?FM MARKER [Cross-Ref] ApplicationException.APPLICATION_DUPLICATE_SCHEDULE_ID?>
<?FM MARKER [Index] ApplicationException:APPLICATION_DUPLICATE_SCHEDULE_ID?>
<?FM MARKER [Index] APPLICATION_DUPLICATE_SCHEDULE_ID?>
APPLICATION_DUPLICATE_SCHEDULE_ID
public static final int APPLICATION_DUPLICATE_SCHEDULE_ID = 5
The application scheduling failed because the specified identifier
is already in use. 
<?FM MARKER [Cross-Ref] ApplicationException.APPLICATION_EXITVALUE_NOT_AVAILABLE?>
<?FM MARKER [Index] ApplicationException:APPLICATION_EXITVALUE_NOT_AVAILABLE?>
<?FM MARKER [Index] APPLICATION_EXITVALUE_NOT_AVAILABLE?>
APPLICATION_EXITVALUE_NOT_AVAILABLE
public static final int APPLICATION_EXITVALUE_NOT_AVAILABLE = 6
The exit value is not available for an application instance because
the instance has not terminated. 
	Since	1.1
<?FM MARKER [Cross-Ref] ApplicationException.APPLICATION_INTERNAL_ERROR?>
<?FM MARKER [Index] ApplicationException:APPLICATION_INTERNAL_ERROR?>
<?FM MARKER [Index] APPLICATION_INTERNAL_ERROR?>
APPLICATION_INTERNAL_ERROR
public static final int APPLICATION_INTERNAL_ERROR = 3
An exception was thrown by the application or the corresponding
container during launch. The exception is available from getCause(). 
<?FM MARKER [Cross-Ref] ApplicationException.APPLICATION_INVALID_STARTUP_ARGUMENT?>
<?FM MARKER [Index] ApplicationException:APPLICATION_INVALID_STARTUP_ARGUMENT?>
<?FM MARKER [Index] APPLICATION_INVALID_STARTUP_ARGUMENT?>
APPLICATION_INVALID_STARTUP_ARGUMENT
public static final int APPLICATION_INVALID_STARTUP_ARGUMENT = 7
One of the specified startup arguments is invalid, for example its
type is not permitted. 
	Since	1.1
<?FM MARKER [Cross-Ref] ApplicationException.APPLICATION_LOCKED?>
<?FM MARKER [Index] ApplicationException:APPLICATION_LOCKED?>
<?FM MARKER [Index] APPLICATION_LOCKED?>
APPLICATION_LOCKED
public static final int APPLICATION_LOCKED = 1
The application couldn’t be launched because it is locked. 
<?FM MARKER [Cross-Ref] ApplicationException.APPLICATION_NOT_LAUNCHABLE?>
<?FM MARKER [Index] ApplicationException:APPLICATION_NOT_LAUNCHABLE?>
<?FM MARKER [Index] APPLICATION_NOT_LAUNCHABLE?>
APPLICATION_NOT_LAUNCHABLE
public static final int APPLICATION_NOT_LAUNCHABLE = 2
The application is not in launchable state, it’s ApplicationDescriptor.APPLICATION_LAUNCHABLE attribute
is false. 
<?FM MARKER [Cross-Ref] ApplicationException.APPLICATION_SCHEDULING_FAILED?>
<?FM MARKER [Index] ApplicationException:APPLICATION_SCHEDULING_FAILED?>
<?FM MARKER [Index] APPLICATION_SCHEDULING_FAILED?>
APPLICATION_SCHEDULING_FAILED
public static final int APPLICATION_SCHEDULING_FAILED = 4
The application schedule could not be created due to some internal
error (for example, the schedule information couldn’t be saved due
to some storage error). 
<?FM MARKER [Cross-Ref] ApplicationException.ApplicationException(int)?>
<?FM MARKER [Index] ApplicationException:ApplicationException?>
<?FM MARKER [Index] ApplicationException?>
ApplicationException(int)
public ApplicationException ( int errorCode ) 
	errorCode	The code of the error
	
Creates an ApplicationException with the specified error code. 
<?FM MARKER [Cross-Ref] ApplicationException.ApplicationException(int,Throwable)?>
<?FM MARKER [Index] ApplicationException:ApplicationException?>
<?FM MARKER [Index] ApplicationException?>
ApplicationException(int,Throwable)
public ApplicationException ( int errorCode , Throwable cause ) 
	errorCode	The code of the error
	cause	The cause of this exception.
	
Creates a ApplicationException that wraps another exception. 
<?FM MARKER [Cross-Ref] ApplicationException.ApplicationException(int,String)?>
<?FM MARKER [Index] ApplicationException:ApplicationException?>
<?FM MARKER [Index] ApplicationException?>
ApplicationException(int,String)
public ApplicationException ( int errorCode , String message ) 
	errorCode	The code of the error
	message	The associated message
	
Creates an ApplicationException with the specified error code. 
<?FM MARKER [Cross-Ref] ApplicationException.ApplicationException(int,String,Throwable)?>
<?FM MARKER [Index] ApplicationException:ApplicationException?>
<?FM MARKER [Index] ApplicationException?>
ApplicationException(int,String,Throwable)
public ApplicationException ( int errorCode , String message , Throwable
cause ) 
	errorCode	The code of the error
	message	The associated message.
	cause	The cause of this exception.
	
Creates a ApplicationException that wraps another exception. 
<?FM MARKER [Cross-Ref] ApplicationException.getCause()?>
<?FM MARKER [Index] ApplicationException:getCause?>
<?FM MARKER [Index] getCause?>
getCause()
public Throwable getCause ( ) 
	
Returns the cause of this exception or null if no cause was set. 
	Returns	The cause of this exception or null if no cause was set.
<?FM MARKER [Cross-Ref] ApplicationException.getErrorCode()?>
<?FM MARKER [Index] ApplicationException:getErrorCode?>
<?FM MARKER [Index] getErrorCode?>
getErrorCode()
public int getErrorCode ( ) 
	
Returns the error code associated with this exception. 
	Returns	The error code of this exception.
<?FM MARKER [Cross-Ref] ApplicationHandle?>
<?FM MARKER [Index] ApplicationHandle?>
<?FM MARKER [Index] class:ApplicationHandle?>
ApplicationHandle
public abstract class ApplicationHandle
ApplicationHandle is an OSGi service interface which represents
an instance of an application. It provides the functionality to
query and manipulate the lifecycle state of the represented application instance.
It defines constants for the lifecycle states. 
<?FM MARKER [Cross-Ref] ApplicationHandle.APPLICATION_DESCRIPTOR?>
<?FM MARKER [Index] ApplicationHandle:APPLICATION_DESCRIPTOR?>
<?FM MARKER [Index] APPLICATION_DESCRIPTOR?>
APPLICATION_DESCRIPTOR
public static final String APPLICATION_DESCRIPTOR = “application.descriptor”<?FM MARKER [Index] application.descriptor?>

The property key for the pid of the corresponding application descriptor. 
<?FM MARKER [Cross-Ref] ApplicationHandle.APPLICATION_PID?>
<?FM MARKER [Index] ApplicationHandle:APPLICATION_PID?>
<?FM MARKER [Index] APPLICATION_PID?>
APPLICATION_PID
public static final String APPLICATION_PID = “service.pid”<?FM MARKER [Index] service.pid?>

The property key for the unique identifier (PID) of the application
instance. 
<?FM MARKER [Cross-Ref] ApplicationHandle.APPLICATION_STATE?>
<?FM MARKER [Index] ApplicationHandle:APPLICATION_STATE?>
<?FM MARKER [Index] APPLICATION_STATE?>
APPLICATION_STATE
public static final String APPLICATION_STATE = “application.state”<?FM MARKER [Index] application.state?>

The property key for the state of this application instance. 
<?FM MARKER [Cross-Ref] ApplicationHandle.APPLICATION_SUPPORTS_EXITVALUE?>
<?FM MARKER [Index] ApplicationHandle:APPLICATION_SUPPORTS_EXITVALUE?>
<?FM MARKER [Index] APPLICATION_SUPPORTS_EXITVALUE?>
APPLICATION_SUPPORTS_EXITVALUE
public static final String APPLICATION_SUPPORTS_EXITVALUE = “application.supports.exitvalue”<?FM MARKER [Index] application.supports.exitvalue?>

The property key for the supports exit value property of this application
instance. 
	Since	1.1
<?FM MARKER [Cross-Ref] ApplicationHandle.RUNNING?>
<?FM MARKER [Index] ApplicationHandle:RUNNING?>
<?FM MARKER [Index] RUNNING?>
RUNNING
public static final String RUNNING = “RUNNING”<?FM MARKER [Index] RUNNING?>

The application instance is running. This is the initial state of
a newly created application instance. 
<?FM MARKER [Cross-Ref] ApplicationHandle.STOPPING?>
<?FM MARKER [Index] ApplicationHandle:STOPPING?>
<?FM MARKER [Index] STOPPING?>
STOPPING
public static final String STOPPING = “STOPPING”<?FM MARKER [Index] STOPPING?>

The application instance is being stopped. This is the state of
the application instance during the execution of the destroy() method. 
<?FM MARKER [Cross-Ref] ApplicationHandle.ApplicationHandle(String,ApplicationDescriptor)?>
<?FM MARKER [Index] ApplicationHandle:ApplicationHandle?>
<?FM MARKER [Index] ApplicationHandle?>
ApplicationHandle(String,ApplicationDescriptor)
protected ApplicationHandle ( String instanceId , ApplicationDescriptor
descriptor ) 
	instanceId	the instance identifier of the represented application
instance. It must not be null.
	descriptor	the ApplicationDescriptor of the represented application
instance. It must not be null.
	
Application instance identifier is specified by the container when
the instance is created. The instance identifier must remain static
for the lifetime of the instance, it must remain the same even across
framework restarts for the same application instance. This value
must be the same as the service.pid service property of this application
handle. 
The instance identifier should follow the following scheme: &lt;application
descriptor PID&gt;.&lt;index&gt; where &lt;application descriptor PID&gt;
is the PID of the corresponding ApplicationDescriptor and &lt;index&gt;
is a unique integer index assigned by the application container.
Even after destroying the application index the same index value
should not be reused in a reasonably long timeframe.
	Throws	NullPointerException –   if any of the arguments is null. 
<?FM MARKER [Cross-Ref] ApplicationHandle.destroy()?>
<?FM MARKER [Index] ApplicationHandle:destroy?>
<?FM MARKER [Index] destroy?>
destroy()
public final void destroy ( ) 
	
The application instance’s lifecycle state can be influenced by
this method. It lets the application instance perform operations
to stop the application safely, e.g. saving its state to a permanent
storage. 
The method must check if the lifecycle transition is valid; a STOPPING
application cannot be stopped. If it is invalid then the method
must exit. Otherwise the lifecycle state of the application instance
must be set to STOPPING. Then the destroySpecific() method must
be called to perform any application model specific steps for safe
stopping of the represented application instance. 
At the end the ApplicationHandle must be unregistered. This method
should free all the resources related to this ApplicationHandle. 
When this method is completed the application instance has already
made its operations for safe stopping, the ApplicationHandle has
been unregistered and its related resources has been freed. Further
calls on this application should not be made because they may have
unexpected results.
	Throws	SecurityException –  if the caller doesn’t have “lifecycle”
ApplicationAdminPermission for the corresponding application. 
		IllegalStateException –  if the application handle is unregistered 
<?FM MARKER [Cross-Ref] ApplicationHandle.destroySpecific()?>
<?FM MARKER [Index] ApplicationHandle:destroySpecific?>
<?FM MARKER [Index] destroySpecific?>
destroySpecific()
protected abstract void destroySpecific ( ) 
	
Called by the destroy() method to perform application model specific
steps to stop and destroy an application instance safely. 
	Throws	IllegalStateException –  if the application handle is unregistered 
<?FM MARKER [Cross-Ref] ApplicationHandle.getApplicationDescriptor()?>
<?FM MARKER [Index] ApplicationHandle:getApplicationDescriptor?>
<?FM MARKER [Index] getApplicationDescriptor?>
getApplicationDescriptor()
public final ApplicationDescriptor getApplicationDescriptor ( ) 
	
Retrieves the ApplicationDescriptor to which this ApplicationHandle
belongs. 
	Returns	The corresponding ApplicationDescriptor
<?FM MARKER [Cross-Ref] ApplicationHandle.getExitValue(long)?>
<?FM MARKER [Index] ApplicationHandle:getExitValue?>
<?FM MARKER [Index] getExitValue?>
getExitValue(long)
public Object getExitValue ( long timeout ) throws ApplicationException
, InterruptedException
	timeout	The maximum time in milliseconds to wait for the application
to timeout.
	
Returns the exit value for the application instance. The timeout
specifies how the method behaves when the application has not yet
terminated. A negative, zero or positive value may be used. 
negative - The method does not wait for termination. If the application
has not terminated then an ApplicationException is thrown.
zero - The method waits until the application terminates.
positive - The method waits until the application terminates or
the timeout expires. If the timeout expires and the application
has not terminated then an ApplicationException is thrown.
The default implementation throws an UnsupportedOperationException.
The application model should override this method if exit values
are supported. 
	Returns	The exit value for the application instance. The value
is application specific.
	Throws	UnsupportedOperationException –  If the application model
does not support exit values. 
		InterruptedException –  If the thread is interrupted while waiting
for the timeout. 
		ApplicationException –  If the application has not terminated.
The error code will be ApplicationException.APPLICATION_EXITVALUE_NOT_AVAILABLE. 
	Since	1.1
<?FM MARKER [Cross-Ref] ApplicationHandle.getInstanceId()?>
<?FM MARKER [Index] ApplicationHandle:getInstanceId?>
<?FM MARKER [Index] getInstanceId?>
getInstanceId()
public final String getInstanceId ( ) 
	
Returns the unique identifier of this instance. This value is also
available as a service property of this application handle’s service.pid. 
	Returns	the unique identifier of the instance
<?FM MARKER [Cross-Ref] ApplicationHandle.getState()?>
<?FM MARKER [Index] ApplicationHandle:getState?>
<?FM MARKER [Index] getState?>
getState()
public abstract String getState ( ) 
	
Get the state of the application instance. 
	Returns	the state of the application.
	Throws	IllegalStateException –  if the application handle is unregistered 
<?FM MARKER [Cross-Ref] ScheduledApplication?>
<?FM MARKER [Index] ScheduledApplication?>
<?FM MARKER [Index] interface:ScheduledApplication?>
ScheduledApplication
public interface ScheduledApplication
It is allowed to schedule an application based on a specific event.
ScheduledApplication service keeps the schedule information. When
the specified event is fired a new instance must be launched. Note that
launching operation may fail because e.g. the application is locked. 
Each ScheduledApplication instance has an identifier which is unique
within the scope of the application being scheduled. 
ScheduledApplication instances are registered as services. The APPLICATION_PID
service property contains the PID of the application being scheduled,
the SCHEDULE_ID service property contains the schedule identifier.
<?FM MARKER [Cross-Ref] ScheduledApplication.APPLICATION_PID?>
<?FM MARKER [Index] ScheduledApplication:APPLICATION_PID?>
<?FM MARKER [Index] APPLICATION_PID?>
APPLICATION_PID
public static final String APPLICATION_PID = “service.pid”<?FM MARKER [Index] service.pid?>

The property key for the identifier of the application being scheduled. 
<?FM MARKER [Cross-Ref] ScheduledApplication.DAY_OF_MONTH?>
<?FM MARKER [Index] ScheduledApplication:DAY_OF_MONTH?>
<?FM MARKER [Index] DAY_OF_MONTH?>
DAY_OF_MONTH
public static final String DAY_OF_MONTH = “day_of_month”<?FM MARKER [Index] day_of_month?>

The name of the day of month attribute of a virtual timer event.
The value is defined by java.util.Calendar.DAY_OF_MONTH. 
<?FM MARKER [Cross-Ref] ScheduledApplication.DAY_OF_WEEK?>
<?FM MARKER [Index] ScheduledApplication:DAY_OF_WEEK?>
<?FM MARKER [Index] DAY_OF_WEEK?>
DAY_OF_WEEK
public static final String DAY_OF_WEEK = “day_of_week”<?FM MARKER [Index] day_of_week?>

The name of the day of week attribute of a virtual timer event.
The value is defined by java.util.Calendar.DAY_OF_WEEK. 
<?FM MARKER [Cross-Ref] ScheduledApplication.HOUR_OF_DAY?>
<?FM MARKER [Index] ScheduledApplication:HOUR_OF_DAY?>
<?FM MARKER [Index] HOUR_OF_DAY?>
HOUR_OF_DAY
public static final String HOUR_OF_DAY = “hour_of_day”<?FM MARKER [Index] hour_of_day?>

The name of the hour of day attribute of a virtual timer event.
The value is defined by java.util.Calendar.HOUR_OF_DAY. 
<?FM MARKER [Cross-Ref] ScheduledApplication.MINUTE?>
<?FM MARKER [Index] ScheduledApplication:MINUTE?>
<?FM MARKER [Index] MINUTE?>
MINUTE
public static final String MINUTE = “minute”<?FM MARKER [Index] minute?>

The name of the minute attribute of a virtual timer event. The value
is defined by java.util.Calendar.MINUTE. 
<?FM MARKER [Cross-Ref] ScheduledApplication.MONTH?>
<?FM MARKER [Index] ScheduledApplication:MONTH?>
<?FM MARKER [Index] MONTH?>
MONTH
public static final String MONTH = “month”<?FM MARKER [Index] month?>

The name of the month attribute of a virtual timer event. The value
is defined by java.util.Calendar.MONTH. 
<?FM MARKER [Cross-Ref] ScheduledApplication.SCHEDULE_ID?>
<?FM MARKER [Index] ScheduledApplication:SCHEDULE_ID?>
<?FM MARKER [Index] SCHEDULE_ID?>
SCHEDULE_ID
public static final String SCHEDULE_ID = “schedule.id”<?FM MARKER [Index] schedule.id?>

The property key for the schedule identifier. The identifier is
unique within the scope of the application being scheduled. 
<?FM MARKER [Cross-Ref] ScheduledApplication.TIMER_TOPIC?>
<?FM MARKER [Index] ScheduledApplication:TIMER_TOPIC?>
<?FM MARKER [Index] TIMER_TOPIC?>
TIMER_TOPIC
public static final String TIMER_TOPIC = “org/osgi/application/timer”<?FM MARKER [Index] org/osgi/application/timer?>

The topic name for the virtual timer topic. Time based schedules
should be created using this topic. 
<?FM MARKER [Cross-Ref] ScheduledApplication.TRIGGERING_EVENT?>
<?FM MARKER [Index] ScheduledApplication:TRIGGERING_EVENT?>
<?FM MARKER [Index] TRIGGERING_EVENT?>
TRIGGERING_EVENT
public static final String TRIGGERING_EVENT = “org.osgi.triggeringevent”<?FM MARKER [Index] org.osgi.triggeringevent?>

The key for the startup argument used to pass the event object that
triggered the schedule to launch the application instance. The event
is passed in a java.security.GuardedObject protected by the corresponding
org.osgi.service.event.TopicPermission. 
<?FM MARKER [Cross-Ref] ScheduledApplication.YEAR?>
<?FM MARKER [Index] ScheduledApplication:YEAR?>
<?FM MARKER [Index] YEAR?>
YEAR
public static final String YEAR = “year”<?FM MARKER [Index] year?>

The name of the year attribute of a virtual timer event. The value
is defined by java.util.Calendar.YEAR. 
<?FM MARKER [Cross-Ref] ScheduledApplication.getApplicationDescriptor()?>
<?FM MARKER [Index] ScheduledApplication:getApplicationDescriptor?>
<?FM MARKER [Index] getApplicationDescriptor?>
getApplicationDescriptor()
public ApplicationDescriptor getApplicationDescriptor ( ) 
	
Retrieves the ApplicationDescriptor which represents the application
and necessary for launching. 
	Returns	the application descriptor that represents the scheduled
application
	Throws	IllegalStateException –  if the scheduled application service
is unregistered 
<?FM MARKER [Cross-Ref] ScheduledApplication.getArguments()?>
<?FM MARKER [Index] ScheduledApplication:getArguments?>
<?FM MARKER [Index] getArguments?>
getArguments()
public Map getArguments ( ) 
	
Queries the startup arguments specified when the application was
scheduled. The method returns a copy of the arguments, it is not
possible to modify the arguments after scheduling. 
	Returns	the startup arguments of the scheduled application. It
may be null if null argument was specified.
	Throws	IllegalStateException –  if the scheduled application service
is unregistered 
<?FM MARKER [Cross-Ref] ScheduledApplication.getEventFilter()?>
<?FM MARKER [Index] ScheduledApplication:getEventFilter?>
<?FM MARKER [Index] getEventFilter?>
getEventFilter()
public String getEventFilter ( ) 
	
Queries the event filter for the triggering event. 
	Returns	the event filter for triggering event
	Throws	IllegalStateException –  if the scheduled application service
is unregistered 
<?FM MARKER [Cross-Ref] ScheduledApplication.getScheduleId()?>
<?FM MARKER [Index] ScheduledApplication:getScheduleId?>
<?FM MARKER [Index] getScheduleId?>
getScheduleId()
public String getScheduleId ( ) 
	
Returns the identifier of this schedule. The identifier is unique
within the scope of the application that the schedule is related
to. 
	Returns	the identifier of this schedule
<?FM MARKER [Cross-Ref] ScheduledApplication.getTopic()?>
<?FM MARKER [Index] ScheduledApplication:getTopic?>
<?FM MARKER [Index] getTopic?>
getTopic()
public String getTopic ( ) 
	
Queries the topic of the triggering event. The topic may contain
a trailing asterisk as wildcard. 
	Returns	the topic of the triggering event
	Throws	IllegalStateException –  if the scheduled application service
is unregistered 
<?FM MARKER [Cross-Ref] ScheduledApplication.isRecurring()?>
<?FM MARKER [Index] ScheduledApplication:isRecurring?>
<?FM MARKER [Index] isRecurring?>
isRecurring()
public boolean isRecurring ( ) 
	
Queries if the schedule is recurring. 
	Returns	true if the schedule is recurring, otherwise returns false
	Throws	IllegalStateException –  if the scheduled application service
is unregistered 
<?FM MARKER [Cross-Ref] ScheduledApplication.remove()?>
<?FM MARKER [Index] ScheduledApplication:remove?>
<?FM MARKER [Index] remove?>
remove()
public void remove ( ) 
	
Cancels this schedule of the application. 
	Throws	SecurityException –  if the caller doesn’t have “schedule”
ApplicationAdminPermission for the scheduled application. 
		IllegalStateException –  if the scheduled application service
is unregistered 

</phrase></INSET>
<section><title>References</title>
<para role="ExternalReference" xml:id="i1519349">
PNG
Image Format</para>
<para role="ExternalReferenceCont">http://www.libpng.org/pub/png/</para>
<para role="ExternalReferenceCont"/></section></chapter>