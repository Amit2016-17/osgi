<?xml version="1.0" encoding="utf-8"?>
<chapter label="147" revision="$Id$" version="5" xml:id="service.transaction.control"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Transaction Control Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.transaction.control-version"
    linkend="org.osgi.service.transaction.control"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>Software Transactions are an important aspect of most modern applications.
    The job of a Transaction is to ensure logical consistency for units of work
    within the application. Any time that the application accesses a persistent 
    external resource then a Transaction ensures that the set of changes made to 
    the resource(s) are Atomic, Consistent, Isolated, and Durable (ACID).</para>

    <para>There are a variety of techniques for managing the lifecycle of software 
    Transactions used in an application. The most primitive mechanisms are for the 
    application code to directly interact with the Transaction Manager, but higher 
    level abstractions can automatically manage the lifecycle of Transactions 
    through the use of Aspect Oriented Programming. Whatever techniques are used
    to manage the Transaction lifecycle it is also necessary for any resource access 
    that occurs within the Transaction to be registered with the Transaction manager. 
    As with managing the Transaction lifecycle, this work may be performed by the 
    client, or by a an intermediate framework without direct action from the client.</para>

    <para>OSGi applications consist of a set of independent modules which interact
    via the OSGi service registry; as such there is no single container which can
    be relied upon to manage the range of tasks needed to successfully use a 
    Transaction. This leaves OSGi clients with little choice but to depend on
    specific environments, sacrificing portability, or to directly use Transactions
    via the <xref linkend="service.jta"/>. The purpose of the Transaction Control 
    Service is twofold:</para>
    
    <itemizedlist>
      <listitem>
        <para>To enable a portable, modular abstraction for Transaction lifecycle
        management</para>
      </listitem>
        
      <listitem>
        <para>To allow different resource types to be easily used within a Transaction</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Scoped Work</emphasis> - A function or code block with an
          associated execution context, known as a Scope. The Scope may be
          <emphasis>Transactional</emphasis>, i.e. associated with a Transaction, 
          or a <emphasis>No Transaction Scope</emphasis>, i.e. with no associated 
          Transaction.</para>          
        </listitem>
      
        <listitem>
          <para><emphasis>Client</emphasis> - Application code that wishes to
          invoke one or more pieces of Scoped Work.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>Transaction Control Service</emphasis> - The OSGi service
          representing the Transaction Control Service implementation. Used by the
          Client to execute pieces of Scoped Work.</para>          
        </listitem>
        
        <listitem>
          <para><emphasis>Resource</emphasis> - A local or remote software component
          which is stateful and can participate in a transaction.</para>          
        </listitem>
        
        <listitem>
          <para><emphasis>Resource Provider</emphasis> - A service or object which
          provides managed access to a Scoped Resource, i.e. a managed connection to
          the Resource which integrates with ongoing Transactions as necessary.</para>          
        </listitem>
      
        <listitem>
          <para><emphasis>Transaction Context</emphasis> - A Java object representing
          the state of a Scope</para>          
        </listitem>
      </itemizedlist>
    </section>
    
    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Transaction Control Service</emphasis> - A service that can
          execute pieces of work within a Scope, and be queried to establish the current 
          Scope.</para>
        </listitem>

        <listitem>
          <para><emphasis>Client</emphasis> - The code that requests for Work to be run
          in a particular Scope.</para>
        </listitem>

        <listitem>
          <para><emphasis>Work</emphasis> - A collection of instructions that interact
          with zero or more Resources within a Scope</para>
        </listitem>

        <listitem>
          <para><emphasis>Scoped Resource</emphasis> - A resource connection with a 
          managed lifecycle. The connection will automatically participate in 
          Transactions associated with Transactional Scopes, and its lifecycle is
          tied to the Scope within which it is used.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Usage</title>

    <para>This section is an introduction in the usage of the Transaction
    Control Service. It is not the formal specification, the normative part 
    starts at <xref linkend="service.transaction.control-main.body"/>. This 
    section leaves out some of the details for clarity.</para>

    <section>
      <title>Synopsis</title>

      <para>The Transaction Control Service provides a mechanism for a client 
      to run work within a defined Scope. Typically a Scope is also associated 
      with a Transaction. The purpose of a Scope is to simplify the lifecycle 
      of resources, and to allow those resources to participate in any ongoing
      Transaction. Any Scoped Resources accessed during a Scope will remain 
      available throughout the scope, and be automatically cleaned up when the 
      Scope completes.</para>

      <para>Each Scope is started by the Client by passing piece of work
      to the Transaction Control Service. The transaction control service will
      then begin a scope if needed, execute the work, and then complete the 
      scope if needed. The different methods on the Transaction Control Service 
      provide different lifecycle semantics for the Scope. Some methods establish
      a Transactional Scope, others may suspend an active Transactional Scope
      replacing it with a No Transaction Scope.</para>
      
      <para>When a piece of Scoped Work is executing it may access one or 
      more Scoped Resources. When a Scoped Resource is first accessed within a 
      Scope it is bound to that Scope so that future accesses use the same 
      physical resource. At the end of the Scope the resource is detached
      from the scope and the physical resource is released. If the Scope
      is Transactional then the Scoped Resource will also participate in
      the transaction.</para>
      
      <para>At the end of a piece of Scoped Work the Scope is finished. For
      a No Transaction Scope this simply involves calling any registered 
      callbacks. For a Transactional Scope, however, the Transaction must
      be completed or rolled back. If the Scoped Work exits normally, and
      no call has been made to force the Transaction to roll back, then the
      Transaction will commit. If, however, the Work exits with an Exception
      or the Transaction has been marked for roll back, then the Transaction
      will roll back. The result of the Work then flows back to the caller
      in an appropriate way.</para>
    </section>

    <section>
      <title>Running Scoped Work</title>

      <para>The general pattern for a client is to obtain the Transaction
      Control Service and one or more Resource Provider instances. The
      Resource Provider(s) may come from the Service Registry, or from
      a Factory, and are used to create Scoped Resource instances. These
      instances can then be used in the scoped work. This is demonstrated 
      in the following example:</para>

      <programlisting xml:id="service.transaction.control-simple-usage">
      
@Reference
TransactionControl control;

Connection connection;

@Reference
void setResourceProvider(JDBCConnectionProvider provider) {
    connection = provider.getResrouce(control)
}

public void addMessage(String message) {
    control.required(() -> {
            PreparedStatement ps = connection.prepareStatement(
                            "Insert into TEST_TABLE values ( ? )");
                    ps.setString(1, message);
                    return ps.executeUpdate();
        });
}

public List&lt;String&gt; listMessages(String message) {
    control.notSupported(() -> {
            List&lt;String&gt; results = new ArrayList&lt;String&gt;();
            ResultSet rs = connection.createStatement()
                    .executeQuery("Select * from TEST_TABLE");
            while(rs.next()) {
                results.add(rs.getString(1));
            }
            return results;
        });
}

      </programlisting>

      <para>This example demonstrates how simply clients can execute scoped
      work using the Transaction Control Service. In this case write
      operations always occur in a Transactional Scope, but read operations may 
      occur in a Transactional Scope <emphasis>or</emphasis> a No Transaction
      Scope. In all cases the lifecycle of the underlying connection is automatically
      managed, and there is no need to close or commit the connection.</para>

    </section>

    <section>
      <title>Accessing Scoped Resources</title>

      <para>The Transaction Control Service can be used to manage the Scope of
      any piece of Work, but Scopes are primarily used to simplify resource
      lifecycle management when using Scoped Resources. A Scoped Resource is
      created using a Resource Provider, and the returned object can then be 
      used in any scope to access the associated Resource.</para>
      
      <para>In the <xref linkend="service.transaction.control-simple-usage" /> 
      the Resource Provider is an instance of <code>JDBCConnectionProvider</code>, 
      which is a specialization of the generic <code>ResourceProvider</code> 
      interface that returns JDBC <code>Connection</code> objects. Other 
      specializations of the Resource Provider exist in this specification, 
      and third party providers may provide their own specializations for
      proprietary resource types.</para>
      
      <para>Once a Resource Provider has been obtained, a Scoped Resource
      is created from it by passing the Transaction Control Service to the
      <code>getResource</code> method. This returns the Scoped Resource
      object that can then be used in Scoped Work.</para>
    </section>

    <section>
      <title>Exception Management</title>

      <para>One of the most significant sources of error in applications
      that use transactions is caused by incorrect Exception Handling.
      These errors are the primary reason for using a framework or 
      container to manage transactions, rather than trying to manage
      them in the application code.</para>

      <para>Exceptions tend to be more common in code that makes use of
      transactions because the code is usually performing actions that
      may fail, for example making updates to a database. Also, many
      of these exceptions (such as <code>java.sql.SQLException</code>)
      are checked exceptions. As Scoped Work will typically raise both
      checked and unchecked exceptions it is defined as a <code>Callable</code>.
      As the callable interface <code>throws Exception</code> it is not 
      necessary to catch or wrap any exception generated within Scoped Work.</para>

      <programlisting>
// An SQLException may be raised by the query, 
// but we don't need to catch it
control.required(() -> connection.createStatement()
    .executeQuery("Insert into TEST_TABLE values ( 'Hello World!' )"));
      </programlisting>

      <para>An exception indicates that a problem has occurred in a piece of
      code therefore, by default, any exception thrown from inside a Transactional
      Scope will cause the Transaction to roll back. This means that the Scoped Work
      can safely ignore any updates that were made in the event of an exception.</para>
      
      <section>
        <title>Handling Exceptions</title>
        
        <para>Scoped Work is free to throw checked or unchecked exceptions, however these 
        exceptions cannot be directly thrown on by the Transaction Control Service. The 
        primary reason for this is that directly rethrowing the exception would force 
        users of the Transaction Control Service to either:</para>
        
        <itemizedlist>
          <listitem>
            <para>Declare <code>throws Exception</code> on the calling method</para>
          </listitem>
          <listitem>
            <para>Add <code>try/catch Exception</code> blocks around the calls to the
            Transaction Control Service.</para>
          </listitem>
        </itemizedlist>
       
        <para>Both of these solutions are undesirable, as they force unnecessary
        boilerplate code, and potentially shadow real checked exceptions in the API.
        Exceptions generated as part of Scoped Work are therefore wrapped by the 
        Transaction Control Service in a <code>ScopedWorkException</code>. 
        <code>ScopedWorkException</code> is an unchecked exception and so can be 
        ignored if no special handling is required.</para>
        
        <para>In the case where the callers API requires the unwrapped exception 
        type to be thrown a <code>ScopedWorkException</code> can be easily unwrapped
        using the <code>as</code> method.</para>
        
        <programlisting>
        
try {
    control.required(() -> connection.createStatement()
        .executeQuery("Insert into TEST_TABLE values ( 'Hello World!' )"));
} catch (ScopedWorkException swe) {
    // This line throws the cause of the ScopedWorkException as
    // an SQLException or as a RuntimeException if appropriate
    throw swe.as(SQLException.class);
}        
        
        </programlisting>
        
        <para>If there is more than one potential checked Exception type that
        should be rethrown then the <code>asOneOf</code> method can be used.</para>
        
        <programlisting>
        
try {
    control.required(() -> connection.createStatement()
        .executeQuery("Insert into TEST_TABLE values ( 'Hello World!' )"));
} catch (ScopedWorkException swe) {
    // This line throws the cause of the ScopedWorkException as
    // an SQLException or as a RuntimeException if appropriate
    throw swe.asOneOf(SQLRecoverableException.class, SQLTransientException.class);
}        
        
        </programlisting>
      </section>
      
      <section>
        <title>Avoiding Transaction Rollback</title>
        
        <para>In general if a piece of Work running in a Transactional Scope
        exits with an exception the the associated Transaction will roll back.
        Sometimes, however, certain exception types should not cause the Transaction
        to roll back. This can be indicated to the Transaction Control Service when 
        the Scope is being declared.</para>

        <programlisting xml:id="service.transaction.control-no-rollback">
        
control.build()
    .noRollbackFor(URISyntaxException.class)
    .required(() -> {
            ...
        });    
        
        </programlisting>        
        
        <para>In the <xref linkend="service.transaction.control-no-rollback"/>
        the Transaction does not roll back for any <code>URISyntaxException</code>.
        Sometimes this is too coarse grained, and the Transaction should only
        avoid rolling back for one specific exception instance. In this case
        the instance can be passed to the Transaction Control Service
        <code>ignoreException</code> method.</para>

        <programlisting>
        
control.required(() -> {
        try {    
            // A URISynaxException from here is safe
            ...
        } catch (URISyntaxException e) {
            control.ignoreException(e);
            throw e;
        }
        // A URISynaxException from here is *not* safe
        ...
    });    
        
        </programlisting>        
      </section>
    </section>

    <section>
      <title>Multi Threading</title>

      <para>By its very definition a Scope is associated with a single
      piece of Work, and therefore a single thread. If a piece of Scoped
      Work starts new threads, or submits tasks to other threads, then any
      code executed on those threads will not occur within the Scope.</para>

      <para>Scoped Resources are always thread-safe, and can be used
      concurrently in different Scopes. This is true even if the underlying
      physical resources are not thread safe. It is the responsibility of
      the Scoped Resource implementation to ensure that the underlying
      physical resources are protected correctly.</para>
    </section>
  </section>

  <section xml:id="service.transaction.control-main.body">
    <title>Transaction Control Service</title>
    
    <para>The Transaction Control Service is the primary interaction point 
    between a client and the Transaction Control Service implementation. A
    Transaction Control Service implementation must expose a service 
    implementing the <xref 
    linkend="org.osgi.service.transaction.control.TransactionControl" 
    xrefstyle="hyperlink"/> interface.</para>
    
    <para>Clients obtain an instance of the Transaction Control Service using 
    the normal OSGi service registry mechanisms, either directly using the 
    OSGi framework API, or using dependency injection.</para>

    <para>The Transaction Control Service is used to:</para>

    <itemizedlist>
      <listitem>
        <para>Execute work within a defined scope</para>
      </listitem>

      <listitem>
        <para>Query the current execution scope</para>
      </listitem>

      <listitem>
        <para>Associate objects with the current execution scope</para>
      </listitem>

      <listitem>
        <para>Register for callbacks when the scope ends</para>
      </listitem>

      <listitem>
        <para>Enlist resource with the current transaction (if there is a
        Transaction Scope active)</para>
      </listitem>

      <listitem>
        <para>Mark the current scope for rollback (if there is a Transaction 
        scope)</para>
      </listitem>
    </itemizedlist>
    
    <section>
      <title>Scope Lifecycle</title>

      <para>The lifecycle of a scope is tied to the execution of a piece of
        scoped work. Unless a scope is being inherited then a scope starts
        immediately before the scoped work executes and ends immediately
        after the scoped work completes, even if the scoped work throws
        an exception.</para>

      <para>The first action that a client wishing to execute scoped work
      must take is to identify the type of scope that they wish to use.
      The work should then be passed to the relevant method on the
      TransactionControl service:</para>
      
      <table>
      <title>Methods for executing scoped work</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth="1.2*"/>

        <colspec colnum="2" colwidth="1.5*"/>

        <colspec colnum="3" colwidth="3.3*"/>

        <thead>
          <row>
            <entry>Method Name</entry>

            <entry>Existing Scope</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry morerows='2' valign='middle'><code>required()</code></entry>
            <entry>Unscoped</entry>
            <entry><para>Begins a new Transaction scope and executes the 
            work inside it</para></entry>
          </row>
          <row>
            <entry>No Transaction scope</entry>
            <entry><para>Suspends the No Transaction Scope and begins a new 
            Transaction scope, executing the work inside it. After the work
            completes the original scope is restored.</para></entry>
          </row>
          <row>
            <entry>Transaction scope</entry>
            <entry><para>Runs the work within the existing scope</para></entry>
          </row>

          <row>
            <entry morerows='2' valign='middle'><code>requiresNew()</code></entry>
            <entry>Unscoped</entry>
            <entry><para>Begins a new Transaction scope and executes the 
            work inside it</para></entry>
          </row>
          <row>
            <entry>No Transaction scope</entry>
            <entry><para>Suspends the No Transaction Scope and begins a new 
            Transaction scope, executing the work inside it. After the work
            completes the original scope is restored.</para></entry>
          </row>
          <row>
            <entry>Transaction scope</entry>
            <entry><para>Suspends the Transaction Scope and begins a new 
            Transaction scope, executing the work inside it. After the work
            completes the original scope is restored.</para></entry>
          </row>
 
          <row>
            <entry morerows='2' valign='middle'><code>supports()</code></entry>
            <entry>Unscoped</entry>
            <entry><para>Begins a new No Transaction scope and executes the 
            work inside it</para></entry>
          </row>
          <row>
            <entry>No Transaction scope</entry>
            <entry><para>Runs the work within the existing scope</para></entry>
          </row>
          <row>
            <entry>Transaction scope</entry>
            <entry><para>Runs the work within the existing scope</para></entry>
          </row>

          <row>
            <entry morerows='2' valign='middle'><code>notSupported()</code></entry>
            <entry>Unscoped</entry>
            <entry><para>Begins a new No Transaction scope and executes the 
            work inside it</para></entry>
          </row>
          <row>
            <entry>No Transaction scope</entry>
            <entry><para>Runs the work within the existing scope</para></entry>
          </row>
          <row>
            <entry>Transaction scope</entry>
            <entry><para>Runs the work within the existing scope</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
      
    <para>Once the relevant method has been identified the client passes
      the scoped work to the Transaction Control Service. In the typical
      case the Transaction Control Service must then:</para>
      
    <orderedlist>
      <listitem>
        <para>Establish a new scope</para>
      </listitem>
      <listitem>
        <para>Execute the scoped work</para>
      </listitem>
      <listitem>
        <para>Finish the scope, calling any registered callbacks
          and committing the Transaction if the scope is a
          Transaction Scope</para>
      </listitem>
      <listitem>
        <para>Return the result of the scoped work to the client</para>
      </listitem>
    </orderedlist>
      
    <para>The Transaction Control Service must only finish a scope once,
      after the execution of the Scoped Work which originally started the
      scope. This means that callbacks registered by a piece of Scoped Work
      may not run immediately after the work finishes, but will be delayed
      until the parent task has finished if the scope was inherited.</para>

    </section>
    
    <section>
      <title>Scopes and Exception Management</title>
      
      <para>Resource access is intrinsically error-prone, and therefore there
        are many potential failure scenarios. Exceptions therefore form an
        important part of the scope lifecycle.</para>
        
        <section>
          <title>Client Exceptions</title>
        
          <para>The work provided by the client to the Transaction Control Service 
          is passed as a <code>Callable</code>, meaning that the work may throw an
          Exception. An Exception thrown by the work is known as a <emphasis>Client
          Exception</emphasis>.</para>
          
          <para>If a client exception is thrown then it must be caught by the
          Transaction Control Service and handled appropriately by finishing the
          scope as required. Once the scope has completed the client exception
          must be wrapped in a <code>ScopedWorkException</code> and rethrown by 
          the Transaction Control service.</para> 
          
          <para>If a number of scopes are nested then a ScopedWorkException may be
          received as a client Exception. A ScopedWorkException should not be re-wrapped
          by the Transaction Control Service but instead a new ScopedWorkException should 
          be created initialised with the original cause. The caught ScopedWorkException 
          must then be added to the new ScopedWorkException as a supressed Exception. 
          This prevents clients from having to deeply introspect the exception cause chain 
          to locate the original error.</para>
        </section>

        <section>
          <title>Rethrowing Client Exceptions</title>
          <para>In the general case clients will not need to catch a ScopedWorkException, 
            and it can be left to report/handle at a higher level. Sometimes, however, 
            the Exceptions thrown by a piece of work represent an important part of the 
            API, and they need to be thrown on without being wrapped in a ScopedWorkException.
            The ScopedWorkException provides a simple mechanism to do this. The client simply 
            calls one of the <code>asOneOf()</code> methods which will throw the cause of the
            Exception as one of the supplied checked Exception types, or directly as an 
            unchecked Exception if the cause is unchecked. 
          </para>
          <para> 
            The <code>asOneOf()</code> methods always throw an Exception, but the method 
            return value is declared as a RuntimeException. This can can be used to simplify 
            the act of rethrowing the cause when using this method.</para>
          
          <programlisting>

try {
    txControl.required(() -> {
                // Do some work in here that may throw IOException
                // or ClassNotFoundException
                return result;
        });
} catch (ScopedWorkException swe) {
    throw swe.asOneOf(IOException.class, ClassNotFoundException.class);
}
          </programlisting>
          
          <para>If the cause of a ScopedWorkException is a checked exception, but that
          exception is not assignable to any of the types passed to the 
          <code>asOneOf()</code> method then this is a programming error and an 
          <code>IllegalArgument</code> exception will be thrown with its cause
          set as the ScopedWorkException</para>
        </section>

        <section>
          <title>Exceptions Generated by the Transaction Control Service</title>
          
          <para>Many operations performed by the Transaction Control Service,
            particularly when finishing a scope, may result in an Exception.
            Internal failures, for example a failure when attempting to commit
            a resource, must be wrapped in a TransactionException and thrown
            to the client.</para>
            <para>A TransactionException must never override a ScopedWorkException.
            In the case where a ScopedWorkException should be thrown and a
            Transaction Control Service failure occurs then the TransactionException
            must be set as a suppressed exception in the ScopedWorkException.</para>
        </section>
      </section>
    
    <section>
      <title>Transaction Scope lifecycle</title>
        <para>In addition to callbacks and scoped variables Transaction scopes also
        provide an ongoing software transaction which shares the lifecycle of the
        scope. There are therefore additional lifecycle rules for Transaction Scopes</para>
      
      <section>
        <title>Triggering Rollback in Transaction Scopes</title>

        <para>By default a transaction will commit automatically when the piece of work 
        completes normally. If this is not desired (for example if the work's business 
        logic determines that the transaction should not complete) then the work may trigger 
        a rollback in one of two ways.</para>
      
        <para>Calling <code>setRollbackOnly()</code> on the Transaction Control object will 
        mark the transaction for rollback so that it will never commit, even if the method 
        completes normally. This is a one-way operation, and the rollback state can be 
        queried using <code>getRollbackOnly().</code></para>
      
        <programlisting>
txControl.required(() -> {
            // Do some work in here
            ...
            // This work will not be committed!
            txControl.setRollbackOnly();
            return result;
    });      
        </programlisting>
      
        <para>Throwing an exception from the piece of work will, by default, cause the 
        transaction to be rolled back. Note that this is different from Java EE behaviour, 
        where a checked exceptions <emphasis>does not</emphasis> trigger rollback. This is 
        a deliberate difference as many applications get the wrong behaviour based on this 
        default. For example SQLException is a commonly thrown Exception in JDBC, but is 
        rarely, if ever, a “safe return”. Forgetting to override this behaviour means that 
        production code will fail to enforce the correct transaction boundaries.</para>
      
        <programlisting>
txControl.required(() -> {
            // Do some work in here
            ...
            // Uh oh – something went wrong!
            throw new IllegalStateException(“Kaboom!”);
    });  
        </programlisting>
      </section> 
        
      <section>
        <title>Avoiding Rollback</title>
        
        <para>Sometimes it is preferable for a piece of work to throw an exception, but 
        for that exception not to trigger a rollback of the transaction. For example some 
        business exceptions may be considered “normal”, or it may be the case that the work 
        performed so far must be persisted for audit reasons.</para>
        
        <para>There are two ways to prevent a transaction from rolling back when a particular 
        exception occurs</para>

        <para>The Transaction Control service provides a <code>TransactionBuilder</code>.
        The builder can can be used to define sets of Exception types that should, or should 
        not, trigger rollback. The most specific match will be used to determine whether the 
        transaction should roll back or not.</para>
        
        <para>The Transaction Control service provides an ignoreException() method. This can 
        be used from within an Active Transaction to declare a specific Exception object that 
        should not trigger rollback.</para>
        
        <para>If a transaction is marked for rollback using <code>setRollbackOnly()</code>
        then it must roll back, even if the work throws an exception which would not normally
        trigger a rollback.</para>
      </section>
      
      <section>
        <title>Read Only transactions</title>
        <para>Resources accessed within a transaction are frequently used to update persistent 
        data, however in some cases it is known in advance that no changes will be made to the 
        data. In the case where no changes are going to be made then different, more optimal, 
        algorithms can be used by the resource to improve performance. It is therefore useful 
        for applications to be able to indicate when resources are going to be used in a 
        read-only way.</para>
        
        <para>To indicate that a transaction is read only the TransactionBuilder must be used.</para>
        
        <programlisting>
txControl.build()
    .readOnly()
    .required(() -> {
            // Do some work in here
            ...
            return result;
        });
        </programlisting>
        
        <para>The readOnly method provides a hint to the TransactionControl service that the 
        scoped work only uses read access to resources. The TransactionControl service is free 
        to ignore this hint if it does not offer read-only optimisations. Also, read only only 
        applies to Transaction Scopes. No Transaction Scopes always ignore the call to readOnly.</para>

        <section>
          <title>Determining whether a Transaction is read only</title>
          <para>The TransactionContext provides access to whether the transaction is read only 
          using the <code>isReadOnly()</code> method. This method will return true if the 
          transaction was started using the read only flag, and the TransactionControl 
          service supports read-only optimization.</para>
          
          <para>This method is primarily available so that resource providers can set their 
          read-only status correctly when they first enlist with the transaction. Resource 
          providers are free to ignore the read only status as it is provided for optimization 
          only.</para>
        </section>
        
        <section>
          <title>Writing to resources using in a read only transaction</title>
            <para>When a client begins a transaction in read-only mode there is no API 
            restriction that prevents them from writing to one or more resources. If the scoped 
            work does write to the resource then the result is undefined. The write may succeed, 
            or it may result in an exception, triggering a rollback. </para>
            
            <para>Clients should avoid declaring a transaction as read only unless they are 
            certain that no resources are updated within the scope of the work. This includes any
            operations performed by external services which inherit the transaction.</para>
        </section>
        
        <section>
          <title>Changing the read state in nested transactions</title>
          
          <para>When a client begins a Transaction Scope using the required method then it 
            inherits the existing Transaction Scope if it exists. It is not possible to change 
            the writability of an inherited transaction.</para>
          
          <para>In the case where the inherited transaction is a writable transaction then 
            the <code>readOnly()</code> state declared for the nested scope will be ignored. 
            In the case where the inherited transaction is read only then an attempt to change 
            the transaction to a writable transaction will fail with a TransactionException.
            </para>
          
          <para>If the nested transaction is declared using requiresNew then it will create 
            a new transaction which may have a different writability from the outer scope.</para>
        </section>
      </section>
    </section>
  </section>
  
  <section>
    <title>The TransactionContext</title>
    
    <para>When a client uses the TransactionControl service to scope a piece of work, the scope 
    gains an associated Transaction Context. The current transaction context is not normally 
    needed by clients, but is an important integration point for ResourceProviders, and for 
    clients that wish to register transaction completion callbacks.</para>
    
    <para>The Transaction Control Service provides methods that can be used to query the current 
    transaction context.</para>
    
    <itemizedlist>
      <listitem>
        <para><code>activeTransaction()</code> - returns true if there is a Transaction
        scope associated with the currently executing work.</para>
      </listitem>
      <listitem>
        <para><code>activeScope()</code> - returns true if there is a Transaction
        Scope or a No Transaction Scope associated with the currently executing work.</para>
      </listitem>
      <listitem>
        <para><code>getCurrentContext()</code> - returns the current 
        <code>TransactionContext</code>, or <code>null</code> if the currently executing code 
        is unscoped. If the current work has a No Transaction scope then the returned 
        Transaction Context will report its status as <code>NO_TRANSACTION</code></para>
      </listitem>
    </itemizedlist>
  
    <para>If a Transaction scope is active then it may either be backed by a 
    Local Transaction, or by an XA Transaction, which affects the types of resource that
    can be used with the Transaction Context. The transaction support can be queried
    using the <code>supportsLocal()</code> and <code>supportsXA()</code> methods on the
    transaction context object. Some implementations may support both XA and Local
    resources in the same transaction, but these are still considered to be XA 
    Transactions.</para>
  
    <section>
      <title>Transaction Lifecycle callbacks</title>
      
      <para>In addition to registering Resources with the Transaction Context clients or resources
      may register callback functions. Callback functions can run either before or after the transaction
      finishes, depending as to whether they are registered using <code>preCompletion</code> or 
      <code>postCompletion</code> to register their callbacks.</para>
      
      <para>Lifecycle callbacks may be registered at any point during the execution of scoped 
      work. Once the scoped work has finished it is no longer possible to register a
      pre-completion callback (for example inside another lifecycle callback). Attempts to
      register a pre-completion callback outside the execution of the scoped work must fail
      with an <code>IllegalStateException</code>. Post-completion callbacks may be also be
      registered with the Transaction Context after the scoped work completes, up to the point
      where the first post-completion callback is called. Specifically a pre-completion
      callback, or a resource participating in the transaction may register a post-completion
      callback. Attempts to register a post-completion callback after this must fail with an
      <code>IllegalStateException</code>.
      </para>
       
      <section>
        <title>Pre-completion Callbacks</title>
        
        <para>Pre-completion callbacks run immediately after the end of the scoped work,
        and before any associated transaction finishes. Because pre-completion callbacks
        run before the end of the transaction they are able to prevent it from committing, 
        either by calling <code>setRollbackOnly()</code> or potentially by throwing a 
        <code>RuntimeException</code>. If the scope is a No Transaction scope then there
        is no commit to prevent.</para>
        
        <para>If scoped work completes with an exception that triggers rollback, then the
        Transaction Context must be marked for rollback before calling any pre-completion
        callbacks.</para>
        
        <para>Exceptions generated by pre-completion callbacks are gathered, If any of the 
        generated Exceptions would trigger rollback then the transaction is treated as having 
        failed with the first of those exceptions. Any other exceptions are added as suppressed 
        exceptions. Assuming that no Client Exception occurred then the failure must be reported
        by throwing a <code>TransactionRolledBackException</code>, or in the case of a 
        No Transaction scope, a <code>TransactionException</code>.</para>
      </section>
      
      <section>
        <title>Post-completion Callbacks</title>
        
        <para>Post-completion callbacks are run after any associated transaction finishes.
        As the transaction has completed, post-completion callbacks receive the completion
        state of the transaction as a method parameter. In the case of a No Transaction 
        context there is no transaction, so the post-completion callbacks immediately 
        follow the pre-completion callbacks, and are passed a status of NO_TRANSACTION.</para>
        
        <para>Exceptions generated by post-completion callbacks are unable to affect the 
        outcome of any transaction, and must therefore be logged, but not acted on further 
        by the Transaction Control service.</para>
        
        <para>Although Post-completion callbacks run after the transaction, the Transaction
        Context must still be valid when they execute. In particular post-completion callbacks
        must have access to any scoped variables registered with the Transaction Context</para>
      </section>
    </section>
  
    <section>
      <title>Scoped variables</title>
    
      <para>A Transaction context may be used to store scoped variables. These variables are 
      attached to the TransactionContext, and will be released after the Context finishes.
      Scoped resources are guaranteed to be accessible in lifecycle callbacks.</para>
    
      <para>Variables may be added to the scope using <code>putScopedValue()</code> and retrieved 
      using <code>getScopedValue()</code>. These methods are valid both for Active Transactions 
      and the No Transaction scope.</para>
    </section>
    
    <section>
      <title>Transaction Key</title>
      
      <para>Every Active Transaction has an associated key, which will be unique within the 
      lifetime of the TransactionControl service's registration i.e. a registered Transaction 
      Control instance will never reuse a key. The key object is opaque, but is guaranteed to 
      be suitable for use as a key in a <code>HashMap</code>. Note that the Transaction Key 
      is not globally unique, but only unique to the registered TransactionControl service. 
      In particular, two concurrently registered TransactionControl services may simultaneously 
      use the same key, and/or a Transaction Control implementation may reuse keys if it 
      unregisters and then re-registers its service with a different service id.</para>

      <para>TransactionContexts for the NovTransaction scope have a null key.</para>
    </section>
    
    <section>
      <title>The Transaction Status</title>
      
      <para>The current state of a Transaction Context is represented by a Java enum, and
      can be queried by calling <code>getTransactionStatus</code>. The status of a 
      Transaction Context will change over time until it reaches a terminal state. 
      Once a terminal state has been reached the status of the Transaction Context will
      not change again. </para>
      
      <para>The status of a Transaction Context will always move forward through the 
      enum values, i.e. the status can never move from one state to another state with 
      a lower sort order. Note that a Transaction Context will not necessarily enter 
      all of the intermediate states between two values.</para>
      
      <table>
        <title>Transaction Status Values</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1.5*"/>

          <colspec colnum="2" colwidth="0.7*"/>

          <colspec colnum="3" colwidth="3.0*"/>

          <thead>
            <row>
              <entry>Status</entry>

              <entry>Terminal</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>NO_TRANSACTION</code></entry>
              <entry>yes</entry>
              <entry>
                <para>This Transaction Context is for a No Transaction Scope</para>
              </entry>
            </row>
          
            <row>
              <entry><code>ACTIVE</code></entry>
              <entry>no</entry>
              <entry>
                <para>This Transaction Scope is executing and not marked for rollback</para>
              </entry>
            </row>

            <row>
              <entry><code>MARKED_ROLLBACK</code></entry>
              <entry>no</entry>
              <entry>
                <para>This Transaction Scope is executing and has been marked for rollback</para>
              </entry>
            </row>

            <row>
              <entry><code>PREPARING</code></entry>
              <entry>no</entry>
              <entry>
                <para>A two phase commit is occurring and the transaction is being prepared.
                This state is visible during the <code>prepare</code> calls on XA resources</para>
              </entry>
            </row>

            <row>
              <entry><code>PREPARED</code></entry>
              <entry>no</entry>
              <entry>
                <para>A two phase commit is occurring and the transaction has been prepared.
                This state is visible immediately prior to committing or rolling back XA resources</para>
              </entry>
            </row>

            <row>
              <entry><code>COMMITTING</code></entry>
              <entry>no</entry>
              <entry>
                <para>The transaction is being committed. This state is visible during the 
                <code>commit</code> calls on resources</para>
              </entry>
            </row>

            <row>
              <entry><code>COMMITTED</code></entry>
              <entry>yes</entry>
              <entry>
                <para>The transaction was successfully committed.</para>
              </entry>
            </row>

            <row>
              <entry><code>ROLLING_BACK</code></entry>
              <entry>no</entry>
              <entry>
                <para>The transaction is being rolled back. This state is visible during the 
                <code>rollback</code> calls on resources</para>
              </entry>
            </row>

            <row>
              <entry><code>ROLLED_BACK</code></entry>
              <entry>yes</entry>
              <entry>
                <para>The transaction was successfully committed.</para>
              </entry>
            </row>
          
          </tbody>
        </tgroup>
      </table>
    </section>
    
    <section>
      <title>Local Transaction scopes</title>
      
      <para>A Local Transaction is not persistent, and therefore not recoverable. It also may
      not be atomic or consistent if multiple resources are involved. Local transactions do, 
      however, provide isolation and durability, even when multiple resources are involved.</para>
      
      <para>A Local Transaction is therefore a very good choice when a single resource is 
      involved as it is extremely lightweight and provides ACID behaviour. Local Transactions 
      do provide benefits when multiple resources are involved, however it is important to realise 
      that Local Transactions may end up in a state where some commits have succeeded and others 
      failed.</para>
      
      <section>
        <title>The Local Transaction Lifecycle</title>
        
        <para>The transaction context for a local transaction begins in the ACTIVE state, 
        and may enter the MARKED_ROLLBACK state if the client calls setRollbackOnly().</para>
        
        <para>A local transaction must always return true from the <code>supportsLocal()</code> 
        method, indicating that LocalResource participants may be registered using the 
        <code>registerLocalResource(LocalResource)</code> method.</para>
        
        <para>Once the transactional work has completed and the pre-completion callbacks have
        run the transaction will be proceed as follows:</para>
 
        <table>
          <title>Lifecycle rules for Local Transactions</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="3*"/>

            <colspec colnum="2" colwidth="3*"/>

            <thead>
              <row>
                <entry>Active</entry>

                <entry>Marked for Rollback</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>
                  <orderedlist>
                    <listitem><para>Set the Transaction Status to COMMITTING</para></listitem>

                    <listitem><para>Call commit on the first LocalResource</para></listitem>
              
                    <listitem><para>If the first commit fails set the status Transaction
                    Status to ROLLING_BACK and initialise a TransactionRolledBackException
                    with its cause set to the failure.</para></listitem>

                    <listitem><para>Continue committing or rolling-back resources based on
                    the Transaction Status. If a failure occurs then add it as a suppressed
                    exception of an existing TransactionException, creating a new
                    TransactionException if this is the first failure.</para></listitem>

                    <listitem><para>Set the Transaction Status to COMMITTED or 
                    ROLLED_BACK as appropriate</para></listitem>

                    <listitem><para>Call the post-completion callbacks, passing the
                    Transaction Status</para></listitem>
                  </orderedlist>
                </entry>
            
                <entry>
                  <orderedlist>
                    <listitem><para>Set the Transaction Status to ROLLING_BACK</para></listitem>

                    <listitem><para>Call rollback on each of the LocalResources</para></listitem>
              
                    <listitem><para>If a failure occurs then add it as a suppressed
                    exception of an existing TransactionException, creating a new
                    TransactionException if this is the first failure.</para></listitem>

                    <listitem><para>Set the Transaction Status to ROLLED_BACK</para></listitem>

                    <listitem><para>Call the post-completion callbacks, passing the
                    Transaction Status</para></listitem>
                  </orderedlist>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Local Transaction Support Service Properties</title>
        <para>A TransactionControl Service which supports local transactions may be identified 
        using the <code>osgi.local.enabled</code> property which will be set to <code>Boolean.TRUE</code>.</para>
      </section>
    </section>
    
    <section>
      <title>XA Transaction scopes</title>
      
      <para>An XA transaction is persistent, and therefore can be recoverable. It is also 
      atomic and consistent even if multiple resources are involved.</para>
      
      <para>An XA Transaction is therefore a very good choice when a multiple resource are 
      involved as it provides ACID behaviour. XA transactions are, however, more heavyweight 
      than local transactions, and should only be used where they are needed.</para>
      
      <section>
        <title>The XA Transaction Lifecycle</title>
        
        <para>The transaction context for an XA transaction begins in the ACTIVE state, 
        and may enter the MARKED_ROLLBACK state if the client calls setRollbackOnly().</para>
        
        <para>An XA transaction must always return true from the <code>supportsXA()</code> 
        method, indicating that XA particpants may be registered using the
        <code>registerXAResource</code> method. XA transactions may also support one
        or more LocalResource participants. In this case the Transaction Context should
        also return <code>true</code> from the <code>supportsLocal()</code>
        method, indicating that LocalResource participants may be registered using the 
        <code>registerLocalResource</code> method.</para>
        
        <para>Once the transactional work has completed and the pre-completion callbacks have
        run the transaction should be completed using the normal XA algorithm. If the
        transaction fails during a commit attempt, resulting in a rollback, then the 
        Transaction Control Service must generate a <code>TransactionRolledBackException</code>. 
        If the transaction fails in any other way then the Transaction Control service must
        generate a <code>TransactionException</code>. Exceptions from the commit should be
        added to an existing ScopedWorkException if it exists.</para>
 
      </section>
      <section>
        <title>XA Transaction Support Service Properties</title>
        <para>A Transaction Control Service which supports XA transactions may be identified 
        using the <code>osgi.xa.enabled</code> property which will be set to <code>Boolean.TRUE</code>.</para>
        <para>If the Transaction Control Service also supports Local transactions then it must also 
        set the <code>osgi.local.enabled</code> property to <code>Boolean.TRUE</code>.</para>
      </section>
    </section>
  </section>
  

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.transaction.control.xml"/>
  
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.transaction.control.jdbc.xml"/>
  
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.transaction.control.jpa.xml"/>
  
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.transaction.control.recovery.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
