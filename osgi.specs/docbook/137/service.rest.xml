<?xml version="1.0" encoding="utf-8"?>
<chapter label="137"
         revision="$Id$"
         version="5" xml:id="service.rest"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>REST Management Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.rest-version"
    linkend="org.osgi.service.rest"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>
	    Cloud computing is a continuing trend in the IT industry. 
	    Due to its service model which embraces dynamism as opposed to masking it, OSGi appears to be an ideal base for building scalable and dependable applications for the cloud where changes in the deployment, network topology, and service availability are the norm rather than the exception. 
	    One of the possible scenarios for OSGi to be successfully applied to cloud computing is using it in a Platform as a Service (PaaS) spirit. 
	    Users write their bundles and can deploy them to their own OSGi instance running in the cloud. 
	    This, however, requires the platform provider to expose the OSGi management API to the end user and make them available through a network protocol. 
	    One of the popular approaches in cloud computing to remote communication is the use of RESTful web services. 

	    Representational State Transfer (REST) is the architectural style of the world wide web. 
	    It can be described as a set of constraints that govern the interactions between the main components of the Internet.  
	    Recently, REST style interaction has gained popularity as a architecture for web services (RESTful web services), mainly to overcome the perceived complexity and verbosity of SOAP-based web services.
	    This specification describes a REST interface for framework management, client-side Java and JavaScript APIs, and an extension mechanism through which other bundles can contribute their own RESTful management APIs and make them discoverable by clients. 
    </para>
    
    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Client-Server</emphasis> A separation of concern between the entity responsible for the user-interaction (client) and the other entity (server) responsible for data storage. For instance, in the original world wide web the browser is the client rendering and presenting the content delivered by one or more web servers. As a result, web content becomes more portable and content providers more scalable.</para>
        </listitem>
        <listitem>
          <para><emphasis>Stateless</emphasis> State is entirely kept at the client side. Therefore, every request must contain all state required for the server to accomplish the transaction and deliver content. The main rationale behind this design constraint is to again improve the scalability since in a pure stateless design the server resources are not burdened with maintaining any client state. Another perceived advantage is that the failure models of stateless interactions is simpler and fault tolerance easier to achieve.</para>
        </listitem>
        <listitem>
          <para><emphasis>Cacheable</emphasis> Content marked as cacheable can be temporarily stored and used to immediately answer future equivalent requests and improve efficiency and reduce network utilization and access latencies. Due to the end-to-end principle, caches can be placed where necessary, e.g., at the client (forward-proxy), or at the server side (backward-proxy). Content marked as non-cacheable must be freshly retrieved with every request even in the presence of caches.</para>
        </listitem>
        <listitem>
          <para><emphasis>Layered</emphasis> Layering introduces natural boundaries to coupling since every layer only accesses the services provided by the lower layer and provides services to the next higher layer.</para>
        </listitem>
        <listitem>
          <para><emphasis>Uniform Interface</emphasis> Generality of component interfaces provides a natural decoupling of implementation and interface. REST furthermore encourages the separation of identifiable resources (addressing) and their representation (content delivery).</para>
  	</listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Resource</emphasis> A resource is abstract piece of information that can be addressed by a resource identifier. The mapping of a resource to a concrete set of entities can vary over time.</para>
        </listitem>
        <listitem>
          <para><emphasis>Representation</emphasis> A representation is a sequence of bytes plus associated meta-data that describe the state of a resource. The data format of a representation is called the media-type. Every concrete representation of a resource is just one of arbitrarily many possible representations. The selection of a concrete representation of a resource can be made according to the media types supported by both the client and the server.</para>
        </listitem>
	<listitem>
          <para><emphasis>REST Management Service</emphasis> The management service exposes a REST API for remotely managing an OSGi framework through the network in a lightweight and portable fashion.</para>
        </listitem>
        <listitem>
          <para><emphasis>Client</emphasis> The client is a machine using the management service by issuing REST requests through the network. It can do so either directly or indirectly, i.e., through client-side libraries using the REST calls internally.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Synopsis</title>

      <para>
	      The manageable entities of an OSGi framework are mapped to resources accessible through resource identifiers. 
	      These identifiers are relative to the (usually externally accessible) root URL of the management service. 
      	      Clients can either discover this root URL or receive it through configuration. 
	      Subsequently, a client is able to introspect the state of the framework and perform management operations. 

	      The internal state of a framework resource is expressed and transmitted as a representation. 
	      The format of the representation is subject to a mutual agreement between client and management service regarding media types commonly supported by both endpoints.
	      This specification describes two possible representation formats: JSON and XML. 
      </para>
    </section>
  </section>

  <section>
    <title>Resources</title>
 
	The framework and its state is mapped to a set of different resources. Each resource is accessible through a resource identifier, as summarized in <TODO>ref</TODO>. 

    <section>
      <title>Framework Startlevel Resource</title>
	 
      The startlevel resource represents the active start level of the framework. It supports the GET and PUT requests. 

      <section>
        <title>GET</title>
	    The GET request retrieves a framework startlevel representation <TODO>ref</TODO> from the REST management service. 
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a startlevel representation.</para>
      		</listitem>
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
 	  <section>
        <title>PUT</title>
	    The PUT request sets the target framework startlevel. The body of the request needs to be a framework startlevel representation <TODO>ref</TODO>. 

	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>204 (NO CONTENT): the request was received and valid. The framework will asynchronously start to adjust the framework startlevel until the target startlevel has been reached.</para>
      		</listitem>
      		<listitem>
        	  <para>415 (UNSUPPORTED MEDIA TYPE): the request had a media type that is not supported by the REST management service.</para>
      		</listitem>
      		<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received an IllegalArgumentException when trying to adjust the framework startlevel, e.g., because the requested startlevel was zero or negative.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>
 

    <section>
      <title>Bundles Resource</title>
	 
      The bundles resource represents the list of all bundles installed on the managed framework. It supports the GET request and two syntactically different forms of POST requests which are used to install new bundles to the framework. 

      <section>
        <title>GET</title>
	    The GET request retrieves a bundle list representation <TODO>ref</TODO> from the REST management service. 
	    
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle list representation.</para>
      		</listitem>
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
      <section>
        <title>POST with Location String</title>
	    The POST request installs a new bundle to the managed framework and thereby logically appends it to the bundles resource. The new bundle to be 
	    installed is referenced by a location string which is passed as the body of the request. In order to disambiguate the request from the other form of POST, 
	    the content type must be set to text/plain. In practice, the location string is usually a URL. Since the framework will use the location
	    retrieving the physical bundle, it needs to be accessible from the remotely managed framework and not necessarily from the managing client.  
	  
	    The management service implementation must check if the result of the install request matches the requested bundle
        since the OSGi framework will return an existing bundle object as the return value of an install call if there was already one with the same location string installed.
        One way of doing it is comparing the last modification timestamp. A detected collision is indicated to the requesting clients through an error code 409. 
	  
	  	The response for the POST request is a local URI denoting path of the newly installed bundle relative to the REST management service root URL.
	  	The request can return the following status codes:
	  	
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the bundle has been successfully installed and the body of the response contains the URI.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to install. The body of the message is a bundleexception representation <TODO>ref</TODO> describing the reason why the installation did not succeed.</para>
      		</listitem>
      		<listitem>
        	  <para>409 (CONFLICT): there is already a bundle installed with the same location string.</para>
      		</listitem>
        </itemizedlist>        
      </section>

	  <section>
        <title>POST with Bundle</title>
	    This variant of the POST request uploads the bundle as the body of the request. The media type of the request should be set to vnd.osgi.bundle 
	    which must be supported by all REST management services. Implementations are free to accept other media types for this request with the 
	    exception of text/plain. For instance, they can opt to additionally support application/zip or application/x-jar.   
	    
        Clients should use the HTTP Content-Location field to set a bundle location.  
        If no content location is given, REST management service implementations must generate a unique location string in order to avoid unintended collisions between unrelated bundles. 
               
	  	The response for the POST request is a local URI denoting path of the newly installed bundle relative to the REST management service root URL.
	  	The request can return the following status codes:
	  	
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the bundle has been successfully installed and the body of the response contains the URI.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to install. The body of the message is a bundleexception representation <TODO>ref</TODO> describing the reason why the installation did not succeed.</para>
      		</listitem>
      		<listitem>
        	  <para>409 (CONFLICT): there is already a bundle installed with the same location string.</para>
      		</listitem>
        </itemizedlist>        
      </section>      
 
      <section>
        <title>GET of the Representations</title>
			The bundles resource returns a list of the URIs of all bundles installed on the framework. 
			For clients interested in all bundles there is also the possibility to retrieve the bundle representation of each installed bundle with 
			a single request through the bundles/representations resource.
			
			
			The body of the response is a bundle representations list <TODO>ref</TODO>.
	  	  	The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle list representation.</para>
      		</listitem>
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>
 
    <section>
      <title>Bundle Resource</title>
	 
      The bundle resource represents a single, distinct bundle in the system. Hence, it has to be qualified by a bundle id. 
      The resource supports the GET, two variants of PUT, and the DELETE requests. 

      <section>
        <title>GET</title>
	    The GET request retrieves a bundle representation <TODO>ref</TODO> from the REST management service. 
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle representation.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>      		
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
 	  <section>
        <title>PUT with Location String</title>
	    The PUT request updates the bundle with a new version, referenced by a location string which is passed as the body of the request. 
	    In order to disambiguate the request from the other form of PUT, the content type must be set to text/plain. 
		The same rationale as in <TODO>ref bundle list POST</TODO>, if a location string is given it must point to a location reachable by the managed framework. 
		If no location string is passed as the body of the request, the framework will perform an update based on the existing bundle's location string.

	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>204 (NO CONTENT): the request was received and valid and the framework has issued the update.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to update. The body of the message is a bundleexception representation <TODO>ref</TODO> describing the reason why the update did not succeed.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
	    </itemizedlist>        
      </section>

 	  <section>
        <title>PUT with Bundle</title>
	    The PUT request updates the bundle with a new version, uploaded as the body of the request. 
	    The media type of the request should be set to vnd.osgi.bundle which must be supported by all REST management services. Implementations are free to accept other media types for this request with the 
	    exception of text/plain. For instance, they can opt to additionally support application/zip or application/x-jar.
	    
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>204 (NO CONTENT): the request was received and valid and the framework has issued the update.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to update. The body of the message is a bundleexception representation <TODO>ref</TODO> describing the reason why the update did not succeed.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
	    </itemizedlist>        
      </section>
      
      <section>
        <title>DELETE</title>
	    The DELETE request uninstalls the bundle from the framework.
	    
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>204 (NO CONTENT): the request was received and valid and the framework has uninstalled the bundle.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to uninstall. The body of the message is a bundleexception representation <TODO>ref</TODO> describing the reason why the uninstallation did not succeed.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
	    </itemizedlist>        
      </section>
           
    </section>
 
 
   <section>
      <title>Bundle State Resource</title>
	 
      The bundle state resource represents the internal state of an installed bundle qualified through its bundle id. 
      It supports the GET and PUT requests. 

      <section>
        <title>GET</title>
	    The GET request retrieves a bundle state representation <TODO>ref</TODO> from the REST management service. 
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle state representation.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
 	  <section>
        <title>PUT</title>
	    The PUT request sets the target state for the given bundle. This can, e.g., be state=32 for transitioning the bundle to started, or state=4 for stopping the bundle and transitioning it to resolved. 
	    The body of the request needs to be a bundle state representation <TODO>ref</TODO>. Not all state transitions are valid.

		The body of the response is the new bundle state implementation <TODO>ref</TODO>.
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request was received and valid. The framework has performed a state change and the new bundle state is contained in the body.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to perform the state transition. 
        	  							The body of the message is a bundleexception representation <TODO>ref</TODO> describing the reason why the operation did not succeed.</para>
      		</listitem>      		
      		<listitem>
        	  <para>402 (PRECONDITION FAILED): the requested target state is not reachable from the current bundle state.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		      		
      		<listitem>
        	  <para>415 (UNSUPPORTED MEDIA TYPE): the request had a media type that is not supported by the REST management service.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>

   <section>
      <title>Bundle Header Resource</title>
	 
      The bundle header resource represents manifest header of a bundle which is qualified by its bundle id. It can only be read through a GET request. 

      <section>
        <title>GET</title>
	    The GET request retrieves a bundle header representation <TODO>ref</TODO> from the REST management service. 
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle header representation.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>
 
     <section>
      <title>Bundle Startlevel Resource</title>
	 
      The bundle startlevel resource represents the start level of the bundle qualified by its bundle id. 
      It supports the GET and PUT requests. 

      <section>
        <title>GET</title>
	    The GET request retrieves a bundle startlevel representation <TODO>ref</TODO> from the REST management service. 
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle startlevel representation.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
 	  <section>
        <title>PUT</title>
	    The PUT request sets the target bundle startlevel. The body of the request needs to be a bundle startlevel representation <TODO>ref</TODO>. 

	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request was received and valid. The REST management service has changed the bundle startlevel according to the target value. 
			  						The body of the response is the new bundle startlevel representation.</para>
      		</listitem>
      		<listitem>
        	  <para>400 (BAD REQUEST):  either the target startlevel state involved invalid values, e.g., a startlevel smaller or equal to zero and the REST 
        	  							management service got an IllegalArgumentException, or the REST management service received a BundleException when trying to perform the startlevel change. 
        	  							In the latter case, the body of the message is a bundleexception representation <TODO>ref</TODO> describing the reason why the operation did not succeed.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		      		
      		<listitem>
        	  <para>415 (UNSUPPORTED MEDIA TYPE): the request had a media type that is not supported by the REST management service.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>
 
 	<section>
      <title>Services Resource</title>
 	</section>
 	
 	<section>
      <title>Service Resource</title>
 	</section>
 	
 
 </section>


 <section>
    <title>Representations</title>

 	<section>
      <title>Bundle Representation</title>
 	</section>

 	<section>
      <title>Bundles Representation</title>
 	</section>

 	<section>
      <title>Bundle State Representation</title>
 	</section>

 	<section>
      <title>Bundle Header Representation</title>
 	</section>

    <section>
        <title>Framework Startlevel Representation</title>

    <table>
      <tgroup cols="2">
        <colspec colnum="1" colwidth="1*"/>

        <colspec colnum="2" colwidth="5*"/>


        <tbody>
          <row>
	    <entry><para><code>JSON</code></para></entry>

	    <entry><para><emphasis>Content-Type: application/org.osgi.frameworkstartlevel+json</emphasis>
			    <code>
{
    "startLevel":6,
    "initialBundleStartLevel":4
}
</code>	    
	    </para></entry>
          </row>

          <row>
	    <entry><para><code>XML</code></para></entry>

	    <entry><para><emphasis>application/org.osgi.frameworkstartlevel+xml</emphasis>
<code>
&lt;frameworkStartLevel&gt;
    &lt;startLevel>6&lt;/startLevel&gt;
    &lt;initialBundleStartLevel>4&lt;/initialBundleStartLevel&gt;
&lt;/frameworkStartLevel&gt;
</code>	    
	    </para></entry>
          </row>

        </tbody>
      </tgroup>
    </table>
	</section>

 	<section>
      <title>Bundle Startlevel Representation</title>
 	</section>

 	<section>
      <title>Service Representation</title>
 	</section>

 	<section>
      <title>Services Representation</title>
 	</section>

 	<section>
      <title>Bundle Exception Representation</title>
 	</section>



 </section>

  <section>
    <title>Domain A</title>

    <para>This is body text.</para>

    <itemizedlist>
      <listitem>
        <para>Bulleted</para>
      </listitem>

      <listitem>
        <para>Bulleted</para>
      </listitem>
      
      <listitem>
        <para>Bulleted</para>
      </listitem>
    </itemizedlist>

    <para>Numbered lists:</para>

    <orderedlist>
      <listitem>
        <para>Numbered</para>
      </listitem>
      
      <listitem>
        <para>Numbered</para>
      </listitem>
      
      <listitem>
        <para>Numbered</para>
      </listitem>
    </orderedlist> 

    <para>An <emphasis>emphasized</emphasis> term.</para>

    <para>The following is a Program Listing style:</para>

    <programlisting>Some s = (Some) context.getService(ref);</programlisting>

    <para>A remark:</para>

    <para>
      <remark>This is a discussion remark</remark>
    </para>

    <section>
      <title>Subsection</title>
      <section>
        <title>Sub-subsection</title>
      </section>
    </section>
  </section>
  
  <section>
    <title>Domain B</title>
  </section>
  
  <section>
    <title>Domain C</title>
  </section>
  
  <section>
    <title>Life Cycle</title>
  </section>
  
  <section>
    <title>Error Handling</title>
  </section>
  
  <section>
    <title>Events</title>
    
    <section>
      <title>Domain Events</title>
    </section>

    <section>
      <title>Event Admin Mapping</title>
    </section>
  </section>
  
  <section>
    <title>Class Loading</title>
  </section>
  
  <section>
    <title>Data Transfer Objects</title>
  </section>
  
  <section>
    <title>XML Schema</title>

    <para>A wide code example (for use with XML Schema). Note that the XML schema is typically included 
        through <code>xi:include</code> tags rather than embedded directly.</para>

    <programlisting role="pgwide">&lt;?xml version="1.0"?&gt;
&lt;!-- XML Schema --&gt;
&lt;top&gt; ... &lt;/top&gt;</programlisting>

  </section>
  
  <section>
    <title>Security</title>
  </section>

  <!-- Include javadoc here, once available
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.rest.xml"/>
  -->

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title>Framework Module Layer</title>OSGi
      Core, Chapter 3 Module Layer</bibliomixed>

      <bibliomixed><title>XML Schema Part 2: Data types
      Second Edition</title>http://www.w3.org/TR/xmlschema-2/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
