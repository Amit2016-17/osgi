<?xml version="1.0" encoding="utf-8"?>
<chapter label="137"
         revision="$Id$"
         version="5" xml:id="service.rest"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>REST Management Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.rest-version"
    linkend="org.osgi.service.rest"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>
	    Cloud computing is a continuing trend in the IT industry. 
	    Due to its service model which embraces dynamism as opposed to masking it, OSGi appears to be an ideal base for building scalable and dependable applications for the cloud where changes in the deployment, network topology, and service availability are the norm rather than the exception. 
	    One of the possible scenarios for OSGi to be successfully applied to cloud computing is using it in a Platform as a Service (PaaS) spirit. 
	    Users write their bundles and can deploy them to their own OSGi instance running in the cloud. 
	    This, however, requires the platform provider to expose the OSGi management API to the end user and make them available through a network protocol. 
	    One of the popular approaches in cloud computing to remote communication is the use of RESTful web services. 
	</para>
	
	<para>
	    Representational State Transfer (REST) is the architectural style of the world wide web. 
	    It can be described as a set of constraints that govern the interactions between the main components of the Internet.  
	    Recently, REST style interaction has gained popularity as a architecture for web services (RESTful web services), mainly to overcome the perceived complexity and verbosity of SOAP-based web services.
	    This specification describes a REST interface for framework management, client-side Java and JavaScript APIs, and an extension mechanism through which other bundles can contribute their own RESTful management APIs and make them discoverable by clients. 
    </para>
    
    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Client-Server</emphasis> A separation of concern between the entity responsible for the user-interaction (client) and the other entity (server) responsible for data storage. For instance, in the original world wide web the browser is the client rendering and presenting the content delivered by one or more web servers. As a result, web content becomes more portable and content providers more scalable.</para>
        </listitem>
        <listitem>
          <para><emphasis>Stateless</emphasis> State is entirely kept at the client side. Therefore, every request must contain all state required for the server to accomplish the transaction and deliver content. The main rationale behind this design constraint is to again improve the scalability since in a pure stateless design the server resources are not burdened with maintaining any client state. Another perceived advantage is that the failure models of stateless interactions is simpler and fault tolerance easier to achieve.</para>
        </listitem>
        <listitem>
          <para><emphasis>Cacheable</emphasis> Content marked as cacheable can be temporarily stored and used to immediately answer future equivalent requests and improve efficiency and reduce network utilization and access latencies. Due to the end-to-end principle, caches can be placed where necessary, e.g., at the client (forward-proxy), or at the server side (backward-proxy). Content marked as non-cacheable must be freshly retrieved with every request even in the presence of caches.</para>
        </listitem>
        <listitem>
          <para><emphasis>Layered</emphasis> Layering introduces natural boundaries to coupling since every layer only accesses the services provided by the lower layer and provides services to the next higher layer.</para>
        </listitem>
        <listitem>
          <para><emphasis>Uniform Interface</emphasis> Generality of component interfaces provides a natural decoupling of implementation and interface. REST furthermore encourages the separation of identifiable resources (addressing) and their representation (content delivery).</para>
  	</listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Resource</emphasis> A resource is abstract piece of information that can be addressed by a resource identifier. The mapping of a resource to a concrete set of entities can vary over time.</para>
        </listitem>
        <listitem>
          <para><emphasis>Representation</emphasis> A representation is a sequence of bytes plus associated meta-data that describe the state of a resource. The data format of a representation is called the media-type. Every concrete representation of a resource is just one of arbitrarily many possible representations. The selection of a concrete representation of a resource can be made according to the media types supported by both the client and the server.</para>
        </listitem>
	<listitem>
          <para><emphasis>REST Management Service</emphasis> The management service exposes a REST API for remotely managing an OSGi framework through the network in a lightweight and portable fashion.</para>
        </listitem>
        <listitem>
          <para><emphasis>Client</emphasis> The client is a machine using the management service by issuing REST requests through the network. It can do so either directly or indirectly, i.e., through client-side libraries using the REST calls internally.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Synopsis</title>

      <para>
	      The manageable entities of an OSGi framework are mapped to resources accessible through resource identifiers. 
	      These identifiers are relative to the (usually externally accessible) root URL of the management service. 
      	      Clients can either discover this root URL or receive it through configuration. 
	      Subsequently, a client is able to introspect the state of the framework and perform management operations. 
	  </para>
	  
	  <para>
	      The internal state of a framework resource is expressed and transmitted as a representation. 
	      The format of the representation is subject to a mutual agreement between client and management service regarding media types commonly supported by both endpoints.
	      This specification describes two possible representation formats: JSON and XML. 
      </para>
    </section>
  </section>

  <section>
  	<title>Interacting with the REST Management Service</title>

    <para>
	   <remark>needs some text</remark>
  	</para>

    <section xml:id="service.rest-resource.identifiers">
  	  <title>Resource Identifier Overview</title>
  	
  	  <para>
  	   <remark>needs some text</remark>
  	  </para>
  	
  	  <code>
	  	framework
		framework/state
		framework/startlevel
		framework/bundles

		framework/bundles/representations

		framework/bundle/{bundleid}
		framework/bundle/{bundleid}/state
		framework/bundle/{bundleid}/startlevel
		framework/bundle/{bundleid}/header
		framework/services

		framework/services/representations

		framework/service/{serviceid}
	  </code>
	
	  <para>
		framework/bundle/0/state is an alias for framework/state
	  </para>

	  <para>
		The bundles, bundles/representations, services, and services/representations resources allow the use of a query parameter which specifies a filter to restrict the result set.
		The filter expression follows the IETF RFC 1960 String Representation of LDAP Search Filter format <remark>TODO: ref</remark>.
	  </para>

	  <para>
		Filters on services are matched against the service attributes. The query parameter is of the form:
		framework/services?filter=ldap-filter

		Filters on bundles are matched against the attributes of capabilities in the respective namespaces. Filters on bundles have the form:

		framework/bundles?namespace1=ldap-filter1&amp;namespace2=ldap-filter2&amp;...

		A missing namespace declaration implies the IdentityNamespace (“osgi.identity”). 
	  </para>
    </section>

    <section>
        <title>Content Type Matching</title>

		<remark>explain the representations and how they are matched based on HTTP accept headers.</remark>
    </section>	

    <section>
        <title>Versioning and Interoperability</title>

		<remark>explain the versioning of the REST API.</remark>
    </section>	
	
  </section>

  <section>
    <title>Resources</title>
 
 	<para>
	   The framework and its state is mapped to a set of different resources. Each resource is accessible through a resource identifier, as summarized in <xref
    linkend="service.rest-resource.identifiers"/>. 
	</para>
	
    <section>
      <title>Framework Startlevel Resource</title>
	 
	  <para>
         The startlevel resource represents the active start level of the framework. It supports the GET and PUT requests. 
	  </para>
	  
      <section>
        <title>GET</title>
	    The GET request retrieves a <xref linkend="service.rest-framework.startlevel.representation" xrefstyle="template:%t"/> from the REST management service. 
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a startlevel representation.</para>
      		</listitem>
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
 	  <section>
        <title>PUT</title>
	    <para>
	       The PUT request sets the target framework startlevel. The body of the request needs to be a <xref linkend="service.rest-framework.startlevel.representation" xrefstyle="template:%t"/>. 
	       
	       The request can return the following status codes:
	  	</para>
	  	
	    <itemizedlist>
      		<listitem>
			  <para>204 (NO CONTENT): the request was received and valid. The framework will asynchronously start to adjust the framework startlevel until the target startlevel has been reached.</para>
      		</listitem>
      		<listitem>
        	  <para>415 (UNSUPPORTED MEDIA TYPE): the request had a media type that is not supported by the REST management service.</para>
      		</listitem>
      		<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received an IllegalArgumentException when trying to adjust the framework startlevel, e.g., because the requested startlevel was zero or negative.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>
 

    <section>
      <title>Bundles Resource</title>
	 
	  <para>
      	The bundles resource represents the list of all bundles installed on the managed framework. It supports the GET request and two syntactically different forms of POST requests which are used to install new bundles to the framework. 
	  </para>

      <section>
        <title>GET</title>
	    The GET request retrieves a <xref linkend="service.rest-bundle.list.representation" xrefstyle="template:%t"/> from the REST management service. 
	    
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle list representation.</para>
      		</listitem>
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
      <section>
        <title>POST with Location String</title>
	    <para>
	    The POST request installs a new bundle to the managed framework and thereby logically appends it to the bundles resource. The new bundle to be 
	    installed is referenced by a location string which is passed as the body of the request. In order to disambiguate the request from the other form of POST, 
	    the content type must be set to text/plain. In practice, the location string is usually a URL. Since the framework will use the location
	    retrieving the physical bundle, it needs to be accessible from the remotely managed framework and not necessarily from the managing client.  
	  	</para>
	  
	  	<para>
	    The management service implementation must check if the result of the install request matches the requested bundle
        since the OSGi framework will return an existing bundle object as the return value of an install call if there was already one with the same location string installed.
        One way of doing it is comparing the last modification timestamp. A detected collision is indicated to the requesting clients through an error code 409. 
	  	</para>
	  
	    <para>
	  	The response for the POST request is a local URI denoting path of the newly installed bundle relative to the REST management service root URL.
	  	The request can return the following status codes:
	  	</para>
	  	
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the bundle has been successfully installed and the body of the response contains the URI.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to install. The body of the message is a <xref linkend="service.rest-bundle.exception.representation" xrefstyle="template:%t"/> describing the reason why the installation did not succeed.</para>
      		</listitem>
      		<listitem>
        	  <para>409 (CONFLICT): there is already a bundle installed with the same location string.</para>
      		</listitem>
        </itemizedlist>        
      </section>

	  <section>
        <title>POST with Bundle</title>
        <para>
	       This variant of the POST request uploads the bundle as the body of the request. The media type of the request should be set to vnd.osgi.bundle 
	       which must be supported by all REST management services. Implementations are free to accept other media types for this request with the 
	       exception of text/plain. For instance, they can opt to additionally support application/zip or application/x-jar.   
	    </para>
	    
	    <para>
           Clients should use the HTTP Content-Location field to set a bundle location.  
           If no content location is given, REST management service implementations must generate a unique location string in order to avoid unintended collisions between unrelated bundles. 
        </para>
               
        <para>
	  	   The response for the POST request is a local URI denoting path of the newly installed bundle relative to the REST management service root URL.
	  	   The request can return the following status codes:
	  	</para>
	  	
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the bundle has been successfully installed and the body of the response contains the URI.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to install. The body of the message is a <xref linkend="service.rest-bundle.exception.representation" xrefstyle="template:%t"/> describing the reason why the installation did not succeed.</para>
      		</listitem>
      		<listitem>
        	  <para>409 (CONFLICT): there is already a bundle installed with the same location string.</para>
      		</listitem>
        </itemizedlist>        
      </section>      
 
      <section>
        <title>GET of the Representations</title>
			<para>
			The bundles resource returns a list of the URIs of all bundles installed on the framework. 
			For clients interested in all bundles there is also the possibility to retrieve the bundle representation of each installed bundle with 
			a single request through the bundles/representations resource.
			</para>
			
			<para>
			The body of the response is a <xref linkend="service.rest-bundle.representations.list.representation" xrefstyle="template:%t"/>.
	  	  	The request can return the following status codes:
	  		</para>
	
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle list representation.</para>
      		</listitem>
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>
 
    <section>
      <title>Bundle Resource</title>
	
	  <para> 
      The bundle resource represents a single, distinct bundle in the system. Hence, it has to be qualified by a bundle id. 
      The resource supports the GET, two variants of PUT, and the DELETE requests. 
	  </para>

      <section>
        <title>GET</title>
	    <para>
	    The GET request retrieves a <xref linkend="service.rest-bundle.representation" xrefstyle="template:%t"/> from the REST management service.
	     
	    The request can return the following status codes:
	  	</para>
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle representation.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>      		
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
 	  <section>
        <title>PUT with Location String</title>
	    <para>
	    The PUT request updates the bundle with a new version, referenced by a location string which is passed as the body of the request. 
	    In order to disambiguate the request from the other form of PUT, the content type must be set to text/plain. 
		The same rationale as in <remark>ref bundle list POST</remark>, if a location string is given it must point to a location reachable by the managed framework. 
		If no location string is passed as the body of the request, the framework will perform an update based on the existing bundle's location string.

	    The request can return the following status codes:
	    </para>
	  
	    <itemizedlist>
      		<listitem>
			  <para>204 (NO CONTENT): the request was received and valid and the framework has issued the update.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to update. The body of the message is a <xref linkend="service.rest-bundle.exception.representation" xrefstyle="template:%t"/> describing the reason why the update did not succeed.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
	    </itemizedlist>        
      </section>

 	  <section>
        <title>PUT with Bundle</title>
        <para>
	    The PUT request updates the bundle with a new version, uploaded as the body of the request. 
	    The media type of the request should be set to vnd.osgi.bundle which must be supported by all REST management services. Implementations are free to accept other media types for this request with the 
	    exception of text/plain. For instance, they can opt to additionally support application/zip or application/x-jar.
	    
	    The request can return the following status codes:
	    </para>
	  
	    <itemizedlist>
      		<listitem>
			  <para>204 (NO CONTENT): the request was received and valid and the framework has issued the update.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to update. The body of the message is a <xref linkend="service.rest-bundle.exception.representation" xrefstyle="template:%t"/> describing the reason why the update did not succeed.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
	    </itemizedlist>        
      </section>
      
      <section>
        <title>DELETE</title>
        <para>
	    The DELETE request uninstalls the bundle from the framework.
	    
	    The request can return the following status codes:
	    </para>
	  
	    <itemizedlist>
      		<listitem>
			  <para>204 (NO CONTENT): the request was received and valid and the framework has uninstalled the bundle.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to uninstall. The body of the message is a <xref linkend="service.rest-bundle.exception.representation" xrefstyle="template:%t"/> describing the reason why the uninstallation did not succeed.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
	    </itemizedlist>        
      </section>
           
    </section>
 
 
   <section>
      <title>Bundle State Resource</title>
	 
	  <para>
      The bundle state resource represents the internal state of an installed bundle qualified through its bundle id. 
      It supports the GET and PUT requests. 
	  </para>

      <section>
        <title>GET</title>
        <para>
	    The GET request retrieves a <xref linkend="service.rest-bundle.state.representation" xrefstyle="template:%t"/> from the REST management service. 
	    The request can return the following status codes:
	    </para>
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle state representation.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
 	  <section>
        <title>PUT</title>
        <para>
	    The PUT request sets the target state for the given bundle. This can, e.g., be state=32 for transitioning the bundle to started, or state=4 for stopping the bundle and transitioning it to resolved. 
	    The body of the request needs to be a <xref linkend="service.rest-bundle.state.representation" xrefstyle="template:%t"/>. Not all state transitions are valid.

		The body of the response is the new <xref linkend="service.rest-bundle.state.representation" xrefstyle="template:%t"/>.
	    The request can return the following status codes:
	    </para>
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request was received and valid. The framework has performed a state change and the new bundle state is contained in the body.</para>
      		</listitem>
  			<listitem>
        	  <para>400 (BAD REQUEST): the REST management service received a BundleException when trying to perform the state transition. 
        	  							The body of the message is a <xref linkend="service.rest-bundle.exception.representation" xrefstyle="template:%t"/> describing the reason why the operation did not succeed.</para>
      		</listitem>      		
      		<listitem>
        	  <para>402 (PRECONDITION FAILED): the requested target state is not reachable from the current bundle state.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		      		
      		<listitem>
        	  <para>415 (UNSUPPORTED MEDIA TYPE): the request had a media type that is not supported by the REST management service.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>

   <section>
      <title>Bundle Header Resource</title>
	 
	  <para>
      The bundle header resource represents manifest header of a bundle which is qualified by its bundle id. It can only be read through a GET request. 
      </para>

      <section>
        <title>GET</title>
        
        <para>
	    The GET request retrieves a <xref linkend="service.rest-bundle.header.representation" xrefstyle="template:%t"/> from the REST management service. 
	    The request can return the following status codes:
	    </para>
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle header representation.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>
 
     <section>
      <title>Bundle Startlevel Resource</title>
	 
	  <para>
      The bundle startlevel resource represents the start level of the bundle qualified by its bundle id. 
      It supports the GET and PUT requests. 
      </para>

      <section>
        <title>GET</title>
	    The GET request retrieves a <xref linkend="service.rest-bundle.startlevel.representation" xrefstyle="template:%t"/> from the REST management service. 
	    The request can return the following status codes:
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request has been served successfully and the body of the response is a bundle startlevel representation.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		
      		<listitem>
        	  <para>406 (NOT ACCEPTABLE): the REST management service does not support any of the requested representations.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    
 	  <section>
        <title>PUT</title>
        <para>
	    The PUT request sets the target bundle startlevel. The body of the request needs to be a <xref linkend="service.rest-bundle.startlevel.representation" xrefstyle="template:%t"/>. 

	    The request can return the following status codes:
	    </para>
	  
	    <itemizedlist>
      		<listitem>
			  <para>200 (OK): the request was received and valid. The REST management service has changed the bundle startlevel according to the target value. 
			  						The body of the response is the new bundle startlevel representation.</para>
      		</listitem>
      		<listitem>
        	  <para>400 (BAD REQUEST):  either the target startlevel state involved invalid values, e.g., a startlevel smaller or equal to zero and the REST 
        	  							management service got an IllegalArgumentException, or the REST management service received a BundleException when trying to perform the startlevel change. 
        	  							In the latter case, the body of the message is a <xref linkend="service.rest-bundle.exception.representation" xrefstyle="template:%t"/> describing the reason why the operation did not succeed.</para>
      		</listitem>
      		<listitem>
			  <para>404 (NOT FOUND): there is not bundle with the given bundle id.</para>
      		</listitem>            		      		
      		<listitem>
        	  <para>415 (UNSUPPORTED MEDIA TYPE): the request had a media type that is not supported by the REST management service.</para>
      		</listitem>
	    </itemizedlist>        
      </section>
    </section>
 
 	<section>
      <title>Services Resource</title>
      
      <para>
      
      
      </para>
      
 	</section>
 	
 	<section>
      <title>Service Resource</title>
 	</section>
 	
 
 </section>


 <section>
    <title>Representations</title>

 	<section xml:id="service.rest-bundle.representation">
      	<title>Bundle Representation</title>
		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.bundle+json</code></para>
	    	<programlisting>	 
{
   "id":0,
   "lastModified":1314999275542,
   "location":"System Bundle",
   "state":32,
   "symbolicName":"org.eclipse.osgi",
   "version":"3.7.0.v20110613"
}			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.bundle+xml</code></para>
			<programlisting><![CDATA[
<bundle>
   <id>0</id>
   <lastModified>1314999275542</lastModified>
   <location>System Bundle</location>
   <state>32</state>
   <symbolicName>org.eclipse.osgi</symbolicName>
   <version>3.7.0.v20110613</version>
</bundle>
			]]></programlisting>    
		</section>
 	</section>

 	<section>
      <title>Bundles Representations</title>
      	<section xml:id="service.rest-bundle.list.representation">
      		<title>Bundle List Representation</title>
		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.bundles+json</code></para>
	    	<programlisting>	 
{
   [bundleURI, bundleURI, ..., bundleURI]
}			
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.bundles+xml</code></para>
			<programlisting><![CDATA[
<bundles>
   <uri>bundleURI</uri>
   <uri>bundleURI</uri>
   ...
   <uri>bundleURI</uri>
</bundles>			
			]]></programlisting>    
		</section>
      	</section>

      	<section xml:id="service.rest-bundle.representations.list.representation">
      		<title>Bundle Representations List Representation</title>
		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.bundles.representations+json</code></para>
	    	<programlisting>	 
[BUNDLE REPRESENTATION, BUNDLE REPRESENTATION, …, BUNDLE REPRESENTATION]		
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.bundles.representations+xml</code></para>
			<programlisting><![CDATA[
<bundles>
   BUNDLE REPRESENTATION
   BUNDLE REPRESENTATION
   ...
   BUNDLE REPRESENTATION
</bundles>		
			]]></programlisting>    
		</section>
      	</section>		
 	</section>

 	<section xml:id="service.bundle.state.representation">
      <title>Bundle State Representation</title>
		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.bundlestate+json</code></para>
	    	<programlisting>	 
{
   "state":32
   “options”:1
}	
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.bundlestate+xml</code></para>
			<programlisting><![CDATA[
<bundleState>
   <state>32</state>
   <options>1</options>
</bundleState>
			]]></programlisting>    
		</section>
 	</section>

 	<section xml:id="service.rest-bundle.header.representation">
      <title>Bundle Header Representation</title>

		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.bundleheader+json</code></para>
	    	<programlisting>	 
{
   key:value,
   key:value,
   ...
   key:value
}
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.bundleheader+xml</code></para>
			<programlisting><![CDATA[
<bundleHeader>
   <entry key="key" value="value"/>
   <entry key="key" value="value"/>
   ...
   <entry key="key" value="value"/>
<bundleHeader>
			]]></programlisting>    
		</section>

 	</section>

	<section xml:id="service.rest-framework.startlevel.representation">
		<title>Framework Startlevel Representation</title>

		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.frameworkstartlevel+json</code></para>
	    	<programlisting>	 
{
    "startLevel":6,
    "initialBundleStartLevel":4
}
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.frameworkstartlevel+xml</code></para>
			<programlisting><![CDATA[
<frameworkStartLevel>
    <startLevel>6</startLevel>
    <initialBundleStartLevel>4</initialBundleStartLevel>
</frameworkStartLevel>
			]]></programlisting>    
		</section>
	</section>

 	<section xml:id="service.rest-bundle.startlevel.representation">
      <title>Bundle Startlevel Representation</title>

		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.bundlestartlevel+json</code></para>
	    	<programlisting>	 
{
   "startLevel":6

   “activationPolicyUsed”:true
   “persistentlyStarted”:false
}
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.bundlestartlevel+xml</code></para>
			<programlisting><![CDATA[
<bundleStartLevel>
    <startLevel>6</startLevel>

    <activationPolicyUsed>true</actiovationPolicyUsed>
    <persistentlyStarted>false</persistentlyStarted>
</bundleStartLevel>
			]]></programlisting>    
		</section>
		
 	</section>

 	<section xml:id="service.rest-service.representation">
      <title>Service Representation</title>

		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.service+json</code></para>
	    	<programlisting>	 
{
   properties:
   {
      key:value,
      key:value,
      ...
      key:value
   },
   "bundle":bundleURI,
   "usingBundles":[bundleURI, bundleURI, … bundleURI],
}
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.service+xml</code></para>
			<programlisting><![CDATA[
<service>
   <properties>
      <entry key=”key” value=”value”/>
      <entry key=”key” value=”value”/>
      ...
      <entry key=”key” value=”value”/>
   </properties>
   <bundle>bundleURI</bundle>
   <usingBundles>
      <bundle>bundleURI</bundle>
      <bundle>bundleURI</bundle>
      ...
      <bundle>bundleURI</bundle>
   </usingBundles>
</service>
			]]></programlisting>    
		</section>
 	</section>

 	<section>
      <title>Services Representations</title>
 
 		<section xml:id="service.rest-service.list.representation">
 			<title>Service List Representation</title>
		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.services+json</code></para>
	    	<programlisting>	 
{
   [serviceURI, serviceURI, ..., serviceURI]
}
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.service+xml</code></para>
			<programlisting><![CDATA[
<service>
   <properties>
      <entry key=”key” value=”value”/>
      <entry key=”key” value=”value”/>
      ...
      <entry key=”key” value=”value”/>
   </properties>
   <bundle>bundleURI</bundle>
   <usingBundles>
      <bundle>bundleURI</bundle>
      <bundle>bundleURI</bundle>
      ...
      <bundle>bundleURI</bundle>
   </usingBundles>
</service>
			]]></programlisting>    
		</section>      
 		</section>     
 		
 		<section xml:id="service.rest-service.representations.list.representation">
 			<title>Service Representations List Representation</title>
		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: org.osgi.services.representations+json</code></para>
	    	<programlisting>	 
[SERVICE REPRESENTATION, SERVICE REPRESENTATION, …, SERVICE REPRESENTATION]
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.services.representations+xml</code></para>
			<programlisting><![CDATA[
<services>
   SERVICE REPRESENTATION
   SERVICE REPRESENTATION
   ...
   SERVICE REPRESENTATION
</services>
			]]></programlisting>    
		</section>      
 		</section>      				
 	</section>

 	<section xml:id="service.rest-bundle.exception.representation">
      <title>Bundle Exception Representation</title>
      
      		<section>
	    	<title>JSON</title>
			<para><code>Content-Type: application/org.osgi.bundleexception+json</code></para>
	    	<programlisting>	 
{
   “typecode”: 5,
   “message”: “BundleException: Bundle activation error”
}
			</programlisting>
		</section>

		<section>
	    	<title>XML</title>
			<para><code>Content-Type: application/org.osgi.bundleexception+xml</code></para>
			<programlisting><![CDATA[
<bundleexception>
   <typecode>5</typecode>
   <message>BundleException: Bundle activation error</message>
</bundleexception>
			]]></programlisting>    
		</section>
 	</section>

 </section>

  <section>
    <title>Extending the REST Management Service</title>
      
  </section>
  
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.rest.xml"/>
  
  <section>
    <title>Java Client API</title>
      
  </section>

	<xi:include href="../../generated/javadoc/docbook/org.osgi.service.rest.client.xml"/>

	<section>
      <title>Javascript Client API</title>
  </section>

  <section>
    <title>XML Schema</title>

    <para>A wide code example (for use with XML Schema). Note that the XML schema is typically included 
        through <code>xi:include</code> tags rather than embedded directly.</para>

    <programlisting role="pgwide">&lt;?xml version="1.0"?&gt;
&lt;!-- XML Schema --&gt;
&lt;top&gt; ... &lt;/top&gt;</programlisting>

  </section>
  
  <section>
    <title>Security</title>
    
    <para>
    	Like any externally visible management interface, the REST interface exposes privileged operations and hence requires access control. Since REST builds upon the HTTP(s) protocol,  authentication mechanisms and  encryption can be applied the same way as usually done for web servers: they can be layered below the REST protocol. E.g., confidentiality of the transmitted commands can be ensured by using HTTPS as the underlying transport. Authentication can be added by requiring, e.g., basic authentication prior to accepting a REST command.  
	The REST interface should only be implemented by a trusted bundle. Implementations of this specification require all admin permissions and all service permissions.
    </para>
  </section>

 

  
<!-- 
  <section>
    <title>Domain A</title>

    <para>This is body text.</para>

    <itemizedlist>
      <listitem>
        <para>Bulleted</para>
      </listitem>

      <listitem>
        <para>Bulleted</para>
      </listitem>
      
      <listitem>
        <para>Bulleted</para>
      </listitem>
    </itemizedlist>

    <para>Numbered lists:</para>

    <orderedlist>
      <listitem>
        <para>Numbered</para>
      </listitem>
      
      <listitem>
        <para>Numbered</para>
      </listitem>
      
      <listitem>
        <para>Numbered</para>
      </listitem>
    </orderedlist> 

    <para>An <emphasis>emphasized</emphasis> term.</para>

    <para>The following is a Program Listing style:</para>

    <programlisting>Some s = (Some) context.getService(ref);</programlisting>

    <para>A remark:</para>

    <para>
      <remark>This is a discussion remark</remark>
    </para>

    <section>
      <title>Subsection</title>
      <section>
        <title>Sub-subsection</title>
      </section>
    </section>
  </section>
  
  <section>
    <title>Domain B</title>
  </section>
  
  <section>
    <title>Domain C</title>
  </section>
  
  <section>
    <title>Life Cycle</title>
  </section>
  
  <section>
    <title>Error Handling</title>
  </section>
  
  <section>
    <title>Events</title>
    
    <section>
      <title>Domain Events</title>
    </section>

    <section>
      <title>Event Admin Mapping</title>
    </section>
  </section>
  
  <section>
    <title>Class Loading</title>
  </section>
  
  <section>
    <title>Data Transfer Objects</title>
  </section>
 
   -->
  

  
 

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title>Framework Module Layer</title>OSGi
      Core, Chapter 3 Module Layer</bibliomixed>

      <bibliomixed><title>XML Schema Part 2: Data types
      Second Edition</title>http://www.w3.org/TR/xmlschema-2/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
