<?xml version="1.0" encoding="utf-8"?>
<chapter label="707"
         revision="$Id$"
         version="5" xml:id="util.converter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Converter Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.util.converter-version"
    linkend="org.osgi.util.converter"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>
    
    <para>Data conversion is an inherent part of writing 
     software in a type safe language. In Java, converting strings to proper types or to convert one type to a more 
     convenient type is often done manually. Any errors are then handled inline.</para>
      
	<para>In release 6, the OSGi specifications introduced Data Transfer Objects (DTOs). DTOs are public objects without 
	open generics that only contain public instance fields based on simple types, arrays, and collections. 
	In many ways DTOs can be used as an alternative to Java beans. 
	Java beans are hiding their fields and provide access methods which separates 
	the contract (the public interface) from the internal usage. Though this model has advantages in technical applications 
    it tends to add overhead. DTOs unify the specification with the data since the data is what is already public 
	when it is sent to another process or serialized.</para>
	
    <para>This specification defines the OSGi Converter that makes it easy to convert many types to other types, including scalars,
    Collections, Maps, Beans, Interfaces and DTOs without having to write the boilerplate conversion code. The converter
    strictly adheres to the rules specified in this chapter. Converters can also be customized using converter
    builders. 
    </para>
  </section> 
  
  <section>
    <title>Entities</title>
    
    <para>The following entities are used in this specification:</para>
    
    <itemizedlist>
      <listitem>
        <para><emphasis>Converter</emphasis> - a converter can perform conversion operations.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Standard Converter</emphasis> - a converter implementation that follows this specification.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Converter Builder</emphasis> - can create customized converters by specifying rules for specific conversions.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Source</emphasis> - the object to be converted.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Target</emphasis> - the target of the conversion.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Source Type</emphasis> - the type of the source to be converted.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Target Type</emphasis> - the desired type of the conversion target.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Rule</emphasis> - a rule is used to customize the behavior of the converter.</para>
      </listitem>
    </itemizedlist>
    <remark>Add entity diagram</remark>
  </section> 

  <section>
    <title>Standard Converter</title>
    
    <para>The Standard Converter is a converter that follows precisely what is described in this 
    specification. It converts objects to the desired target type if a suitable conversion is 
    available. 
    An instance can be obtained by creating a <code>new StandardConverter()</code>.</para> 
    
    <para>Some example conversions:
    <programlisting>Converter c = new StandardConverter();
    
// Scalar conversions    
MyEnum e = c.convert(MyOtherEnum.BLUE).to(MyEnum.class);
BigDecimal bd = c.convert(12345).to(BigDecimal.class);

// Aggregate conversions
List&lt;String&gt; ls = Arrays.asList("978", "142", "-99");
long[] la = c.convert(ls).to(long[].class);

// Map conversions
Map someMap = new HashMap();
someMap.put("timeout", "700"); 
MyInterface mi = c.convert(someMap).to(MyInterface.class);
int t = mi.timeout(); // t=700</programlisting>
    </para>
    
  </section> 

  <section>
    <title>Conversions</title>
    
    <para>For scalars, conversions are only performed when the target type is not compatible
    with the source type. For example, when requesting to convert a <code>java.math.BigDecimal</code> to a 
    <code>java.lang.Number</code> the big decimal is simply used as-is as this type is assignable to the 
    requested target type.</para>
    
    <para>In the case of Aggregates (Arrays and Collections) and Map-like structures a new object is always returned, 
    even if the target type is compatible with the source type. This copy can be owned and optionally further
    modified by the caller.</para>
    
    <section>
      <title>Generics</title>
      <para>When converting to a target type with generic type parameters it is necessary to capture 
      the generic type parameters to instruct the converter to produce the correct parameterized type.
      This can be achieved with the <code>TypeReference</code> based APIs, for example:
      <programlisting>Converter c = new StandardConverter();
List&lt;Long&gt; list = c.convert("123").to(new TypeReference&lt;List&lt;Long&gt;&gt;());
// list will contain the Long value 123L</programlisting></para>
    </section>
    
    <section>
      <title>Scalars</title>
          
      <section>
        <title>Direct conversion between scalars</title>
        
        <para>Direct conversion between certain scalar types is supported. Except conversions from
        <code>Map.Entry</code>, see <xref linkend="util.converter-special.cases.map.entry"/>,
        all other 
        scalar types conversion is done by converting to <code>String</code> and then converting 
        into the target type.
        </para>
  
        <table pgwide="1" rowheader="firstcol">
          <title>Direct conversions between scalar types</title>
          
          <tgroup cols="5">
            <colspec colnum="1" colwidth="0.5*"/>
            <colspec colnum="5" colwidth="0.5*"/>
           
            <thead>
              <row>
                <entry><subscript>to</subscript> \ <superscript>from</superscript></entry>
                <entry>Boolean</entry>
                <entry>Character</entry>
                <entry><emphasis>Number</emphasis></entry>
                <entry><code>null</code></entry>
              </row>
            </thead>
            
            <tbody>
              <row>
                <entry>boolean</entry>
                <entry><code>v.booleanValue()</code></entry>
                <entry><code>v.charValue() != 0</code></entry>
                <entry><code>v.</code><emphasis>number</emphasis><code>Value() != 0</code></entry>
                <entry><code>false</code></entry>
              </row>
            
              <row>
                <entry>char</entry>
                <entry><code>v.booleanValue() ? 1 : 0</code></entry>
                <entry><code>v.charValue()</code></entry>
                <entry><code>(char) v.intValue()</code></entry>
                <entry>0</entry>
              </row>
              
              <row>
                <entry><emphasis>number</emphasis></entry>
                <entry><code>v.booleanValue() ? 1 : 0</code></entry>
                <entry><code>(</code><emphasis>number</emphasis><code>) v.charValue()</code></entry>
                <entry><code>v.</code><emphasis>number</emphasis><code>Value()</code></entry>
                <entry>0</entry>
              </row>
            </tbody>
          </tgroup>
        </table>   
        
        <para>Where conversion is done from corresponding primitive types, these types
        are boxed before converting. Where conversion is done to corresponding boxed types,
        the types are boxed after converting.</para>     

        <para>Direct conversions between Enums and ints and between Dates and longs are also supported, see
        the sections below.</para>
      </section>
  
      <section>
        <title>Conversion to String</title>
        
        <para>Conversion to <code>String</code> is done by calling <code>toString()</code> on the object to
        be converted. In the case of a primitive type, the object is boxed first.</para>
        
        <para>A <code>null</code> object results in a <code>null</code> String value.</para>
        
        <para><emphasis>Exception: </emphasis><code>java.util.Calendar</code> and 
        <code>java.util.Date</code> are converted to <code>String</code> as described in 
        <xref linkend="util.converter-date.calendar"/>.
        </para>
      </section>
      
      <section>
        <title>Conversion from String</title>
        
        <para>Conversion from String is done by attempting to invoke the following methods, in order: 
        
          <orderedlist>
            <listitem>
              <para><code>public static valueOf(String s)</code></para>
            </listitem>
  
            <listitem>
              <para>public constructor taking a single <code>String</code> argument.</para>
            </listitem>
          </orderedlist>
          
          Some scalars have special rules for converting from String
          values. See below.
        </para>
      </section>
      <section xml:id="util.converter-special.cases.string">
        <title>Special cases converting from String</title>
        <table>
          <title>Special cases converting scalars from String</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry><code>char / Character</code></entry>
                <entry><code>v.length() > 0 ? v.charAt(0) : 0</code></entry>
              </row>
                
              <row>
                <entry><code>java.time.Duration</code></entry>
                <entry><code>Duration.parse(v)</code></entry>
              </row>

              <row>
                <entry><code>java.time.Instant</code></entry>
                <entry><code>Instant.parse(v)</code></entry>
              </row>

              <row>
                <entry><code>java.time.LocalDate</code></entry>
                <entry><code>LocalDate.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.LocalDateTime</code></entry>
                <entry><code>LocalDateTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.LocalTime</code></entry>
                <entry><code>LocalTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.MonthDay</code></entry>
                <entry><code>MonthDay.parse(v)</code></entry>
              </row>

              <row>
                <entry><code>java.time.OffsetTime</code></entry>
                <entry><code>OffsetTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.OffsetDateTime</code></entry>
                <entry><code>OffsetDateTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.Year</code></entry>
                <entry><code>Year.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.YearMonth</code></entry>
                <entry><code>YearMonth.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.ZonedDateTime</code></entry>
                <entry><code>ZonedDateTime.parse(v)</code></entry>
              </row>
              
              <row>
                <entry><code>java.util.Calendar</code></entry>
                <entry>See <xref linkend="util.converter-date.calendar"/>.</entry>
              </row>

              <row>
                <entry><code>java.util.Date</code></entry>
                <entry><code>Date.from(Instant.parse(v))</code></entry>
              </row>
              
              <row>
                <entry><code>java.util.UUID</code></entry>
                <entry><code>UUID.fromString(v)</code></entry>
              </row>              
  
              <row>
                <entry><code>java.util.regex.Pattern</code></entry>
                <entry><code>Pattern.compile(v)</code></entry>
              </row>
            </tbody>   
          </tgroup>
        </table>
        
        <para><emphasis>Note to implementors:</emphasis> some of the classes mentioned in table 
        <xref linkend="util.converter-special.cases.string"/> are introduced 
        in Java 8. However, a converter implementation does not need to depend on 
        Java 8 in order to function. An implementation of the converter
        specification could determine its Java runtime dynamically and 
        handle classes in this table depending on availability.</para>
      </section>
      
      <section xml:id="util.converter-date.calendar">
        <title>Date and Calendar</title>
        <para>A <code>java.util.Date</code> instance is converted to 
        a <code>long</code> value by calling <code>Date.getTime()</code>.
        Converting a <code>long</code> into a <code>java.util.Date</code>
        is done by calling <code>new Date(long)</code>.</para> 
        
        <para>Converting a Date to a String is done by converting it to an 
        <code>Instant</code> and then calling <code>Instant.toString()</code>.
        This will produce a ISO-8601 UTC date/time string in the following 
        format: <code>2011-12-03T10:15:30Z</code>. Converting a String to
        a date is done by calling <code>Date.from(Instant.parse(v))</code>
        which can convert this ISO-8601 format back into a Date.
        </para>
          
        <para>Conversions from Calendar objects are done by converting the Calendar
        to a Date via <code>getTime()</code> first, and then converting the resulting Date to the 
        target type. Convertions to a Calendar object are done by converting the
        source to a Date object with the desired time (always in UTC) and then setting the 
        time in the Calendar object via <code>setTime()</code>.</para>
      </section>
        
        <section>
          <title>Enums</title>
          <para>Conversions to Enum types are supported as follows.</para>
          <table>
            <title>Converting to Enum types</title>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>Source</entry>
                  <entry>Method</entry>
                </row>
              </thead>         
              <tbody>
              <row>
                <entry><emphasis>Number</emphasis></entry>
                <entry><emphasis>EnumType</emphasis><code>.values()[v.intValue()]</code></entry>
              </row>
                
              <row>
                <entry><code>String</code></entry>
                <entry><emphasis>EnumType</emphasis><code>.valueOf(v)</code>. If this does not produce a result
                a case-insensitive lookup is done for a matching enum value.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>  
        <para>
        Primitives are boxed before conversion is done.
          Other source types are converted to String before converting to Enum.</para>
      </section>
        
      <section xml:id="util.converter-special.cases.map.entry">
        <title>Map.Entry</title>
        <para>Conversion of <code>Map.Entry&lt;K,V&gt;</code> to a target scalar type is done by evaluating the compatibility of the 
        target type with both the key and the value in the entry and then using the best match. This is done in the following order:
        <orderedlist>
          <listitem><para>If one of the key or value is the same as the target type, then this is used.
          If both are the same, the key is used.</para></listitem>
          <listitem><para>If one of the key or value type is assignable to the target type, then this is used.
          If both are assignable the most specific is used. If key and value type are both equally assignable
          the key is used.</para></listitem>
          <listitem><para>If one of the key or value is of type <code>String</code>, this is used and converted to the target type. If both are of type <code>String</code> the key is used.</para></listitem>
          <listitem><para>If none of the above matches the key is converted into a <code>String</code> and this
          value is then converted to the target type.</para></listitem>
        </orderedlist>
        </para>
                        
        <para>Conversion to <code>Map.Entry</code> from a scalar is not supported.</para>
      </section>
      </section>
    
    <section>
      <title>Aggregates</title>
  
      <para>Aggregates represent Collections and Arrays, including Lists, Sets, Queues and 
      Double-ended Queues (<emphasis>Deques</emphasis>).</para>
      
      <section>
        <title>Converting to a scalar</title>
        <para>
        If a Collection or array needs to be converted to a scalar,
        the first element is taken and converted into the target type. Example:
        <programlisting>Converter converter = new StandardConverter();
String s = converter.convert(new int[] {1,2}).to(String.class)); // s="1"</programlisting></para>
        
        <para>If the collection or array has no elements, the <code>null</code> value is
        used to convert into the target type.</para>
        
        <para><emphasis>Note: </emphasis>deviations from this mechanism can be achieved by using an 
          <xref linkend="org.osgi.util.converter.ConverterBuilder" xrefstyle="hyperlink"/>. For example:
          <programlisting>// Use an ConverterBuilder to create a customized converter          
ConverterBuilder cb = converter.newConverterBuilder();
cb.rule(new Rule&lt;int[], String&gt;(v -&gt; Arrays.stream(v).
    mapToObj(Integer::toString).collect(Collectors.joining(","))) {});
cb.rule(new Rule&lt;String, int[]&gt;(v -&gt; Arrays.stream(v.split(",")).
    mapToInt(Integer::parseInt).toArray()) {});
Converter c = cb.build();

String s2 = c.convert(new int[] {1,2}).to(String.class)); // s2="1,2"
int[] sa = c.convert("1,2").to(String[].class); // sa={1,2}</programlisting> 
        </para>
      </section>
      
      <section>
        <title>Converting to an Array or Collection</title>
        <para>When converting to a <code>java.util.Collection</code>, <code>java.util.List</code> 
          or <code>java.util.Set</code> the converter will return a live view 
          over the backing object that changes when the backing object changes. The live view can be 
          prevented by providing the 
          <xref linkend="org.osgi.util.converter.Converting.copy--" xrefstyle="hyperlink"/>
          modifier. When converting to other collection types or arrays a copy is always produced.
        </para>

        <para>In all cases the object returned is a separate instance that
          can be owned by the client. Once the client modifies
          the returned object a live view will stop reflecting changes to the backing object.</para>
        
        <table>
          <title>Collection / Array target creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry><code>Collection</code>, <code>List</code> or <code>Set</code></entry>
                <entry>A live view over the backing object is created, changes to the backing
                object will be reflected, unless the view object is modified by the client.</entry>
              </row>
              <row>
                <entry>Other Collection interface</entry>
                <entry>A mutable implementation is created. For example, if the target type is 
                <code>java.util.Queue</code> then the converter can create a
                <code>java.util.LinkedList</code>. When converting to a <code>java.util.Set</code>
                the converter must choose a set implementation that preserves iteration order.</entry>
              </row>
              <row>
                <entry>Collection concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> on the 
                provided type. For example if the target type is <code>ArrayDeque</code> then the 
                converter creates a target object by calling <code>ArrayDeque.class.newInstance()</code>.
                The converter may choose to use a call a well-known constructor to optimize the
                creation of the collection.</entry>
              </row>
              <row>
                <entry><code>T[]</code></entry>
                <entry>A new array is created via <code>Array.newInstance(Class&lt;T&gt; cls, int x)</code> where 
                <code>x</code> is the required size of the target collection.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Before inserting values into the resulting collection/array they are converted to the desired
        target type. In the case of arrays this is the type of the array. When inserting into a 
        Collection generic type information about the target type can be made available by using the
        <xref linkend="org.osgi.util.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.util.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. If no type information is available, source elements are inserted into the target 
        aggregate as-is without further treatment.</para>
        
        <para>Example: 
        to convert an array of <code>String</code>s into a list of <code>Integer</code>s:
        
        <programlisting>List&lt;Integer&gt; result =
  converter.convert(Arrays.asList("1","2","3")).
    to(new TypeReference&lt;List&lt;Integer&gt;&gt;() {});</programlisting>
    
        The following example converts an array of <code>int</code>s into a set of <code>Double</code>s. Note that
        the resulting set must preserve the same iteration order as the original array:
        
        <programlisting>Set&lt;Double&gt; result =
  converter.convert(new int[] {2,3,2,1}).
    to(new TypeReference&lt;Set&lt;Double&gt;&gt;() {})
// result is 2,3,1</programlisting>
        
        Values are inserted in the target Collection/array as follows:
        
          <itemizedlist>
            <listitem>
              <para>If the source object is <code>null</code>, an empty collection/array is produced.</para>
            </listitem>
            
            <listitem>
              <para>If the source is not a Collection, Array or Map-like structure (as described
              in <xref linkend="util.converter-special.cases.maps"/>) a target with
              a single element is produced. The value is first converted into the desired
              target type, if the target type is known.</para>
            </listitem>
            
            <listitem>
              <para>If the source is a Collection or Array, then each of its elements is converted 
              into desired target type, if known, before inserting. Elements are inserted into the target
              collection in their normal iteration order.</para>
            </listitem>
            
            <listitem>
              <para>If the source is a Map-like structure (as described
              in <xref linkend="util.converter-special.cases.maps"/>) then <code>Map.Entry</code> elements 
              are obtained from it via <code>Map.entrySet()</code>. 
              Each <code>Map.Entry</code> element is then converted into the target type 
              as described in <xref linkend="util.converter-special.cases.map.entry"/> 
              before inserting in the
              target.</para>
            </listitem>
          </itemizedlist>         
        </para>
      </section>
      
      <section>
        <title>Converting to maps</title>
        <para>Conversion to a map-like structure from an aggregate is not supported by the Standard Converter.</para>
      </section>
    </section>
    
    <section xml:id="util.converter-special.cases.maps">
      <title>Maps, Interfaces, Java Beans, DTOs and Annotations</title>
      <para>Entities that can hold multiple key-value pairs are all treated in a similar way. These entities
      include Maps, Dictionaries, Interfaces, Java Beans, Annotations and OSGi DTOs. We call these 
      <emphasis>map-like</emphasis> types.
      Additionally objects that provide a map view via <code>getProperties()</code>
      are supported.</para>
      
      <para>When converting between map-like types, a <code>Map</code> can be used as intermediary.
      When converting to other, non <emphasis>map-like</emphasis>, structures 
      the map is converted into an iteration order preserving collection of
      <code>Map.Entry</code> values which in turn is converted into the target type.
      </para>
      
      <section>
        <title>Converting to a Map</title>
        <para>When converting a map-like structure to a <code>java.util.Map</code>
          the converter will return a live view 
          over the backing object that changes when the backing object changes. The live view can be 
          prevented by providing the 
          <xref linkend="org.osgi.util.converter.Converting.copy--" xrefstyle="hyperlink"/>
          modifier. When converting to other map types a copy is always produced.
        </para>

        <para>In all cases the object returned is a separate instance that
          can be owned by the client. When the client modifies
          the returned object a live view will stop reflecting changes to the backing object.</para>
        <table>
          <title>Map target creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry><code>java.util.Map</code></entry>
                <entry>A map view over the backing object is created, changes to the backing
                object will be reflected in the map, unless the map is modified by the client.</entry>
              </row>
              <row>
                <entry>Other Map interface</entry>
                <entry>A mutable implementation is created. For example, if the target type is 
                <code>ConcurrentNavigableMap</code> then the implementation can create a 
                <code>ConcurrentSkipListMap</code>.</entry>
              </row>
              <row>
                <entry>Map concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> 
                on the provided type. For example if the target type is <code>HashMap</code> 
                then the converter creates a target object by calling
                <code>HashMap.class.newInstance()</code>.
                The converter may choose to use a call a well-known constructor to optimize the
                creation of the map.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>When converting from a map-like object to a <code>Map</code> or sub-type, each key-value pair 
        in the source map is converted to desired types of the target map
        using the generic information if available.
        
        Map type information for the target type can be made available by using the
        <xref linkend="org.osgi.util.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.util.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. If no type information is available, key-value pairs are provided in the map as-is.    
        </para>      
      </section>
      
      <section>
        <title>Dictionary</title>
        <para>Converting between a map and a <code>Dictionary</code> is done by iterating over the
        source and inserting the key value pairs in the target, converting them to the requested target 
        type, if known. As with other generic types, target type information for Dictionaries can be provided
        via a <xref linkend="org.osgi.util.converter.TypeReference" xrefstyle="hyperlink"/>.</para> 
      </section>
      
      <section>
        <title>Interface</title>
        <para>Converting a map-like structure into an interface can be a useful way to give a map of 
        untyped data a typed API. The converter synthesizes an interface instance to represent the
        conversion.</para>
        
        <para>Note that converting to annotations provides similar functionality as converting to 
        interfaces with the added benefit of being able to specify default values in the annotation code.
        </para>
        <section>
        <title>Converting to an Interface</title>
        <para>When converting into an interface the converter will create a dynamic proxy to 
        implement the interface. The name of the method returning the value should match the key 
        of the map entry, taking into account the mapping rules specified in 
        <xref linkend="util.converter-key.mapping"/>.
        The key of the map may need to be converted into a <code>String</code> first.</para>
        
        <para>Conversion is done <emphasis>on demand</emphasis>: only when the method on 
        the interface is actually invoked. This avoids conversion errors on methods 
        for which the information is missing or cannot be converted, but which the caller 
        does not require.</para>
        
        <para>Note that the converter will not copy the source map when converting to an interface
        so any changes to the source map will be reflected live to the proxy. 
        The proxy cannot cache the conversions.</para>
        
        <para>Interfaces can provide methods for default values by providing a single-argument method
        override in addition to the no-arg method matching the key name. If the type of the default
        does not match the target type it is converted first. 
        For example:  
        <programlisting>interface Config {
  int my_value(); // no default
  int my_value(int defVal);
  int my_value(String defVal); // String value is automatically converted to int
  boolean my_other_value();
}

// Usage
Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;(); // an example map
myMap.put("my.other.value", "true");
Config cfg = converter.convert(myMap).to(Config.class);
int val = cfg.my_value(17); // if not set then use 17
boolean val2 = cfg.my_other_value(); // val2=true
</programlisting>
        Default values are used when the key is not present in the map for the method. If a key is 
        present with a <code>null</code> value, then <code>null</code> is taken as the value and 
        converted to the target type.</para>
        
        <para>If no default is specified and a requested value is not present in the map,
        a <code>ConversionException</code> is thrown.</para>
      </section>
      <section>
        <title>Converting from an Interface</title>
        <para>
        Whether a conversion source object is an interface is determined dynamically, taking the
        <xref linkend="util.converter-priorities"/> into account. When an object implements multiple interfaces
        by default the first interface from these that has no-arg methods 
        is taken as the source type. To select a different
        interface use the 
        <xref linkend="org.osgi.util.converter.Converting.sourceAs-Class-" xrefstyle="hyperlink"/> modifier:
        <programlisting>  Map m = converter.convert(myMultiInterface).
      sourceAs(MyInterfaceB.class).to(Map.class);</programlisting>
        </para>
      </section>
              
      </section>
      
      <section>
        <title>Annotation</title>
        <para>Conversion to and from annotations behaves similar to 
        interface conversion with the added capability of specifying a default in the annotation definition.
        </para>
        
        <para>When converting to an annotation type, the converter will return an instance of the requested
        annotation class. As with interfaces, values are only obtained from the conversion source when the 
        annotation method is actually called. If the requested value is not available, the default as 
        specified in the annotation class is used. If no default is specified a <code>ConversionException</code>
        is thrown.
        </para>
        
        <para>Similar to interfaces, conversions to and from annotations also follow the
        <xref linkend="util.converter-key.mapping"/> for annotation element names.
        Below a few examples of conversions to an annotation:
        <programlisting>@interface MyAnnotation {
  String[] args() default {"arg1", "arg2"};
}

// Will set sa={"args1", "arg2"}
String[] sa = converter.convert(new HashMap()).to(MyAnnotation.class).args();

// Will set a={"x", "y", "z"}
Map m = Collections.singletonMap("args", new String [] {"x", "y", "z"});
String[] a = converter.convert(m).to(MyAnnotation.class).args();

// Will set a1={}
Map m1 = Collections.singletonMap("args", null)
String[] a1 = converter.convert(m1).to(MyAnnotation.class).args();

// Will set a2={""}
Map m2 = Collections.singletonMap("args", "")
String[] a2 = converter.convert(m2).to(MyAnnotation.class).args();

// Will set a3={","}
Map m3 = Collections.singletonMap("args", ",")
String[] a3 = converter.convert(m3).to(MyAnnotation.class).args();</programlisting>
        </para>
      </section>
      
      <section>
        <title>Java Beans</title>
        <para>Java Beans are concrete (non-abstract) classes that follow the Java Bean naming convention. They provide 
        public getters and setters to
        access their properties and have a public no-arg constructor. When converting from a Java Bean introspection
        is used to find the read accessors. A read accessor must have no arguments and a non-<code>void</code> return 
        value. The method name must start with <code>get</code> followed by a capitalized property name, 
        for example <code>getSize()</code> provides access to the property <code>size</code>. 
        For <code>boolean/Boolean</code> properties a prefix of <code>is</code>
        is also permitted. Properties names follow the <xref linkend="util.converter-key.mapping"/>.</para> 
        <para>
        For the converter to consider an object as a Java Bean the 
          <xref linkend="org.osgi.util.converter.Converting.sourceAsBean--" xrefstyle="hyperlink"/> or
          <xref linkend="org.osgi.util.converter.Converting.targetAsBean--" xrefstyle="hyperlink"/>
        modifier needs to be invoked, for example:
          <programlisting>  Map m = converter.convert(myBean).sourceAsBean().to(Map.class);</programlisting></para>
        <para>When converting to a Java Bean, the bean is constructed eagerly. All available properties
            are set in the bean using the bean's write accessors, that is, public setters methods with a single argument. 
            All methods of the bean class itself and its 
            super classes are considered. 
            When a property cannot be converted this will cause a 
            <xref linkend="org.osgi.util.converter.ConversionException" xrefstyle="hyperlink"/>.
            If a property is missing in the source, the property will not be set in the bean.
            </para>
        <para><emphasis>Note: </emphasis>access via indexed bean properties is not supported.
        </para>
        <para><emphasis>Note: </emphasis>the <code>getClass()</code> method of the <code>java.lang.Object</code>
        class is not considered an accessor.
        </para>
      </section>
      
      <section>
        <title>DTOs</title>
        <para>
        DTOs are classes with public non-static fields and no methods other than the ones provided by the 
        <code>java.lang.Object class</code>. OSGi DTOs extend the <code>org.osgi.dto.DTO</code> class,
        however objects following the DTO rules that do not extend the DTO
        class are also treated as DTOs. 
        DTOs may have static fields, or non-public instance fields. These are ignored by the converter.</para>

        <para>When converting to a DTO, the converter attempts to find fields that match the key of each 
        entry in the source map and then converts the value to the field type before assigning it. They key of
        the map entries may need to be converted into a String first. Keys are mapped according to 
        <xref linkend="util.converter-key.mapping"/>.</para>
        
        <para>The DTO is constructed using its no-arg constructor and each public 
        field is filled with data from the source eagerly. Fields present in the DTO but missing in the source
        object not be set. 
        </para>
      </section>
      
      <section>
        <title>Types with getProperties()</title>
        
        <para>The converter uses reflection to find a <code>java.util.Map getProperties()</code> or 
        <code>java.util.Dictionary getProperties()</code> method on the source type to obtain a map view over
        the source object. This map view is used to convert the source object to a map-like structure.</para>
        
        <para><emphasis>Note: </emphasis>this mechanism can only be used to convert <emphasis>to</emphasis> another type. 
        The reverse is not supported</para>
      </section>

      <section>
        <title>Other types</title>
        <para>
          When converting from a map-like structure to other types, the map is first converted in an ordered collection 
          of <code>Map.Entry</code> objects. This collection is then converted to the target type using the rules specified
          in <xref linkend="util.converter-special.cases.map.entry"/>.
        </para>
      </section> 

      <section xml:id="util.converter-key.mapping">
        <title>Key Mapping</title>

        <para>When converting to or from a Java type, the key is derived from the method name.
        Certain common property name characters, such as full stop (<code>'.'
        \u002E</code>) and hyphen-minus (<code>'-' \u002D</code>) are not
        valid in Java identifiers. So the name of a method must be converted
        to its corresponding key name as follows:<itemizedlist>
            <listitem>
              <para>A single dollar sign (<code>'$' \u0024</code>) is removed
              unless it is followed by:<itemizedlist>
                  <listitem>
                    <para>A low line (<code>'_' \u005F</code>) and a dollar
                    sign in which case the three consecutive characters
                    (<code>"$_$"</code>) are converted to a single
                    hyphen-minus (<code>'-' \u002D</code>).</para>
                  </listitem>

                  <listitem>
                    <para>Another dollar sign in which case the two
                    consecutive dollar signs (<code>"$$"</code>) are converted
                    to a single dollar sign.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <para>A single low line (<code>'_' \u005F</code>) is converted
              into a full stop (<code>'.' \u002E</code>) unless is it followed
              by another low line in which case the two consecutive low lines
              (<code>"__"</code>) are converted to a single low line.</para>
            </listitem>

            <listitem>
              <para>All other characters are unchanged.</para>
            </listitem>

            <listitem>
              <para>If type contains a static final
              <code>PREFIX_</code> field whose value is a compile-time
              constant String, then the key name is prefixed with the
              value of the <code>PREFIX_</code> field. <code>PREFIX_</code>
              fields in super-classes or super-interfaces are ignored.</para>
            </listitem>
          </itemizedlist></para>

        <para><xref
        linkend="util.converter-key.name.mapping"/> contains
        some name mapping examples.</para>

        <table xml:id="util.converter-key.name.mapping">
          <title>Component Property Name Mapping Examples</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="1*"/>

            <colspec colnum="2" colwidth="1*"/>

            <thead>
              <row>
                <entry>Component Property Type Method Name</entry>

                <entry>Component Property Name</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>myProperty143</code></entry>

                <entry><code>myProperty143</code></entry>
              </row>

              <row>
                <entry><code>$new</code></entry>

                <entry><code>new</code></entry>
              </row>

              <row>
                <entry><code>my$$prop</code></entry>

                <entry><code>my$prop</code></entry>
              </row>

              <row>
                <entry><code>dot_prop</code></entry>

                <entry><code>dot.prop</code></entry>
              </row>

              <row>
                <entry><code>_secret</code></entry>

                <entry><code>.secret</code></entry>
              </row>

              <row>
                <entry><code>another__prop</code></entry>

                <entry><code>another_prop</code></entry>
              </row>

              <row>
                <entry><code>three___prop</code></entry>

                <entry><code>three_.prop</code></entry>
              </row>

              <row>
                <entry><code>four_$__prop</code></entry>

                <entry><code>four._prop</code></entry>
              </row>

              <row>
                <entry><code>five_$_prop</code></entry>

                <entry><code>five..prop</code></entry>
              </row>

              <row>
                <entry><code>six$_$prop</code></entry>

                <entry><code>six-prop</code></entry>
              </row>

              <row>
                <entry><code>seven$$_$prop</code></entry>

                <entry><code>seven$.prop</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Below is an example of using the <code>PREFIX_</code> constant 
        in an annotation. This example assumes a Declarative
        Services component that is configured with the following configuration 
        property:
        <programlisting>"com.acme.config.type"="MULTI"</programlisting> 
        When Declarative Services invokes the <code>@Activate</code>
        method the configuration provided is already converted into the
        <code>MyAnnotation</code> 
        annotation. This example shows also how the annotation can be converted
        back into a Map.
        <programlisting>  public @interface MyAnnotation {
    static final String PREFIX_ = "com.acme.config.";

    enum Type { SINGLE, MULTI };

    long timeout() default 1000L;
    Type type() default Type.SINGLE;
  }
  
  @Activate
  private void activate(MyAnnotation ann) {
    long configuredTimeout = ann.timeout(); // value will be 1000
    MyAnnotation.Type configuredType = ann.type(); // value will be MULTI
    
    Map m = converter.convert(ann).to(Map.class);
    // m will contain:
    // { "com.acme.config.timeout" = 1000L,
    //   "com.acme.config.type" = MULTI }
  }</programlisting></para>

        <para>However, if the type is a
        <emphasis>single-element annotation</emphasis>, see 9.7.3 in <xref
        linkend="util.converter-jls.ref"/>, then the key name for the
        <code>value</code> method is derived from the name of the component
        property type rather than the name of the method. In this case, the
        simple name of the component property type, that is, the name of the
        class without any package name or outer class name, if the component
        property type is an inner class, must be converted to the
        <code>value</code> method's property name as follows:<itemizedlist>
            <listitem>
              <para>When a lower case character is followed by an upper case
              character, a full stop (<code>'.' \u002E</code>) is inserted
              between them.</para>
            </listitem>

            <listitem>
              <para>Each uppercase character is converted to lower
              case.</para>
            </listitem>

            <listitem>
              <para>All other characters are unchanged.</para>
            </listitem>

            <listitem>
              <para>If the type contains a static final
              <code>PREFIX_</code> field whose value is a compile-time
              constant String, then the key name is prefixed with the
              value of the <code>PREFIX_</code> field. <code>PREFIX_</code>
              fields in super-classes or super-interfaces are ignored.</para>
            </listitem>
          </itemizedlist></para>

        <para><xref linkend="util.converter-single.element.name.mapping"/>
        contains some mapping examples for the <code>value</code>
        method.</para>

        <table xml:id="util.converter-single.element.name.mapping">
          <title>Single-Element Annotaton Mapping Examples for
          <code>value</code> Method</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="1*"/>

            <colspec colnum="2" colwidth="1*"/>

            <thead>
              <row>
                <entry>Type Name</entry>

                <entry><code>value</code> Method Component Property
                Name</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>ServiceRanking</code></entry>

                <entry><code>service.ranking</code></entry>
              </row>

              <row>
                <entry><code>Some_Name</code></entry>

                <entry><code>some_name</code></entry>
              </row>

              <row>
                <entry><code>OSGiProperty</code></entry>

                <entry><code>osgi.property</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

    </section>
    
    <section xml:id="util.converter-priorities">
      <title>Priority</title>
      
      <para>In case multiple conversion rules match, the rule with the highest priority is used, where 1 is the highest overall priority.
        <table>
          <title>Conversion rule priority</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Priority</entry>
                <entry>Rule</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>annotation</entry>
              </row>

              <row>
                <entry>2</entry>
                <entry>DTO</entry>
              </row>
              
              <row>
                <entry>3</entry>
                <entry><emphasis>entity.</emphasis><code>getProperties()</code></entry>
              </row>
              
              <row>
                <entry>4</entry>
                <entry>interface (including Collections and Maps)</entry>
              </row>

              <row>
                <entry>5</entry>
                <entry>scalar</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        The priority rules defined in the above table can be overridden by using 
        <xref linkend="org.osgi.util.converter.Converting.sourceAs-Class-" xrefstyle="hyperlink"/>,
        <xref linkend="org.osgi.util.converter.Converting.sourceAsBean--" xrefstyle="hyperlink"/> 
        or         
        <xref linkend="org.osgi.util.converter.Converting.sourceAsDTO--" xrefstyle="hyperlink"/> 
        to indicate as what class the source or target object should be treated. 
        Consider the following example:
        <programlisting>  Class MyClass implements MyInterface {
    @Override
    long amount() { // returns amount }

    Map getProperties() { // returns properties }
  }</programlisting>
        MyClass both implements an interface and provides the <code>getProperties()</code> method.
        According to the priority rules, the default behaviour is that when converting an instance of this class 
        to a map-like structure, the <code>getProperties()</code> result is used as the source. 
        To instruct the converter to view the object as an interface instead use <code>as()</code>
        <programlisting>  Map m = converter.convert(myClassObj).
      sourceAs(MyInterface.class).to(Map.class);
  long l = m.get("amount");</programlisting>
      </para>
      
      <section>
        <title>Specifying target types</title>
        <para>The converter always produces an instance of the target type as specified with the
        <xref linkend="org.osgi.util.converter.Converting.to-Class-" xrefstyle="hyperlink"/>,
        <xref linkend="org.osgi.util.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> or
        <xref linkend="org.osgi.util.converter.Converting.to-Type-" xrefstyle="hyperlink"/> method.
        In some cases the converter needs to be instructed how to treat this target object.
        For example the desired target type might extend a DTO class adding some methods and behavior to 
        the DTO. As this target class now has methods, the converter will not recognize it as a DTO.
        The <xref linkend="org.osgi.util.converter.Converting.targetAs-Class-" xrefstyle="hyperlink"/>,
        <xref linkend="org.osgi.util.converter.Converting.targetAsBean--" xrefstyle="hyperlink"/>
        and <xref linkend="org.osgi.util.converter.Converting.targetAsDTO--" xrefstyle="hyperlink"/>
        methods can be used here to instruct the converter to treat the target object as certain type
        of object to guide the conversion.
        </para>
        
        <para>For example:
        <programlisting>  MyExtendedDTO med = converter.convert(someMap).
      targetAsDTO().to(MyExtendedDTO.class)</programlisting>
        In this example the converter will return a <code>MyExtendedDTO</code> instance
        but it will treat is as a <code>MyDTO</code> type.      
      </para>
      </section>
    </section>
    
    <section>
      <title>Conversion failures</title>
      <para>...</para>
    </section>
  </section>

  <section>
    <title>Customizing converters</title>
    <para>The Standard Converter applies the conversion rules described in this specification. While this is 
    useful for many applications, in some cases deviations from the specified rules may be necessary.
    This can be done by creating a customized converter. 
    Customized converters are created based on an existing converter with additional rules specified that
    override the existing converter's behavior.
    A customized converter is created through a 
    <xref linkend="org.osgi.util.converter.ConverterBuilder" xrefstyle="hyperlink"/>. Customized converters
    implement the converter interface and as such can be used to create further customized converters.
    Converters are immutable, once created they cannot be modified, so they can be freely shared without the 
    risk of modification to the converter's behavior.
    </para>
    
    <para>For example converting a Date to a String may require a specific format. The default 
    <code>Date</code> to <code>String</code> conversion produces a String in the format 
    <code>yyyy-MM-ddTHH:mm:ss.SSSZ</code>. If we want to produce a String in the format 
    <code>yyMMddHHmmssZ</code> instead a custom converter can be applied:
    <programlisting>SimpleDateFormat sdf = new SimpleDateFormat("yyMMddHHmmssZ");
ConverterBuilder cb = new StandardConverter().newConverterBuilder();
cb.rule(new TypeRule&lt;&gt;(Date.class, String.class, sdf::format));
Converter c = cb.build();
    
String s = c.convert(new Date()).to(String.class);
// s = "160923102853+0100" or similar</programlisting>
    Custom conversions are also applied to embedded conversions that are part of a map or other enclosing object:
    <programlisting>class MyBean {
  //... fields ommitted
  boolean getEnabled() { /* ... */ }
  void setEnabled(boolean e)  { /* ... */ }
  Date getStartDate() { /* ... */ }
  void setStartDate(Date d) { /* ... */ }
}

MyBean mb = new MyBean();
mb.setStartDate(new Date());
mb.setEnabled(true);

Map&lt;String, String&gt; m = c.convert(mb).sourceAsBean().
    to(new TypeReference&lt;Map&lt;String, String&gt;&gt;(){});
String en = m.get("enabled");   // en = "true"
String sd = m.get("startDate"); // sd = "160923102853+0100" or similar</programlisting>
	Rules will only be invoked when an actual object needs to be converted, <code>null</code> values are never 
	handed to converter rules. A converter rule can return <code>null</code> however to indicate that it cannot handle
	the conversion, in which case next applicable rule is handed the conversion. If none of the registered rules for the 
    current converter can handle the conversion, the parent converter object is asked to convert the value.
	Since custom converters can be the basis for further custom converters, a chain of custom converters can be 
	created where a custom converter rule can either decide to handle the conversion, or it can delegate
	back to the next converter in the chain by returning <code>null</code> if it wishes to do so.
	</para>
  
    <section>
    <title>Catchall rules</title>
    <para>It is also possible to register converter rules which are invoked for every conversion with the 
    <xref linkend="org.osgi.util.converter.ConverterBuilder.rule-ConvertFunction-" xrefstyle="hyperlink"/>
    method. When multiple rules are registered, they are evaluated in the order of registration,
    until a rule indicates that it can handle a conversion by returning a non-<code>null</code> value. 
    Rules targeting
    specific types are evaluated before catchall rules.
    </para>
    </section>
  </section>

  <section>
    <title>Security</title>
    <para>...</para>
  </section> 

  <xi:include href="../../generated/javadoc/docbook/org.osgi.util.converter.xml"/>
 
  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>

      <bibliomixed xml:id="util.converter-jls.ref"><title>The Java Language
      Specification, Java SE 8
      Edition</title>https://docs.oracle.com/javase/specs/jls/se8/html/index.html</bibliomixed>
    </bibliolist>
  </section>
</chapter>
