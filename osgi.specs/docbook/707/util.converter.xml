<?xml version="1.0" encoding="utf-8"?>
<chapter label="707"
         revision="$Id$"
         version="5" xml:id="service.converter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Converter Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.util.converter-version"
    linkend="org.osgi.util.converter"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>
    
    <para>Data conversion is an inherent part of writing 
     software in a type safe language. In Java, converting strings to proper types or to convert one type to a more 
     convenient type is often done manually. Any errors are then handled inline.</para>
      
	<para>In release 6, the OSGi specifications introduced Data Transfer Objects (DTOs). DTOs are public objects without 
	open generics that only contain public instance fields based on simple types, arrays, and collections. 
	In many ways DTOs can be used as an alternative to Java beans. 
	Java beans are hiding their fields and provide access methods which separates 
	the contract (the public interface) from the internal usage. Though this model has advantages in technical applications 
    it tends to add overhead. DTOs unify the specification with the data since the data is what is already public 
	when it is sent to another process or serialized.</para>
	
    <para>This specification defines the OSGi Converter that makes it easy to convert many types to other types, including scalars,
    Collections, Maps, Beans, Interfaces and DTOs without having to write the boilerplate conversion code. The converter
    strictly adheres to the rule specified in this chapter. Converters can also be customized using converter
    builders. 
    </para>
  </section> 
  
  <section>
    <title>Entities</title>
    
    <para>The following entities are used in this specification</para>
    
    <itemizedlist>
      <listitem>
        <para><emphasis>Converter</emphasis> - a converter implements the Converter interface and can perform conversion operations.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Standard Converter</emphasis> - a converter implementation that follows this specification.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Converter Builder</emphasis> - can create customized converters by specifying rules for specific conversions.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Source</emphasis> - the object to be converted.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Result</emphasis> - the result of the conversion.</para>
      </listitem>
    
      <listitem>
        <para><emphasis>Source Type</emphasis> - the type of the source to be converted.</para>
      </listitem>
      
      <listitem>
        <para><emphasis>Target Type</emphasis> - the desired type of the conversion result.</para>
      </listitem>
    </itemizedlist>
    <remark>Add entity diagram</remark>
  </section> 

  <section>
    <title>Standard Converter</title>
    
    <para>The Standard Converter is a converter that follows precisely what is described in this 
    specification. It converts objects to the desired target type if a suitable conversion is 
    available. 
    An instance can be obtained by creating a <code>new StandardConverter()</code>.</para> 
    
    <para>Some example conversions:
    <programlisting>Converter c = new StandardConverter();
    
// Scalar conversions    
MyEnum e = c.convert(MyOtherEnum.BLUE).to(MyEnum.class);
BigDecimal bd = c.convert(12345).to(BigDecimal.class);

// Aggregate conversions
List&lt;String&gt; ls = Arrays.asList("978", "142", "-99");
long[] la = c.convert(ls).to(long[].class);

// Map conversions
Map someMap = new HashMap();
someMap.put("timeout", "700"); 
MyInterface mi = c.convert(someMap).to(MyInterface.class);
int t = mi.timeout(); // t=700</programlisting>
    </para>
    
  </section> 

  <section>
    <title>Conversions</title>
    
    <para>For scalars, conversions are only performed when the target type is not compatible
    with the source type. For example, when requesting to convert a <code>java.math.BigDecimal</code> to a 
    <code>java.lang.Number</code> the big decimal is simply used as-is as this type is assignable to the 
    requested target type.</para>
    
    <para>In the case of Aggregates (Arrays and Collections) and Map-like structures a new object is always returned, 
    even if the target type is compatible with the source type. This copy can be owned and optionally further
    modified by the caller.</para>
    
    <section>
      <title>Generics</title>
      <para>When converting to a target type with generic type parameters it is necessary to capture 
      the generic type parameters to instruct the converter to produce the correct parameterized type.
      This can be achieved with the <code>TypeReference</code> based APIs, for example:
      <programlisting>Converter c = new StandardConverter();
List&lt;Long&gt; list = c.convert("123").to(new TypeReference&lt;List&lt;Long&gt;&gt;());
// list will contain the Long value 123L</programlisting></para>
    </section>
    
    <section>
      <title>Scalars</title>
          
      <section>
        <title>Direct conversion between scalars</title>
        
        <para>Direct conversion between certain scalar types is supported. For all other 
        scalar types conversion is done by converting to <code>String</code> and then converting 
        into the target type.
        </para>
  
        <table pgwide="1" rowheader="firstcol">
          <title>Direct conversions between scalar types</title>
          
          <tgroup cols="5">
            <colspec colnum="1" colwidth="0.5*"/>
            <colspec colnum="5" colwidth="0.5*"/>
           
            <thead>
              <row>
                <entry><subscript>to</subscript> \ <superscript>from</superscript></entry>
                <entry>Boolean</entry>
                <entry>Character</entry>
                <entry><emphasis>Number</emphasis></entry>
                <entry><code>null</code></entry>
              </row>
            </thead>
            
            <tbody>
              <row>
                <entry>boolean</entry>
                <entry><code>v.booleanValue()</code></entry>
                <entry><code>v.charValue() != 0</code></entry>
                <entry><code>v.</code><emphasis>number</emphasis><code>Value() != 0</code></entry>
                <entry><code>false</code></entry>
              </row>
            
              <row>
                <entry>char</entry>
                <entry><code>v.booleanValue() ? 1 : 0</code></entry>
                <entry><code>v.charValue()</code></entry>
                <entry><code>(char) v.intValue()</code></entry>
                <entry>0</entry>
              </row>
              
              <row>
                <entry><emphasis>number</emphasis></entry>
                <entry><code>v.booleanValue() ? 1 : 0</code></entry>
                <entry><code>(</code><emphasis>number</emphasis><code>) v.charValue()</code></entry>
                <entry><code>v.</code><emphasis>number</emphasis><code>Value()</code></entry>
                <entry>0</entry>
              </row>
            </tbody>
          </tgroup>
        </table>   
        
        <para>Where conversion is done from corresponding primitive types, these types
        are boxed before converting. Where conversion is done to corresponding boxed types,
        the types are boxed after converting.</para>     

        <para>Direct conversions between Enums and ints and between Dates and longs are also supported, see
        the sections below.</para>
      </section>
  
      <section>
        <title>Conversion to String</title>
        
        <para>Conversion to <code>String</code> is done by calling <code>toString()</code> on the object to
        be converted. In the case of a primitive type, the object is boxed first.</para>
        
        <para>A <code>null</code> object results in a <code>null</code> String value.</para>
        
        <para><emphasis>Exception: </emphasis><code>java.util.Calendar</code> and 
        <code>java.util.Date</code> are converted to <code>String</code> as described in 
        <xref linkend="service.converter.date.calendar"/>.
        </para>
      </section>
      
      <section>
        <title>Conversion from String</title>
        
        <para>Conversion from String is done by attempting to invoke the following methods, in order: 
        
          <orderedlist>
            <listitem>
              <para><code>public static valueOf(String s)</code></para>
            </listitem>
  
            <listitem>
              <para>public constructor taking a single <code>String</code> argument.</para>
            </listitem>
          </orderedlist>
          
          Some scalars have special rules for converting from String
          values. See below.
        </para>
      </section>
      <section xml:id="service.converter.special.cases.string">
        <title>Special cases converting from String</title>
        <remark>Removed from the following table: Boolean.parseBoolean(v) and Number.parseNumber(v) as both Boolean and Number have static valueOf()</remark>
        <table>
          <title>Special cases converting scalars from String</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry><code>char / Character</code></entry>
                <entry><code>v.length() > 0 ? v.charAt(0) : 0</code></entry>
              </row>
                
              <row>
                <entry><code>java.time.Instant</code></entry>
                <entry><code>Instant.parse(v)</code></entry>
              </row>

              <row>
                <entry><code>java.time.LocalDate</code></entry>
                <entry><code>LocalDate.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.LocalDateTime</code></entry>
                <entry><code>LocalDateTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.LocalTime</code></entry>
                <entry><code>LocalTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.OffsetTime</code></entry>
                <entry><code>OffsetTime.parse(v)</code></entry>
              </row>
  
              <row>
                <entry><code>java.time.ZonedDateTime</code></entry>
                <entry><code>ZonedDateTime.parse(v)</code></entry>
              </row>
              
              <row>
                <entry><code>java.util.Calendar</code></entry>
                <entry>See <xref linkend="service.converter.date.calendar"/>.</entry>
              </row>

              <row>
                <entry><code>java.util.Date</code></entry>
                <entry><code>Date.from(Instant.parse(v))</code></entry>
              </row>
              
              <row>
                <entry><code>java.util.UUID</code></entry>
                <entry><code>UUID.fromString(v)</code></entry>
              </row>              
  
              <row>
                <entry><code>java.util.regex.Pattern</code></entry>
                <entry><code>Pattern.compile(v)</code></entry>
              </row>
            </tbody>   
          </tgroup>
        </table>
      </section>
      
      <section xml:id="service.converter.date.calendar">
        <title>Date and Calendar</title>
        <para>A <code>java.util.Date</code> instance is converted to 
        a <code>long</code> value by calling <code>Date.getTime()</code>.
        Converting a <code>long</code> into a <code>java.util.Date</code>
        is done by calling <code>new Date(long)</code>.</para> 
        
        <para>Converting a Date to a String is done by converting it to an 
        <code>Instant</code> and then calling <code>Instant.toString()</code>.
        This will produce a ISO-8601 UTC date/time string in the following 
        format: <code>2011-12-03T10:15:30Z</code>. Converting a String to
        a date is done by calling <code>Date.from(Instant.parse(v))</code>
        which can convert this ISO-8601 format back into a Date.
        </para>
          
        <para>Conversions from Calendar objects are done by converting the Calendar
        to a Date via <code>getTime()</code> first, and then converting the resulting Date to the 
        target type. Convertions to a Calendar object are done by converting the
        source to a Date object with the desired time (always in UTC) and then setting the 
        time in the Calendar object via <code>setTime()</code>.</para>
      </section>
        
        <section>
          <title>Enums</title>
          <para>Conversions to Enum types are supported as follows.</para>
          <table>
            <title>Converting to Enum types</title>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>Source</entry>
                  <entry>Method</entry>
                </row>
              </thead>         
              <tbody>
              <row>
                <entry><emphasis>Number</emphasis></entry>
                <entry><emphasis>EnumType</emphasis><code>.values()[v.intValue()]</code></entry>
              </row>
                
              <row>
                <entry><code>String</code></entry>
                <entry><emphasis>EnumType</emphasis><code>.valueOf(v)</code>. If no matching enum value can be found
                a case-insensitive lookup is done for a matching enum value.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>  
        <para>
        Primitives are boxed before conversion is done.
          Other source types are converted to String before converting to Enum.</para>
      </section>
        
      <section xml:id="service.converter.special.cases.map.entry">
        <title>Map.Entry</title>
        <para>Conversion of <code>Map.Entry&lt;K,V&gt;</code> to a target scalar type is done by evaluating the compatibility of the 
        target type with both the key and the value in the entry and then using the best match. This is done in the following order:
        <orderedlist>
          <listitem><para>If one of the key or value is the same as the target type, then this is used.
          If both are the same, the key is used.</para></listitem>
          <listitem><para>If one of the key or value type is assignable to the target type, then this is used.
          If both are assignable the most specific is used. If key and value type are both equally assignable
          the key is used.</para></listitem>
          <listitem><para>If one of the key or value is of type <code>String</code>, this is used and converted to the target type. If both are of type <code>String</code> the key is used.</para></listitem>
          <listitem><para>If none of the above matches the key is converted into a <code>String</code> and this
          value is then converted to the target type.</para></listitem>
        </orderedlist>
        </para>
                        
        <para>Conversion to <code>Map.Entry</code> from a scalar is not supported.</para>
      </section>
      </section>
    
    <section>
      <title>Aggregates</title>
  
      <para>Aggregates represent Collections and Arrays, including Lists and Sets.</para>
      
      <section>
        <title>Converting to a scalar</title>
        <para>
        If a Collection or array needs to be converted to a scalar,
        the first element is taken and converted into the target type. Example:
        <programlisting>Converter converter = new StandardConverter();
String s = converter.convert(new int[] {1,2}).to(String.class)); // s="1"</programlisting></para>
        
        <para>If the collection or array has no elements, the <code>null</code> value is
        used to convert into the target type.</para>
        
        <para><emphasis>Note: </emphasis>deviations from this mechanism can be achieved by using an 
          <xref linkend="org.osgi.util.converter.ConverterBuilder" xrefstyle="hyperlink"/>. For example:
          <programlisting>// Use an ConverterBuilder to create a customized converter          
ConverterBuilder cb = converter.newConverterBuilder();
cb.rule(int[].class, String.class,
  v -> Arrays.stream(v).mapToObj(Integer::toString).collect(Collectors.joining(",")),
  v -> Arrays.stream(v.split(",")).mapToInt(Integer::parseInt).toArray());
Converter c = cb.build();

String s2 = c.convert(new int[] {1,2}).to(String.class)); // s2="1,2"
int[] sa = c.convert("1,2").to(String[].class); // sa={1,2}</programlisting> 
        </para>
      </section>
      
      <section>
        <title>Converting to an Array or Collection</title>
        <para>When converting to a <code>java.util.Collection</code>, <code>java.util.List</code> 
          or <code>java.util.Set</code> the converter will return a live view 
          over the backing object that changes when the backing object changes. The live view can be 
          prevented by providing the 
          <xref linkend="org.osgi.util.converter.Converting.copy--" xrefstyle="hyperlink"/>
          modifier. When converting to other collection types or arrays a copy is always produced.
        </para>

        <para>In all cases the object returned is a separate instance that
          can be owned by the client. Once the client modifies
          the returned object it will stop reflecting changes to the backing object.</para>
        
        <table>
          <title>Collection / Array result creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry><code>Collection</code>, <code>List</code> or <code>Set</code></entry>
                <entry>A live view over the backing object is created, changes to the backing
                object will be reflected, unless the view object is modified by the client.</entry>
              </row>
              <row>
                <entry>Other Collection interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>java.util.List</code> then the converter can create a
                <code>java.util.ArrayList</code>. When converting to a <code>java.util.Set</code>
                the converter must choose a set implementation that preserves iteration order.</entry>
              </row>
              <row>
                <entry>Collection concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> on the 
                provided type. For example if the target type is <code>LinkedList</code> then the 
                converter creates a target object by calling <code>LinkedList.class.newInstance()</code>.
                The converter may choose to use a call a well-known constructor to optimize the
                creation of the collection.</entry>
              </row>
              <row>
                <entry><code>T[]</code></entry>
                <entry>A new array is created via <code>Array.newInstance(Class&lt;T&gt; cls, int x)</code> where 
                <code>x</code> is the required size of the target collection.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>Before inserting values into the resulting collection/array they are converted to the desired
        target type. In the case of arrays this is the type of the array. When inserting into a 
        Collection generic type information about the target type can be made available by using the
        <xref linkend="org.osgi.util.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.util.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. If no type information is available, source elements are inserted into the target 
        aggregate as-is.</para>
        
        <para>Example: 
        to convert an array of <code>String</code>s into a list of <code>Integer</code>s:
        
        <programlisting>List&lt;Integer&gt; result =
  converter.convert(Arrays.asList("1","2","3")).
    to(new TypeReference&lt;List&lt;Integer&gt;&gt;() {});</programlisting>
    
        The following example converts an array of <code>int</code>s into a set of <code>Double</code>s. Note that
        the resulting set must preserve the same iteration order as the original array:
        
        <programlisting>Set&lt;Double&gt; result =
  converter.convert(new int[] {3,2,1}).
    to(new TypeReference&lt;Set&lt;Double&gt;&gt;() {})</programlisting>
        
        Values are inserted in the resulting Collection/array as follows:
        
          <itemizedlist>
            <listitem>
              <para>If the source object is <code>null</code>, an empty collection/array is produced.</para>
            </listitem>
            
            <listitem>
              <para>If the value is not a Collection, Array or Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) a result with
              a single element is produced. The value is first converted into the desired
              target type, if the target type is known.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Collection or Array, then each of its elements is converted 
              into desired target type, if known, before inserting. Elements are inserted into the target
              collection in their normal iteration order.</para>
            </listitem>
            
            <listitem>
              <para>If the value is a Map-like structure (as described
              in <xref linkend="service.converter.special.cases.maps"/>) then <code>Map.Entry</code> elements 
              are obtained from it via <code>Map.entrySet()</code>. 
              Each <code>Map.Entry</code> element is then converted into the target type before inserting in the
              result.</para>
            </listitem>
          </itemizedlist>         
        </para>
      </section>
      
      <section>
        <title>Converting to maps</title>
        <para>Conversion to a map-like structure from an aggregate is not supported by the Standard Converter.</para>
      </section>
    </section>
    
    <section xml:id="service.converter.special.cases.maps">
      <title>Maps, Interfaces, Java Beans, DTOs and Annotations</title>
      <para>Entities that can hold multiple key-value pairs are all treated in a similar way. These entities
      include Maps, Dictionaries, Interfaces, Java Beans, Annotations and OSGi DTOs. We call these 
      <emphasis>map-like</emphasis> types.
      Additionally objects that provide a map view
      are supported.</para>
      
      <para>When converting between map-like types, a <code>Map</code> can be used as intermediary.
      When converting to other structures, the map is converted into an iteration order preserving collection of
      <code>Map.Entry</code> values which in turn is converted into the target type.
      </para>
      
      <section>
        <title>Converting to a Map</title>
        <para>When converting to a <code>java.util.Map</code>
          the converter will return a live view 
          over the backing object that changes when the backing object changes. The live view can be 
          prevented by providing the 
          <xref linkend="org.osgi.util.converter.Converting.copy--" xrefstyle="hyperlink"/>
          modifier. When converting to other collection types or arrays a copy is always produced.
        </para>

        <para>In all cases the object returned is a separate instance that
          can be owned by the client. When the client modifies
          the returned object it will stop reflecting changes to the backing object.</para>
        <table>
          <title>Map result creation</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="0.5*"/>
            <thead>
              <row>
                <entry>Target</entry>
                <entry>Method</entry>
              </row>
            </thead>         
            <tbody>
              <row>
                <entry><code>java.util.Map</code></entry>
                <entry>A map view over the backing object is created, changes to the backing
                object will be reflected in the map, unless the map is modified by the client.</entry>
              </row>
              <row>
                <entry>Other Map interface</entry>
                <entry>A mutable implementation is created. E.g. if the target type is 
                <code>ConcurrentNavigableMap</code> then the implementation can create a 
                <code>ConcurrentSkipListMap</code>.</entry>
              </row>
              <row>
                <entry>Map concrete type</entry>
                <entry>A new instance is created by calling <code>Class.newInstance()</code> 
                on the provided type. For example if the target type is <code>HashMap</code> 
                then the converter creates a target object by calling
                <code>HashMap.class.newInstance()</code>.
                The converter may choose to use a call a well-known constructor to optimize the
                creation of the map.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        
        <para>When converting from a map-like object to a <code>Map</code> or sub-type, each key-value pair 
        in the source map is converted to desired types of the target map
        using the generic information if available.
        
        Map type information for the target type can be made available by using the
        <xref linkend="org.osgi.util.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> 
        or <xref linkend="org.osgi.util.converter.Converting.to-Type-" xrefstyle="hyperlink"/> 
        methods. If no type information is available, key-value pairs are inserted into the map as-is.    
        </para>      
      </section>
      
      <section>
        <title>Dictionary</title>
        <para>Converting between a map and a <code>Dictionary</code> is done by iterating over the
        source and inserting the key value pairs in the result, converting them to the requested target 
        type, if known. As with other generic types, target type information for Dictionaries can be provided
        via a <xref linkend="org.osgi.util.converter.TypeReference" xrefstyle="hyperlink"/>.</para> 
      </section>
      
      <section>
        <title>Interface</title>
        <para>Converting a map-like structure into an interface can be a useful way to give a map of 
        untyped data a typed API. The converter synthesizes an interface instance to represent the
        conversion.</para>
        
        <para>Note that converting to annotations provides similar functionality as converting to 
        interfaces with the added benefit of being able to specify default values in the annotation code.
        </para>
        <section>
        <title>Converting to an Interface</title>
        <para>When converting into an interface the converter will create a dynamic proxy to 
        implement the interface. The name of the method returning the value should match the key 
        of the map entry, taking into account the mapping rules specified in 
        <xref linkend="service.converter-key.mapping"/>.
        The key of the map may need to be converted into a <code>String</code> first.</para>
        
        <para>Conversion is done <emphasis>on demand</emphasis>: only when the method on 
        the interface is actually invoked. This avoids conversion errors on methods 
        for which the information is missing or cannot be converted, but which the caller 
        does not require.</para>
        
        <para>Note that the converter will not copy the source map when converting to an interface
        so any changes to the source map will be reflected live to the proxy. 
        The proxy cannot cache the conversion results.</para>
        
        <para>Interfaces can provide methods for default values by providing a single-argument method
        override in addition to the no-arg method matching the key name. If the type of the default
        does not match the target type it is converted first. 
        For example:  
        <programlisting>interface Config {
  int my_value(); // no default
  int my_value(int defVal);
  int my_value(String defVal); // String value is automatically converted to int
  boolean my_other_value();
}

// Usage
Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;(); // an example map
myMap.put("my.other.value", "true");
Config cfg = converter.convert(myMap).to(Config.class);
int val = cfg.my_value(17); // if not set then use 17
boolean val2 = cfg.my_other_value(); // val2=true
</programlisting>
        Default values are used when the key is not present in the map for the method. If a key is 
        present with a <code>null</code> value, then <code>null</code> is taken as the value and 
        converted to the target type.</para>
        
        <para>If no default is specified and a requested value is not present in the map,
        a <code>ConversionException</code> is thrown.</para>
      </section>
      <section>
        <title>Converting from an Interface</title>
        <para>
        Whether a conversion source object is an interface is determined dynamically, taking the
        <xref linkend="service.converter-priorities"/> into account. When an object implements multiple interfaces
        by default the first interface from these is taken as the source type. To select a different
        interface use the 
        <xref linkend="org.osgi.util.converter.Converting.sourceAs-Class-" xrefstyle="hyperlink"/> modifier:
        <programlisting>  Map m = converter.convert(myMultiInterface).
      sourceAs(MyInterfaceB.class).to(Map.class);</programlisting>
        </para>
      </section>
      <section xml:id="service.converter-key.mapping">
        <title>Key Mapping</title>

        <para>The key name is derived from the method name.
        Certain common property name characters, such as full stop (<code>'.'
        \u002E</code>) are not valid in Java identifiers. So the name of a
        method must be converted to its corresponding property name as
        follows:<itemizedlist>
            <listitem>
              <para>A single dollar sign (<code>'$' \u0024</code>) is removed
              unless it is followed by another dollar sign in which case the
              two consecutive dollar signs (<code>"$$"</code>) are converted
              to a single dollar sign.</para>
            </listitem>

            <listitem>
              <para>A single low line (<code>'_' \u005F</code>) is converted
              into a full stop (<code>'.' \u002E</code>) unless is it followed
              by another low line in which case the two consecutive low lines
              (<code>"__"</code>) are converted to a single low line.</para>
            </listitem>

            <listitem>
              <para>All other characters are unchanged.</para>
            </listitem>
          </itemizedlist></para>

        <para><xref
        linkend="service.converter-key.name.mapping"/> contains
        some name mapping examples.</para>

        <table xml:id="service.converter-key.name.mapping">
          <title>Name Mapping Examples</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="1*"/>

            <colspec colnum="2" colwidth="1*"/>

            <thead>
              <row>
                <entry>Method Name</entry>

                <entry>Property Name</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>myProperty143</code></entry>

                <entry><code>myProperty143</code></entry>
              </row>

              <row>
                <entry><code>$new</code></entry>

                <entry><code>new</code></entry>
              </row>

              <row>
                <entry><code>my$$prop</code></entry>

                <entry><code>my$prop</code></entry>
              </row>

              <row>
                <entry><code>dot_prop</code></entry>

                <entry><code>dot.prop</code></entry>
              </row>

              <row>
                <entry><code>_secret</code></entry>

                <entry><code>.secret</code></entry>
              </row>

              <row>
                <entry><code>another__prop</code></entry>

                <entry><code>another_prop</code></entry>
              </row>

              <row>
                <entry><code>three___prop</code></entry>

                <entry><code>three_.prop</code></entry>
              </row>

              <row>
                <entry><code>four_$__prop</code></entry>

                <entry><code>four._prop</code></entry>
              </row>

              <row>
                <entry><code>five_$_prop</code></entry>

                <entry><code>five..prop</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
        
      </section>
      
      <section>
        <title>Annotation</title>
        <para>Conversion to and from annotations behaves identical to 
        interface conversion with the added capability of specifying a default in the annotation definition.
        </para>
        
        <para>When converting to an annotation type, the converter will return an instance of the requested
        annotation class. As with interfaces, values are only obtained from the conversion source when the 
        annotation method is actually called. If the requested value is not available, the default as 
        specified in the annotation class is used. If no default is specified a <code>ConversionException</code>
        is thrown.
        </para>
        
        <para>Below a few examples of conversions to an annotation:
        <programlisting>@interface MyAnnotation {
  String[] args() default {"arg1", "arg2"};
}

// Will set sa={"args1", "arg2"}
String[] sa = converter.convert(new HashMap()).to(MyAnnotation.class).args();

// Will set a={"x", "y", "z"}
Map m = Collections.singletonMap("args", new String [] {"x", "y", "z"});
String[] a = converter.convert(m).to(MyAnnotation.class).args();

// Will set a1={}
Map m1 = Collections.singletonMap("args", null)
String[] a1 = converter.convert(m1).to(MyAnnotation.class).args();

// Will set a2={""}
Map m2 = Collections.singletonMap("args", "")
String[] a2 = converter.convert(m2).to(MyAnnotation.class).args();

// Will set a3={","}
Map m3 = Collections.singletonMap("args", ",")
String[] a3 = converter.convert(m3).to(MyAnnotation.class).args();</programlisting>
        </para>
      </section>
      
      <section>
        <title>Java Beans</title>
        <para>Java Beans are concrete (non-abstract) classes that follow a naming convention. They provide 
        public getters and setters to
        access their properties and have a public no-arg constructor. When converting from a Java Bean introspection
        is used to find the read accessors. A read accessor must have no arguments and a non-<code>void</code> return 
        value. The method name must start with <code>get</code> followed by a capitalized property name, 
        e.g. <code>getSize()</code> provides access to the property <code>size</code>. 
        For <code>boolean/Boolean</code> properties a prefix of <code>is</code>
        is also permitted.</para> 
        <para>
        For the converter to consider an object as a Java Bean the 
          <xref linkend="org.osgi.util.converter.Converting.sourceAsBean--" xrefstyle="hyperlink"/>
        modifier needs to be invoked, for example:
          <programlisting>  Map m = converter.convert(myBean).sourceAsBean().to(Map.class);</programlisting></para>
        <para>When converting to a Java Bean, the bean is constructed eagerly. All available properties
            are set in the bean using the bean's write accessors, i.e. public setters methods with a single argument. 
            All methods of the bean class itself and its 
            super classes are considered. 
            If a property cannot be converted this will cause a 
            <xref linkend="org.osgi.util.converter.ConversionException" xrefstyle="hyperlink"/>.
            <remark>Discuss: so if any of the JavaBean's properties is missing that will cause a conversion exception!</remark>
            </para>
        <para><emphasis>Note: </emphasis>access via indexed bean properties is not supported as there is no way to 
        find out the size of the array via these accessors.
        </para>
        <para><emphasis>Note: </emphasis>the <code>getClass()</code> method of the <code>java.lang.Object</code>
        class is not considered an accessor.
        </para>
      </section>
      
      <section>
        <title>DTOs</title>
        <para>
        DTOs are classes with public non-static fields and no methods other than the ones provided by the 
        <code>java.lang.Object class</code>. OSGi DTOs extend the <code>org.osgi.dto.DTO</code> class,
        however objects following the DTO rules that do not extend the DTO
        class are also treated as DTOs. 
        DTOs may have static fields, these are ignored by the converter.</para>

        <remark>Is a class with private/package/protected fields a DTO?</remark>
        
        <para>When converting to a DTO, the converter attempts to find fields that match the key of each 
        entry in the source map and then converts the value to the field type before assigning it. They key of
        the map entries may need to be converted into a String first. Keys are mapped according to 
        <xref linkend="service.converter-key.mapping"/>.</para>
        
        <para>The DTO is constructed using its no-arg constructor and each public 
        field is filled with data from the source eagerly. Fields present in the DTO but missing in the source
        object will cause a <code>ConversionException</code>. 
        <remark>yes?</remark>
        </para>
      </section>
      
      <section>
        <title>Types with getProperties()</title>
        
        <para>The converter uses reflection to find a <code>java.util.Map getProperties()</code> or 
        <code>java.util.Dictionary getProperties()</code> method on the source type to obtain a map view over
        the source object. This map view is used to convert the source object to another map-like structure.</para>
        
        <para><emphasis>Note: </emphasis>this mechanism can only be used to convert <emphasis>to</emphasis> another type. 
        The reverse is not supported</para>
      </section>

      <section>
        <title>Other types</title>
        <para>
          When converting from a map-like structure to other types, the map is first converted in an ordered collection 
          of <code>Map.Entry</code> objects. This collection is then converted to the target type using the rules specified
          in <xref linkend="service.converter.special.cases.map.entry"/>.
        </para>
        <para>
          No other conversions to map-like structures are supported.
        </para>
      </section> 


    </section>
    
    <section xml:id="service.converter-priorities">
      <title>Priority</title>
      
      <para>In case multiple conversion rules match, the rule with the highest priority is used, where 1 is the highest overall priority.
        <table>
          <title>Conversion rule priority</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Priority</entry>
                <entry>Rule</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>annotation</entry>
              </row>

              <row>
                <entry>2</entry>
                <entry>DTO</entry>
              </row>
              
              <row>
                <entry>3</entry>
                <entry><emphasis>entity.</emphasis><code>getProperties()</code></entry>
              </row>
              
              <row>
                <entry>4</entry>
                <entry>interface (including Collections and Maps)</entry>
              </row>

              <row>
                <entry>5</entry>
                <entry>scalar</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        The priority rules defined in the above table can be overridden by using 
        <xref linkend="org.osgi.util.converter.Converting.sourceAs-Class-" xrefstyle="hyperlink"/>
        or         
        <xref linkend="org.osgi.util.converter.Converting.targetAs-Class-" xrefstyle="hyperlink"/> 
        to indicate as what class the source or target object should be treated. 
        Consider the following example:
        <programlisting>  Class MyClass implements MyInterface {
    @Override
    long amount() { // returns amount }

    Map getProperties() { // returns properties }
  }</programlisting>
        MyClass both implements an interface and provides the <code>getProperties()</code> method.
        According to the priority rules, the default behaviour is that when converting an instance of this class 
        to a map-like structure, the <code>getProperties()</code> result is used as the source. 
        To instruct the converter to view the object as an interface instead use <code>as()</code>
        <programlisting>  Map m = converter.convert(myClassObj).
      sourceAs(MyInterface.class).to(Map.class);
  long l = m.get("amount");</programlisting>
      </para>
      
      <section>
        <title>Specifying target types</title>
        <para>The converter always produces an instance of the target type as specified with the
        <xref linkend="org.osgi.util.converter.Converting.to-Class-" xrefstyle="hyperlink"/>,
        <xref linkend="org.osgi.util.converter.Converting.to-TypeReference-" xrefstyle="hyperlink"/> or
        <xref linkend="org.osgi.util.converter.Converting.to-Type-" xrefstyle="hyperlink"/> method.
        In some cases the converter needs to be instructed how to treat this target object.
        For example the desired target type might extend a DTO class adding some methods and behavior to 
        the DTO. As this target class now has methods, the converter will not recognize as a DTO.
        The <xref linkend="org.osgi.util.converter.Converting.targetAs-Class-" xrefstyle="hyperlink"/>
        and <xref linkend="org.osgi.util.converter.Converting.targetAsBean--" xrefstyle="hyperlink"/>
        methods can be used here to instruct the converter to treat the target object as certain type
        of object to guide the conversion.
        </para>
        
        <para>For example:
        <programlisting>  MyExtendedDTO med = converter.convert(someMap).
      targetAs(MyDTO.class).to(MyExtendedDTO.class)</programlisting>
        In this example the converter will return a <code>MyExtendedDTO</code> instance
        but it will treat is as a <code>MyDTO</code> type. The target class must provide
        the same public API as the class specified with 
        <xref linkend="org.osgi.util.converter.Converting.targetAs-Class-" xrefstyle="hyperlink"/>.      
      </para>
        <remark>Do we need a targetAsDTO()? Or is targetAs() sufficient?</remark>
      </section>
    </section>
    
    <section>
      <title>Conversion failures</title>
      <para>...</para>
    </section>
  </section>

  <section>
    <title>Customizing converters</title>
    <para>The Standard Converter applies the conversion rules described in this specification. While this is 
    useful for many applications, in some cases deviations from the specified rules may be necessary.
    This can be done by creating customized converter. 
    Customized converters are created based on an existing converter with additional rules specified that
    override the existing converter's behavior.
    A customized converter is created through a 
    <xref linkend="org.osgi.util.converter.ConverterBuilder" xrefstyle="hyperlink"/>. Customized converters
    implement the converter interface and as such can be used to create further customized converters.
    Converters are immutable, once created they cannot be modified, so they can be freely shared without the 
    risk of modification to the converter's behavior.
    </para>
    
    <para>For example converting a Date to a String may require a specific format. The default 
    <code>Date</code> to <code>String</code> conversion produces a String in the format 
    <code>yyyy-MM-ddTHH:mm:ss.SSSZ</code>. If we want to produce a String in the format 
    <code>yyMMddHHmmssZ</code> instead a custom converter can be applied:
    <programlisting>SimpleDateFormat sdf = new SimpleDateFormat("yyMMddHHmmssZ");
ConverterBuilder cb = new StandardConverter().newConverterBuilder();
cb.rule(Date.class, String.class, v -&gt; sdf.format(v), v -&gt; sdf.parse(v));
Converter c = cb.build();
    
String s = c.convert(new Date()).to(String.class); // s = "160923102853+0100" or similar</programlisting>
    Custom conversions are also applied to embedded conversions that are part of a map or other enclosing object:
    <programlisting>class MyBean {
  //... fields ommitted
  boolean getEnabled() { /* ... */ }
  void setEnabled(boolean e)  { /* ... */ }
  Date getStartDate() { /* ... */ }
  void setStartDate(Date d) { /* ... */ }
}

MyBean mb = new MyBean();
mb.setStartDate(new Date());
mb.setEnabled(true);

Map&lt;String, String&gt; m = c.convert(mb).sourceAsBean().
    to(new TypeReference&lt;Map&lt;String, String&gt;&gt;(){});
String en = m.get("enabled");   // en = "true"
String sd = m.get("startDate"); // sd = "160923102853+0100" or similar</programlisting>
	Rules will only be invoked when an actual object needs to be converted, <code>null</code> values are never 
	handed to converter rules. A converter rule can return <code>null</code> however to indicate that it cannot handle
	the conversion, in which case the parent converter object is asked to convert the value.
	Since custom converters can be the basis for further custom converters, a chain of custom converters can be 
	created where the outermost converter is given the opportunity to convert an object first, but it can delegate
	back to the next converter in the hierarchy by returning <code>null</code> if it wishes to do so.
	</para>
	<section>
	  <title>Abstract converter rules</title>
	  <para>
	  When specifying the types for the converter rules, types higher in the hierarchy can be used. When the converter looks for 
	  a customized converter rule, it first looks for a converter rule for the most specific types. If it cannot 
	  find a matching rule, it will look for matching converters for the supertypes of the provided objects. It will 
	  continue to go up the type hierarchy until it reaches <code>java.lang.Object</code>. Therefore converter 
	  rules that convert from or to Object can be used as catchall or default rules that are invoked if no specific rule
	  is available.
	  <remark>Need to specify what the order or lookup is if class x extends s implements a,b,c</remark>
	  </para>
	</section>
  </section>

  <section>
    <title>Security</title>
    <para>...</para>
  </section> 

  <xi:include href="../../generated/javadoc/docbook/org.osgi.util.converter.xml"/>
 
  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
