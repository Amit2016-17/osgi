<?xml version="1.0" encoding="utf-8"?>
<chapter label="134"
         revision="$Id$"
         version="5" xml:id="service.subsystem"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1999/xhtml"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Subsystem Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.subsystem-version"
    linkend="org.osgi.service.subsystem"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The <xref linkend="intro.core.release" xrefstyle="template:%t"/>
    specifies a life-cycle model where bundles can be installed, resolved, and
    started in order to provide their own classes and services as well as use
    those provided by other bundles in the system. In the core framework, the
    bundle is the coarsest deployment unit that a management agent is able to
    work with; however, oftentimes it is necessary to work with collections of
    bundles and other types of <emphasis>resources</emphasis>, such as
    subsystems and implementation specific resources. For example, a
    collection of bundles may correspond to a particular feature of a
    middleware product, such as a Web container. The applications deployed to
    that container may also be developed as a collection of bundles that an
    administrator is required to manage as a consistent whole. The Subsystems
    specification provides a declarative model for defining resource
    collections, including bundles, and an API for installing and managing
    those collections of resources.</para>

    <para>Many use cases only require <emphasis>unscoped</emphasis> resource
    collections where all provided capabilities are freely exported to and all
    required capabilities are freely imported from the system. However, in
    some cases, it is important to allow the exporting of provided
    capabilities to be <emphasis>scoped</emphasis> such that they can only be
    used by a subset of resources in the system. It may also be necessary to
    restrict the importing of required capabilities from outside the
    collection to ensure its internal capabilities are always preferred over
    capabilities outside the collection. For example, applications running on
    a Web application server or in a cloud environment may be deployed to the
    same server instance. The side-effects of co-locating applications on the
    same server must be minimized, and scoping is used to ensure each
    application does not use the classes and services of the others.</para>

    <para>The framework provides hooks for influencing resolution, and access
    to bundles and services. These framework hooks may be used to implement
    scoping for a collection of bundles. The Subsystems specification provides
    a higher-level declarative model for defining scoping for collections of
    resources, including bundles.</para>

    <para>When deploying a collection of bundles in an OSGi framework, gaps
    can exist between the requirements of the bundles and the capabilities
    provided by the target runtime. Management agents are responsible for
    ensuring additional bundles are installed to plug these gaps such that the
    collection of bundles will resolve and run. The <xref
    linkend="service.resolver"/> and <xref linkend="service.repository"/> help
    management agents address these needs but do not cover how deployment
    works for resource collections, especially when those collections are
    scoped. Scoping affects requirement and capability resolution and
    therefore affects the choice of resources. The Subsystems specification
    defines resolution and provisioning rules to help management agents
    consistently deploy collections of resources. The specification also
    defines a format for developers and testers to provide predetermined
    deployment resolutions to help ensure consistency between test and
    production environments.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Collections</emphasis> - Allow the management of a
          collection of resources as a whole.</para>
        </listitem>

        <listitem>
          <para><emphasis>Scoping - </emphasis>Provide support for isolating
          resources in the collection such that a subset of their capabilities
          (for example packages and services) are available to satisfy
          requirements outside the Subsystem and a subset of their
          requirements are able to resolve to capabilities provided outside
          the Subsystem.</para>
        </listitem>

        <listitem>
          <para><emphasis>Sharing</emphasis> - Allow Scoped Subsystems to
          share their resources with others and share resources from
          others.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dynamic</emphasis> - Provide life cycle information
          to users of Subsystems and be able to react to changes in the state
          of the environment in which a Subsystem is deployed.</para>
        </listitem>

        <listitem>
          <para><emphasis>Flexible</emphasis> - Enable a flexible definition
          with subsequent resolution to determine the resources to be
          used.</para>
        </listitem>

        <listitem>
          <para><emphasis>Deterministic</emphasis> - Enable the choice of
          resources deployed for a Subsystem to be determined ahead of
          deployment.</para>
        </listitem>

        <listitem>
          <para><emphasis>Life-cycle</emphasis> - Define a life cycle for a
          Subsystem describing how it affects the Subsystem's resources and
          allow the life cycle to be observed.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reflective</emphasis> - Allow discovery of runtime
          structural and state information.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resolution</emphasis> - Allow the resolution of a
          flexible definition during installation to determine the resources
          to be used.</para>
        </listitem>

        <listitem>
          <para><emphasis>Recursive</emphasis> - Allow Subsystems to be
          defined in terms of other Subsystems.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Subsystem</emphasis> - A collection of resources,
          such as bundles, or other Subsystems, administered as a whole
          through a Subsystem service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Subsystem Manifest</emphasis> - A manifest used to
          provide a Subsystem definition.</para>
        </listitem>

        <listitem>
          <para><emphasis>Deployment Manifest</emphasis> - A manifest used to
          provide a deployment definition for a Subsystem. The definition
          identifies the exact resources to be deployed for the
          Subsystem.</para>
        </listitem>

        <listitem>
          <para><emphasis>Subsystem Archive</emphasis> - A zip file with an
          <code>.esa</code> extension that describes a Subsystem definition.
          It may include the Subsystem Manifest, Deployment Manifest, or
          resource files that constitute the Subsystem.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resource</emphasis> - An element which may be used
          in the composition of a Subsystem, such as a bundle or another
          Subsystem.</para>
        </listitem>

        <listitem>
          <para><emphasis>Repository</emphasis> - A service that is used to
          discover a Subsystem's content and dependencies. The repository
          service is described in the <xref
          linkend="service.repository"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resolver</emphasis> - A service used to resolve
          requirements against capabilities to determine the resources
          required by a Subsystem. The resolver service is described in the
          <xref linkend="service.resolver"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Constituent</emphasis> - A resource that belongs to
          one or more Subsystems.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Entities org.osgi.service. subsystem</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.618in"
                       contentwidth="6.209in" fileref="subsystem-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Synopsis</title>

      <para>The OSGi framework does not provide any support for managing
      collections of resources. Management of collections of resources is
      enabled by a Subsystems implementation. When a Subsystems implementation
      is installed into the framework, it registers a Subsystem service. This
      service represents the framework as the <emphasis>Root
      Subsystem</emphasis>, which is a Subsystem that provides the capability
      to install and manage other <emphasis>child Subsystems</emphasis>, and
      is the parent of those Subsystems, but does not itself have a
      parent.</para>

      <para>A Subsystem Archive provides a definition of a Subsystem that is
      read by the Subsystem implementation as part of installation. The
      Subsystem is packaged in a Subsystem Archive (<code>.esa</code>) file
      which is the Subsystem equivalent of a bundle <code>.jar</code> file.
      The Subsystem definition can be described using a Subsystem Manifest or
      defaulted based on the name and contents of the Subsystem Archive.
      Installing a new Subsystem results in another Subsystem service being
      registered to represent that Subsystem in the runtime. Each Subsystem
      service enables management and reflection of the Subsystem it
      represents.</para>

      <para>A Subsystem Manifest allows flexibility in the identification of
      the Subsystem's content resources through version ranges and
      optionality. The exact versions to be deployed and any required
      <emphasis>dependencies</emphasis> (resources required to satisfy
      unresolved requirements of the Subsystem's content resources) can be
      identified in an optional Deployment Manifest. The corresponding
      resource binaries can be packaged in the Subsystem Archive, or found in
      a repository. Depending on the type of Subsystem the Subsystem Manifest
      may describe a <emphasis>sharing policy</emphasis> for the Subsystem,
      such as the packages or services the Subsystem exports or
      imports.<emphasis> </emphasis>The Deployment Manifest also describes the
      <emphasis>sharing policy</emphasis> details for the Subsystem and is
      defined by the type of Subsystem and the <emphasis>sharing
      policy</emphasis> described in the Subsystem Manifest.</para>

      <para>A Subsystem that does not have a Deployment Manifest has its
      deployment details calculated during installation. This may be done
      using the <xref linkend="service.resolver"/>, if available. The starting
      set of requirements to be resolved are those identifying the Subsystem
      content (that is, requirements for content resources). The Subsystems
      implementation provides a resolve context that implements the policy for
      the Subsystem and consults the configured Repository services to find
      candidates to satisfy requirements.</para>

      <para>This resolve context can also represent the target deployment
      environment, which might be a live framework, or a static definition of
      a target runtime. The resulting resolution is used to determine the
      exact resources to provision, equivalent to those identified in the
      deployment manifest. If any of the Repository or Resolver services are
      unavailable, then a Subsystem implementation can use its own means to
      determine the deployment, or fail the installation.</para>

      <para>A Subsystem definition includes sharing policy configuration to
      scope requirements and capabilities visibility into and out of a
      Subsystem. The Subsystems specification defines the concept of Subsystem
      types to help simplify the configuration of sharing policies. Each type
      has its own default sharing policy, for example, to forbid the sharing
      of capabilities out, or to share all capabilities in. Three Subsystem
      types are defined in the Subsystems specification:
      <emphasis>application</emphasis>, <emphasis>composite</emphasis> and
      <emphasis>feature</emphasis>.</para>

      <para>An <emphasis>Application Subsystem </emphasis>is a Scoped
      Subsystem with a sharing policy associated with what is often considered
      to be an application. An application does not share (export) any
      capabilities. Any requirements that are not satisfied by the
      application's contents are automatically imported from outside the
      application.</para>

      <para>A <emphasis>Composite Subsystem</emphasis> is a Scoped Subsystem
      with a fully explicit sharing policy. Capabilities may be explicitly
      imported into, or exported out of, the Composite Subsystem.</para>

      <para>A <emphasis>Feature Subsystem </emphasis>is an Unscoped Subsystem
      and so all its requirements and capabilities are shared.</para>

      <para>This specification allows for other types to be defined, including
      ones outside this specification.</para>
    </section>
  </section>

  <section xml:id="i3345962">
    <title>Subsystems</title>

    <para>This specification defines a unit of installation called a
    <emphasis>Subsystem</emphasis>. A Subsystem is comprised of resources,
    including OSGi bundles and other Subsystems, which together can provide
    functions to end users.</para>

    <para>A Subsystem is deployed as a Subsystem Archive (<code>.esa</code>)
    file. Subsystem Archives are used to store Subsystems and optionally their
    resources in a standard ZIP-based file format. This format is defined in
    <xref linkend="i3321126"/>. Subsystems normally use the Subsystem Archive
    extension of <code>.esa</code> but are not required to. However there is a
    special MIME type reserved for OSGi Subsystems that can be used to
    distinguish Subsystems from normal ZIP files. This MIME type is:</para>

    <programlisting>application/vnd.osgi.subsystem</programlisting>

    <para>The type is defined in <xref linkend="i3321186"/>. A Subsystem is a
    ZIP file that:</para>

    <itemizedlist>
      <listitem>
        <para>Contains zero or more resources. These resources may be OSGi
        bundles or other Subsystems. Subsystems may be nested or included to
        any depth.</para>
      </listitem>

      <listitem>
        <para>Contains an optional Subsystem Manifest named
        <code>OSGI-INF/SUBSYSTEM.MF</code>. The Subsystem Manifest describes
        the contents of the Subsystem Archive and provides information about
        the Subsystem. The Subsystem Archive uses headers to specify
        information that the Subsystems implementation needs to install,
        resolve and start the Subsystem correctly. For example, it can state
        the list of content resources that comprise the Subsystem and the
        Subsystem's type.</para>
      </listitem>

      <listitem>
        <para>Contains an optional Deployment Manifest file named
        <code>OSGI-INF/DEPLOYMENT.MF</code>. The Deployment Manifest describes
        the content resources, dependencies, and sharing policy that need to
        be provisioned to satisfy the Subsystem definition and ultimately
        allow it to resolve at runtime.</para>
      </listitem>
    </itemizedlist>

    <para>The Subsystem and Deployment Manifest follow the JAR manifest format
    (version 1.0), but with the following relaxed rules:</para>

    <itemizedlist>
      <listitem>
        <para>No limit on the line length. Lines are allowed to exceed the JAR
        manifest maximum of 72 bytes.</para>
      </listitem>

      <listitem>
        <para>The last line is not required to be a carriage-return new-line
        combination.</para>
      </listitem>

      <listitem>
        <para>There is only one section in the manifest (the main section). A
        Subsystems implementation is free to ignore other sections of the
        manifest.</para>
      </listitem>
    </itemizedlist>

    <para>Once a Subsystem is started, its functionality is provided.
    Depending on the type of Subsystem it may expose capabilities, such as
    packages and services, to other resources installed in the OSGi
    framework.</para>

    <section>
      <title>Subsystem Manifest Headers</title>

      <para>A Subsystem can carry descriptive information about itself in the
      Subsystem manifest file contained in its Subsystem Archive under the
      name <code>OSGI-INF/SUBSYSTEM.MF</code>. This specification defines
      Subsystem manifest headers, such as Subsystem-SymbolicName and
      Subsystem-Version, which Subsystem developers use to supply descriptive
      information about a Subsystem. A Subsystems implementation must:</para>

      <itemizedlist>
        <listitem>
          <para>Process the main section of the manifest. Any other sections
          of the manifest can be ignored.</para>
        </listitem>

        <listitem>
          <para>Ignore unknown manifest headers. The Subsystem developer can
          define additional manifest headers as needed.</para>
        </listitem>

        <listitem>
          <para>Ignore unknown attributes and directives.</para>
        </listitem>
      </itemizedlist>

      <para>All specified manifest headers are listed in the following
      sections. All headers are optional. Example values are provided to help
      explain each header (e.g. Export-Package: org.acme.logging;
      version=1.0).</para>

      <section>
        <title>Export-Package: org.acme.logging; version=1.0</title>

        <para>The Export-Package header declares the exported packages for a
        Scoped Subsystem. See <xref linkend="i3321359"/>.</para>
      </section>

      <section>
        <title>Import-Package: org.osgi.util.tracker; version="[1.4,
        2.0)"</title>

        <para>The Import-Package header declares the imported packages for a
        Scoped Subsystem. See <xref linkend="i3321439"/>.</para>
      </section>

      <section>
        <title>Preferred-Provider: com.acme.logging</title>

        <para>The Preferred-Provider header declares a list bundles and
        Subsystems which are the providers of capabilities that are preferred
        when wiring the requirements of a Scoped Subsystem. See <xref
        linkend="i3321603"/>.</para>
      </section>

      <section>
        <title>Provide-Capability: com.acme.dict; from=nl; to=de;
        version:Version=1.2</title>

        <para>The Provide-Capability header declares the capabilities exported
        for a Scoped Subsystem. See <xref linkend="i3394044"/>.</para>
      </section>

      <section>
        <title>Require-Bundle: com.acme.chess; version= "[1.0, 2.0)"</title>

        <para>The Require-Bundle header declares the required bundles for a
        Scoped Subsystem. See <xref linkend="i3321711"/>.</para>
      </section>

      <section>
        <title>Require-Capability: osgi.ee; filter:="(osgi.ee=*)"</title>

        <para>The Require-Capability header declares the required capabilities
        for a Scoped Subsystem. See <xref linkend="i3394044"/>.</para>
      </section>
      
      <section>
        <title>Subsystem-Category</title>
        
        <para>The Subsystem-Category header identifies the categories of the 
        subsystem as a comma-delimited list.</para>
      </section>
      
      <section>
        <title>Subsystem-ContactAddress</title>
        
        <para>The Subsystem-ContactAddress header identifies the contact address 
        where problems with the subsystem may be reported; for example, an email 
        address.</para>
      </section>

      <section>
        <title>Subsystem-Content: com.acme.logging</title>

        <para>The Subsystem-Content header lists requirements for resources
        that are considered to be the contents of this Subsystem. See <xref
        linkend="i3321875"/>.</para>
      </section>
      
      <section>
        <title>Subsystem-Copyright</title>
        
        <para>The Subsystem-Copyright header identifies the subsystem's 
        copyright information.</para>
      </section>

      <section>
        <title>Subsystem-Description: The ACME Account Admin
        Application</title>

        <para>The Subsystem-Description header defines a human-readable
        description for this Subsystem, which can potentially be
        localized.</para>
      </section>
      
      <section>
        <title>Subsystem-DocURL</title>
        
        <para>The Subsystem-DocURL header identifies the subsystem's 
        documentation URL, from which further information about the subsystem 
        may be obtained.</para>
      </section>

      <section>
        <title>Subsystem-ExportService: org.acme.billing.Account;
        filter:="(user=bob)"</title>

        <para>The Subsystem-ExportService header specifies the exported
        services for a Scoped Subsystem. See <xref
        linkend="i3321933"/>.</para>
      </section>
      
      <section>
        <title>Subsystem-Icon</title>
        
        <para>The Subsystem-Icon header identifies the icon URL for the 
        subsystem.</para>
      </section>

      <section>
        <title>Subsystem-ImportService: org.acme.billing.Account;
        filter:="(type=premium)"</title>

        <para>The Subsystem-ImportService header specifies the imported
        services for a Scoped Subsystem. See <xref
        linkend="i3322018"/>.</para>
      </section>

      <section>
        <title>Subsystem-License</title>
        
        <para>The Subsystem-License header identifies the subsystem's license.</para>
      </section>

      <section>
        <title>Subsystem-Localization: OSGI-INF/l10n/subsystem</title>
        
        <para>The Subsystem-Localization header identifies the default base name
        of the localization properties files contained in the subsystem archive.
        The default value is <code>OSGI-INF/l10n/subsystem</code>. Translations 
        are therefore, by default, <code>OSGI-INF/l10n/subsystem_de.properties
        </code>, <code>OSGI-INF/l10n/subsystem_nl.properties</code>, and so on. 
        The location is relative to the root of the subsystem archive. See
        <xref linkend="service.subsystem-subsystem.localization.detail"/></para>
      </section>

      <section>
        <title>Subsystem-ManifestVersion: 1</title>

        <para>The Subsystem-ManifestVersion header defines that the Subsystem
        follows the rules of a Subsystems Specification. It is 1 (the default)
        for this version of the specification. Future versions of the
        Subsystems Specification can define higher numbers for this
        header.</para>
      </section>

      <section>
        <title>Subsystem-Name: Account Application</title>

        <para>The Subsystem-Name header defines a short, human-readable name
        for this Subsystem which may be localized. This should be a short,
        human-readable name that can contain spaces.</para>
      </section>

      <section>
        <title>Subsystem-SymbolicName: com.acme.subsystem.logging</title>

        <para>The Subsystem-SymbolicName header specifies a non-localizable
        name for this Subsystem. The Subsystem symbolic name together with a
        version identify a Subsystem Definition though a Subsystem can be
        installed multiple times in a framework. The Subsystem symbolic name
        should be based on the reverse domain name convention. See <xref
        linkend="i3322062"/>.</para>
      </section>

      <section>
        <title>Subsystem-Type: osgi.subsystem.application</title>

        <para>The Subsystem-Type header specifies the type for this Subsystem.
        Three types of Subsystems must be supported:
        <code>osgi.subsystem.application</code>,
        <code>osgi.subsystem.composite</code> and
        <code>osgi.subsystem.feature</code>. See <xref linkend="i3322207"/>
        for details about the three different types of Subsystems. See <xref
        linkend="i3322247"/> for more information about the values for the
        Subsystem-Type header.</para>
      </section>

      <section>
        <title>Subsystem-Vendor</title>
        
        <para>The Subsystem-Vendor header identifies the subsystem's vendor.</para>
      </section>

      <section>
        <title>Subsystem-Version: 1.0</title>

        <para>The Subsystem-Version header specifies the version of this
        Subsystem. See <xref linkend="i3322283"/>.</para>
      </section>
    </section>

    <section xml:id="i3322207">
      <title>Subsystem Identifiers and Type</title>

      <para>A Subsystem is identified by a number of names that vary in their
      Scope:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Subsystem identifier</emphasis> - A long that is a
          Subsystems implementation assigned unique identifier for the full
          lifetime of an installed Subsystem, even if the framework or the
          Subsystem's implementation is restarted. Its purpose is to
          distinguish Subsystems installed in a framework. Subsystem
          identifiers are assigned in ascending order to Subsystems when they
          are installed. The <xref
          linkend="org.osgi.service.subsystem.Subsystem.getSubsystemId--"
          xrefstyle="hyperlink"/> method returns a Subsystem's
          identifier.</para>
        </listitem>

        <listitem>
          <para><emphasis>Subsystem location</emphasis> - A name assigned by a
          management agent to a Subsystem during the installation. This string
          is normally interpreted as a URL to the Subsystem Archive but this
          is not mandatory. Within a particular framework, a Subsystem
          location must be unique. A location string uniquely identifies a
          Subsystem. The <xref
          linkend="org.osgi.service.subsystem.Subsystem.getLocation--"
          xrefstyle="hyperlink"/> method returns a Subsystem's
          location.</para>
        </listitem>

        <listitem>
          <para><emphasis>Subsystem Symbolic Name and Subsystem
          Version</emphasis> - A name and version assigned by the developer.
          The combination of a Subsystem symbolic name and Subsystem version
          is intended to provide a globally unique identifier for a Subsystem
          Archive or Subsystem definition. The <xref
          linkend="org.osgi.service.subsystem.Subsystem.getSymbolicName--"
          xrefstyle="hyperlink"/> method returns the assigned Subsystem name.
          The <xref
          linkend="org.osgi.service.subsystem.Subsystem.getVersion--"
          xrefstyle="hyperlink"/> method returns the assigned version. Though
          this pair is intended to be unique, it is developer assigned and
          there is no verification at runtime that the pair uniquely
          identifies a Subsystem Archive. It is possible to install a
          Subsystem multiple times as long as the multiple Subsystem symbolic
          name and version pairs are isolated from each other by Subsystem
          sharing policies.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3322062">
      <title>Subsystem-SymbolicName Header</title>

      <para>The Subsystem-SymbolicName header specifies the symbolic name of
      the Subsystem. The Subsystem-SymbolicName header may also specify
      arbitrary matching attributes. Subsystem-SymbolicName is an optional
      header; the default value is derived as described in <xref
      linkend="i3322503"/>.</para>

      <para>The Subsystem-SymbolicName header must conform to the following
      syntax:</para>

      <programlisting>Subsystem-SymbolicName ::= symbolic-name(';' parameter )*</programlisting>

      <para>No directives are defined by this specification for the
      Subsystem-SymbolicName header. The header allows the use of arbitrary
      attributes that can be required by the Subsystem-Content header.</para>
    </section>

    <section xml:id="i3322283">
      <title>Subsystem-Version Header</title>

      <para>The Subsystem-Version header is optional and must conform to the
      following syntax:</para>

      <programlisting>Subsystem-Version ::= version</programlisting>

      <para>If the Subsystem-Version header is not specified then the default
      value is derived as described in <xref linkend="i3322503"/>.</para>
    </section>

    <section xml:id="i3322247">
      <title>Subsystem-Type Header</title>

      <para>The Subsystem-Type header specifies the <emphasis>type</emphasis>
      of the Subsystem. Three types of Subsystems are defined by this
      specification:</para>

      <itemizedlist>
        <listitem>
          <para><code>osgi.subsystem.application</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.composite</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.feature</code></para>
        </listitem>
      </itemizedlist>

      <para>See <xref linkend="i3322905"/> for details about the three
      different types of Subsystems. Subsystem-Type is an optional header; the
      default value is <code>osgi.subsystem.application</code>.</para>

      <para>The following directive must be recognized for the Subsystem-Type
      header:</para>

      <itemizedlist>
        <listitem>
          <para><code>provision-policy</code> -
          (<code>rejectDependencies|acceptDependencies</code>) Directive used
          to declare if the Subsystem is willing to accept dependencies as
          <emphasis>constituents</emphasis>. A
          <emphasis>constituent</emphasis> is the term used to refer to a
          resource that belongs to one or more Subsystems. It can belong to a
          Subsystem as a result of being listed as content or, as described
          here, can have been provisioned into the Subsystem as a dependency.
          The default policy is <code>rejectDependencies</code>. See <xref
          linkend="i3323024"/> for installing and tracking dependencies. The
          value <code>acceptDependencies</code> must not be used for Feature
          Subsystems. If a Feature Subsystem attempts to use the
          <code>acceptDependencies</code> policy then the Subsystem
          installation must fail. If the <code>provision-policy</code>
          directive is declared and has any other value besides
          <code>acceptDependencies</code> or <code>rejectDependencies</code>
          then the Subsystem installation must fail.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3322503">
      <title>Deriving the Subsystem Identity</title>

      <para>If the Subsystem-SymbolicName and Subsystem-Version are not
      specified, then the following rules are defined for deriving the values
      of the Subsystem's symbolic name and version. If not otherwise
      specified, the default value of the version is
      <code>0.0.0</code>.</para>

      <para>When installing a Subsystem, the following URI syntax must be used
      as the location string in order to specify default values.</para>

      <programlisting>subsystem-uri ::= 'subsystem://' url? '?' params?
params        ::= param ( '&amp;' param )*
param         ::= key '=' value
key           ::= unreserved | escaped
value         ::= unreserved | escaped
url           ::= &lt;see <xref linkend="i3323132"/>&gt; 
escaped       ::= &lt;see <xref linkend="i3323360"/>&gt;
unreserved    ::= &lt;see <xref linkend="i3323360"/>&gt;</programlisting>

      <para>The query parameters represent Subsystem Manifest header names and
      values. Implementations must support the Subsystem-SymbolicName and
      Subsystem-Version parameters. Implementations can support additional
      parameters but must fail the installation if any unsupported parameters
      are included.</para>

      <para>As an example, the following Subsystem URI has an embedded URL
      of:</para>

      <programlisting>http://www.foo.com/sub#system.esa</programlisting>

      <para>It includes a default symbolic name of <code>com.acme.foo</code>
      and default version of <code>1.0.0</code>.</para>

      <programlisting>subsystem://http%3A%2F%2Fwww.foo.com%2Fsub%2523system.esa? «
    Subsystem-SymbolicName=com.acme.foo&amp;Subsystem-Version=1.0.0</programlisting>

      <para>When installing a Subsystem containing other Subsystem Archives
      with no symbolic name or version, values will be derived from the
      Subsystem Archive file or resource name. The syntax is as
      follows:</para>

      <programlisting>subsystem-archive ::= symbolic-name ( '@'version ) '.esa'</programlisting>

      <para>If the symbolic name is not provided in the manifest and cannot be
      computed by any other means then the Subsystem must fail to
      install.</para>
    </section>

    <section>
      <title>Subsystem Identity Capability</title>

      <para>The Subsystem's symbolic name, version, type and the arbitrary
      matching attributes specified on the Subsystem-SymbolicName header
      compose the <code>osgi.identity</code> capability for a Subsystem
      resource. The <code>osgi.identity</code> capability is provided by a
      Subsystem resource when contained within a Repository service, see <xref
      linkend="service.repository"/>. For example:</para>

      <programlisting>Subsystem-SymbolicName: org.acme.billing;category=banking
Subsystem-Version:      1.0.0
Subsystem-Type:         osgi.subsystem.composite</programlisting>

      <para>The above headers are used to declare a Subsystem of type
      <code>osgi.subsystem.composite</code> with the symbolic name of
      <code>org.acme.billing</code>, version of 1.0.0 and arbitrary matching
      attribute <code>category</code> of <code>banking</code>. This
      information will also be reflected in the <code>osgi.identity</code>
      capability of the Subsystem's Resource
      (<code>org.osgi.resource.Resource</code>). The following
      <code>osgi.identity</code> capability would be generated for a Subsystem
      resource from the above headers using the Provide-Capability header
      syntax. For example:</para>

      <programlisting>osgi.identity;
osgi.identity=org.acme.billing;
 version:Version=1.0.0;
 type=osgi.subsystem.composite;
 category=banking</programlisting>

      <para>This allows for requirements to be used to search a repository for
      Subsystems. The following requirement could be used to search for all
      Subsystems of type <code>osgi.subsystem.composite</code> using the
      Require-Capability header syntax. For example:</para>

      <programlisting>osgi.identity; filter:="(type=osgi.subsystem.composite)"</programlisting>
    </section>
    
    <section xml:id="service.subsystem-subsystem.localization.detail">
      <title>Subsystem-Localization Header</title>
      
      <para>For consistency and ease of comprehension, the design for localizing
      subsystem manifest headers follows the approach used by bundles.</para>
      
      <section>
        <title>Localization Properties</title>
        
        <para>A localization entry contains key/value entries for localized 
        information. All headers in a subsystem's manifest can be localized. 
        However, the subsystems implementation must always use the non-localized
        versions of headers that have subsystem semantics.</para>

        <para>A localization key can be specified as the value of a subsystem's 
        manifest header using the following syntax:</para>

        <programlisting>header-value ::= ’%’text
text ::= &lt; any value which is both a valid manifest header value and a valid
    property key name &gt;</programlisting>
        
        <para>For example, consider the following subsystem manifest entries:
        </para>

        <programlisting>Subsystem-Name: %acme subsystem
Subsystem-Description: %acme description
Subsystem-SymbolicName: acme.Subsystem
Acme-Defined-Header: %acme special header</programlisting>

        <para>User-defined headers can also be localized. Spaces in the 
        localization keys are explicitly allowed.</para>

        <para>The previous example manifest entries could be localized by the 
        following entries in the manifest localization entry <code>
        OSGI-INF/l10n/subsystem.properties</code>.</para>

        <programlisting># subsystem.properties
acme\ subsystem=The ACME Subsystem
acme\ description=The ACME Subsystem provides all of the ACME \ services
acme\ special\ header=user-defined Acme Data</programlisting>
        
        <para>The above manifest entries could also have French localizations in
        the manifest localization entry:</para>

        <programlisting>OSGI-INF/l10n/subsystem_fr_FR.properties.</programlisting>
      </section>
      
      <section>
        <title>Locating Localization Entries</title>
        
        <para>The Subsystems implementation must search for localization entries
        by appending suffixes to the localization base name according to a 
        specified locale and finally appending the .properties suffix. If a 
        translation is not found, the locale must be made more generic by first 
        removing the variant, then the country and finally the language until an 
        entry is found that contains a valid translation. For example, looking 
        up a translation for the locale <code>en_GB_welsh</code> will search in 
        the following order:</para>
        
        <programlisting>OSGI-INF/l10n/subsystem_en_GB_welsh.properties
OSGI-INF/l10n/subsystem_en_GB.properties
OSGI-INF/l10n/subsystem_en.properties
OSGI-INF/l10n/subsystem.properties</programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>Subsystem Region</title>

    <para>A <emphasis>Region</emphasis> provides isolation for a group of one
    or more Subsystems. Each Subsystem installed must be a member of one and
    only one Region. A Region consists of one and only one Scoped Subsystem
    and optionally a set of Unscoped Subsystems. Every Region has one and only
    one Parent Region, with the exception of the Root Region which has no
    Parent Region. The Region parent <phrase role="symbol">→</phrase> child
    connections form the <emphasis>Region Tree</emphasis>, which by definition
    contains no cycles.</para>

    <para>Each Region, except the Root Region, has a <emphasis>sharing
    policy</emphasis> associated with it which is defined by a Scoped
    Subsystem. A <emphasis>sharing policy</emphasis> consists of two
    parts:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Export Policy</emphasis> - Defines the set of
        capabilities provided by the constituents contained in the Region that
        are made available to the parent Region.</para>
      </listitem>

      <listitem>
        <para><emphasis>Import Policy</emphasis> - Defines the set of
        capabilities which are available in the parent Region that are made
        available to the child Region.</para>
      </listitem>
    </itemizedlist>

    <para><xref linkend="i3296632"/> illustrates a set of Regions that contain
    capabilities and requirements for a capability. For the purposes of this
    illustration the Subsystems and resources have been omitted.</para>

    <figure xml:id="i3296632">
      <title>Regions and Import/Export</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.700in"
                     contentwidth="6.209in"
                     fileref="regions-import-export.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In this example some constituent of Region <code>S1Region</code>
    provide a capability <code>S1</code><phrase
    role="symbol">→</phrase><code>X</code>. The <code>S1Region</code>'s
    sharing policy exports the capability <code>S1</code><phrase
    role="symbol">→</phrase><code>X</code> to its parent
    <code>RootRegion</code>. The <code>RootRegion</code> contains a
    constituent which has a requirement <code>Root</code><phrase
    role="symbol">→</phrase><code>X</code>. The export sharing policy of
    <code>S1Region</code> allows visibility to the capability
    <code>S1</code><phrase role="symbol">→</phrase><code>X</code> from the
    <code>RootRegion</code> which allows requirement <code>Root</code><phrase
    role="symbol">→</phrase><code>X</code> to be satisfied by the capability
    <code>S1</code><phrase role="symbol">→</phrase><code>X</code>. The
    <code>S2Region</code> also contains a constituent which has a requirement
    on <code>S2</code><phrase role="symbol">→</phrase><code>X</code>. The
    sharing policy of <code>S2Region</code> imports the capability
    <code>X</code> from its parent Region <code>RootRegion</code>. Since
    <code>RootRegion</code> has visibility to the capability
    <code>S1</code><phrase role="symbol">→</phrase><code>X</code> this allows
    <code>S2Region</code> to also have visibility to capability
    <code>S1</code><phrase role="symbol">→</phrase><code>X</code> through its
    import sharing policy which allows requirement <code>S2</code><phrase
    role="symbol">→</phrase><code>X</code> to be satisfied by the capability
    <code>S1</code><phrase role="symbol">→</phrase><code>X</code>.</para>

    <para>Sharing policies of the Regions allow for a capability to be shared
    across an arbitrary number of Regions. For those familiar with the Region
    digraph, see <xref linkend="i3324343"/>, the connections between Subsystem
    Regions is more restrictive than what the full Region digraph
    specification allows. A <emphasis>visibility path </emphasis>is the path
    over the sharing policies of the Region tree from a requirement to a
    capability that allows a requirement to get wired to a capability. Since
    all (non-Root) Regions have one and only one Parent Region the
    <emphasis>visibility paths</emphasis> over the sharing policies between a
    requirement and a capability is limited to 0 or 1. <xref
    linkend="i3297602"/> is another figure that illustrates a capability being
    shared across many different Regions.</para>

    <figure xml:id="i3297602">
      <title>Regions and Sharing Capabilities</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.491in"
                     contentwidth="6.209in"
                     fileref="regions-sharing-capabilities.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In this example the capability <code>S3</code><phrase
    role="symbol">→</phrase><code>X</code> is exported by the
    <code>S3Region</code> sharing policy to its parent <code>S1Region</code>.
    <code>S1Region</code> also exports <code>X</code> to its parent
    <code>RootRegion</code>. Then <code>S2Region</code> imports <code>X</code>
    from its parent <code>RootRegion</code> and finally <code>S4Region</code>
    imports <code>X</code> from its parent <code>S2Region</code>. The
    visibility path from requirement <code>S4</code><phrase
    role="symbol">→</phrase><code>X</code> to capability
    <code>S3</code><phrase role="symbol">→</phrase><code>X</code> is the
    following: <code>S4</code> <phrase role="symbol">→</phrase>
    <code>S2</code> <phrase role="symbol">→</phrase> <code>Root</code> <phrase
    role="symbol">→</phrase> <code>S1</code> <phrase role="symbol">→</phrase>
    <code>S3</code>.</para>

    <para>Notice that in this example the <code>S5Region</code> also has a
    sharing policy that imports <code>X</code> from its parent
    <code>S3Region</code>. Child Regions are allowed to import any capability
    to which the Parent Region has visibility. This is true even if the Parent
    Region does not export the capability. Regions can selectively choose what
    capabilities they want to expose (or export) to their Parent Region. Child
    Regions also can selectively choose what capabilities they want to be
    exposed to (or import) from their Parent Region. A Parent Region has no
    control over what capabilities its children have visibility. Similarly a
    Parent Region has no control over what capabilities a Child Region is
    allowed to export to the Parent Region. In other words, a Parent Region
    must give a Child Region everything the Child Region asks for (if the
    Parent Region has access to it) and a Parent Region must accept everything
    a Child Region offers to the Parent Region.</para>
  </section>

  <section>
    <title>Subsystem Relationships</title>

    <para>Subsystems installed into a framework become part of the S
    <emphasis>ubsystem graph</emphasis>. The Subsystem graph may be thought of
    as is directed acyclic graph with one and only one source vertex, which is
    the Root Subsystem. The edges have the child as the head and parent as the
    tail (parent<phrase role="symbol">→</phrase>child). This is depicted in
    <xref linkend="i3298109"/>.</para>

    <figure xml:id="i3298109">
      <title>Parent Child Relationship</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.207in"
                     contentwidth="6.209in"
                     fileref="parent-child-relationship.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>A Subsystem installed into or included within one or more Subsystems
    is called a <emphasis>child Subsystem</emphasis>. A Subsystem which has
    one or more child Subsystem(s) installed or included in it is called a
    <emphasis>parent Subsystem</emphasis>. Note that a Subsystem may be both a
    parent and child Subsystem.The Subsystem graph has the following
    rules:</para>

    <itemizedlist>
      <listitem>
        <para>There is one and only one source vertex (i.e. a Subsystem with
        no parents), which is the <emphasis>Root Subsystem</emphasis>.</para>
      </listitem>

      <listitem>
        <para>The Root Subsystem is considered a Scoped Subsystem of type
        <code>application</code> with a <code>provision-policy</code> of
        <code>acceptDependencies</code>.</para>
      </listitem>

      <listitem>
        <para>The Root Subsystem has a symbolic name of
        <code>org.osgi.service.subsystem.root</code>, version 1.0.0, Subsystem
        identifier of 0, and a location of <programlisting>subsystem://?Subsystem-SymbolicName=org.osgi.service.subsystem.root&amp; «
    Subsystem-Version=1.0.0</programlisting></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para>The Root Subsystem always exists when a Subsystems
        implementation is active, even if no other Subsystems are installed
        and all initial bundles installed into the framework along with the
        Subsystems implementation are considered content resources of the Root
        Subsystem.</para>
      </listitem>

      <listitem>
        <para>All other (non-root) Subsystems must have one or more parent
        Subsystems. This implies that there are no orphan Subsystems (except
        the Root Subsystem) and the Subsystem graph is fully connected.</para>
      </listitem>

      <listitem>
        <para>All parents of a Subsystem belong to the same Region.</para>
      </listitem>

      <listitem>
        <para>An Unscoped Subsystem must belong to the same Region to which
        its parents belong.</para>
      </listitem>

      <listitem>
        <para>A Scoped Subsystem (other than the Root Subsystem) must belong
        to a child Region of the Region to which the Subsystem's parents
        belong.</para>
      </listitem>
    </itemizedlist>

    <para>When a Subsystem is installed using a Subsystem service <xref
    linkend="org.osgi.service.subsystem.Subsystem.install-String-"
    xrefstyle="hyperlink"/> or <xref
    linkend="org.osgi.service.subsystem.Subsystem.install-String-InputStream-"
    xrefstyle="hyperlink"/> method the <emphasis>Subsystem resource
    </emphasis>becomes a constituent of the Subsystem which the
    <code>install</code> method was called on. The <emphasis>Subsystem
    resource </emphasis>is the Subsystem Archive and may be retrieved by
    calling the Subsystem service <xref
    linkend="org.osgi.service.subsystem.Subsystem.getConstituents--"
    xrefstyle="hyperlink"/> method. <xref linkend="i3298109"/> illustrates the
    Root Subsystem with initial bundles <code>A</code>, <code>B</code>,
    <code>SI</code> (Subsystems implementation, may be multiple bundles), and
    the system bundle (identifier 0).</para>

    <figure xml:id="i3298464">
      <title>Subsystem resources</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="0.938in"
                     contentwidth="6.209in" fileref="subsystem-resources.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In <xref linkend="i3298464"/> Bundles <code>A</code>, <code>B</code>
    and <code>SI</code> are considered constituents of the Root Subsystem. The
    system bundle is also considered to be a constituent of the Root Subsystem
    (bundle zero). A Subsystem service <code>R</code> is registered that
    represents the Root Subsystem. When Subsystems are installed using the
    Root Subsystem then these Subsystem resources become constituents of the
    Root Subsystem and the Subsystems become child Subsystems of the Root
    Subsystem. For example, <xref linkend="i3328151"/> illustrates the Root
    Subsystem with Scoped Subsystem <code>S1</code> with constituent bundles
    <code>C</code> and <code>D</code> and Scoped Subsystem <code>S2</code>
    with constituent bundles <code>E</code> and <code>F</code>:</para>

    <figure xml:id="i3328151">
      <title>Subsystems</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.565in"
                     contentwidth="6.209in" fileref="subsystems.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The two Subsystems <code>S1</code> and <code>S2</code> have the same
    parent and Subsystems <code>S1</code> and <code>S2</code> are children of
    the Root Subsystem. <xref linkend="i3328220"/> shows a more complicated
    tree that has both Scoped and Unscoped Subsystems installed. This figure
    omits the constituent resources and Subsystem services:</para>

    <figure xml:id="i3328220">
      <title>Parent Child Relationship with Unscoped Subsystems</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.310in"
                     contentwidth="6.209in"
                     fileref="parent-child-unscoped.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Prevent Cycles and Recursion</title>

      <para>It is possible to end up with cycles in the parent <phrase
      role="symbol">→</phrase> child relationships between Subsystems
      contained in the same Region. <xref linkend="i3328641"/> illustrates
      this.</para>

      <figure xml:id="i3328641">
        <title>Subsystems and cycles</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.095in"
                       contentwidth="6.209in" fileref="subsystems-cycles.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>In this example Subsystem S1 has been installed. The Scoped
      Subsystem <code>S1</code> has included in its constituents the Unscoped
      Subsystems <code>U1</code> and <code>U2</code>. Furthermore<code>
      U1</code> has included the Unscoped Subsystem <code>U2</code> as a
      constituent and <code>U2</code> has included the Unscoped Subsystem
      <code>U1</code> as a constituent. This causes Unscoped Subsystem
      <code>U1</code> to have parents <code>S1</code> and <code>U2</code> and
      Unscoped Subsystem <code>U2</code> to have parents <code>S1</code> and
      <code>U1</code>. There is now a cycle between the Subsystems
      <code>U1</code> and <code>U2</code>. Subsystems implementations must
      detect this cycle and fail the installation of such a degenerative
      Subsystem. The top level Subsystem being installed must fail the install
      operation by throwing a Subsystem Exception. In this case the install
      operation of the <code>S1</code> Subsystem must fail with a Subsystem
      Exception being thrown.</para>

      <para>Cycles may also exist in the definition of Scoped Subsystems which
      includes other child Subsystems. <xref linkend="i3329066"/> illustrates
      this.</para>

      <figure xml:id="i3329066">
        <title>Scoped Subsystems and cycles</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="0.556in"
                       contentwidth="6.209in"
                       fileref="scoped-subsystems-cycles.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>In this example the Scoped Subsystem <code>S1</code> includes as a
      child the Scoped Subsystem <code>S2</code>. The <code>S2</code>
      Subsystem also includes as a child the Scoped Subsystem <code>S1</code>.
      Subsystems implementations must detect this and fail the installation of
      such a degenerative Subsystem. The top level Subsystem being installed
      must fail the install operation by throwing a Subsystem Exception. In
      this case the install operation of the first <code>S1</code> Subsystem
      must fail by throwing a Subsystem Exception.</para>
    </section>
  </section>

  <section xml:id="i3346687">
    <title>Determining Content</title>

    <para>A Subsystem definition may declare different types of
    <emphasis>content resources</emphasis>. A Subsystems implementation may
    support additional types, but the following types must be
    supported:</para>

    <itemizedlist>
      <listitem>
        <para><code>osgi.bundle</code></para>
      </listitem>

      <listitem>
        <para><code>osgi.fragment</code></para>
      </listitem>

      <listitem>
        <para><code>osgi.subsystem.application</code></para>
      </listitem>

      <listitem>
        <para><code>osgi.subsystem.feature</code></para>
      </listitem>

      <listitem>
        <para><code>osgi.subsystem.composite</code></para>
      </listitem>
    </itemizedlist>

    <para>A Subsystems implementation is free to support additional content
    types as value-add, but an implementation is required to fail the
    installation of a Subsystem which declares content resource types which
    are not recognized by the implementation.</para>

    <para>The individual content resources may be specified in the following
    ways:</para>

    <itemizedlist>
      <listitem>
        <para>The Subsystem-Content header, or</para>
      </listitem>

      <listitem>
        <para>The entries of the Subsystem Local Repository, see <xref
        linkend="i3385009"/>.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="i3321875">
      <title>Subsystem-Content Header</title>

      <para>The Subsystem-Content header contains a list of symbolic names,
      with optional attribute and directive assertions. Each element specifies
      a single resource that is to be a content resource of the Subsystem. See
      also <xref linkend="i3329153"/>. The Subsystem-Content header must
      conform to the following syntax:</para>

      <programlisting>Subsystem-Content ::= resource ( ','resource )*
resource          ::= symbolic-name ( ';' parameter )*</programlisting>

      <para>The Subsystem-Content header may specify the following
      directives:</para>

      <itemizedlist>
        <listitem>
          <para><code>resolution</code> - (<code>mandatory</code>|
          <code>optional</code>) A <code>mandatory</code> content resource
          prevents the Subsystem from successfully installing when the
          constituent cannot be found (or satisfied); an optional content
          resource allows a Subsystem to successfully install even if the
          content cannot be found (or satisfied). The default value is
          <code>mandatory</code>.</para>
        </listitem>

        <listitem>
          <para><code>start-order</code> - (<code>Integer &gt;= 1</code>)
          Specifies the start order of the content resource in relation to
          other content resources of the Subsystem. See <xref
          linkend="i3329174"/>.</para>
        </listitem>
      </itemizedlist>

      <para>The Subsystem-Content header may specify the following architected
      matching attributes as well as any arbitrary matching attributes:</para>

      <itemizedlist>
        <listitem>
          <para><code>version</code> - (<code>Version</code>) A version range
          used to select the version of the resource to use. This follows the
          OSGi version range scheme, including the default value of
          0.0.0.</para>
        </listitem>

        <listitem>
          <para><code>type</code> - Indicates the type of the content. It is
          recommended that a reverse domain name convention is used unless
          those types and their processing is standardized by the OSGi
          Alliance, for example bundles. The default type is
          <code>osgi.bundle</code>. A Subsystems implementation may support
          additional types, but the following types must be supported:</para>

          <itemizedlist>
            <listitem>
              <para><code>osgi.bundle</code></para>
            </listitem>

            <listitem>
              <para><code>osgi.fragment</code></para>
            </listitem>

            <listitem>
              <para><code>osgi.subsystem.application</code></para>
            </listitem>

            <listitem>
              <para><code>osgi.subsystem.composite</code></para>
            </listitem>

            <listitem>
              <para><code>osgi.subsystem.feature</code></para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>For example, the following header specifies three Subsystem
      constituents:</para>

      <programlisting>Subsystem-Content:
    org.acme.billing.impl;
        type=osgi.bundle;
        version=1.0,
    org.acme.billing.frag;
        type=osgi.fragment;
        version=1.0,
    org.acme.billing.credit.subsystem;
        type=osgi.subsystem.composite;
        version=1.0</programlisting>

      <para>The above header specifies three content resources of a
      Subsystem:</para>

      <itemizedlist>
        <listitem>
          <para>A bundle resource with the symbolic name
          <code>org.acme.billing.impl</code> at <code>version</code> 1.0 or
          greater</para>
        </listitem>

        <listitem>
          <para>A fragment resource with the symbolic name
          <code>org.acme.billing.frag</code> at <code>version</code> 1.0 or
          greater</para>
        </listitem>

        <listitem>
          <para>A child composite Subsystem resource with the symbolic name
          <code>org.acme.billing.credit.subsystem</code> at
          <code>version</code> 1.0 or greater</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3329687">
      <title>Subsystem-Content Requirements</title>

      <para>Each element of the Subsystem-Content header is used to locate a
      resource that is to be used as content of the Subsystem. One way of
      describing the elements of the Subsystem-Content header is in terms of a
      Requirement using the <code>osgi.identity</code> namespace. The
      Requirement is defined in <xref linkend="i3394044"/>. To illustrate, a
      single Subsystem-Content element:</para>

      <programlisting>org.acme.billing.impl; 
    type=osgi.bundle;
    version=1.0</programlisting>

      <para>This Subsystem-Content header can be converted into the following
      <code>osgi.identity</code> Requirement with the Require-Capability
      syntax for illustration:</para>

      <programlisting>osgi.identity;
    filter:="(&amp;
        (osgi.identity=org.acme.billing.impl)
        (type=osgi.bundle)
        (version&gt;=1.0)
    )"</programlisting>

      <para>All directives specified on the Subsystem-Content header, except
      <code>start-order</code>, should be included in the Requirement. All
      attributes should be included in the <code>filter</code> directive of
      the Requirement. Notice that the <code>version</code> attribute is a
      range and must be converted into a proper filter. The
      <code>VersionRange.toFilter</code> method can be used to do this
      conversion. All other matching attributes are treated as type String and
      use an equality operation in the filter. Here is an example of a more
      complex transformation to Requirement:</para>

      <programlisting>org.acme.billing.credit.subsystem;
    type=osgi.subsystem.composite;
    version="[1.0, 1.1)";
    category=banking;
    resolution:=optional;
    start-order:=1</programlisting>

      <para>The above Subsystem-Content element converts into the following
      <code>osgi.identity</code> Requirement:</para>

      <programlisting>osgi.identity; 
    filter:="(&amp;
        (osgi.identity=org.acme.billing.impl)
        (type=osgi.subsystem.composite)
        (&amp;(version&gt;=1.0)(!(version&gt;=1.1))
            (category=banking)
        )"
    resolution:=optional</programlisting>
    </section>

    <section xml:id="i3321603">
      <title>Preferred-Provider Header</title>

      <para>The Preferred-Provider header contains a list of symbolic names,
      with optional attributes assertions. Each element specifies a single
      bundle or Subsystem resource that is to be preferred when resolving the
      requirements of the Subsystem content resources. The Preferred-Provider
      header must conform to the following syntax:</para>

      <programlisting>Preferred-Provider ::= resource (',' resource )*
resource           ::= symbolic-name ( ';' attribute )*</programlisting>

      <para>The Preferred-Provider header may specify the following
      architected matching attributes:</para>

      <itemizedlist>
        <listitem>
          <para><code>version</code> - (<code>Version</code>) A version range
          used to select the version of the bundle or Subsystem to use. This
          follows the OSGi version range scheme, including the default value
          of 0.0.0.</para>
        </listitem>

        <listitem>
          <para><code>type</code> - (String) Indicates the type of the
          provider. Valid types are:</para>

          <itemizedlist>
            <listitem>
              <para><code>osgi.bundle</code></para>
            </listitem>

            <listitem>
              <para><code>osgi.subsystem.composite</code></para>
            </listitem>

            <listitem>
              <para><code>osgi.subsystem.feature</code></para>
            </listitem>
          </itemizedlist>

          <para>The default type is <code>osgi.subsystem.composite</code>.
          Specifying an unsupported type results in an installation
          failure.</para>
        </listitem>
      </itemizedlist>

      <para>Each element of the Preferred-Provider header is used to locate a
      resource that is to be used as a preferred provider of the Subsystem.
      The Preferred-Provider header elements are converted to Requirements
      using the <code>osgi.identity</code> namespace just like the
      Subsystem-Content header except the default type is
      <code>osgi.subsystem.composite</code>. See <xref
      linkend="i3329687"/>.</para>

      <para>Because this header influences resolution, it is only valid for it
      to be used on a Scoped Subsystem. If a Subsystems implementation
      encounters this header on an Unscoped Subsystem, it must fail the
      installation of the Subsystem.</para>

      <para>The Preferred-Provider header has the effect of influencing the
      import policy into the Region representing the Scoped Subsystem that
      specified the header. If there are multiple candidate capabilities for a
      requirement and one or more of those capabilities is from a bundle or
      Subsystem identified in the Preferred-Provider header, then the Region
      import policy must prefer the capabilities from the preferred bundle or
      Subsystem.</para>

      <para>A resource may be considered as a preferred provider only if it is
      a constituent of either the Scoped Subsystem's or any ancestor's
      Region.</para>
    </section>

    <section xml:id="i3385009">
      <title>Resource Repositories</title>

      <para>When a Subsystem is installed the Subsystems implementation is
      responsible for provisioning resources that are associated with the
      Subsystem. For example, the Subsystem's content resources as well as any
      resources that are needed to satisfy dependencies of a Subsystem's
      content resources. During the Subsystem install process the Subsystems
      implementation uses a defined set of repositories to find the required
      resources needed to install a Subsystem. This set of repositories
      includes the following:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Local Repository</emphasis> - Contains the resources
          included in the Subsystem Archive, see <xref
          linkend="i3329832"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>System Repository</emphasis> - Contains the
          resources currently installed, see <xref linkend="i3329893"/></para>
        </listitem>

        <listitem>
          <para><emphasis>Repository Services</emphasis> - The set of
          repositories registered as OSGi services, see <xref
          linkend="i3329894"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Content Repository</emphasis> - The set of resources
          that comprise the Subsystem content, see <xref
          linkend="i3329906"/></para>
        </listitem>

        <listitem>
          <para><emphasis>Preferred Repository</emphasis> - The set of
          resources that are considered preferred providers, see <xref
          linkend="i3329932"/>.</para>
        </listitem>
      </itemizedlist>

      <section xml:id="i3329832">
        <title>Local Repository</title>

        <para>The Root of the Subsystem Archive contains 0 or more resources.
        The Subsystems implementation must read all entries (except directory
        entries) in the Root of the Subsystem Archive and treat each entry as
        a potential resource. One way of describing the resource entries
        contained in the Root of the Subsystem Archive is in the terms of an
        <code>Repository</code> implementation. For the purpose of this
        specification these resources are referred to as the Subsystem's
        <emphasis>Local Repository</emphasis>. The Local Repositories must not
        be registered as an OSGi Repository service. Also, it is not required
        that the Subsystem implementation actually implement a Local
        Repository as a concrete implementation of the Repository service
        interface.</para>
      </section>

      <section xml:id="i3329893">
        <title>System Repository</title>

        <para>The term <emphasis>System Repository</emphasis> is used to
        describe the set of resources that are constituents of one or more of
        the currently installed Subsystems. The System Repository must not be
        registered as an OSGi service. Also it is not required that System
        Repository be implemented as a concrete implementation of the
        Repository service. There is a single System Repository representing
        the resources installed in the OSGi framework.</para>
      </section>

      <section xml:id="i3329894">
        <title>Repository Services</title>

        <para>The repositories which are registered as Repository services,
        see <xref linkend="service.repository"/>. These Repositories are used
        to discover Subsystem content resources and dependencies. A Subsystems
        implementation searches registered Repository services by service
        ranking order.</para>
      </section>

      <section xml:id="i3329906">
        <title>Content Repository</title>

        <para>The set of content resources for a Subsystem is referred to as
        the Subsystem's Content Repository. Similar to the Local and System
        Repositories, the Content Repositories must not be registered as an
        OSGi service and it is not required that the Subsystems implementation
        actually implement a Content Repository as a concrete implementation
        of the Repository service. There are two types of resources that can
        exist in a Subsystem's Content Repository:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Installable Content</emphasis> - A content
            resource which must be installed and result in a distinct resource
            at runtime. That is, a distinct bundle or Subsystem
            installation.</para>
          </listitem>

          <listitem>
            <para><emphasis>Shared Content</emphasis> - A content resource
            which is already installed and is a constituent of one or more
            already installed Subsystems that belong to the same Region as the
            Subsystem that the Subsystem content repository is for. This
            resource must be reused, the Subsystems implementation must not
            install another instance of the resource.</para>
          </listitem>
        </itemizedlist>

        <para>Details on how the content resources are discovered for the
        Content Repository are discussed in <xref linkend="i3329153"/>.</para>
      </section>

      <section xml:id="i3329932">
        <title>Preferred Repository</title>

        <para>The set of resources which are considered preferred providers of
        capabilities required by a Subsystem is referred to as the Preferred
        Provider Repository for the Subsystem. The Preferred Provider
        Repository for a Subsystem must not be registered as an OSGi service
        and it is not required that the Subsystems implementation actually
        implement the Preferred Provider Repository as a concrete
        implementation of the Repository service.</para>

        <para>The following steps must be followed to discover the resources
        of the preferred provider repository for a Subsystem:</para>

        <orderedlist>
          <listitem>
            <para>The Preferred-Provider header is parsed into a list of
            elements where each element specifies a single
            <code>osgi.identity</code> requirement, see <xref
            linkend="i3321603"/>.</para>
          </listitem>

          <listitem>
            <para>For each <code>osgi.identity</code> requirement a
            <code>Requirement</code> object is created and used to search
            Repositories for preferred provider resources.</para>
          </listitem>

          <listitem>
            <para>The System Repository is searched. For each capability found
            in the System Repository; if the resource providing the
            <code>osgi.identity</code> capability is a constituent contained
            in the parent Region of the Scoped Subsystem's Region then the
            providing Resource of the Capability is considered a preferred
            provider and the search stops; otherwise continue to the next
            step.</para>
          </listitem>

          <listitem>
            <para>The Subsystem's Local Repository is searched. If a
            capability is found then the providing resource is used as a
            preferred provider and the search stops; otherwise continue to the
            next step.</para>
          </listitem>

          <listitem>
            <para>The registered Repository services are searched. If a
            repository service finds a capability then the providing resource
            is used as a preferred provider and the search stops; otherwise
            the preferred provider is not found.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section xml:id="i3329153">
      <title>Discovering Content Resources</title>

      <para>When a Subsystem is installed the Subsystems implementation must
      determine the set of resources that compose the content of the
      Subsystem. The content resources of a Subsystem may be specified in the
      following ways:</para>

      <itemizedlist>
        <listitem>
          <para>The values of the Subsystem-Content header must be used if it
          is present. See <xref linkend="i3321875"/>.</para>
        </listitem>

        <listitem>
          <para>The content of the Subsystem's Local Repository, if the
          Subsystem-Content header is not present.</para>
        </listitem>
      </itemizedlist>

      <para>When a Deployment Manifest is not present, <xref
      linkend="i3330073"/>, the Subsystems implementation must use this
      information to discover the content resources for a Subsystem as
      described in the following sections.</para>

      <section>
        <title>Declared Subsystem-Content</title>

        <para>If the Subsystem-Content manifest header is declared then the
        following steps must be followed to discover the Subsystem's
        contents:</para>

        <itemizedlist>
          <listitem>
            <para>The Subsystem-Content header is parsed into a list of
            elements where each element specifies a single
            <code>osgi.identity</code> requirement. For each
            <code>osgi.identity</code> requirement element a Requirement is
            created and used to search Repositories for content
            resources.</para>

            <itemizedlist>
              <listitem>
                <para>If the Subsystem is a Scoped Subsystem then continue to
                the next step; otherwise if the Subsystem is an Unscoped
                Subsystem then the System Repository must be searched in order
                to discover any currently installed resources that match the
                content Requirement. For each matching capability found it
                must be determined if the capability provider Resource is a
                constituent of a Subsystem which is in the same Region as the
                installing Subsystem; if so then the provider Resource must be
                used as an <emphasis>shared content</emphasis> resource. If no
                <emphasis>shared content</emphasis> resource is found then
                continue to the next step; otherwise the search stops.</para>
              </listitem>

              <listitem>
                <para>The Subsystem's Local Repository is searched to find a
                matching Capability for the content Requirement. If a
                Capability is found then the providing Resource of the
                Capability is used as an <emphasis>installable
                content</emphasis> resource of the Subsystem. If no
                <emphasis>installable content</emphasis> resource is found
                then continue to the next step, otherwise the search
                stops.</para>
              </listitem>

              <listitem>
                <para>The registered Repository services are searched to find
                a matching capability for the content Requirement. If a
                Repository finds a provider for the content requirement then
                the provider Resource of the capability is used as an
                <emphasis>installable content</emphasis> resource of the
                Subsystem. If no matching provider is found then the discovery
                of the content resource has failed.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Use Subsystem Local Repository</title>

        <para>If the Subsystem-Content header is not declared then the list of
        content resources is defined as all the Resources within the
        Subsystem's Local Repository which provide an
        <code>osgi.identity</code> capability with the type attribute
        of:</para>

        <itemizedlist>
          <listitem>
            <para><code>osgi.bundle</code></para>
          </listitem>

          <listitem>
            <para><code>osgi.fragment</code></para>
          </listitem>

          <listitem>
            <para><code>osgi.subsystem.application</code></para>
          </listitem>

          <listitem>
            <para><code>osgi.subsystem.composite</code></para>
          </listitem>

          <listitem>
            <para><code>osgi.subsystem.feature</code></para>
          </listitem>

          <listitem>
            <para>Any other type that is supported by the
            implementation.</para>
          </listitem>
        </itemizedlist>

        <para>If a resource is found to be an unsupported type then
        installation of the Subsystem must fail.</para>

        <para>For Scoped Subsystems this list is used as is and each Resource
        is considered an installable content resource. For Unscoped Subsystems
        the System Repository must be searched in order to determine if there
        are any already installed contents resources which may be used as a
        <emphasis>shared content</emphasis> resources. If no shared content
        resource can be found then the resource is considered an
        <emphasis>installable content</emphasis> resource.</para>
      </section>
    </section>
  </section>

  <section xml:id="i3330142">
    <title>Determining Dependencies</title>

    <para>When a Subsystem is installed the Subsystems implementation
    determines the set of resources that compose the content of the Subsystem.
    Content resources may have requirements on capabilities that are not
    provided by any of the content resources for the Subsystem. When a
    Subsystem is installed the Subsystems implementation must determine the
    set of additional resources that are required in order to allow the
    Subsystem's content resources to resolve. These additional resources are
    called <emphasis>dependencies</emphasis>. When a Subsystem is installed
    the set of dependencies contains two types of resources:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Installable Dependency</emphasis> - A resource which
        must be installed and result in a distinct resource at runtime. That
        is, a distinct bundle or Subsystem installation.</para>
      </listitem>

      <listitem>
        <para><emphasis>Preinstalled Dependency</emphasis> - A resource which
        is already installed and is a constituent of one or more already
        installed Subsystems and the required capabilities provided by the
        resource are accessible according to the sharing policies of the
        Subsystems. This resource must be reused, the Subsystems
        implementation must not install another instance of the
        resource.</para>
      </listitem>
    </itemizedlist>

    <para>When a Deployment Manifest is not present, see <xref
    linkend="i3330073"/>, the Subsystems implementation must determine the set
    of dependencies for the Subsystem. To determine the set of dependencies
    the Subsystems implementation should attempt to resolve the Subsystem
    content resources before installing the content resources. One possible
    way of resolving the content resources, before installing them, is to use
    a Resolver service, see <xref linkend="service.resolver"/>. This
    specification illustrates the behavior of dependency resource discovery
    using terms defined by the Resolver service. A Subsystems implementation
    is not required to use the Resolver service to accomplish dependency
    resource discovery. Other mechanisms may be used to accomplish the same
    goal as long as the resolution results in a valid class space. Subsystems
    implementations need not guarantee to find a solution to every resolution
    problem, but if a valid solution is not found, then discovery of the
    dependencies must fail, resulting in an installation failure.</para>

    <para>In order to use the Resolver service the Subsystems implementation
    has to provide a <code>ResolveContext</code> object that represents the
    currently installed Subsystems and their constituent resources. This
    resolve context must search Repositories in the following order when
    searching for capabilities to satisfy content dependencies within the
    <code>ResolveContext.findProviders</code> method. All repositories must be
    searched, with Repository services being optional unless a matching 
    capability has not yet been found. The order of matching capabilities
    presented to the Resolver must coincide with the Repository search order.</para>

    <orderedlist>
      <listitem xml:id="service.subsystem-determiningdependencies1">
        <para>The Content Repository.</para>
      </listitem>

      <listitem>
        <para>The Preferred Provider Repository.</para>
      </listitem>

      <listitem>
        <para>The System Repository. For each matching capability found in the
        System Repository the Subsystems implementation must determine if the
        capability is accessible to the content resources of the installing
        Subsystem according to the sharing policy of the Subsystem. See <xref
        linkend="i3328531"/> for more details on Subsystem types and their
        sharing policies.</para>
      </listitem>

      <listitem>
        <para>The Local Repository. This allows a Subsystem Archive to 
        optionally include dependencies.</para>
      </listitem>

      <listitem>
        <para>The registered Repository services.</para>
      </listitem>
    </orderedlist>

    <para>Any matching capabilities found in the steps after step <xref
    linkend="service.subsystem-determiningdependencies1"/> above are
    considered to be provided by potential dependencies for the Subsystem. The
    capabilities found in the System Repository are provided by already
    installed resources, referred to as potential <emphasis>pre-installed
    dependencies</emphasis>. The capabilities found which are provided by
    other potential dependencies must be installed in order to resolve the
    Subsystem content resources, referred to as <emphasis>installable
    dependencies</emphasis>.</para>

    <para>The Resolver's job is to select one of the potential capabilities
    returned by the <code>findProviders</code> method as the capability to
    satisfy a Requirement. At the end of a resolve operation a result
    (<code>Map&lt;Resource, List&lt;Wire&gt;</code>) is returned which
    contains the Resources that got resolved and a list containing the Wires
    for the resolved Resource. The Subsystems implementation uses this
    resolution result in order to determine which resolved Resources are
    content resources, pre-installed dependencies, or installable
    dependencies. The installable dependencies must be installed as described
    in <xref linkend="i3323024"/>. The pre-installed dependencies must have
    their reference count incremented as described in <xref
    linkend="i3365854"/>.</para>
  </section>

  <section xml:id="i3323024">
    <title>Accepting Dependencies</title>

    <para>When a Subsystem is installed the Subsystems implementation must
    determine the set of installable dependencies as described in <xref
    linkend="i3330142"/>. The Subsystems implementation must also determine
    what Subsystem is willing to accept the installable dependency as a
    constituent, referred to as an <emphasis>accepted dependency
    constituent</emphasis>. A Subsystem declares that it is willing to accept
    dependencies as constituents by specifying the
    <code>provision-policy</code> directive with the
    <code>acceptDependencies</code> value on the Subsystem-Type header, see
    <xref linkend="i3322247"/>.</para>

    <para>The <code>acceptDependencies</code> provision policy is useful for
    creating isolation layers that do not pollute parent Regions with
    dependencies. For example, an application container may be implemented as
    a Subsystem. Such a container Subsystem could be installed into something
    called a kernel Subsystem. Applications are installed as Subsystems into
    the container Subsystem. In this case the container Subsystem would likely
    use the <code>acceptDependencies</code> provision policy so that any
    applications installed into the container Subsystem do not end up
    polluting the kernel Subsystem with the application's dependencies.</para>

    <para>A dependency becomes an accepted dependency constituent of the
    Subsystem with a provision policy of <code>acceptDependencies</code> and
    that lies on the longest path between the Root Subsystem and the Subsystem
    being installed, inclusively. Note that a Subsystem that has
    <code>acceptDependencies</code> provision policy will accept its own
    installable dependencies as constituents since it lies on the longest path
    between the Root Subsystem and itself, inclusively.</para>

    <para>The following figure illustrates a simple example of accepting
    dependency constituents. A Scoped Subsystem <code>S2</code> is being
    installed into another Scoped Subsystem <code>S1</code> and
    <code>S1</code> has a <code>provision-policy</code> of
    <code>acceptDependencies</code>. When <code>S2</code> is being installed
    the Subsystems implementation discovers content resources <code>A</code>
    and <code>B</code> and installable dependencies <code>C</code> and
    <code>D</code>. This is depicted in <xref linkend="i3330314"/>.</para>

    <figure xml:id="i3330314">
      <title>Provision Policy</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="0.830in"
                     contentwidth="6.209in" fileref="provision-policy1.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In the previous example the Subsystem with a
    <code>provision-policy</code> of <code>acceptDependencies</code> and that
    lies on the longest path between the Root Subsystem and the Subsystem
    being installed is <code>S1</code>. Therefore the installable dependencies
    <code>C</code> and <code>D</code> become accepted dependency constituents
    of <code>S1</code>.</para>

    <para><xref linkend="i3354897"/> illustrates the same example but with
    <code>S2</code> also having a <code>provision-policy</code> of
    <code>acceptDependencies</code></para>

    <figure xml:id="i3354897">
      <title>Provision Policy</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.112in"
                     contentwidth="6.209in" fileref="provision-policy2.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In this example the Subsystem with a <code>provision-policy</code>
    of <code>acceptDependencies</code> and that lies on the longest path
    between the Root Subsystem and the Subsystem being installed is
    <code>S2</code> itself. Therefore the installable dependencies
    <code>C</code> and <code>D</code> become accepted dependency constituents
    of <code>S2</code>.</para>

    <para><xref linkend="i3331477"/> illustrates the same example but with
    <code>S1</code> and <code>S2</code> not defining the
    <code>provision-policy</code> (default is
    <code>rejectDependencies</code>). The Root Subsystem always has a
    <code>provision-policy</code> of <code>acceptDependencies</code>:</para>

    <figure xml:id="i3331477">
      <title>Subsystems and acceptDependencies</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="0.797in"
                     contentwidth="6.209in" fileref="acceptdependencies.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In this example the Subsystem with a provision policy of
    acceptDependencies and that lies on the longest path between the Root
    Subsystem and the Subsystem being installed is the Root Subsystem.
    Therefore the installable dependencies <code>C</code> and <code>D</code>
    become accepted dependency constituents of the Root Subsystem.</para>
  </section>

  <section xml:id="i3328531">
    <title>Sharing Capabilities</title>

    <para>Scoped Subsystems define a sharing policy for the Region they are
    contained in. A sharing policy controls access to capabilities between
    parent <phrase role="symbol">→</phrase> child Region boundaries. For
    Subsystems, a sharing policy is composed of two parts: an import policy
    and an export policy:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Export Policy</emphasis> - Defines the set of
        capabilities provided by the constituents contained in the Region that
        are made available to the parent Region.</para>
      </listitem>

      <listitem>
        <para><emphasis>Import Policy</emphasis> - Defines the set of
        capabilities which are available in the parent Region that are made
        available to the child Region.</para>
      </listitem>
    </itemizedlist>

    <para>The import sharing policies of a Subsystem's ancestor parent chain
    may prevent a Subsystem from accessing the required capabilities provided
    by a dependency. <xref linkend="i3333158"/> illustrates this.</para>

    <figure xml:id="i3333158">
      <title>Sharing Capabilities</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.408in"
                     contentwidth="6.209in" fileref="sharing-capabilities.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In this example the <code>C</code> and <code>D</code> provide
    capabilities that are required by <code>A</code> and <code>B</code>
    respectively. The import sharing policy of <code>S</code>2 allows the
    capabilities to be imported into <code>S2</code>, but the import sharing
    policy for <code>S1</code> denies the import of one of the capabilities
    and allows the other. In order for <code>A</code> or <code>B</code> to
    access capabilities provided by <code>C</code> or <code>D</code> they must
    traverse both the import sharing policy of <code>S2</code> and
    <code>S1</code>. Ultimately <code>S1</code> sharing policy prevents the
    necessary access to the dependencies necessary to resolve <code>S2</code>.
    Such a situation must be detected during the discovery of the installable
    dependencies and result in a failure to install the dependencies. This
    must result in the failure to install the Subsystem that requires the
    dependency, in this case <code>S2</code>.</para>

    <section xml:id="i3321523">
      <title>Preferred Provider</title>

      <para>The sharing policy for a Scoped Subsystem may specify a set of
      preferred providers. If a capability is provided by a preferred provider
      then that capability must be used to resolve a Scoped Subsystem's import
      policy. <xref linkend="i3333158"/> illustrates this.</para>

      <figure>
        <title>Preferred Provider</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="0.968in"
                       contentwidth="6.209in" fileref="preferred-provider.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>In this example constituent <code>B</code> of the Root Region
      provides the capability <code>X</code> (called <code>Root</code><phrase
      role="symbol">→</phrase><code>X</code>). Also constituent <code>C</code>
      of <code>S2Region</code> provides the capability <code>S2</code><phrase
      role="symbol">→</phrase><code>X</code>. The export sharing policy of
      <code>S2</code> policy exports the capability <code>S2</code><phrase
      role="symbol">→</phrase><code>X</code> to its parent Region, the
      <code>RootRegion</code>. The <code>S1Region</code> contains a
      constituent A that has a requirement on <code>S1</code><phrase
      role="symbol">→</phrase><code>X</code>. The two capabilities,
      <code>Root</code><phrase role="symbol">→</phrase><code>X</code> and
      <code>S2</code><phrase role="symbol">→</phrase><code>X</code>, are
      available to satisfy the requirement <code>S1</code><phrase
      role="symbol">→</phrase><code>X</code>. The <code>S1Region</code>'s
      import sharing policy imports capability <code>X</code> and has a
      preferred provider of <code>S2</code>. This means that the capability
      <code>S2</code><phrase role="symbol">→</phrase><code>X</code> must be
      used to satisfy the requirement <code>S1</code><phrase
      role="symbol">→</phrase><code>X</code>.</para>
    </section>
  </section>

  <section xml:id="i3345965">
    <title>Region Context Bundle</title>

    <para>The Region context bundle provides a perspective from a constituent
    of a Subsystem contained in the Region. When a Scoped Subsystem is
    installed the Subsystems implementation must generate the Region context
    bundle and install it as a constituent bundle of the Subsystem. The Region
    context bundle has the following characteristics:</para>

    <itemizedlist>
      <listitem>
        <para>Has a symbolic name of
        <code>org.osgi.service.subsystem.region.context.&lt;subsystem
        id&gt;</code></para>
      </listitem>

      <listitem>
        <para>Version 1.0.0</para>
      </listitem>

      <listitem>
        <para>Has a location string of <code>&lt;subsystem
        location&gt;/&lt;subsystem id&gt;</code></para>
      </listitem>

      <listitem>
        <para>Must always be allowed to resolve and start (i.e. has no
        requirements, imports or bundle activator).</para>
      </listitem>

      <listitem>
        <para>Has a start-level of 1 and is persistently started.</para>
      </listitem>

      <listitem>
        <para>Is installed and started before the Subsystem service is
        registered.</para>
      </listitem>
    </itemizedlist>

    <para>This bundle is installed and must remain active as long as the
    Subsystem is installed. If the Region context bundle is stopped, updated
    or uninstalled then the Subsystem runtime should log an error and may
    ensure the context bundle is installed and restarted.</para>

    <para>When the Subsystems implementation is active it must establish the
    Root Subsystem, see <xref linkend="i3333429"/>. In establishing the Root
    Subsystem the Subsystems implementation must ensure that there is a Region
    context bundle available for the Root Region. This Root Region context
    bundle will have a symbolic name of
    <code>org.osgi.service.subsystem.region.context.0</code>.</para>

    <para>Typically the Region's context bundle would be used to obtain a
    bundle context with the <xref
    linkend="org.osgi.service.subsystem.Subsystem.getBundleContext--"
    xrefstyle="hyperlink"/> method, which has a perspective as a constituent
    of the Region. This is useful in the following ways:</para>

    <itemizedlist>
      <listitem>
        <para>Implementing Subsystem aware extenders. Such extenders need to
        be able to register listeners and monitor the inside of a Region in
        order to react to the constituent bundles of a Region.</para>
      </listitem>

      <listitem>
        <para>Monitoring of internal events.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="i3346786">
    <title>Explicit and Implicit Resources</title>

    <para>Depending on how a resource is installed the Subsystems
    implementation considers the resource to be either an <emphasis>explicit
    resource </emphasis>or <emphasis> implicit resource</emphasis>. An
    <emphasis>explicit resource</emphasis> is a resource whose installation
    was initiated by an agent outside of the Subsystems implementation.
    An<emphasis> implicit resource</emphasis> is a resource whose installation
    was initiated by the Subsystems implementation during the explicit
    installation of a Subsystem, including the content and dependencies of the
    explicitly installed Subsystem.</para>

    <section xml:id="i3339411">
      <title>Explicit Resources</title>

      <para>An explicit resource is a resource that was installed
      programmatically, by an agent outside of the Subsystems implementation,
      using some resource specific API. This specification defines two types
      of resources that can be installed explicitly:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Subsystem resource</emphasis> - A Subsystem resource
          may be installed explicitly by using the Subsystem service. Note
          that content and dependencies of an explicitly installed Subsystem
          are not considered to be explicit resources themselves since they
          were implicitly installed by the Subsystems implementation.</para>
        </listitem>

        <listitem>
          <para><emphasis>Bundle resource</emphasis> - A bundle resource may
          be installed explicitly by using a bundle context. This includes
          fragments.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>Explicit Bundle Resources</title>

        <para>When a bundle is installed explicitly with a bundle context, the
        Subsystems implementation must determine the Subsystem of which a
        bundle becomes a constituent. The following rules are followed when a
        bundle is installed explicitly with a bundle context:</para>

        <orderedlist>
          <listitem>
            <para>Determine the bundle performing the install. This is the
            bundle whose Bundle Context is performing the install
            operation.</para>
          </listitem>

          <listitem>
            <para>Determine the target Region. This is the Region to which the
            bundle performing the install operation belongs.</para>
          </listitem>

          <listitem>
            <para>If a bundle with the same symbolic name and version already
            exists in the target Region then the bundle installation must fail
            unless the same location string is used. If the same location is
            used then the existing bundle is returned. This may be
            accomplished by the use of a bundle collision hook.</para>
          </listitem>

          <listitem>
            <para>Determine the Subsystem(s) of which the bundle performing
            the install is a constituent. The bundle performing the install
            may be a shared resource. In that case the bundle performing the
            install is a constituent of two or more Subsystems.</para>
          </listitem>

          <listitem>
            <para>The newly installed bundle must become a constituent of all
            the Subsystems of which the bundle performing the install is a
            constituent.</para>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>Explicit Subsystem Resources</title>

        <para>When a Subsystem is installed explicitly with a Subsystem
        service, the Subsystems implementation must determine what
        Subsystem(s) the Subsystem resource and its children will become a
        constituent of. The following rules are followed when a Subsystem is
        installed:</para>

        <orderedlist>
          <listitem>
            <para>Determine the target Subsystem. This is the Subsystem
            service which is performing the install operation or the Subsystem
            which includes another Subsystem as part of its content, see <xref
            linkend="i3346687"/>.</para>
          </listitem>

          <listitem>
            <para>Determine the target Region. This is the Region to which the
            target Subsystem belongs.</para>
          </listitem>

          <listitem>
            <para>If no Subsystem resource with the same location exists then
            continue to the next step; otherwise do the following:</para>

            <itemizedlist>
              <listitem>
                <para>If the existing Subsystem is not a part of the target
                Region then fail the install operation by throwing a Subsystem
                Exception; otherwise continue to the next step.</para>
              </listitem>

              <listitem>
                <para>If the existing Subsystem symbolic name, version and
                type is not the same as the Subsystem being installed then
                fail the install operation by throwing a Subsystem Exception;
                otherwise continue to the next step.</para>
              </listitem>

              <listitem>
                <para>If the existing Subsystem is already a constituent of
                the target Subsystem then return the existing Subsystem from
                the install method; otherwise the existing Subsystem resource
                becomes a shared resource by increasing the reference count of
                the existing Subsystem by one, see <xref linkend="i3365854"/>,
                and the existing Subsystem becomes a constituent of the target
                Subsystem; finally, the existing Subsystem is returned from
                the install method.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>If no Subsystem resource with the same symbolic-name and
            version already exists in the target Region then the Subsystem
            resource being installed becomes a constituent of the Subsystem
            target; otherwise do the following:</para>

            <itemizedlist>
              <listitem>
                <para>If the existing Subsystem type is not the same as the
                type of the Subsystem being installed then fail the install
                operation by throwing a Subsystem Exception; otherwise
                continue to the next sub-step.</para>
              </listitem>

              <listitem>
                <para>If the existing Subsystem is already a constituent of
                the target Subsystem then return the existing Subsystem from
                the install method; otherwise the existing Subsystem resource
                becomes a shared resource by increasing the reference count of
                the existing Subsystem by one and the existing Subsystem
                becomes a constituent of the target Subsystem; finally, the
                existing Subsystem is returned from the install method.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section>
      <title>Explicit Resource Example</title>

      <para>A scenario is used to illustrate the rules for determining which
      Subsystem an explicitly installed resource is a constituent. <xref
      linkend="i3336223"/> illustrates the Root Subsystem with initial content
      bundles <code>A</code>, <code>SI</code> (Subsystems implementation) and
      the system bundle (id = 0) installed.</para>

      <figure xml:id="i3336223">
        <title>Explicit Resource Example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.067in"
                       contentwidth="6.209in"
                       fileref="explicit-resource-example.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>If bundle <code>A</code> uses its own Bundle Context to explicitly
      install bundle <code>B</code> then bundle <code>B</code> becomes a
      constituent of the Root Subsystem. If bundle <code>A</code> uses
      Subsystem <code>R</code> to install Scoped Subsystem <code>S1</code>
      then the <code>S1</code> resource becomes a constituent of the
      <code>Root</code> Subsystem and <code>S1</code> Subsystem becomes a
      child of the <code>Root</code> Subsystem. <code>S1</code> contains
      constituent bundles <code>C</code> and <code>D</code>. Also, if bundle
      <code>B</code> uses Subsystem <code>R</code> to install Scoped Subsystem
      <code>S2</code> then the <code>S2</code> resource becomes a constituent
      of the <code>Root</code> Subsystem and the <code>S2</code> Subsystem
      becomes a child of the <code>Root</code> Subsystem. <code>S2</code>
      contains constituent bundles <code>E</code> and <code>F</code>. <xref
      linkend="i3361375"/> illustrates this.</para>

      <figure xml:id="i3361375">
        <title>Subsystems and Resources</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.408in"
                       contentwidth="6.209in"
                       fileref="subsystems-resources1.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Then if bundle <code>C</code> uses its own Bundle Context to
      install bundle <code>F</code> (using a different location string from
      constituent bundle <code>S2</code><phrase
      role="symbol">→</phrase><code>F</code>) then the bundle becomes a
      constituent of <code>S1</code>. If bundle <code>E</code> uses Subsystem
      service <code>S2</code> to install Unscoped Subsystem <code>U1</code>
      (with constituents <code>G</code> and <code>H</code>) and installs
      Unscoped Subsystem <code>U2</code> (with constituents <code>H</code> and
      <code>J</code>) then both Subsystem bundles <code>U1</code> and
      <code>U2</code> become constituents of <code>S2</code>. The
      <code>S2</code> Subsystem also becomes the parent Subsystem for both
      <code>U1</code> and <code>U2</code> Subsystems, see <xref
      linkend="i3336802"/>.</para>

      <figure xml:id="i3336802">
        <title>Subsystems and Resources</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.040in"
                       contentwidth="6.209in"
                       fileref="subsystems-resources2.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>In this scenario bundle H is a shared constituent of both U1 and
      U2 Subsystems. If bundle H installs a bundle K with its bundle context
      then bundle K becomes a shared constituent of both U1 and U2 Subsystems.
      Also, if Subsystem service U1 is used to install Scoped Subsystem S3 and
      Subsystem service U2 is also used to install Subsystem S3 then S3
      resource becomes a shared constituent of both Unscoped Subsystems U1 and
      U2. The following illustrates this:</para>

      <figure pgwide="1">
        <title>Subsystems and Resources</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.969in"
                       contentwidth="6.209in"
                       fileref="subsystems-resources3.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Since the S3 Subsystem resource is a shared constituent of both
      Subsystems U1 and U2 the S3 Subsystem has two parents: U1 and U2. In
      this case S3 Subsystem has two parent Subsystems but the S3Region still
      must only have one parent of S2Region. This is enforced by the rule that
      requires all of the parents of a Subsystem to belong to the same Region.
      For Scoped Subsystems the Region which contains all of the Subsystem's
      parents is parent Region.</para>

      <para>So far the examples have illustrated cases where the Root
      Subsystem has Scoped Subsystem children. It is also acceptable for an
      Unscoped Subsystem to be installed into the Root Region as the following
      figure illustrates:</para>

      <figure>
        <title>Subsystems and Resources</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.932in"
                       contentwidth="6.209in"
                       fileref="subsystems-resources4.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section xml:id="i3339635">
    <title>Resource References</title>

    <para>A Subsystems implementation must track the resources which are
    installed and determine which Subsystems reference a resource.
    The<emphasis> reference count</emphasis> indicates the number of installed
    Subsystems which reference an installed resource. The resource references
    and reference counts are used by the Subsystems implementation to
    determine if an installed resource is eligible for garbage collection and
    also plays a role in determining when a resource should be started and
    stopped, see <xref linkend="i3339345"/> ; the term reference count is only
    used to illustrate these concepts. The reference count of a resource is
    not exposed in the API of Subsystems. The following types of resources are
    referenced by a Subsystem:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Content Resources</emphasis> - These are the content
        resources which were installed when the Subsystem was installed, that
        is the resources declared in the Subsystem-Content header or from the
        Local Repository when the Subsystem-Content header is not specified,
        see <xref linkend="i3346687"/>. Content Resources are considered to be
        implicit resources.</para>
      </listitem>

      <listitem>
        <para><emphasis>Explicit Resources</emphasis> - These are constituent
        resources which are installed explicitly, see <xref
        linkend="i3339411"/>.</para>
      </listitem>

      <listitem>
        <para><emphasis>Dependencies</emphasis> - These resources provide
        capabilities required to satisfy requirements for a Subsystem's
        content resources, see <xref linkend="i3330142"/>. Dependencies are
        considered to be implicit resources.</para>
      </listitem>
    </itemizedlist>

    <para>Accepted dependency constituents are not defined as being referenced
    by the Subsystem of which they are a constituent unless constituent
    resource is a dependency for that Subsystem. Parent Subsystems are also
    not defined as being referenced by a child Subsystem.</para>

    <section xml:id="i3365854">
      <title>Reference Count</title>

      <para>When a Subsystem is being installed the Subsystems implementation
      must determine what resources are referenced by the Subsystem being
      installed. Each resource that is referenced by the Subsystem being
      installed will have its reference count incremented by 1. A top-level
      Subsystem being installed may contain child Subsystems. Each resource
      that is referenced by the child Subsystem being installed will have its
      reference count incremented by 1.</para>

      <para>When a Subsystem is being uninstalled the Subsystems
      implementation must determine what resources are referenced by the
      Subsystem being uninstalled. Each resource that is referenced by the
      Subsystem being uninstalled will have its reference count decremented by
      1. A top-level Subsystem being uninstalled may contain child Subsystems.
      Each resource that is referenced by each child Subsystem being
      uninstalled will have its reference count decremented by 1.</para>

      <para>When a reference count gets set to zero then the resource is
      eligible for garbage collection and will be uninstalled. A Subsystems
      implementation may perform the garbage collection immediately or
      postpone the garbage collection for later. If garbage collection is
      postponed then the Subsystems implementation must prevent any additional
      usage of capabilities provided by the resource which is to be
      uninstalled. The garbage collection must occur in a reasonable period of
      time.</para>

      <para>Bundle resources (including fragments) and Subsystem resources may
      be uninstalled explicitly. For example, uninstalling a Subsystem
      resource through the Subsystem service, or by other means outside of the
      Subsystems API such as uninstalling a bundle using a Bundle object. Each
      of the following must occur when a resource is explicitly
      uninstalled:</para>

      <itemizedlist>
        <listitem>
          <para>If the resource being explicitly uninstalled was not itself
          installed explicitly then an error must be logged indicating that
          the explicitly uninstalled resource still has one or more Subsystems
          referencing it.</para>
        </listitem>

        <listitem>
          <para>If the resource being explicitly uninstalled was itself
          installed explicitly and the reference count is greater than 1 then
          an error must be logged indicating that the explicitly uninstalled
          resource still has one or more Subsystems referencing it.</para>
        </listitem>

        <listitem>
          <para>The resource being explicitly uninstalled has its reference
          count set to 0 and finally the resource is uninstalled.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="i3339345">
    <title>Starting and Stopping Resources</title>

    <para>A Subsystem can be started by calling the Subsystem <emphasis>start
    </emphasis>method or the Subsystems implementation can automatically start
    the Subsystem if the Subsystem is <emphasis>ready </emphasis>and the
    <emphasis>autostart setting </emphasis>of the Subsystem indicates that it
    must be started.</para>

    <para>A Subsystem is <emphasis>ready</emphasis> if the Subsystem's parent
    is in the process of starting or is active. A started Subsystem may need
    to be automatically started again by the Subsystems implementation after a
    restart. The Subsystems implementation therefore maintains a persistent
    <emphasis>autostart setting</emphasis> for each Subsystem. This
    <emphasis>autostart setting</emphasis> can have the following
    values:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Stopped</emphasis> - The Subsystem should not be
        started.</para>
      </listitem>

      <listitem>
        <para><emphasis>Started</emphasis> - The Subsystem must be started
        once it is ready.</para>
      </listitem>
    </itemizedlist>

    <para>Subsystem resources which are installed as content resources, see
    <xref linkend="i3329153"/>, of one or more Subsystems must have their
    <emphasis>autostart setting</emphasis> set to
    <emphasis>started</emphasis>.</para>

    <para>When a Subsystem is started and stopped then the resources the
    Subsystem references may be started and stopped. See for details <xref
    linkend="i3365470"/> and <xref linkend="i3348344"/>.</para>

    <para>The Subsystems implementation must track the resources which are
    installed and be able to determine when a resource must be started and
    stopped. To describe this behavior the term<emphasis> active use
    count</emphasis> is used. A active use count indicates the number of
    active Subsystems which reference a resource. The active use count is used
    by the Subsystems implementation in order to determine when a resource is
    started and stopped. The term active use count is only used to illustrate
    the starting and stopping of resources. The active use count of a resource
    is not exposed in the API of Subsystems.</para>

    <para>Resource starting and stopping only applies to resources for which
    it is valid to start and stop. For example, it is not valid to start or
    stop resources of type <code>osgi.fragment</code> and a Subsystems
    implementation must not attempt to start or stop such resources.</para>

    <section xml:id="i3329174">
      <title>Start Order</title>

      <para>A Subsystem's Subsystem-Content header, see <xref
      linkend="i3321875"/>, can use the optional <code>start-order</code>
      directive for each content resource it declares. The
      <code>start-order</code> directive specifies the start order of the
      content resource in relation to other content resources of the
      Subsystem. Content resources are started in ascending order and stopped
      in descending order according to the start-order directive values.
      Content resources with the same start-order value may be started and
      stopped in any order in relation to each other. There is no default
      value for <code>start-order</code>. If the <code>start-order</code> is
      not specified then a Subsystem implementation is free to start the
      resource in any order. For example, the following header specifies four
      Subsystem content resources:</para>

      <programlisting>Subsystem-SymbolicName: S1
Subsystem-Type: osgi.subsystem.composite
Subsystem-Content: 
    A;
        <code>type=osgi.bundle;</code>
        version=1.0;
        start-order:=3,
    <code>B;</code>
        type=osgi.bundle;
        version=1.0;
        start-order:=2,
    <code>C;</code>
        type=osgi.bundle;
        version=1.0;
        start-order:=1,
    D;
        type=osgi.bundle;
        <code>version=1.0;</code>
        start-order:=2</programlisting>

      <para>The above headers specify a Subsystem <code>S1</code> with four
      content resources: <code>A</code>, <code>B</code>, <code>C</code> and
      <code>D</code>. The <code>start-order</code> directive is used to sort
      the content resources to determine the order to start or stop them when
      the Subsystem is started or stopped. The content resources are sorted
      from lowest to highest start-order. Content resources that have the same
      <code>start-order</code> value may be started and stopped in any order
      in relation to each other. In this example the content resources are
      sorted into the list <code>[C]</code>, <code>[B, D]</code>,
      <code>[A]</code>. <code>C</code> has the lowest start-order, therefore
      it is the first in the list. <code>B</code> and <code>D</code> have the
      same <code>start-order</code> and therefore can be started in any order
      in relation to each other. Finally <code>A</code> is last in the list
      because it has the highest start-order.</para>

      <para>When the Subsystem <code>S1</code> is started the content resource
      <code>C</code> must be started first, followed by the starting of
      <code>B</code> and <code>D</code> in any order, finally resource
      <code>A</code> is started last. When the Subsystem <code>S1</code> is
      stopped the content resource A must be stopped first, followed by the
      stopping of <code>B</code> and <code>D</code> in any order, finally
      resource <code>C</code> is stopped last.</para>

      <para>Resources that do not specify a start-order can be started and
      stopped in any order.</para>
    </section>

    <section xml:id="i3365590">
      <title>Active Use Count</title>

      <para>When a Subsystem is being started the Subsystems implementation
      must increment the active use count of every resource which is
      referenced by the Subsystem being started, see <xref
      linkend="i3339635"/>. After incrementing the active use counts of the
      resources referenced by a Subsystem, the Subsystems implementation must
      determine which referenced resources need to be started. For each
      resource referenced by the Subsystem which is valid to be started; if
      the active use count is greater than zero and the resource is not
      currently active then the resource must be started. The collection of
      dependencies are started before the Subsystem's content resources. The
      start order for the individual resources contained in the collection of
      dependencies is not specified. See <xref linkend="i3329174"/>.</para>

      <para>When a Subsystem is being stopped the Subsystems implementation
      must decrement the active use count of every resource which is
      referenced by the Subsystem being stopped. After decrementing the active
      use counts of the resources referenced by a Subsystem, the Subsystems
      implementation must determine which referenced resources need to be
      stopped. For each resource referenced by the Subsystem which is valid to
      be started; if the active use count equals zero and the resource is
      currently active then the resource must be stopped. The Subsystem
      content resources are stopped before the collection of dependencies.
      <xref linkend="i3329174"/> describes the stop order of the Subsystem's
      content resources. The stop order of the individual resources contained
      in the collection of dependencies is not specified.</para>

      <para>When starting the resource types supported by this specification
      the following rules apply:</para>

      <itemizedlist>
        <listitem>
          <para><code>osgi.bundle</code> - The bundle must be transiently
          started using the activation policy of the bundle, that is with the
          <code>Bundle.START_ACTIVATION_POLICY</code>.</para>
        </listitem>

        <listitem>
          <para><code>osgi.fragment</code> - fragments cannot be started, this
          is a no-op.</para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.application</code>,
          <code>osgi.subsystem.composite</code>,
          <code>osgi.subsystem.feature</code> - The Subsystem must be
          transiently started if its <emphasis>autostart setting</emphasis> is
          set to <emphasis>started</emphasis>.</para>
        </listitem>
      </itemizedlist>

      <para>When stopping the resource types supported by this specification
      the following rules apply:</para>

      <itemizedlist>
        <listitem>
          <para><code>osgi.bundle</code> - The bundle must be persistently
          stopped.</para>
        </listitem>

        <listitem>
          <para><code>osgi.fragment</code> - Fragments cannot be stopped, this
          is a no-op.</para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.application</code>,
          <code>osgi.subsystem.composite</code>,
          <code>osgi.subsystem.feature</code> - The Subsystem must be
          transiently stopped. Its <emphasis>autostart setting</emphasis> must
          not be changed.</para>
        </listitem>
      </itemizedlist>

      <para>Note that for resources referenced by a stopped Subsystem; bundle
      resources are persistently stopped and Subsystem resources are
      transiently stopped. This is a safeguard to handle cases where a
      constituent bundle is eagerly started by some other agent outside of the
      Subsystems implementation. Persistently started bundles will get auto
      started by the framework according to the start-level of the bundle.
      This can cause a constituent bundle to be stopped even though the
      Subsystem it is a constituent of is not active. To avoid this situation
      the Subsystems implementation always clears the persistent autostart
      setting of the bundle resources.</para>

      <para>Subsystem resources which are referenced by a Subsystem are
      started or stopped transiently. There is no API to transiently start or
      stop a Subsystem. The Subsystems implementation must perform the
      starting or stopping of a referenced Subsystem normally except the
      starting or stopping process does not change the <emphasis>autostart
      setting</emphasis> for the referenced Subsystem.</para>
    </section>
  </section>

  <section xml:id="i3333429">
    <title>Subsystem Service</title>

    <para>The Subsystem service represents an Subsystem Archive resource that
    is installed in an OSGi Framework. The installation of a Subsystem can
    only be performed by using the Subsystem service API or through
    implementation specific means. The Subsystem interface's methods and
    service properties can be divided into the following categories:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis> Information</emphasis> - Access to information about
        the Subsystem itself as well as other Subsystems that are
        installed.</para>
      </listitem>

      <listitem>
        <para><emphasis> Life Cycle</emphasis> - The possibility to install
        other Subsystems and start, stop, and uninstall Subsystems.</para>
      </listitem>
    </itemizedlist>

    <para>For each Subsystem installed, the Subsystems implementation must
    register an associated Subsystem object as a service. The Subsystem
    service is used for monitoring the state of the Subsystem, for controlling
    the life cycle of the installed Subsystem and for installing child
    Subsystems.</para>

    <section>
      <title>Root Subsystem</title>

      <para>A Subsystems implementation must register the Root Subsystem
      service. When a Subsystems implementation is started for the first time
      it must establish the Root Subsystem. The following steps are required
      to establish the Root Subsystem.</para>

      <orderedlist>
        <listitem>
          <para>The Root Subsystem has a symbolic name
          <code>org.osgi.service.subsystem.root</code>, <code>version
          1.0.0</code> (the version of the Subsystems specification), a
          Subsystem <code>id</code> of 0 and a location of</para>

          <programlisting>subsystem://?Subsystem-SymbolicName=org.osgi.service.subsystem.root&amp; «
 Subsystem-Version=1.0.0</programlisting>
        </listitem>

        <listitem>
          <para>The Root Subsystem has no parent Subsystem. More specifically
          the Root Subsystem is the only source vertex in the Subsystem
          graph.</para>
        </listitem>

        <listitem>
          <para>The Root Subsystem is considered a Scoped Subsystem of type
          <code>application</code>, with <code>provision-policy</code> of
          <code>acceptDependencies</code>. Since the Root Subsystem has no
          parent it does not import or export any capabilities.</para>
        </listitem>

        <listitem>
          <para>The Subsystem content is the set of bundles installed in the
          framework that do not belong to any other Subsystem.</para>
        </listitem>

        <listitem>
          <para>The root subsystem has a region context bundle as described in
          <xref linkend="i3345965"/>.</para>
        </listitem>
      </orderedlist>

      <para>The Root Subsystem always exists when a Subsystems implementation
      is present and active, even if no other Subsystems are installed The
      Root Subsystem is used as the starting point for installing Subsystems
      as child Subsystems. The Root Subsystem cannot be stopped or uninstalled
      by calling the Subsystem service stop or uninstall methods. Any attempt
      to do so must result in a Subsystem Exception.</para>
    </section>

    <section xml:id="i3346175">
      <title>Subsystem Service Properties</title>

      <para>The primary means of discovering and monitoring a Subsystem is the
      Subsystem service. A Subsystems implementation must register one
      Subsystem service for each Subsystem installed. The Subsystem service is
      used for monitoring and controlling the life-cycle of the installed
      Subsystem. Service properties on the Subsystem service carry most of the
      information required to monitor Subsystem life cycle operations and the
      current state of a Subsystem. The following table describes the service
      properties of a Subsystem:</para>

      <table>
        <title>Subsystem Mandatory Service Properties</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="2*"/>

          <colspec colnum="2" colwidth="1.5*"/>

          <colspec colnum="3" colwidth="3*"/>

          <thead>
            <row>
              <entry>Key Name</entry>

              <entry>Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>subsystem.id</code></entry>

              <entry><code>Long</code></entry>

              <entry><para>The Subsystem id of the Subsystem</para></entry>
            </row>

            <row>
              <entry><code>subsystem.symbolicName</code></entry>

              <entry><code>String</code></entry>

              <entry><para>The symbolic name of the Subsystem</para></entry>
            </row>

            <row>
              <entry><code>subsystem.version</code></entry>

              <entry><code>Version</code></entry>

              <entry><para>The version of the Subsystem</para></entry>
            </row>

            <row>
              <entry><code>subsystem.type</code></entry>

              <entry><code>String</code></entry>

              <entry><para>The type of Subsystem.</para></entry>
            </row>

            <row>
              <entry><code>subsystem.state</code></entry>

              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Contains the current state of the
              Subsystem</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Subsystem States</title>

      <para>The Subsystem service property <code>subsystem.state</code>
      contains the current state of the Subsystem (this is referred to as the
      <emphasis>subsystem state</emphasis>). All Subsystem states are defined
      by the <code>Subsystem.State</code> <code>enum</code>, for example,
      <code>INSTALLED</code>. The possible values of a
      <code>subsystem.state</code> are shown in the table below:</para>

      <table pgwide="1">
        <title>Subsystem States</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="4*"/>

          <thead>
            <row>
              <entry>subsystem.state</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLING"
              xrefstyle="hyperlink"/></entry>

              <entry><para>When a Subsystem is first installed the Subsystems
              implementation must register a Subsystem service with the
              initial <code>subsystem.state</code> of <xref
              linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLING"
              xrefstyle="hyperlink"/>. The <code>subsystem.state</code> must
              remain in the <xref
              linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLING"
              xrefstyle="hyperlink"/> state until all of the Subsystem
              constituents are installed successfully.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
              xrefstyle="hyperlink"/></entry>

              <entry><para>When all contents of a Subsystem has been
              successfully provisioned then the <code>subsystem.state</code>
              is set to <xref
              linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
              xrefstyle="hyperlink"/>.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.INSTALL_FAILED"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Indicates that some failure occurred while
              attempting to install the Subsystem's contents.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVING"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Starting a Subsystem triggers the resolution of a
              Subsystem if the <code>subsystem.state</code> is <xref
              linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
              xrefstyle="hyperlink"/>. A <xref
              linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVING"
              xrefstyle="hyperlink"/> state indicates that a resolve process
              is occurring in an attempt to resolve all of the subsystem's
              content resources.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVED"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Indicates that the Subsystem is resolved. A
              Subsystem is resolved if all of its content resources are
              resolved.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.STARTING"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Indicates that the Subsystem is in the process of
              being started. During this state the resources the Subsystem
              references which are eligible for starting are started, see
              <xref linkend="i3339345"/>. Once all the eligible resources are
              successfully started then the <code>subsystem.state</code> is
              set to <xref
              linkend="org.osgi.service.subsystem.Subsystem.State.ACTIVE"
              xrefstyle="hyperlink"/>.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.ACTIVE"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The <xref
              linkend="org.osgi.service.subsystem.Subsystem.State.ACTIVE"
              xrefstyle="hyperlink"/> state indicates that all eligible
              resources referenced by the Subsystem were successfully started
              during the starting process.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.STOPPING"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Indicates that the Subsystem is in the process of
              being stopped. During this state the resources referenced by the
              Subsystem are stopped if appropriate.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLING"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Indicates that the Subsystem is in the process of
              being uninstalled. During this state the resources referenced by
              the Subsystem are marked for garbage collection if they are
              eligible, see <xref linkend="i3339635"/>.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLED"
              xrefstyle="hyperlink"/></entry>

              <entry><para>When all of the resources referenced by the
              Subsystem which are eligible for garbage collection have been
              uninstalled then the <code>subsystem.state</code> is set to
              <xref
              linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLED"
              xrefstyle="hyperlink"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="i3346431">
      <title>Subsystem Service Registrations</title>

      <para>The Subsystems implementation must register one Subsystem service
      for each Subsystem installed. The Subsystems implementation must provide
      access to every Subsystem service from the Root Region. Every other
      Region must have access to the following Subsystem Services:</para>

      <itemizedlist>
        <listitem>
          <para>Subsystem service representing the Scoped Subsystem of the
          Region.</para>
        </listitem>

        <listitem>
          <para>All Unscoped Subsystem services contained in the
          Region.</para>
        </listitem>

        <listitem>
          <para>All Subsystems which are children of a Subsystem contained in
          the Region.</para>
        </listitem>
      </itemizedlist>

      <para>A Region is granted access to the Subsystem services listed above
      automatically by the Subsystems implementation regardless of the sharing
      policy defined by the Scoped Subsystem of that Region. Additional
      Subsystem services may be imported into a Region from its parent Region
      by the sharing policy defined by the Scoped Subsystem of that
      Region.</para>

      <para>For example, a Root Subsystem and <code>Root</code> Region that
      has two Scoped Subsystem children, <code>S1</code> and <code>S2</code>.
      All Subsystem services are registered by the Subsystems implementation
      and are visible in the <code>Root</code> Region. The <code>S1</code>
      Subsystem service is also implicitly visible in the <code>S1</code>
      Region because it represents the Scoped Subsystem <code>S1</code>
      contained in that Region. Similarly the <code>S2</code> Subsystem
      service is also implicitly visible from the <code>S2</code> Region. This
      example is depicted in <xref linkend="i3378540"/>.</para>

      <figure xml:id="i3378540">
        <title>Root, attached to Scoped Subsystems S1, S2</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.408in"
                       contentwidth="6.209in"
                       fileref="root-attached-scoped.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para><xref linkend="i3344569"/> defines a more complicated scenario
      where Subsystems and multiple children are involved.</para>

      <figure pgwide="1" xml:id="i3344569">
        <title>Complex example Subsystem scoping</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.329in"
                       contentwidth="6.209in" fileref="complex-scoping.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>All Subsystem services are visible in the <code>Root</code>
      Region. The <code>S1</code> Subsystem service is also implicitly visible
      in the <code>S1</code> Region because it represents the Scoped Subsystem
      <code>S1</code> contained in that Region. The <code>S1</code> Region
      also has visibility to the <code>U1</code> and <code>U2</code> Subsystem
      services because these Unscoped Subsystems are contained in the
      <code>S1</code> Region. Similarly the <code>S2</code> Subsystem service
      is also implicitly visible from the <code>S2</code> Region. The
      <code>S2</code> Region also has visibility to the <code>U3</code> and
      <code>U4</code> Subsystem services because these Unscoped Subsystems are
      contained in the <code>S2</code> Region. The <code>S2</code> Region also
      has visibility to the <code>S3</code> Subsystem service because the
      <code>S3</code> Subsystem is a child of a Subsystem contained in the
      <code>S2</code> Region. Finally, the <code>S3</code> Region has implicit
      visibility to the <code>S3</code> Subsystem service and it has
      visibility to the <code>U5</code> Subsystem service because the Unscoped
      Subsystem is contained in the <code>S3</code> Region.</para>

      <para>Note that a Scoped Subsystem's import sharing policy may grant its
      Region visibility to additional Subsystem services.</para>
    </section>

    <section>
      <title>Subsystem Manifest Headers</title>

      <para>The Subsystem service interface has the <xref
      linkend="org.osgi.service.subsystem.Subsystem.getSubsystemHeaders-Locale-"
      xrefstyle="hyperlink"/> method which returns the values of the
      Subsystem's manifest headers. The headers returned by this method
      includes the values specified in the Subsystem manifest file and the
      values derived by the Subsystems implementation. Certain manifest
      headers may be derived at install time by the Subsystems implementation
      if they were not specified in the Subsystem manifest file. When a
      Subsystem manifest value is derived then the derived value must be
      included in the headers returned by the method <xref
      linkend="org.osgi.service.subsystem.Subsystem.getSubsystemHeaders-Locale-"
      xrefstyle="hyperlink"/>. The following Subsystem manifest headers may be
      derived by the Subsystems implementation:</para>

      <itemizedlist>
        <listitem>
          <para><code>Subsystem-SymbolicName</code></para>
        </listitem>

        <listitem>
          <para><code>Subsystem-Version</code></para>
        </listitem>

        <listitem>
          <para><code>Subsystem-Content</code></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Subsystem Life Cycle</title>

    <para>The Subsystems specification provides an API to control the life
    cycle operations of a Subsystem. For each Subsystem installed there is an
    associated <code>Subsystem</code> object (also registered as a Subsystem
    service). A Subsystem's life-cycle is controlled by operations performed
    on the <code>Subsystem</code> object. Operations performed on the
    Subsystem may also cause equivalent operations on the resources referenced
    by the Subsystem. For example starting a Subsystem will cause all of its
    content resources to start if appropriate.</para>

    <para>For Scoped Subsystems the export and import sharing policies are
    initially disabled at runtime and get enabled at runtime by the Subsystems
    implementation depending on the state of the Scoped Subsystem which
    defines the sharing policy. When an import sharing policy is disabled at
    runtime, none of the installed resources contained in the Region
    associated with the Scoped Subsystem have visibility to capabilities
    available in the parent Region. Once an import policy is enabled at
    runtime the installed resources contained in the Region have visibility to
    capabilities available in the parent Region according to what the import
    sharing policy specifies. When an export sharing policy is disabled at
    runtime, none of the capabilities provided by installed resources
    contained in the Region associated with the Scoped Subsystem are visible
    in the parent Region. Once an export policy is enabled at runtime the
    capabilities provided by installed resources contained in the Region are
    visible in the parent Region according to what the export sharing policy
    specifies.</para>

    <para>The <code>subsystem.state</code> is a reflection of the last action
    performed on the Subsystem through the Subsystem service. The use of any
    other API to change the state of a resource referenced by a Subsystem
    directly does not result in a change of the <code>subsystem.state</code>
    (i.e. calling stop on a bundle). For example, uninstalling a Subsystem
    content resource which is a bundle does not cause the Subsystem to be
    uninstalled, but it does result in an error being logged.</para>

    <para>All references to changing the state of this Subsystem include both
    changing the state of the <code>Subsystem</code> object as well as the
    state property of the Subsystem service.</para>

    <para>The following figure illustrates the life cycle of a
    Subsystem:</para>

    <figure xml:id="i3314824">
      <title>State diagram Subsystems</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="3.517in"
                     contentwidth="7.125in" fileref="subsystem-state.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section xml:id="i3330130">
      <title>Installing</title>

      <para>A Subsystem's install process is initiated using one of the
      Subsystem service's <emphasis>install </emphasis>methods. The Subsystems
      implementation must assign a unique Subsystem identifier that is higher
      than any previous installed Subsystem identifier. Previously installed
      Subsystem identifiers include Subsystems which were uninstalled in a
      previous session of the framework. The installation of a Subsystem must
      be:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Persistent</emphasis> - The Subsystem must remain
          installed across framework and Java VM invocations until the
          Subsystem is explicitly uninstalled.</para>
        </listitem>

        <listitem>
          <para><emphasis>Atomic</emphasis> - The install method must
          completely install the Subsystem or, if installation fails, the
          Subsystems implementation must leave the framework in the same state
          as it was before the method was called.</para>
        </listitem>
      </itemizedlist>

      <para>Once a Subsystem has been installed, a <code>Subsystem</code>
      object is created and all remaining life cycle operations for the
      installed Subsystem must be performed upon this object. The returned
      <code>Subsystem</code> object can be used to start, stop, and uninstall
      the Subsystem as well as install child Subsystems.</para>

      <para>When a Subsystem is being installed the Subsystems implementation
      must perform the following operations synchronously before returning
      from the install method:</para>

      <orderedlist>
        <listitem>
          <para>Determine the symbolic name, version, and type for the
          Subsystem being installed as defined in <xref linkend="i3345962"/>.
          If the Subsystem name, version or type are invalid then the install
          fails and a Subsystem Exception is thrown.</para>
        </listitem>

        <listitem>
          <para>Determine the Subsystems for which the Subsystem being
          installed will become a constituent of by following the steps in
          <xref linkend="i3346786"/>.</para>
        </listitem>

        <listitem>
          <para>Determine the Subsystem identifier. Subsystem identifiers are
          unique and assigned by the Subsystems implementation.</para>
        </listitem>

        <listitem>
          <para>If the Subsystem is a Scoped Subsystem then create the new
          Region for the Subsystem and install and start the Region context
          bundle. See <xref linkend="i3345965"/> for the Region context
          bundle.</para>
        </listitem>

        <listitem>
          <para>Register a Subsystem service with the initial
          <code>subsystem.state</code> service property set to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLING"
          xrefstyle="hyperlink"/>. This Subsystem service represents the
          Subsystem resource. See <xref linkend="i3346175"/> and <xref
          linkend="i3346431"/> for more details.</para>
        </listitem>

        <listitem>
          <para>Determine the Subsystem content resources. See <xref
          linkend="i3346687"/> for details on how the Subsystem contents are
          determined. If the contents cannot be discovered successfully and
          the content is not optional then an installation failure occurs and
          a Subsystem Exception is thrown. Otherwise continue to the next
          step.</para>
        </listitem>

        <listitem>
          <para>Determine the Subsystem dependencies. See <xref
          linkend="i3330142"/> for details on determining the Subsystem's
          dependencies. If the dependencies cannot be determined successfully
          then an installation failure occurs and a Subsystem Exception is
          thrown. Otherwise continue to the next step.</para>
        </listitem>

        <listitem>
          <para>Install the dependencies. The Subsystems implementation must
          prevent resolution of dependency wires to the capabilities provided
          by the installed dependencies until the Subsystem has successfully
          entered <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
          xrefstyle="hyperlink"/> state. See <xref linkend="i3346786"/> for
          details on where dependencies are installed and see <xref
          linkend="i3339635"/> for how they are tracked. If any dependency
          fails to install then an installation failure occurs and a Subsystem
          Exception is thrown. Otherwise continue to the next step.</para>
        </listitem>

        <listitem>
          <para>Install content resources. The content resources must be
          disabled from resolving until the Subsystem has successfully entered
          <xref linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
          xrefstyle="hyperlink"/> state. If any content resource fails to
          install then and installation failure occurs and a Subsystem
          Exception is thrown. Otherwise continue to the next step.</para>
        </listitem>

        <listitem>
          <para>If the Subsystem is scoped, enable the import sharing policy
          for the Region. See <xref linkend="i3328531"/>.</para>
        </listitem>

        <listitem>
          <para>Enable resolution for all of the Subsystem content and any
          dependencies installed. Set the <code>subsystem.state</code> to
          <xref linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
          xrefstyle="hyperlink"/> and return the installed
          <code>Subsystem</code> object.</para>
        </listitem>
      </orderedlist>

      <para>The state <xref
      linkend="org.osgi.service.subsystem.Subsystem.State.INSTALL_FAILED"
      xrefstyle="hyperlink"/> is used to inform about an installation failure.
      All installation failures use the following steps:</para>

      <orderedlist>
        <listitem>
          <para>When a Subsystem fails to install it enters the <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALL_FAILED"
          xrefstyle="hyperlink"/> state.</para>
        </listitem>

        <listitem>
          <para>Immediately transition the Subsystem to the <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLING"
          xrefstyle="hyperlink"/> state.</para>
        </listitem>

        <listitem>
          <para>All content and dependencies which may have been installed by
          the Subsystem installing process must be uninstalled.</para>
        </listitem>

        <listitem>
          <para>Transition the Subsystem to the <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLED"
          xrefstyle="hyperlink"/> state.</para>
        </listitem>

        <listitem>
          <para>Unregister the Subsystem service.</para>
        </listitem>

        <listitem>
          <para>If the Subsystem is scoped then, uninstall the Region context
          bundle.</para>
        </listitem>

        <listitem>
          <para>Throw a Subsystem Exception indicating an install
          failure.</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>Resolving</title>

      <para>A Subsystem's resolve process is initiated by performing a start
      operation on a Subsystem whose <code>subsystem.state</code> is currently
      set to <xref
      linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
      xrefstyle="hyperlink"/>. There is no explicit operation for initiating
      the resolve process of a Subsystem.</para>
    </section>

    <section xml:id="i3365470">
      <title>Starting</title>

      <para>A Subsystem can be started by calling the Subsystem <xref
      linkend="org.osgi.service.subsystem.Subsystem.start--"
      xrefstyle="hyperlink"/> method or the Subsystems implementation can
      automatically start the Subsystem if the Subsystem is <emphasis>ready
      </emphasis>and the <emphasis>autostart setting </emphasis>of the
      Subsystem indicates that it must be started. When a Subsystem is being
      started the Subsystems implementation must perform the following
      operations synchronously before returning from the <xref
      linkend="org.osgi.service.subsystem.Subsystem.start--"
      xrefstyle="hyperlink"/> method:</para>

      <orderedlist>
        <listitem>
          <para>If the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALL_FAILED"
          xrefstyle="hyperlink"/>, <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLED"
          xrefstyle="hyperlink"/>, or <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLING"
          xrefstyle="hyperlink"/>, then an Illegal State Exception is
          thrown.</para>
        </listitem>

        <listitem>
          <para>Set the Subsystems <emphasis>autostart setting </emphasis>to
          <emphasis>started</emphasis>.</para>
        </listitem>

        <listitem>
          <para>If the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.ACTIVE"
          xrefstyle="hyperlink"/> then the start method returns
          immediately.</para>
        </listitem>

        <listitem>
          <para>If the Subsystem is not <emphasis>ready </emphasis>to be
          started then the start method returns immediately.</para>
        </listitem>

        <listitem>
          <para>If this <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVING"
          xrefstyle="hyperlink"/>, <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STARTING"
          xrefstyle="hyperlink"/> or <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STOPPING"
          xrefstyle="hyperlink"/>, then the start method must wait for
          starting or stopping to complete before continuing. If this does not
          occur in a reasonable time, a Subsystem Exception is thrown to
          indicate the Subsystem was unable to be started.</para>
        </listitem>

        <listitem>
          <para>If the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVED"
          xrefstyle="hyperlink"/> then continue to the next step; otherwise if
          the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
          xrefstyle="hyperlink"/> then the <code>subsystem.state</code> is set
          to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVING"
          xrefstyle="hyperlink"/> and an attempt is made to resolve all of the
          Subsystem's content resources. If all contents are resolved then set
          the <code>subsystem.state</code> to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVED"
          xrefstyle="hyperlink"/>, enable the export sharing policy and
          continue to the next step; otherwise a starting failure occurs and a
          Subsystem Exception is thrown.</para>
        </listitem>

        <listitem>
          <para>Set the <code>subsystem.state</code> to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STARTING"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para>Start all resources referenced by the Subsystem according to
          <xref linkend="i3339345"/>. If all of the resources start
          successfully then continue to the next step; otherwise a start
          failure occurs.</para>
        </listitem>

        <listitem>
          <para>Set the <code>subsystem.state</code> to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.ACTIVE"
          xrefstyle="hyperlink"/> and return.</para>
        </listitem>
      </orderedlist>

      <para>All start failures use the following steps:</para>

      <orderedlist>
        <listitem>
          <para>If the subsystem state is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STARTING"
          xrefstyle="hyperlink"/> then change the state to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STOPPING"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para>Stop all resources that were started as part of this
          operation.</para>
        </listitem>

        <listitem>
          <para>Change the state to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
          xrefstyle="hyperlink"/> or <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVED"
          xrefstyle="hyperlink"/> depending on if the Subsystem was
          resolved.</para>
        </listitem>

        <listitem>
          <para>Throw a Subsystem Exception indicating the cause of the start
          failure.</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="i3348344">
      <title>Stopping</title>

      <para>A Subsystem's stop process is initiated using the Subsystem
      service's <xref linkend="org.osgi.service.subsystem.Subsystem.stop--"
      xrefstyle="hyperlink"/> method. When a Subsystem is being stopped the
      Subsystems implementation must perform the following operations
      synchronously before returning from the <xref
      linkend="org.osgi.service.subsystem.Subsystem.stop--"
      xrefstyle="hyperlink"/> method:</para>

      <orderedlist>
        <listitem>
          <para>If the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLED"
          xrefstyle="hyperlink"/>, <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALL_FAILED"
          xrefstyle="hyperlink"/>, or <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLING"
          xrefstyle="hyperlink"/>, then an Illegal State Exception is
          thrown.</para>
        </listitem>

        <listitem>
          <para>Set the Subsystems <emphasis>autostart setting </emphasis>to
          <emphasis>stopped</emphasis>.</para>
        </listitem>

        <listitem>
          <para>If the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVED"
          xrefstyle="hyperlink"/> or <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
          xrefstyle="hyperlink"/> then the <xref
          linkend="org.osgi.service.subsystem.Subsystem.stop--"
          xrefstyle="hyperlink"/> method returns immediately.</para>
        </listitem>

        <listitem>
          <para>If this <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STARTING"
          xrefstyle="hyperlink"/> or <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STOPPING"
          xrefstyle="hyperlink"/>, then the stop method must wait for starting
          or stopping to complete before continuing. If this does not occur in
          a reasonable time, a Subsystem Exception is thrown to indicate the
          Subsystem was unable to be stopped.</para>
        </listitem>

        <listitem>
          <para>Set the <code>subsystem.state</code> to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STOPPING"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para>Stop all resources referenced by the Subsystem according to
          <xref linkend="i3339345"/>. If any error occurs while stopping a
          resource the Subsystems implementation must continue to stop the
          remaining resources that are eligible to stop.</para>
        </listitem>

        <listitem>
          <para>Set the <code>subsystem.state</code> to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.RESOLVED"
          xrefstyle="hyperlink"/>.</para>
        </listitem>
      </orderedlist>

      <para>With regard to error handling while stopping resources referenced
      by the Subsystem, errors subsequent to the first should be logged. Once
      the stop process has completed, a Subsystem Exception must be thrown
      with the initial error as the specified cause.</para>
    </section>

    <section>
      <title>Uninstalling</title>

      <para>A Subsystem's uninstall process is initiated using the Subsystem
      service's <xref
      linkend="org.osgi.service.subsystem.Subsystem.uninstall--"
      xrefstyle="hyperlink"/> method. To whatever extent possible, the
      Subsystems implementation must determine the resources referenced by the
      Subsystem which are eligible for garbage collection, <xref
      linkend="i3365854"/>. This method must always uninstall the Subsystem
      from the persistent storage of the Subsystems implementation.</para>

      <para>Once this method returns, the state of the platform must be the
      same as if the Subsystem had never been installed, unless some bundle
      resource which was uninstalled has exported package which are being used
      by other bundles still installed in the platform. All old exports must
      remain available for existing bundles and future resolves until the
      uninstalled bundle is refreshed or the framework is restarted.</para>

      <para>When a Subsystem is being uninstalled the Subsystems
      implementation must perform the following operations before returning
      from the <xref
      linkend="org.osgi.service.subsystem.Subsystem.uninstall--"
      xrefstyle="hyperlink"/> method:</para>

      <orderedlist>
        <listitem>
          <para>If the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLED"
          xrefstyle="hyperlink"/> then this method returns immediately.</para>
        </listitem>

        <listitem>
          <para>If the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STARTING"
          xrefstyle="hyperlink"/>, <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.STOPPING"
          xrefstyle="hyperlink"/> or <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.ACTIVE"
          xrefstyle="hyperlink"/> then the Subsystem is stopped according to
          <xref linkend="i3348344"/>. Otherwise continue to the next
          step.</para>
        </listitem>

        <listitem>
          <para>If the <code>subsystem.state</code> is <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLING"
          xrefstyle="hyperlink"/> and the installing process is interruptible,
          fail the install process; otherwise, wait until the installation is
          complete.</para>
        </listitem>

        <listitem>
          <para>If the <code>subsystem.state</code> is in the <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALL_FAILED"
          xrefstyle="hyperlink"/> state then skip to step <xref
          linkend="service.subsystem-subsystemuninstalling6"/>.</para>
        </listitem>

        <listitem>
          <para>Set the <code>subsystem.state</code> to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.INSTALLED"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem xml:id="service.subsystem-subsystemuninstalling6">
          <para>Set the <code>subsystem.state</code> to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLING"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para>Determine the resources referenced by the Subsystem which are
          eligible for garbage collection according to <xref
          linkend="i3365854"/>. If a Subsystems implementation does garbage
          collection synchronously and any error occurs while uninstalling a
          resource the Subsystems implementation must continue to uninstall
          the remaining resources that are eligible to garbage collect.</para>
        </listitem>

        <listitem>
          <para>Set the <code>subsystem.state</code> to <xref
          linkend="org.osgi.service.subsystem.Subsystem.State.UNINSTALLED"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para>Unregister the Subsystem service.</para>
        </listitem>

        <listitem>
          <para>If the Subsystem is a Scoped Subsystem then uninstall the
          Region context bundle. At this point the Region no longer
          exists.</para>
        </listitem>
      </orderedlist>

      <para>With regard to error handling while synchronously uninstalling
      resources eligible for garbage collection, errors subsequent to the
      first should be logged. Once the uninstall process has completed, a
      Subsystem Exception must be thrown with the initial error as the
      specified cause.</para>
    </section>
  </section>

  <section xml:id="i3330073">
    <title>Pre-Calculated Deployment</title>

    <para>A pre-calculated deployment in the form of a deployment manifest can
    be included as part of a Subsystem Archive or provided by a deployer at
    installation time. Manifests provided at install time override those
    included within an archive, and those within an archive override generated
    ones. The deployment manifest defines the precise deployment of the 
    Subsystem. Providing a deployment manifest means a Subsystem can be deployed
    and the exact resources that are installed are known ahead of time. This 
    allows test teams to test specific deployments and these same deployments 
    can then be used in production. The deployment manifest is a locking down of
    the variability in a Subsystem manifest (or the equivalent if the Subsystem 
    definition is calculated during deployment based on the Subsystem Archive). 
    The deployment manifest follows the same syntax rules as the Subsystem 
    manifest but uses different headers for deployment-specific information. A 
    deployment manifest describes the following:</para>

    <itemizedlist>
      <listitem>
        <para>The exact versions for content resources</para>
      </listitem>

      <listitem>
        <para>Any dependencies required to resolve the Subsystem's content
        that are not satisfied by the target runtime</para>
      </listitem>

      <listitem>
        <para>Sharing policy for requirements and capabilities shared into or
        out of the Subsystem.</para>
      </listitem>
    </itemizedlist>

    <para>Because a Deployment Manifest's dependencies bridge between the
    requirements of the Subsystem and the capabilities of the target runtime,
    it is not guaranteed to be portable. If available, the Subsystem service
    implementation must first attempt to use the Deployment Manifest to deploy
    the Subsystem. If the Deployment Manifest is found not to work, for
    example, the chosen resources do not resolve for the target runtime, then
    the Subsystem's implementation must fail the installation of the
    Subsystem.</para>

    <section>
      <title>Deployment Headers</title>

      <para>A Subsystem can carry descriptive information about its deployment
      in the Deployment Manifest file contained in its Subsystem Archive under
      the name <code>OSGI-INF/DEPLOYMENT.MF</code>. This specification defines
      Deployment Manifest headers such as Deployed-Content, which Subsystem
      deployers (typically tools) use to supply deployment information about a
      Subsystem. A Subsystems implementation must:</para>

      <itemizedlist>
        <listitem>
          <para>Process the main section of the manifest. Individual section
          of the manifest are ignored.</para>
        </listitem>

        <listitem>
          <para>Ignore unknown manifest headers. The Subsystem deployer can
          define additional manifest headers as needed.</para>
        </listitem>

        <listitem>
          <para>Ignore unknown attributes and directives.</para>
        </listitem>
      </itemizedlist>

      <para>All specified manifest headers are listed in the following
      sections, and include example values. All headers are optional, unless
      specifically indicated.</para>

      <section>
        <title>Deployment-ManifestVersion: 1</title>

        <para>The Deployment-ManifestVersion header defines that the
        deployment manifest follows the rules of a Subsystems Specification.
        It is 1 (the default) for this version of the specification. Future
        versions of the Subsystems Specification can define higher numbers for
        this header.</para>
      </section>

      <section>
        <title>Subsystem-SymbolicName: com.acme.subsystem.logging</title>

        <para>The Subsystem-SymbolicName header specifies a non-localizable
        name for the Subsystem that the deployment manifest is for. The
        Subsystem symbolic name together with a version must identify a unique
        Subsystem though it can be installed multiple times in a framework.
        See <xref linkend="i3348566"/>.</para>
      </section>

      <section>
        <title>Subsystem-Version: 1.0</title>

        <para>The Subsystem-Version header specifies the version of this
        Subsystem that the deployment manifest is for. See <xref
        linkend="i3348566"/>.</para>
      </section>

      <section>
        <title>Deployed-Content:
        com.acme.logging;type:=osgi.bundle;deployed-version=1.0.0</title>

        <para>The Deployed-Content header lists requirements for the exact
        resources that are considered to be the contents of this Subsystem.
        This header identifies the exact versions of the resources listed in
        the Subsystem-Content header. See <xref linkend="i3348639"/>.</para>
      </section>

      <section>
        <title>Provision-Resource:
        com.acme.logging;type:=osgi.bundle;deployed-version=1.0.0</title>

        <para>The Provision-Resource header lists requirements for the exact
        resources to be installed in order to satisfy requirements from the
        Deployed-Content resources that are not satisfied by the capabilities
        of the target runtime. See <xref linkend="i3348654"/>.</para>
      </section>

      <section>
        <title>Import-Package: com.acme.api;version="[1.0,1.1)"</title>

        <para>The Import-Package header lists package requirements for
        capabilities that are to be imported into a Scoped Subsystem. See
        <xref linkend="i3321439"/>.</para>
      </section>

      <section>
        <title>Export-Package: com.acme.api;version=1.0.1</title>

        <para>The Export-Package header lists package capabilities that are to
        be exported out of a Scoped Subsystem. See <xref
        linkend="i3321359"/>.</para>
      </section>

      <section>
        <title>Require-Bundle: com.acme.logging;version="[1.0, 1.1)"</title>

        <para>The Require-Bundle header lists bundle requirements for bundle
        capabilities that are to be imported into a Scoped Subsystem. See
        <xref linkend="i3321711"/>.</para>
      </section>

      <section>
        <title>Provide-Capability: com.acme.dict; from=nl; to=de;
        version:Version=1.2</title>

        <para>The Provide-Capability header declares the capabilities exported
        for a Scoped Subsystem. See <xref linkend="i3394044"/>.</para>
      </section>

      <section>
        <title>Require-Capability: osgi.ee; filter:="(osgi.ee=*)"</title>

        <para>The Require-Capability header declares the required capabilities
        for a Scoped Subsystem. See <xref linkend="i3394044"/>.</para>
      </section>

      <section>
        <title>Subsystem-ImportService: com.acme.service.Logging</title>

        <para>The Subsystem-ImportService header lists service requirements
        for service capabilities that are to be imported into a Scoped
        Subsystem. See <xref linkend="i3348699"/>.</para>
      </section>

      <section xml:id="i3321913">
        <title>Subsystem-ExportService: com.acme.service.Logging</title>

        <para>The Subsystem-ExportService header lists service requirements
        that are matched against service capabilities provided by the
        Deployed-Content resources. Any matching capabilities are exported out
        of the Scoped Subsystem.</para>
      </section>
    </section>

    <section xml:id="i3348566">
      <title>Validating Subsystem Identity</title>

      <para>The Subsystem to which the deployment manifest applies is
      identified by the Subsystem's symbolic name and version headers. These
      headers are identical to those specific in the Subsystem manifest. A
      Subsystem runtime must validate that the headers specified in the
      deployment manifest match those of the Subsystem manifest, taking into
      account Subsystem manifest defaulting rules. This allows the two
      manifests to be managed by teams separately during development or
      testing whilst ensuring no mistakes have been made when they are brought
      together for deployment. If the headers do not match, then the runtime
      must not use the deployment manifest and must fail the
      installation.</para>
    </section>

    <section xml:id="i3348639">
      <title>Deployed-Content</title>

      <para>The Deployed-Content header lists the exact constituents to be
      installed for the Subsystem. For each mandatory entry in the
      Subsystem-Content header, there must be a corresponding Deployed-Content
      entry. If a content resources is identified as optional and there is a
      corresponding entry in the deployment manifest, then it must be
      deployed. If there is no corresponding entry in the deployment manifest
      then no resource must be deployed for it. The Deployed-Content entry
      identifies the exact version of the constituent whereas the
      Subsystem-Content entry may specify a version range. Each
      Deployed-Content entry is identified by symbolic name, version and type
      (an osgi identity).</para>

      <programlisting>Deployed-Content:
    com.acme.logging;
        deployed-version=1.0,
    com.acme.persistence;
        deployed-version=1.1;
        type:=osgi.subsystem.composite </programlisting>

      <para>Each entry must uniquely identify the resource to be provisioned
      as a constituent of the Subsystem.</para>

      <para>The following mandatory matching attributes must be applied to
      each entry:</para>

      <itemizedlist>
        <listitem>
          <para><code>deployed-version</code> - The exact version of the
          resource to be deployed. Deployed version is a specific version, not
          a version range, hence the use of a new attribute name. There is no
          default value for this attribute.</para>
        </listitem>
      </itemizedlist>

      <para>The following architected matching attribute as well as any
      arbitrary matching attributes can be applied to each entry:</para>

      <para><code>type</code> - The type of the constituent. It is recommended
      that a reverse domain name convention is used unless those types and
      their processing is standardized by the OSGi Alliance (e.g. bundles).
      The default value is <code>osgi.bundle</code>. A Subsystems
      implementation may support additional types, but the following types
      must be supported:</para>

      <itemizedlist>
        <listitem>
          <para><code>osgi.bundle</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.fragment</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.application</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.composite</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.feature</code></para>
        </listitem>
      </itemizedlist>

      <para>The value of this directive must match the type directive for the
      corresponding entry in the Subsystem-Content header, including taking
      into account defaulting. If the type does not match, then the
      installation must fail.</para>

      <para>The following directive can be applied to each entry:</para>

      <itemizedlist>
        <listitem>
          <para><code>start-order</code> - The precedence the constituent
          should have during the start sequence. Resources with lower
          <code>start-order</code> values are started before resources with
          higher values. Resources with the same <code>start-order</code>
          value may be started sequentially or in parallel. The value of this
          directive must match the <code>start-order</code> directive for the
          corresponding entry in the Subsystem-Content header, including
          taking into account defaulting.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3348654">
      <title>Provision-Resource</title>

      <para>The Provision-Resource header lists the resources to be
      provisioned in support of the Subsystem's dependencies. The exact
      location in the Subsystem hierarchy where the resources are installed is
      determined by the <code>provision-policy</code> of the Subsystem or its
      parents.</para>

      <para>The Provision-Resource header must result in a transitively
      complete deployment. For example, if a resource added to
      Provision-Resource brings in additional unsatisfied requirements,
      further resources must be added to satisfy these, until there are no
      unresolved requirements remaining.</para>

      <para>Provision resource has one required matching attribute:</para>

      <itemizedlist>
        <listitem>
          <para><code>deployed-version</code> - The exact version of the
          resource to be deployed. Deployed version is a specific version, not
          a version range, hence the use of a new attribute name. There is no
          default value for this attribute.</para>
        </listitem>
      </itemizedlist>

      <para>The following architected matching attributes as well as any
      arbitrary matching attributes can be applied to each entry:</para>

      <para><code>type</code> - The type of the resource. It is recommended
      that a reverse domain name convention is used unless those types and
      their processing is standardized by the OSGi Alliance (e.g. bundles).
      The default type is <code>osgi.bundle</code>. A Subsystems
      implementation may support additional types, but the following types
      must be supported:</para>

      <itemizedlist>
        <listitem>
          <para><code>osgi.bundle</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.fragment</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.application</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.composite</code></para>
        </listitem>

        <listitem>
          <para><code>osgi.subsystem.feature</code></para>
        </listitem>
      </itemizedlist>

      <para>The list of the Provision-Resource entries is determined by
      resolving the Subsystem's requirements. The way in which the Subsystem's
      requirements are resolved is dependent on the Subsystem's sharing
      policy.</para>

      <para>For a Scoped Subsystem the provision resources header must
      identify a set of resources necessary to satisfy the requirements into
      the Subsystem that are not satisfied by the target deployment
      environment. These requirements may be for packages, services, or other
      types of requirements, and are those identified in the deployment
      manifest using headers such as Import-Package and
      Subsystem-ImportService.</para>

      <para>For an Unscoped Subsystem any mandatory requirements that are not
      satisfied by capabilities provided by the target environment may be
      satisfied by other constituents or a resource added to the
      Provision-Resource header. The resolution process for Unscoped
      Subsystems has no propensity to resolve to capabilities provided by the
      Subsystem's constituents and so a resource listed in Provision-Resource
      may provide capabilities that are also provided by a constituent
      resource.</para>
    </section>

    <section xml:id="i3321439">
      <title>Import-Package</title>

      <para>Scoped Subsystems describe the exact packages they import in their
      Deployment Manifests. They do this using the bundle Import-Package
      header. Any packages that match the Import-Package statement must be
      allowed into the Scoped Subsystem by its associated Region's sharing
      policy.</para>

      <para>Unscoped Subsystems have a sharing policy that shares all packages
      and therefore their deployment manifests do not use this header to
      describe the sharing of individual packages. If this header is present
      and the Subsystem is unscoped, then the runtime must fail the
      installation of the Subsystem.</para>
    </section>

    <section xml:id="i3321359">
      <title>Export-Package</title>

      <para>Scoped Subsystems describe the exact packages they export in their
      deployment manifests. They do this using the bundle Export-Package
      header. Any packages that match the Export-Package statement must be
      made available outside the Subsystem by its associated Region's sharing
      policy.</para>

      <para>Unscoped Subsystems have a sharing policy that shares all packages
      and therefore their deployment manifests do not use this header to
      describe the sharing of individual packages. If this header is present
      and the Subsystem is unscoped, then the runtime must fail the
      installation of the Subsystem.</para>
    </section>

    <section xml:id="i3321711">
      <title>Require-Bundle</title>

      <para>Scoped Subsystems can have Require-Bundle requirements satisfied
      by bundles outside the Subsystem. These bundle requirements are
      described using the bundle Require-Bundle header. Any bundles that match
      the Require-Bundle statement must be allowed into the Scoped Subsystem
      by its associated Region's sharing policy. If a bundle matches the
      Require-Bundle requirement then it becomes available as a candidate for
      wiring any Require-Bundle requirements inside the Subsystem. However,
      any packages the matching bundle provides are not made available to
      satisfy Import-Package requirements by the Region's sharing policy. If
      the packages are also required then they must be listed in the
      deployment manifest's Import-Package header.</para>

      <para>Unscoped Subsystems have a sharing policy that shares all bundles
      and therefore their deployment manifests do not use this header to
      describe the sharing of specific bundles. If this header is present and
      the Subsystem is unscoped, then the runtime must fail the installation
      of the Subsystem.</para>
    </section>

    <section xml:id="i3348699">
      <title>Services</title>

      <para>Scoped Subsystems can import and export services using the
      Subsystem-ImportService and Subsystem-ExportService headers
      respectively. These two headers must conform to the following
      syntax:</para>

      <programlisting>Subsystem-ImportService ::= service( ',' service )*
Subsystem-ExportService ::= service ( ',' service )*
service                 ::= qname ( ';' parameter )*</programlisting>

      <para>Both headers support the following directive:</para>

      <itemizedlist>
        <listitem>
          <para><code>filter</code> - A filter expression that is used to
          match against the service properties of services registered using
          the specified <code>qname</code> of the service's object class. The
          <code>filter</code> directive is optional. If no <code>filter</code>
          directive is defined then all services registered using the
          specified <code>qname</code> match the service statement.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i3322018">
      <title>Subsystem-ImportService</title>

      <para>Scoped Subsystems describe the services they import in their
      deployment manifests. They do this using the Subsystem-ImportService
      header. Subsystem-ImportService header defines a list of OSGi service
      filters that are matched against the services visible inside the Scoped
      Subsystem's parent Region. Each service visible in the Subsystem's
      parent Region that matches one or more Subsystem-ImportService
      statements must be allowed into the Scoped Subsystem by its associated
      Region's sharing policy. The following example imports services
      registered under the <code>com.acme.logging.Log</code>interface with a
      service property <code>threshold=error</code>.</para>

      <programlisting>Subsystem-ImportService: com.acme.logging.Log;filter:="(threshold=error)"</programlisting>

      <para>Unscoped Subsystems have a sharing policy that shares all services
      and therefore their deployment manifests do not use this header to
      describe the sharing of specific services. If this header is present and
      the Subsystem is unscoped, then the runtime must fail the installation
      of the Subsystem.</para>
    </section>

    <section xml:id="i3321933">
      <title>Subsystem-ExportService</title>

      <para>Scoped Subsystems describe the services they export in their
      deployment manifests. They do this using the Subsystem-ExportService
      header. The Subsystem-ExportService header defines a list of OSGi
      service filters that are matched against the services visible inside the
      Scoped Subsystem's Region. Each service visible in the Scoped
      Subsystem's Region that matches one or more Subsystem-ExportService
      statements must be allowed by its associated Region's sharing policy
      into the Scoped Subsystem's parent Region. The following example exports
      services registered under the <code>com.acme.logging.Log</code>
      interface with a service property <code>threshold=error</code>.</para>

      <programlisting>Subsystem-ExportService: com.acme.logging.Log;filter:="(threshold=error)"</programlisting>

      <para>Unscoped Subsystems have a sharing policy that shares all services
      and therefore their Deployment Manifests do not use this header to
      describe the sharing of specific services. If this header is present and
      the Subsystem is unscoped, then the runtime must fail the installation
      of the Subsystem.</para>
    </section>
  </section>

  <section xml:id="i3322905">
    <title>Subsystem Types</title>

    <para>Subsystem types simplify the configuration of sharing policies. The
    type of Subsystem is specified using the Subsystem-Type header. Each type
    has its own default sharing policy, for example, to forbid the sharing of
    capabilities out, or to share all capabilities in. This specification
    defines three Subsystem types:</para>

    <itemizedlist>
      <listitem>
        <para><code>osgi.subsystem.application</code></para>
      </listitem>

      <listitem>
        <para><code>osgi.subsystem.composite</code></para>
      </listitem>

      <listitem>
        <para><code>osgi.subsystem.feature</code></para>
      </listitem>
    </itemizedlist>

    <para>Other, non-standard, types are permitted. The specifics of each
    standard type are describe below.</para>

    <section>
      <title>Application</title>

      <para>An application is a Scoped Subsystem with a sharing policy
      associated with what is often considered to be an application. An
      application does not share (export) any capabilities to other bundles or
      Subsystems. It also does not explicitly import any capabilities. Any
      required capabilities that are not satisfied by the application's
      constituents are automatically shared in (imported) from the parent
      Subsystem.</para>

      <para>A Subsystem is identified as an application by specifying a
      Subsystem type value of <code>osgi.subsystem.application</code> in the
      Subsystem manifest.</para>

      <programlisting>Subsystem-Type: osgi.subsystem.application</programlisting>
    </section>

    <section>
      <title>Application Deployment</title>

      <para>Application Subsystems are not configured using additional
      requirement or capability headers, such as Import-Package. Applications
      do not export any capabilities. If an application Subsystem contains any
      capability exports then the Subsystem runtime should log an error and
      must fail.</para>

      <para>Any imported capabilities are derived from the application
      Subsystem content. An application Subsystem implicitly imports any
      capabilities required to satisfy requirements from the Subsystem
      contents that are not satisfied by the capabilities of the Subsystem
      content.</para>

      <para>Unsatisfied mandatory requirements result in a subsystem 
      installation failure. Unsatisfied optional requirements do not. However,
      implementations must ensure any unsatisfied optional requirements are
      added to the sharing policy.</para>

      <section>
        <title>Package Imports</title>

        <para>Application resolution is required to prefer packages provided
        by content bundles over those provided outside the application. For
        this reason, the application Subsystem sharing policy only imports
        packages corresponding to Import-Package statements from the content
        bundles that are not satisfied when resolving the application contents
        in isolation. This is equivalent to first resolving the
        Subsystem-Content requirements to determine the Deployed-Content and
        then based on this set of resources, determining which Import-Package
        requirements remain unsatisfied.</para>

        <para>A deployment manifest for an application Subsystem would list
        these package imports using the Import-Package header.</para>
      </section>

      <section>
        <title>Service Imports</title>

        <para>Application resolution is required to prefer services provided
        by content bundles over those provided outside the application. For
        this reason, the application Subsystem sharing policy only imports
        services required by the Subsystem's content bundles that are not also
        provided by the content bundles. This specification provides a means of 
        declaratively identifying the services a bundle provides or requires 
        using the <code>Provide-Capability</code> and <code>Require-Capability</code> 
        headers with the <code>osgi.service</code> namespace. See <xref 
        linkend="service.namespaces-osgi.service.namespace"/></para>
        
        <para>An example of a bundle providing the service and declaring it 
        using the <code>Provide-Capability</code> header is as follows:</para>
        
        <programlisting>Provide-Capability: osgi.service;
 objectClass=com.foo.MyService;
 a.service.prop=somePropertyValue</programlisting>

        <para>Note that declaring a provided service in this manner only affects
        resolution. It does not affect service visibility at runtime. In other 
        words, a subsystem that imports service <code>com.acme.Foo</code> will
        see all of the corresponding service registrations that its parent sees
        regardless of whether or not the provider declared this service in the
        <code>Provide-Capability</code> header.</para>

        <para>An example of a bundle requiring a service and declaring the 
        requirement using the <code>Require-Capability</code> header is as 
        follows:</para>

        <programlisting>Require-Capability: osgi.service;
 filter:=&quot;(&amp;(objectClass=com.foo.MyService)(a.service.prop=somePropertyValue))&quot;</programlisting>

        <para>These headers can be hand-written (e.g., to declare programmatic 
        use of an OSGi service) or generated by a tool (e.g., BND) based on a 
        declarative component model configuration (e.g., Declarative Services or 
        Blueprint). A Subsystems implementation must assume these headers, if 
        present, declare all of the service dependencies. Implementations must 
        therefore not search the bundle for additional dependencies from other 
        sources.</para>

        <para>A deployment manifest for an application Subsystem would list
        these service imports using the Subsystem-ImportService header.</para>
      </section>

      <section>
        <title>Bundle Requirements</title>

        <para>Application resolution is required to prefer bundle capabilities
        provided by content bundles over those provided outside the
        application. For this reason, the application Subsystem sharing policy
        only requires bundle capabilities corresponding to Require-Bundle
        statements from the content bundles that are not satisfied when
        resolving the application contents in isolation. This is equivalent to
        first resolving the Subsystem-Content requirements to determine the
        Deployed-Content and then based on this set of resources, determining
        which Require-Bundle requirements remain unsatisfied.</para>

        <para>A Deployment Manifest for an application Subsystem would list
        these bundle requirements using the Require-Bundle header.</para>
      </section>

      <section>
        <title>Generic Requirements</title>

        <para>Application resolution is required to prefer generic
        capabilities provided by content bundles over those provided outside
        the application. For this reason, the application Subsystem sharing
        policy only generic requirements corresponding to Require-Capability
        statements from the content bundles that are not satisfied by
        Provide-Capability statements of the content bundles when resolving
        the application contents in isolation. This is equivalent to first
        resolving the Subsystem-Content requirements to determine the
        Deployed-Content and then based on this set of resources, determining
        which Require-Capability statements remain unsatisfied.</para>

        <para>An deployment manifest for an application Subsystem would list
        these generic requirements using the Require-Capability header.</para>
      </section>

      <section>
        <title>Dependencies</title>

        <para>Application Subsystems' implicit requirements are determined as
        described in the Application Deployment section in <xref
        linkend="i3330142"/>. Any mandatory requirements from constituents
        that are not satisfied by capabilities provided by the target
        environment or other constituents must be satisfied by additional
        dependencies. The Subsystem runtime is responsible for provisioning
        these based on the Subsystem's provision policy or those of its scoped
        parents. If the application Subsystem has an associated deployment
        manifest, then these resources are described in the Provision-Resource
        header.</para>
      </section>
    </section>

    <section>
      <title>Composite</title>

      <para>A composite is a Scoped Subsystem with a sharing policy that by
      default does not share anything with its parent and therefore all
      sharing is fully explicit. Capabilities, such as packages and services,
      may be explicitly imported into or exported out of the composite.</para>

      <para>A Subsystem is identified as an composite by specifying a
      Subsystem type value of <code>osgi.subsystem.composite</code> in the
      Subsystem manifest.</para>

      <programlisting>Subsystem-Type: osgi.subsystem.composite</programlisting>

      <section>
        <title>Subsystem Content</title>

        <para>The Subsystem-Content header allows version ranges for content
        resources. For composite Subsystems, this value must be a fixed
        version range (e.g. <code>[1.0, 1.0]</code>) for resources of type
        <code>osgi.bundle</code>, <code>osgi.fragment</code>,
        <code>osgi.subsystem.application</code>,
        <code>osgi.subsystem.composite</code>, and
        <code>osgi.subsystem.feature</code>. This is due to the fact that
        there is an inextricable link between the versions on the explicit
        import and export statements made on a composite and the chosen
        versions of the content bundles. Allowing variability in the content
        versions for these types of resources risks introducing
        incompatibilities with sharing policy for the composite. If a
        composite Subsystem does not use strict version ranges then the
        composite Subsystem must fail to install.</para>
      </section>

      <section>
        <title>Package Imports</title>

        <para>A composite Subsystem explicitly states the packages it imports
        using the Import-Package header. If the composite includes a
        deployment manifest then the Import-Package header is used to describe
        these and they must be identical (logically, not syntactically) to the
        Import-Package headers in the composite's Subsystem manifest. If the
        imports are not the same then the Subsystem runtime should log an
        error and must fail the installation.</para>
      </section>

      <section>
        <title>Package Exports</title>

        <para>A composite Subsystem explicitly states the packages it exports
        using the Export-Package header. If the composite includes a
        deployment manifest then the Export-Package header is used to describe
        these and they must be identical (logically, not syntactically) to the
        Export-Package headers in the composite's Subsystem manifest. If the
        exports are not the same then the Subsystem runtime should log an
        error and must fail the installation.</para>
      </section>

      <section>
        <title>Service Imports</title>

        <para>A composite Subsystem explicitly states the services it imports
        using the Subsystem-ImportService header (see <xref
        linkend="i3322018"/> ). For example:</para>

        <programlisting>Subsystem-ImportService: com.acme.logging.Log</programlisting>

        <para>If the composite includes a deployment manifest then the
        Subsystem-ImportService header is used to describe these and they must
        be identical (logically, not syntactically) to the
        Subsystem-ImportService headers in the composite's Subsystem manifest.
        If the imports are not the same then the Subsystem runtime should log
        an error and must fail the installation.</para>
      </section>

      <section>
        <title>Service Exports</title>

        <para>A composite Subsystem explicitly states the services it exports
        using the Subsystem-ExportService header (see <xref
        linkend="i3321933"/> ). For example:</para>

        <programlisting>Subsystem-ServiceExport: com.acme.logging.Log</programlisting>

        <para>If the composite includes a deployment manifest then the
        Subsystem-ExportService header is used to describe these and they must
        be identical (logically, not syntactically) to the
        Subsystem-ExportService headers in the composite's Subsystem manifest.
        If the exports are not the same then the Subsystem runtime should log
        an error and must fail the installation.</para>
      </section>

      <section>
        <title>Bundle Requirements</title>

        <para>A composite Subsystem explicitly states the bundles it requires
        using the Require-Bundle header.</para>

        <para>If the composite includes a deployment manifest then the
        Require-Bundle header is used to describe these and the requirements
        must be identical (logically, not syntactically) to the Require-Bundle
        requirements in the composite's Subsystem manifest. If the
        requirements are not the same then the Subsystem runtime should log an
        error and must fail the installation.</para>
      </section>

      <section>
        <title>Generic Requirements</title>

        <para>A composite Subsystem explicitly states the generic capabilities
        it requires using the Require-Capability header.</para>

        <para>If the composite includes a deployment manifest then the
        Require-Capability header is used to describe these and they must be
        identical (logically, not syntactically) to the Require-Capability
        headers in the composite's Subsystem manifest. If the capability
        requirements are not the same then the Subsystem runtime should log an
        error and must fail the installation.</para>
      </section>

      <section>
        <title>Generic Capabilities</title>

        <para>A composite Subsystem explicitly states the generic capabilities
        it provides using the Provide-Capability header.</para>

        <para>If the composite includes a deployment manifest then the
        Provide-Capability header is used to describe these and they must be
        identical (logically, not syntactically) to the Provide-Capability
        headers in the composite's Subsystem manifest. If the capabilities are
        not the same then the Subsystem runtime should log an error and must
        fail the installation.</para>
      </section>

      <section>
        <title>Dependencies</title>

        <para>A composite Subsystem's explicit requirements are stated in the
        Subsystem manifest. Any mandatory requirements that are not satisfied
        by capabilities provided by the target environment must be satisfied
        by additional dependencies. The Subsystem runtime is responsible for
        provisioning these based on the Subsystem's provision policy or the
        provision policy of its scoped parents. If the composite Subsystem has
        an associated deployment manifest, then these resources are described
        in the Provision-Resource header.</para>
      </section>
    </section>

    <section>
      <title>Feature</title>

      <para>A feature is an Unscoped Subsystem and therefore provides no
      isolation of its own. A feature does however always exist in the context
      of one and only one Region which can restrict the capabilities a feature
      can see and the extent to which a feature's capabilities are
      shared.</para>

      <para>A Subsystem is identified as a feature by specifying a Subsystem
      type value of <code>osgi.subsystem.feature</code> in the Subsystem
      manifest.</para>

      <programlisting>Subsystem-Type: osgi.subsystem.feature</programlisting>

      <section>
        <title>Explicit Requirements and Capabilities</title>

        <para>A feature Subsystem implicitly imports and exports all
        requirements and capabilities. If the feature Subsystem include any
        headers designed to modify the sharing policy of a Subsystem, such as
        Import-Package or Subsystem-ImportService, then the Subsystem runtime
        should log an error and must fail the installation of the
        Subsystem.</para>
      </section>

      <section>
        <title>Dependencies</title>

        <para>Feature Subsystems implicitly import all capabilities. A
        Subsystem runtime is responsible for provisioning any dependencies
        necessary for the Subsystem's constituents to resolve. The calculation
        of the dependencies can also take into account capabilities provided
        by the target runtime. The dependencies can include resources that
        provide capabilities equivalent to those provided by one or more of
        the constituent resources where the dependency's capability is a
        considered a better match in the context of some resolution. The
        Subsystem runtime is responsible for provisioning the dependencies
        based on the Subsystem's provision policy or the provision policy of
        its scoped parents. If the feature Subsystem has an associated
        deployment manifest, then these dependencies are described in the
        Provision-Resource header.</para>
      </section>
    </section>
  </section>
  
  <section>
    <title>Weaving Hooks</title>
    
    <para>Subsystems implementations must ensure that dynamic package imports
    added by weaving hooks are available to subsystems whose classes have been
    woven by updating the sharing policies.</para>
    
    <para>Dynamic package imports added by weaving hooks are observed by 
    registering a <code>WovenClassListener</code> service and receiving 
    notifications via the <code>WovenClassListener.modified(WovenClass)</code> 
    method. The sharing policy must be updated while the woven class is in the 
    <code>TRANSFORMED</code> state so that it takes effect before the bundle 
    wiring is updated during the transition to <code>DEFINED</code>; otherwise, 
    the class would fail to load.</para>
    
    <para>The bundle containing the woven class can be obtained by calling the
    <code>WovenClass.getBundleWiring().getBundle()</code> method. A bundle might
    be a constituent of multiple subsystems, but never more than one scoped 
    subsystem. The rest are features, which have no sharing policies to update. 
    It's possible the bundle will not be a constituent of a scoped subsystem.
    The scoped subsystem, if any, containing the bundle as a constituent is 
    retrieved.</para>
    
    <para>It's possible for a classload request to occur on a bundle in an 
    unresolved subsystem because the framework is free to resolve bundles 
    whenever it desires. A resolved bundle can potentially receive a classload 
    request. For example, a <code>BundleEventListener</code> registered with the
    system  bundle context could receive the <code>RESOLVED</code> event and, 
    for whatever reason, load a class. Also, a resolved bundle in an unresolved 
    feature might get wired to another bundle. If this is the case, the 
    subsystem must be resolved in order to guarantee the dynamic imports will 
    not effect the resolution and, therefore, potentially create a wiring 
    inconsistent with the deployment manifest. Just as the framework is free to
    resolve bundles at anytime and for whatever reason, Subsystems 
    implementations are free to resolve subsystems.</para>
    
    <para>The sharing policy is only updated if the dynamic import cannot be 
    completely satisfied from within the subsystem. Note that all dynamic 
    imports with a wildcard must always be added to the sharing policy.</para>
  </section>

  <section>
    <title>Security</title>

    <section>
      <title>Subsystem Permission</title>

      <para>The Subsystem Permission is a permission used to grant the right
      to manage Subsystems with the option to restrict this right to a subset
      of Subsystems, called targets. For example, an operator can give a
      bundle the right to only manage Subsystems with a symbolic-name prefix
      of <code>com.acme.</code>:</para>

      <programlisting>...SubsystemPermission("<code>(name=com.acme.*)",
...)</code></programlisting>

      <para>The actions of Subsystem Permission are fine-grained. They allow a
      deployer to assign only the permissions that are necessary for a bundle.
      For example, a bundle may be granted only the permission to start and
      stop all Subsystems:</para>

      <programlisting>...SubsystemPermission["*", <code>EXECUTE]</code></programlisting>

      <para>Code that needs to check Subsystem Permission must always use the
      constructor that takes a Subsystem as a parameter:
      <code>SubsystemPermssion(Subsystem, String)</code> with a single
      action.</para>

      <para>For example, the implementation of <code>Subsystem.start</code>
      method must check that the caller has access to execute the
      Subsystem:</para>

      <programlisting>public class SubsystemImpl implements Subsystem{
    public void start() {
        securityManager.checkPermission(new SubsystemPermission(this,"execute"));
    }
}</programlisting>

      <para>The Subsystem Permission takes a Filter as its name argument.
      Filter based permissions are described in <xref linkend="i3394869"/>.
      Subsystem Archives are not signed and therefore the <code>signer</code>
      key is not supported. The keys have the following meaning for the
      Subsystem Permission:</para>

      <itemizedlist>
        <listitem>
          <para>id - The Subsystem ID of a Subsystem. For example
          <code>(id=23)</code></para>
        </listitem>

        <listitem>
          <para><code>location</code> - The location of a Subsystem. For
          example<code>
          (location=https://www.acme.com/download/*)</code></para>
        </listitem>

        <listitem>
          <para><code>name</code> - The symbolic name of a Subsystem. For
          example <code>(name=com.acme.*)</code></para>
        </listitem>
      </itemizedlist>

      <para>The name parameter of the permission can also be a single wildcard
      character (<code>'*' \u002a</code>). In that case all Subsystems must
      match.</para>
    </section>

    <section>
      <title>Actions</title>

      <para>The action parameter of Subsystem Permission will specify the
      subset of privileged Subsystem management operations that are allowed.
      The actions that are architected are listed below. Future versions of
      the specification can add additional actions. The given set should
      therefore not be assumed to be a closed set.</para>

      <table>
        <title>Actions</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="4*"/>

          <thead>
            <row>
              <entry>Action</entry>

              <entry>Used in</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>CONTEXT</code></entry>

              <entry><para><code>Subsystem.getBundleContext</code></para></entry>
            </row>

            <row>
              <entry><code>METADATA</code></entry>

              <entry><para><code>Subsystem.getSubsystemHeaders</code></para><para><code>Subsystem.getLocation</code></para></entry>
            </row>

            <row>
              <entry><code>LIFECYCLE</code></entry>

              <entry><para><code>Subsystem.install</code></para><para><code>Subsystem.uninstall</code></para></entry>
            </row>

            <row>
              <entry><code>EXECUTE</code></entry>

              <entry><para><code>Subsystem.start</code></para><para><code>Subsystem.stop</code></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Required Permissions</title>

      <para>A Subsystems implementation must check the caller for the
      appropriate Subsystem Permission before initiating a Subsystem
      management operation (e.g. install, start, stop, uninstall). Once the
      Subsystem Permission is checked against the caller the Subsystems
      implementation will proceed with the actual Subsystem operation. This
      operation will require a number of other permissions to complete. For
      example, the Admin Permission will be needed to install, start, stop,
      and uninstall resources of type osgi.bundle for a Subsystem. The
      Subsystems implementation must isolate the caller from such permission
      checks by use of a proper <code>doPrivileged</code> block.</para>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.subsystem.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i3394869"><title>Filter Based
      Permissions</title>OSGi Core, Chapter 2, Filter Based
      Permissions</bibliomixed>

      <bibliomixed><title>Core Service Hooks</title>OSGi Core, Chapter 55
      Service Hook Service Specification</bibliomixed>

      <bibliomixed xml:id="i3394044"><title>Resource and Wiring</title>OSGi
      Core, Chapter 6 Resource API Specification</bibliomixed>

      <bibliomixed xml:id="i3321126"><title>Zip File Format</title>The Zip
      file format as defined by the java.util.zip package.</bibliomixed>

      <bibliomixed xml:id="i3321186"><title>IANA
      application/vnd.osgi.subsystem</title>www.iana.org/assignments/media-types/application/vnd.osgi.subsystem</bibliomixed>

      <bibliomixed xml:id="i3323132"><title>RFC 1738 Uniform Resource
      Locators</title>http://www.ietf.org/rfc/rfc1738.txt</bibliomixed>

      <bibliomixed xml:id="i3323360"><title>Uniform Resource Identifiers
      (URI): Generic
      Syntax</title>http://www.ietf.org/rfc/rfc2396.txt</bibliomixed>

      <bibliomixed xml:id="i3324343"><title>Equinox Region
      Digraph</title>http://underlap.blogspot.com/2011/02/stumbling-towards-better-design.html</bibliomixed>
    </bibliolist>
  </section>
  
  <section>
    <title>Changes</title>

    <itemizedlist>
      <listitem>
        <para>Specified the translation of subsystem manifest headers.</para>
      </listitem>
      <listitem>
        <para>Added more informational subsystem manifest headers.</para>
      </listitem>
      <listitem>
        <para>Specified the interaction between Subsystems and Weaving Hooks for
        the purposes of supporting dynamically added import packages.</para>
      </listitem>
      <listitem>
        <para>Added the ability to override the archive's deployment manifest
        at install time.</para>
      </listitem>
      <listitem>
        <para>Added the ability to retrieve deployment manifest headers.</para>
      </listitem>
      <listitem>
        <para>Specified a means for declaratively identifying the services a
        bundle provides.</para>
      </listitem>
      <listitem>
        <para>Modified the procedure for determining dependencies to include
        the capabilities, in a specified order, from all repositories in order
        to increase the likelihood that a resolution will be found such as when
        a uses constraint violation would otherwise result.</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
