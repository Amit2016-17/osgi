/*
 * Copyright (c) OSGi Alliance (2011). All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.osgi.service.subsystem;

import java.io.InputStream;
import java.util.Collection;
import java.util.Map;

import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.Version;
import org.osgi.framework.resource.Capability;
import org.osgi.framework.resource.Requirement;
import org.osgi.framework.resource.Resource;

/**
 * A subsystem is a collection of {@link Resource resources} constituting a
 * logical, possibly isolated, unit of functionality. There are three types of
 * standard resources.
 * <ul>
 * <li>{@link SubsystemConstants#IDENTITY_TYPE_BUNDLE Bundle}<br/>
 *     A bundle that is not a fragment.</li>
 * <li>{@link SubsystemConstants#IDENTITY_TYPE_FRAGMENT Fragment}<br/>
 *     A fragment bundle.</li>
 * <li>{@link SubsystemConstants#IDENTITY_TYPE_SUBSYSTEM Subsystem}<br/>
 *     A subsystem defined by this specification.</li>
 * </ul>
 * A scoped subsystem is isolated according to its share policy, which may be
 * implicit or explicit. An unscoped subsystem is not isolated and, therefore,
 * has no share policy. There are three standard {@link
 * SubsystemConstants#SUBSYSTEM_TYPE types} of subsystems.
 * <ul>
 * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_APPLICATION Application}<br/>
 *     An implicitly scoped subsystem. Nothing is exported. Imports are computed
 *     based on any requirements not satisfied by the constituents.</li>
 * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_COMPOSITE Composite}<br/>
 *     An explicitly scoped subsystem. The share policy is defined by metadata
 *     within the subsystem archive.</li>
 * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_FEATURE Feature}<br/>
 *     An unscoped subsystem.
 * </ul>
 * A subsystem may have {@link #getChildren() children} and, unless it's the
 * root, must have at least one {@link #getParents() parent}. A subsystem
 * becomes a child of the subsystem used to install it. An unscoped subsystem
 * may have more than one parent if, for example, it was included as a resource
 * in more than one subsystem within the same region. A scoped subsystem always
 * has only one parent. 
 * <p/>
 * A subsystem has several unique identifiers that may or may not equate to the
 * same instance.
 * <ul>
 * <li>{@link #getLocation() Location}<br/>
 *     An identifier specified by the client as part of installation. It is
 *     guaranteed to be unique within the same framework. Subsystems with the
 *     same location are the same instance.</li>
 * <li>{@link #getSubsystemId() ID}<br/>
 *     An identifier generated by the implementation as part of installation. It
 *     is guaranteed to be unique within the same framework. Subsystems with the
 *     same ID are the same instance.</li>
 * <li>{@link #getSymbolicName() Symbolic Name}/{@link #getVersion() Version}
 *     <br/>The combination of symbolic name and version uniquely identifies a
 *     subsystem but not necessarily the same instance.</li>
 * </ul>
 * The {@link SubsystemConstants#RESOLUTION_DIRECTIVE resolution} of a subsystem
 * may be {@link SubsystemConstants#RESOLUTION_MANDATORY mandatory} or {@link
 * SubsystemConstants#RESOLUTION_OPTIONAL optional} for a given resource.
 * Optional resources do not prevent the subsystem from installing, although
 * they may prevent it from resolving.
 * <p/>
 * A subsystem may either {@link SubsystemConstants#
 * PROVISION_POLICY_ACCEPT_TRANSITIVE accept} or {@link SubsystemConstants#
 * PROVISION_POLICY_REJECT_TRANSITIVE reject} transitive dependencies as part of
 * its {@link SubsystemConstants#PROVISION_POLICY_DIRECTIVE provision policy}. A
 * transitive dependency is a {@link Requirement requirement} on a {@link
 * Capability capability} not provided by an intrinsic constituent of the
 * subsystem. An intrinsic constituent is an explicitly defined resource within
 * the subsystem metadata. A resource provisioned to satisfy the transitive
 * dependency is called a transitive resource and becomes an extrinsic
 * constituent of the first subsystem in the hierarchy that accepts transitive
 * dependencies, with the root subsystem being a fail-safe catch-all. An
 * extrinsic constituent is a resource that was not explicitly defined within
 * the subsystem metadata.
 * <p/>
 * Conceptually, a subsystem may be thought of as existing in a region isolated
 * by a share policy. Each region has one and only one scoped subsystem
 * dictating the share policy. The region may, however, have many unscoped
 * subsystems. It is therefore possible to have shared constituents across
 * multiple subsystems within a region. The region graph is an arborescence. The
 * root is identified as the region containing the root subsystem.
 * <p/>
 * Although the subsystem graph would appear to be a tree based on the parent/
 * child relationships, it is actually a directed, connected graph since there
 * may be cycles between subsystems within the same region. This is reflected by
 * the fact that a subsystem may have more than one parent. Care must be taken
 * when executing a depth-first search on the subsystem graph to avoid infinite
 * loops.
 * <p/>
 * A subsystem archive is a ZIP file having an SSA extension and containing
 * metadata describing the subsystem. The form of the metadata may be a
 * subsystem or deployment manifest, as well as any resource files {@link
 * #getConstituents() constituting} the subsystem. The manifests are optional
 * and will be computed if not present. The subsystem manifest headers may be
 * retrieved using the {@link #getHeaders() default} or a {@link
 * #getHeaders(String) specified} locale.
 * <p/>
 * A subsystem is installed using {@link #install(String) one} of the {@link
 * #install(String, InputStream) two} install methods. Because a subsystem must
 * be used to install other subsystems, a root subsystem is provided as a
 * starting point. A subsystem may be obtained by invoking one of the install
 * methods or through the service registry. Every installed subsystem has a
 * corresponding service registration. A bundle requesting a subsystem service
 * will receive the subsystem of which it is a constituent.
 * <p/>
 * The root subsystem has the following characteristics.
 * <ul>
 * <li>An ID of {@link SubsystemConstants#ROOT_SUBSYSTEM_ID 0}.</li>
 * <li>A symbolic name of {@link SubsystemConstants#ROOT_SUBSYSTEM_SYMBOLICNAME
 *     org.osgi.service.subsystem.root}.</li>
 * <li>A version of {@link SubsystemConstants#ROOT_SUBSYSTEM_VERSION 
 *     1.0.0}.</li>
 * <li>Has no parent.</li>
 * <li>All existing bundles, including the system and subsystems implementation
 *     bundles, are constituents.</li>
 * <li>A scoped subsystem with a provision policy of accept transitive.</li>
 * </ul>
 * A subsystem service has the following properties.
 * <ul>
 * <li>{@link SubsystemConstants#SUBSYSTEM_ID_PROPERTY subsystem.id}</li>
 * <li>{@link SubsystemConstants#SUBSYSTEM_SYMBOLICNAME_PROPERTY 
 *     subsystem.symbolic.name}</li>
 * <li>{@link SubsystemConstants#SUBSYSTEM_VERSION_PROPERTY 
 *     subsystem.version}</li>
 * <li>{@link SubsystemConstants#SUBSYSTEM_TYPE_PROPERTY subsystem.type}</li>
 * <li>{@link SubsystemConstants#SUBSYSTEM_STATE_PROPERTY subsystem.state}</li>
 * </ul>
 * <p/>
 * Each subsystem has an associated bundle providing the region context within 
 * which its constituents operate. All subsystems within the same region have
 * the same context. This context may be used, for example, to monitor framework
 * and service events affecting the constituents of subsystems within the
 * region. A region context bundle has the following characteristics.
 * <ul>
 * <li>A symbolic name of {@link SubsystemConstants#
 *     REGION_CONTEXT_BUNDLE_SYMBOLICNAME_PREFIX 
 *     org.osgi.service.subsystem.region.context.}&lt;subsystem id&gt;.</li>
 * <li>A version of {@link SubsystemConstants#REGION_CONTEXT_BUNDLE_VERSION
 *     1.0.0}.</li>
 * <li>A location string of &lt;subsystem bundle location&gt;/&lt;subsystem
 *     bundle id&gt;</li>
 * </ul>
 * 
 * @ThreadSafe
 * @noimplement
 */
public interface Subsystem {
	/**
	 * The states of a subsystem in the framework. These states match those of 
	 * a Bundle and are derived using the same rules as CompositeBundles. As 
	 * such, they are more a reflection of what content bundles are permitted 
	 * to do rather than an aggregation of the content bundle states. 
	 */
	public static enum State {
		/**
		 * A subsystem is in the INSTALLING state when it is initially created.
		 */
		INSTALLING,
		/**
		 * A subsystem is in the INSTALLED state when all resources are
		 * successfully installed.
		 */
		INSTALLED,
		/**
		 * A subsystem is in the INSTALL_FAILED state when an unrecoverable
		 * error occurred during installation.
		 */
		INSTALL_FAILED,
		/**
		 *  A subsystem in the RESOLVING is allowed to have its content bundles 
		 * resolved.
		 */
		RESOLVING,
		/**
		 *  A subsystem is in the RESOLVED state when all resources are 
		 * resolved.
		 */
		RESOLVED,
		/**
		 * A subsystem is in the STARTING state when all its content bundles 
		 * are enabled for activation.
		 */
		STARTING,
		/**
		 * A subsystem is in the ACTIVE state when it has reached the beginning 
		 * start-level (for starting it's contents), and all its persistently 
		 * started content bundles that are resolved and have had their 
		 * start-levels met have completed, or failed, their activator start 
		 * method.
		 */
		ACTIVE,
		/**
		 *  A subsystem in the STOPPING state is in the process of taking its 
		 * its active start level to zero, stopping all the content bundles.
		 */
		STOPPING,
		/**
		 * A subsystem in the UNINSTALLING state is in the process of
		 * uninstalling its constituent resources.
		 */
		UNINSTALLING,
		/**
		 * A subsystem is in the UNINSTALLED state when all its content bundles 
		 * and uninstalled and its system bundle context is invalidated.
		 */
		UNINSTALLED
	}
	
	/**
	 * Returns the {@link BundleContext bundle context} of the region context
	 * {@link Bundle bundle}. It represents the perspective of all {@link 
	 * Resource resources} that are {@link #getConstituents() constituents} of
	 * subsystems within the region. It may be used to monitor events internal
	 * to the region as well as external events visible to the region.
	 * 
	 * @return The bundle context of the context bundle for the region within
	 *         which this subsystem resides.
	 */
	public BundleContext getBundleContext();
	
	/**
	 * Gets the subsystems managed by this service. This only includes the 
	 * top-level Subsystems installed in the Framework, CoompositeBundle or 
	 * Subsystem from which this service has been retrieved.
	 * 
	 * @return The Subsystems managed by this service.
	 * @throws IllegalStateException If the subsystem is in the {@link 
	 *         State#INSTALLING installing state} or transitioned to the {@link 
	 *         State#UNINSTALLED uninstalled state} due to a failed 
	 *         installation.
	 */
	public Collection<Subsystem> getChildren();
	
	/**
	 * Returns a snapshot of all {@code Resources} currently constituting this 
	 * {@link Subsystem}. If this {@code Subsystem} has no {@code Resources}, 
	 * the {@link Collection} will be empty.
	 * 
	 * @return A snapshot of all {@code Resources} currently constituting this
	 *         {@code Subsystem}.
	 * @throws IllegalStateException If the subsystem is in the {@link 
	 *         State#INSTALLING installing state} or transitioned to the {@link 
	 *         State#UNINSTALLED uninstalled state} due to a failed 
	 *         installation.
	 */
	public Collection<Resource> getConstituents();
	
	/**
	 * Gets the headers used to define this subsystem. The headers will be 
	 * localized using the locale returned by java.util.Locale.getDefault. This 
	 * is equivalent to calling getHeaders(null).
	 * 
	 * @return The headers used to define this subsystem.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         AdminPermission[this,METADATA] and the runtime supports 
	 *         permissions.
	 * @throws IllegalStateException If the subsystem is in the {@link 
	 *         State#INSTALLING installing state} or transitioned to the {@link 
	 *         State#UNINSTALLED uninstalled state} due to a failed 
	 *         installation.
	 */
	public Map<String, String> getHeaders();
	
	/**
	 * Gets the headers used to define this subsystem.
	 * 
	 * @param locale The locale name to be used to localize the headers. If the 
	 *        locale is null then the locale returned by 
	 *        java.util.Locale.getDefault is used. If the value is the empty 
	 *        string then the returned headers are returned unlocalized. 
	 * @return the headers used to define this subsystem, localized to the 
	 *         specified locale.
	 * @throws IllegalStateException If the subsystem is in the {@link 
	 *         State#INSTALLING installing state} or transitioned to the {@link 
	 *         State#UNINSTALLED uninstalled state} due to a failed 
	 *         installation.
	 */
	public Map<String, String> getHeaders(String locale);
	
	/**
	 * The location identifier used to install this subsystem through 
	 * Subsystem.install. This identifier does not change while this subsystem 
	 * remains installed, even after Subsystem.update. This location identifier 
	 * is used in Subsystem.update if no other update source is specified. 
	 * @return The string representation of the subsystem's location identifier.
	 */
	public String getLocation();
	
	/**
	 * Returns the parent subsystems of this subsystem. If this is the root
	 * subsystem, an empty collection is returned. Otherwise, the collection
	 * will contain at least one parent. More than one parent will be present
	 * if this subsystem is a constituent of multiple subsystems within the same
	 * region.
	 * 
	 * @return The parent subsystems of this subsystem or an empty collection if
	 *         this is the root subsystem.
	 */
	public Collection<Subsystem> getParents();
	
	/**
	 * Gets the state of the subsystem.
	 * @return The state of the subsystem.
	 */
	public State getState();
	
	/**
	 * Gets the identifier of the subsystem. Subsystem identifiers are assigned 
	 * when the subsystem is installed and are unique within the framework. 
	 * @return The identifier of the subsystem.
	 */
	public long getSubsystemId();
	
	/**
	 * Gets the symbolic name of this subsystem.
	 * 
	 * @return The symbolic name of this subsystem.
	 * @throws IllegalStateException If the subsystem is in the {@link 
	 *         State#INSTALLING installing state} or transitioned to the {@link 
	 *         State#UNINSTALLED uninstalled state} due to a failed 
	 *         installation.
	 */
	public String getSymbolicName();
	
	/**
	 * Gets the version of this subsystem.
	 * 
	 * @return The version of this subsystem.
	 * @throws IllegalStateException If the subsystem is in the {@link 
	 *         State#INSTALLING installing state} or transitioned to the {@link 
	 *         State#UNINSTALLED uninstalled state} due to a failed 
	 *         installation.
	 */
	public Version getVersion();
	
	/**
	 * Install a new subsystem from the specified location identifier.
	 * <p>
	 * This method performs the same function as calling install(String, 
	 * InputStream) with the specified location identifier and a null 
	 * InputStream.
	 * @param location The location identifier of the subsystem to be installed.
	 * @return The installed subsystem.
	 * @throws SubsystemException If the subsystem could not be installed for
	 *         any reason.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         AdminPermission[installed subsystem,LIFECYCLE], and the Java 
	 *         Runtime Environment supports permissions.
	 */
	public Subsystem install(String location) throws SubsystemException;
	
	/**
	 * Install a new subsystem from the specified InputStream object.
	 * <p/>
	 * If the specified InputStream is null, the InputStream must be created 
	 * from the specified location.
	 * <p/>
	 * The specified location identifier will be used as the identity of the 
	 * subsystem. Every installed subsystem is uniquely identified by its 
	 * location identifier which is typically in the form of a URL.
	 * <p/>
	 * TODO: Understand whether this all change when we can install the same 
	 * bundle multiple times.
	 * <p/>
	 * A subsystem and its contents must remain installed across Framework and 
	 * VM restarts. The subsystem itself is installed atomically, however its 
	 * contents are not.
	 * <p/>
	 * The following steps are required to install a subsystem:
	 * <ol>
	 * 		<li>If there is an existing subsystem containing the same location 
	 *          identifier as the subsystem to be installed, then the existing
	 *          subsystem is returned.</li>
	 * 		<li>If this is a new install, then a new Subsystem is created with 
	 *          its id set to the next available value (ascending order).</li>
	 * 		<li>The subsystem's state is set to INSTALLING and if EventAdmin is 
	 *          available, an event of type INSTALLING is fired.</li>
	 *      <li>The following installation steps are then started and performed 
	 *          asynchronously and the new subsystem is returned to the caller.</li>
	 * 		<li>The subsystem content is read from the input stream.</li>
	 * 		<li>If the subsystem requires isolation (i.e. is an application or 
	 *          a composite), then isolation is set up while the install is in 
	 *          progress, such that none of the content bundles can be resolved.
	 *          This isolation is not changed until the subsystem is explicitly 
	 *          requested to resolve (i.e. as a result of a Subsystem.start() 
	 *          operation).</li>
	 * 		<li>If the subsystem does not include a deployment manifest, then 
	 *          the subsystem runtime must calculate one.</li>
	 * 		<li>The resources identified in the deployment manifest are 
	 *          installed into the framework.  All content resources are 
	 *          installed into the Subsystem, whereas transitive dependencies 
	 *          are installed into an ancestor subsystem. If any resources fail 
	 *          to install, then the entire installation is failed. Transitive 
	 *          resources are free to resolve and start independent of the 
	 *          subsystem they were installed for.</li>
	 * 		<li>The subsystem's state is set to INSTALLED and if EventAdmin is 
	 *          available an INSTALLED event is fired.</li>
	 * </ol>
	 * @param location The location identifier of the subsystem to be installed.
	 * @param content The InputStream from where the subsystem is to be 
	 *        installed or null if the location is to be used to create the 
	 *        InputStream.
	 * @return The installed subsystem.
	 * @throws SubsystemException If the subsystem could not be installed for
	 *         any reason.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         AdminPermission[installed subsystem,LIFECYCLE], and the Java 
	 *         Runtime Environment supports permissions.
	 */
	public Subsystem install(String location, InputStream content) throws SubsystemException;
	
	/**
	 * Starts the subsystem. The subsystem is started according to the rules 
	 * defined for Bundles and the content bundles are enabled for activation. 
	 * @throws SubsystemException If this subsystem could not be started. 
	 * @throws IllegalStateException If this subsystem has been uninstalled. 
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         AdminPermission[this,EXECUTE] and the runtime supports 
	 *         permissions.
	 */
	public void start() throws SubsystemException;
	
	/**
	 * Stops the subsystem. The subsystem is stopped according to the rules 
	 * defined for Bundles and the content bundles are disabled for activation 
	 * and stopped.
	 * @throws SubsystemException If an internal exception is thrown while 
	 *         stopping the subsystem (e.g. a BundleException from Bundle.stop). 
	 * @throws IllegalStateException - If this subsystem has been uninstalled. 
	 * @throws SecurityException - If the caller does not have the appropriate 
	 *         AdminPermission[this,EXECUTE] and the runtime supports 
	 *         permissions.
	 */
	public void stop() throws SubsystemException;
	
	/**
	 * Uninstall the given subsystem.
	 * <p/>
	 * This method causes the Framework to notify other bundles and subsystems 
	 * that this subsystem is being uninstalled, and then puts this subsystem 
	 * into the UNINSTALLED state. The Framework must remove any resources 
	 * related to this subsystem that it is able to remove. If this subsystem 
	 * has exported any packages, the Framework must continue to make these 
	 * packages available to their importing bundles or subsystems until the 
	 * org.osgi.service.packageadmin.PackageAdmin.refreshPackages(
	 * org.osgi.framework.Bundle[]) method has been called or the Framework is 
	 * relaunched. The following steps are required to uninstall a subsystem:
	 * <ol>
	 * 		<li>If this subsystem's state is UNINSTALLED then an 
	 *          IllegalStateException is thrown.</li>
	 * 		<li>If this subsystem's state is ACTIVE, STARTING or STOPPING, this 
	 *          subsystem is stopped as described in the Subsystem.stop() 
	 *          method. If Subsystem.stop() throws an exception, a Framework 
	 *          event of type FrameworkEvent.ERROR is fired containing the 
	 *          exception.</li>
	 * 		<li>This subsystem's state is set to UNINSTALLED.</li>
	 * 		<li>A subsystem event of type SubsystemEvent.UNINSTALLED is fired.</li>
	 * 		<li>This subsystem and any persistent storage area provided for this 
	 *          subsystem by the Framework are removed.</li>
	 * </ol>
	 * @throws SubsystemException If the uninstall failed.
	 * @throws IllegalStateException If the subsystem is already in the 
	 *         UNISTALLED state.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         AdminPermission[this,LIFECYCLE] and the Java Runtime Environment 
	 *         supports permissions.
	 */
	public void uninstall() throws SubsystemException;
}
