/*
 * Copyright (c) OSGi Alliance (2011). All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.osgi.service.subsystem;

import java.io.InputStream;
import java.util.Collection;
import java.util.Locale;
import java.util.Map;

import org.osgi.framework.BundleContext;
import org.osgi.framework.Version;
import org.osgi.framework.resource.Resource;

/**
 * A subsystem is a collection of resources constituting a logical, possibly
 * isolated, unit of functionality. There are three types of standard resources.
 * <ul>
 * 		<li>Bundle - A bundle that is not a fragment.
 * 		</li>
 * 		<li>Fragment - A fragment bundle.
 * 		</li>
 * 		<li>Subsystem - A subsystem defined by this specification.
 * 		</li>
 * </ul>
 * A scoped subsystem is isolated according to its share policy, which may be
 * implicit or explicit. An unscoped subsystem is not isolated and, therefore,
 * has no share policy. There are three standard types of subsystems.
 * <ul>
 * 		<li>Application - An implicitly scoped subsystem. Nothing is exported.
 *          Imports are computed based on any requirements not satisfied by the
 *          constituents.
 *     </li>
 * 		<li>Composite - An explicitly scoped subsystem. The share policy is
 *          defined by metadata within the subsystem archive.
 *     </li>
 * 		<li>Feature - An unscoped subsystem.
 *     </li>
 * </ul>
 * A subsystem may have children and, unless it's the root, must have at least
 * one parent. A subsystem becomes a child of the installing subsystem. An
 * unscoped subsystem may have more than one parent if, for example, it is a
 * constituent of more than one subsystem within the same region. A scoped
 * subsystem always has only one parent. 
 * <p/>
 * A subsystem has several unique identifiers that may or may not equate to the
 * same instance.
 * <ul>
 * 		<li>Location - An identifier specified by the client as part of
 *          installation. It is guaranteed to be unique within the same
 *          framework. Subsystems with the same location are the same instance.
 *     </li>
 * 		<li>ID - An identifier generated by the implementation as part of
 *          installation. It is guaranteed to be unique within the same
 *          framework. Subsystems with the same ID are the same instance.
 *     </li>
 * 		<li>Symbolic Name/Version - The combination of symbolic name and version
 *          uniquely identifies a subsystem but not necessarily the same
 *          instance.
 *     </li>
 * </ul>
 * The resolution of a subsystem may be mandatory or optional for a given
 * resource. Optional resources do not prevent the subsystem from installing,
 * although they may prevent it from resolving.
 * <p/>
 * A subsystem may either accept or reject transitive resources as part of its
 * provision policy. A transitive resource provides a capability (called a
 * transitive dependency) for a content resource's requirement that was not
 * satisfied by any content resource in the subsystem. A transitive resource
 * becomes a constituent of the subsystem with a provision policy of accept
 * transitive and that lies on the longest path between the subsystem and the
 * root subsystem, inclusively.
 * <p/>
 * Conceptually, a subsystem may be thought of as existing in a region isolated
 * by a share policy. Each region has one and only one scoped subsystem, which
 * dictates the sharing policy. The region may, however, have many unscoped
 * subsystems. It is therefore possible to have shared constituents across
 * multiple subsystems within a region.
 * <p/>
 * The subsystem graph may be though of as is an acyclic digraph with the root 
 * subsystem as the sole source vertex. The edges have the child as the head and
 * parent as the tail.
 * <p/>
 * A subsystem archive is a ZIP file having an SSA extension and containing
 * metadata describing the subsystem. The form of the metadata may be a
 * subsystem or deployment manifest, as well as any resource files constituting
 * the subsystem. The manifests are optional and will be computed if not
 * present. The subsystem manifest headers may be retrieved using the default or
 * a specified locale.
 * <p/>
 * A subsystem is installed using one of the two install methods. Because a
 * subsystem must be used to install other subsystems, a root subsystem is
 * provided as a starting point. A subsystem may be obtained by invoking one of
 * the install methods or through the service registry. Every installed
 * subsystem has a corresponding service registration. A bundle requesting a
 * subsystem service will receive the subsystem of which it is a constituent.
 * <p/>
 * The root subsystem has the following characteristics.
 * <ul>
 * <li>An ID of 0.</li>
 * <li>A symbolic name of org.osgi.service.subsystem.root.</li>
 * <li>A version of 1.0.0.</li>
 * <li>Has no parent.</li>
 * <li>All existing bundles, including the system and subsystems implementation
 *     bundles, are constituents.</li>
 * <li>A scoped subsystem with a provision policy of accept transitive.</li>
 * </ul>
 * A subsystem service has the following properties.
 * <ul>
 * <li>subsystem.id</li>
 * <li>subsystem.symbolic.name</li>
 * <li>subsystem.version</li>
 * <li>subsystem.type</li>
 * <li>subsystem.state</li>
 * </ul>
 * <p/>
 * Each subsystem has an associated bundle providing the region context within 
 * which its constituents operate. All subsystems within the same region have
 * the same context. This context may be used, for example, to monitor framework
 * and service events affecting the constituents of subsystems within the
 * region. A region context bundle has the following characteristics.
 * <ul>
 * 		<li>A symbolic name of 
 *          org.osgi.service.subsystem.region.context.&lt;subsystem id&gt;.
 * 		</li>
 * 		<li>A version of 1.0.0.
 * 		</li>
 * 		<li>A location string of &lt;subsystem bundle location&gt;/&lt;subsystem
 *          bundle id&gt;
 *      </li>
 * </ul>
 * 
 * @ThreadSafe
 * @noimplement
 */
public interface Subsystem {
	/**
	 * Identifies the category a resource falls under for the purpose of
	 * filtering the results when {@link Subsystem#getResources(
	 * ResourceCategory...) retrieving} resources associated with this
	 * subsystem.
	 * <p/>
	 * Resource categories may be compatible or incompatible. A resource may
	 * be in more than one compatible category but never in more than one
	 * incompatible category. In the following table, incompatible categories
	 * are marked with an "X".
	 * <p/>
	 * <table border="1">
	 * 		<tr align="center">
	 * 			<th>&nbsp;</th>
	 * 			<th>CONTENT</th>
	 * 			<th>TRANSITIVE_INTRINSIC</th>
	 * 			<th>TRANSITIVE_EXTRINSIC</th>
	 * 			<th>SHARED</th>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<th>CONTENT</th>
	 * 			<td>&nbsp;</td>
	 * 			<td>X</td>
	 * 			<td>X</td>
	 * 			<td>&nbsp;</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<th>TRANSITIVE_INTRINSIC</th>
	 * 			<td>X</td>
	 * 			<td>&nbsp;</td>
	 * 			<td>X</td>
	 * 			<td>X</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<th>TRANSITIVE_EXTRINSIC</th>
	 * 			<td>X</td>
	 * 			<td>X</td>
	 * 			<td>&nbsp;</td>
	 * 			<td>X</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<th>SHARED</th>
	 * 			<td>&nbsp;</td>
	 * 			<td>X</td>
	 * 			<td>X</td>
	 * 			<td>&nbsp;</td>
	 * 		</tr>
	 * </table>
	 */
	public static enum ResourceCategory {
		/**
		 * A resource contained by this subsystem that was specified in the
		 * Subsystem-Content manifest header or included in the subsystem
		 * archive when the Subsystem-Content header was omitted.
		 */
		CONTENT,
		/**
		 * A transitive resource provisioned on behalf of this subsystem. It may
		 * or may not be contained by this subsystem.
		 */
		TRANSITIVE_INTRINSIC,
		/**
		 * A transitive resource contained by this subsystem but provisioned on
		 * behalf of another subsystem. Only subsystems with a provision policy
		 * of accept transitive may contain this type of resource.
		 */
		TRANSITIVE_EXTRINSIC,
		/**
		 * A content resource contained by this subsystem and at least one other
		 * subsystem. Equivalently, a content resource contained by this
		 * subsystem whose reference count is greater than one.
		 */
		SHARED
	}
	
	/**
	 * The states of a subsystem in the framework. These states match those of 
	 * a Bundle and are derived using the same rules as CompositeBundles. As 
	 * such, they are more a reflection of what content bundles are permitted 
	 * to do rather than an aggregation of the content bundle states. 
	 */
	public static enum State {
		/**
		 * A subsystem is in the INSTALLING state when it is initially created.
		 */
		INSTALLING,
		/**
		 * A subsystem is in the INSTALLED state when all resources are
		 * successfully installed.
		 */
		INSTALLED,
		/**
		 * A subsystem is in the INSTALL_FAILED state when an unrecoverable
		 * error occurred during installation.
		 */
		INSTALL_FAILED,
		/**
		 *  A subsystem in the RESOLVING is allowed to have its content bundles 
		 * resolved.
		 */
		RESOLVING,
		/**
		 *  A subsystem is in the RESOLVED state when all resources are 
		 * resolved.
		 */
		RESOLVED,
		/**
		 * A subsystem is in the STARTING state when all its content bundles 
		 * are enabled for activation.
		 */
		STARTING,
		/**
		 * A subsystem is in the ACTIVE state when it has reached the beginning 
		 * start-level (for starting it's contents), and all its persistently 
		 * started content bundles that are resolved and have had their 
		 * start-levels met have completed, or failed, their activator start 
		 * method.
		 */
		ACTIVE,
		/**
		 *  A subsystem in the STOPPING state is in the process of taking its 
		 * its active start level to zero, stopping all the content bundles.
		 */
		STOPPING,
		/**
		 * A subsystem in the UNINSTALLING state is in the process of
		 * uninstalling its constituent resources.
		 */
		UNINSTALLING,
		/**
		 * A subsystem is in the UNINSTALLED state when all its content bundles 
		 * and uninstalled and its system bundle context is invalidated.
		 */
		UNINSTALLED
	}
	
	/**
	 * Returns the bundle context of the region context bundle. The context is
	 * that of all resources contained by subsystems within the region. It may
	 * be used to monitor events internal to the region as well as external
	 * events visible to the region.
	 * <p/>
	 * All subsystems within the same region will return the same bundle
	 * context.
	 * <p/>
	 * This method will block if this subsystem's state is in {INSTALLING} until
	 * a state transition occurs. Implementations should be sensitive to the
	 * potential for long running operations and periodically check the current
	 * thread for interruption. An interrupted thread should result in a
	 * SubsystemException being thrown with an InterruptedException as the
	 * cause.
	 * 
	 * @return The bundle context of the context bundle for the region within
	 *         which this subsystem resides.
	 * @throws IllegalStateException If this subsystem's state is in
	 *         {INSTALL_FAILED, UNINSTALLING, UNINSTALLED}.
	 */
	public BundleContext getBundleContext();
	
	/**
	 * Returns the child subsystems of this subsystem.
	 * <p/>
	 * The returned collection represents a snapshot of all child subsystems of
	 * this subsystem at the time this method was invoked. It is a property of
	 * the caller and may be modified by the caller. Each child will have this
	 * subsystem as one of its parents.
	 * <p/>
	 * A subsystem becomes a child of this subsystem in one of two ways.
	 * <ol>
	 * 		<li>The child subsystem is installed into this subsystem by
	 *          invoking one of this subsystem's install methods.
	 *      </li>
	 *      <li>The child subsystem is nested within this subsystem.
	 *          A subsystem is nested within another subsystem when specified as
	 *          part of the Subsystem-Content header of the other subsystem's
	 *          archive. Alternatively, a subsystem is nested when its archive
	 *          is included in the other subsystem's archive, and the manifest
	 *          of the other subsystem omits the Subsystem-Content header.
	 *      </li>
	 * </ol>
	 * This method will block if this subsystem's state is in {INSTALLING} until
	 * a state transition occurs. Implementations should be sensitive to the
	 * potential for long running operations and periodically check the current
	 * thread for interruption. An interrupted thread should result in a
	 * SubsystemException being thrown with an InterruptedException as the
	 * cause.
	 * <p/>
	 * @return The child subsystems of this subsystem.
	 * @throws IllegalStateException If this subsystem's state is in
	 *         {INSTALL_FAILED, UNINSTALLING, UNINSTALLED}.
	 */
	public Collection<Subsystem> getChildren();
	
	/**
	 * Returns the headers from the main section of this subsystem's manifest.
	 * <p/>
	 * The returned map is unmodifiable. The keys are header names, and the
	 * values are header values. Because header names are case-insensitive, the
	 * methods of the map must treat them in a case-insensitive manner. If the
	 * manifest was omitted or contained no main section, the map will be empty.
	 * <p/>
	 * The header values are translated according to the specified locale. If
	 * the specified locale is null or not supported, the raw values are
	 * returned.
	 * <p/>
	 * This method will block if this subsystem's state is in {INSTALLING} until
	 * a state transition occurs. Implementations should be sensitive to the
	 * potential for long running operations and periodically check the current
	 * thread for interruption. An interrupted thread should result in a
	 * SubsystemException being thrown with an InterruptedException as the
	 * cause.
	 * <p/>
	 * @param locale The locale for which translations are desired, or null to
	 *        receive the raw header values.
	 * @return The headers from the main section of this subsystem's manifest
	 *         translated according to the specified locale if supported and not
	 *         null.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         SubsystemPermission[this,METADATA] and the runtime supports 
	 *         permissions.
	 * @throws IllegalStateException If this subsystem's state is in
	 *         {INSTALL_FAILED}.
	 * @throws SubsystemException If the current thread is interrupted while
	 *         this subsystem's state is in {INSTALLING}.
	 */
	public Map<String, String> getHeaders(Locale locale);
	
	/**
	 * Returns the location identifier of this subsystem.
	 * <p/>
	 * The location identifier is the {@code location} that was passed to {@link
	 * #install(String) one} of the {@link #install(String, InputStream) two}
	 * install methods of the {@link #getParents() parent} subsystem.
	 * <p/>
	 * @return The location identifier of this subsystem.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         SubsystemPermission[this,METADATA], and the runtime supports 
	 *         permissions.
	 */
	public String getLocation();
	
	/**
	 * Returns the parent subsystems of this subsystem.
	 * <p/>
	 * The returned collection is an unmodifiable snapshot of all parent
	 * subsystems of this subsystem at the time this method was invoked. If this
	 * is the root subsystem, an empty collection is returned. Otherwise, the
	 * collection will contain at least one parent. More than one parent will be
	 * present if this subsystem is a constituent of multiple subsystems within
	 * the same region.
	 * <p/>
	 * A subsystem becomes a parent of this subsystem in one of two ways.
	 * <ol>
	 * 		<li>This subsystem is installed into the parent subsystem by
	 *          invoking one of the parent subsystem's install methods.
	 *      </li>
	 *      <li>This subsystem is nested within the parent subsystem. A
	 *          subsystem is nested within another subsystem when specified as
	 *          part of the Subsystem-Content header of the other subsystem's
	 *          manifest or included in the other subsystem's archive when the
	 *          Subsystem-Content header was omitted.
	 *      </li>
	 * </ol>
	 * <p/>
	 * @return The parent subsystems of this subsystem or an empty collection if
	 *         this is the root subsystem.
	 * @throws IllegalStateException If this subsystem's state is in
	 *         {INSTALL_FAILED, UNINSTALLING, UNINSTALLED}.
	 */
	public Collection<Subsystem> getParents();
	
	/**
	 * Returns the resources associated with this subsystem according to the
	 * specified categories.
	 * <p/>
	 * Resources are {@link ResourceCategory categorized} based on their
	 * relationship with the subsystem. The returned collection is unmodifiable
	 * and represents a snapshot of all resources associated with this subsystem
	 * that fell under one or more of the specified categories. Resources that
	 * fall under more than one specified category will not appear more than
	 * once in the returned collection. If the specified categories parameter is
	 * null or an empty array, resources from all categories are returned.
	 * <p/>
	 * This method will block if this subsystem's state is in {INSTALLING} until
	 * a state transition occurs. Implementations should be sensitive to the
	 * potential for long running operations and periodically check the current
	 * thread for interruption. An interrupted thread should result in a
	 * SubsystemException being thrown with an InterruptedException as the
	 * cause.
	 * <p/>
	 * @param categories The categories for which resources are desired or null
	 *        or an empty array for resources from all categories.
	 * @return The resources associated with this subsystem according to the
	 *         specified categories.
	 * @throws IllegalStateException If this subsystem's state is in
	 *         {INSTALL_FAILED, UNINSTALLING, UNINSTALLED}.
	 * @throws SubsystemException If the current thread is interrupted while
	 *         this subsystem's state is in {INSTALLING}.
	 */
	public Collection<Resource> getResources(ResourceCategory...categories);
	
	/**
	 * Returns the current state of this subsystem.
	 * <p/>
	 * @return The current state of this subsystem.
	 */
	public State getState();
	
	/**
	 * Returns the identifier of this subsystem.
	 * <p/>
	 * The identifier is a monotonically increasing, non-negative integer
	 * automatically generated at installation time and guaranteed to be unique
	 * within the framework. The identifier of the root subsystem is zero.
	 * <p/>
	 * @return The identifier of this subsystem.
	 */
	public long getSubsystemId();
	
	/**
	 * Returns the symbolic name of this subsystem.
	 * <p/>
	 * The subsystem symbolic name conforms to the same grammar rules as the
	 * bundle symbolic name and is derived from one of the following, in order.
	 * <ul>
	 * 		<li>The value of the Subsystem-Content header, if specified.
	 * 		</li>
	 * 		<li>The subsystem URI if passed as the location along with the
	 *          content to the install method.
	 *      </li>
	 * 		<li>Optionally generated in an implementation specific way.
	 * 		</li>
	 * </ul>
	 * The combination of symbolic name and version is unique within a region.
	 * The symbolic name of the root subsystem is {@code
	 * org.osgi.service.subsystem.root}.
	 * <p/>
	 * @return The symbolic name of this subsystem.
	 */
	public String getSymbolicName();
	
	/**
	 * Returns the version of this subsystem.
	 * <p/>
	 * The subsystem version conforms to the same grammar rules as the bundle
	 * version and is derived from one of the following, in order.
	 * <ul>
	 * 		<li>The value of the Subsystem-Version header, if specified.
	 * 		</li>
	 * 		<li>The subsystem URI if passed as the location along with the
	 *          content to the install method.
	 *      </li>
	 * 		<li>Defaults to {@code 0.0.0}.
	 * 		</li>
	 * </ul>
	 * The combination of symbolic name and version is unique within a region.
	 * The version of the root subsystem is {@code 1.0.0}.
	 * <p/>
	 * @return The version of this subsystem.
	 */
	public Version getVersion();
	
	/**
	 * Installs a subsystem from the specified <code>location</code> identifier.
	 * <p/>
	 * This method performs the same function as calling {@link #install(String,
	 * InputStream)} with the specified <code>location</code> identifier and a
	 * <code>null</code> InputStream.
	 * 
	 * @param location - The location identifier of the subsystem to install.
	 * @return The installed subsystem.
	 * @throws SubsystemException If the installation failed.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         SubsystemPermission[installed subsystem,LIFECYCLE], and the Java 
	 *         Runtime Environment supports permissions.
	 * @see #install(String, InputStream)
	 */
	public Subsystem install(String location) throws SubsystemException;
	
	/**
	 * Installs a subsystem from the specified content.
	 * <p/>
	 * If the specified content is null, a new input stream must be created from
	 * which to read the subsystem by interpreting, in an implementation
	 * dependent manner, the specified location.
	 * <p/>
	 * The specified location will be used as an identifier of the subsystem.
	 * Every installed subsystem is uniquely identified by its location, which
	 * is typically in the form of a URI.
	 * <p/>
	 * A subsystem installation must be persistent. That is, an installed
	 * subsystem must remain installed across Framework and VM restarts.
	 * <p/>
	 * The following table shows which actions are associated with each state.
	 * An action of Wait means this method will block until a state transition
	 * occurs, upon which the new state will be evaluated in order to
	 * determine how to proceed. An action of Return means this method returns
	 * immediately without taking any other action.
	 * <p/>
	 * <table border="1"">
	 * 		<tr>
	 * 			<th>State</td>
	 * 			<th>Action</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALLING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALLED</td>
	 * 			<td>Install</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALL_FAILED</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>RESOLVING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>RESOLVED</td>
	 * 			<td>Install</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>STARTING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>ACTIVE</td>
	 * 			<td>Install</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>STOPPING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>UNINSTALLING</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>UNINSTALLED</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * </table>
	 * <p/>
	 * All references to changing the state of this subsystem include both
	 * changing the state of the subsystem object as well as the state property
	 * of the subsystem service registration.
	 * <p/>
	 * All installation failure flows include the following.
	 * <ul>
	 * 		<li>A state change to INSTALL_FAILED.
	 * 		</li>
	 * 		<li>A SubsystemException being thrown, sometimes with a specified
	 *          cause.
	 *      </li>
	 *      <li>Unregistering the subsystem service.
	 *      </li>
	 *      <li>Uninstalling the region context bundle.
	 *      </li>
	 *      <li>All resources installed as part of this operation are
	 *          uninstalled.
	 *      </li>
	 * </ul>
	 * <p/>
	 * Implementations should be sensitive to the potential for long running
	 * operations and periodically check the current thread for interruption. An
	 * interrupted thread should be treated as an installation failure with an
	 * InterruptedException as the cause of the SubsystemException.
	 * <p/>
	 * The following steps are required to install a subsystem.
	 * <ol>
	 * <li>If an installed subsystem with the specified location identifier
	 *     already exists, return the installed subsystem.
	 * </li>
	 * <li>Read the specified content in order to determine the symbolic name,
	 *     version, and type of the installing subsystem. If an error occurs
	 *     while reading the content, an installation failure results.
	 * </li>
	 * <li>If an installed subsystem with the same symbolic name and version
	 *     already exists within this subsystem's region, complete the
	 *     installation with one of the following.
	 *     <ul>
	 *     <li>If the installing and installed subsystems' types are not equal,
	 *         an installation failure results.
	 *     </li>
	 *     <li>If the installing and installed subsystems' types are equal, and
	 *         the installed subsystem is already a constituent of this
	 *         subsystem, return the installed subsystem.
	 *     </li>
	 *     <li>If the installing and installed subsystems' types are equal, and
	 *         the installed subsystem is not already a constituent of this
	 *         subsystem, add the installed subsystem as a constituent of this
	 *         subsystem, increment the installed subsystem's reference count by
	 *         one, and return the installed subsystem.
	 *     </li>
	 *     </ul>
	 * </li>
	 * <li>Create a new subsystem based on the specified location and content.
	 * </li>
	 * <li>If the subsystem is scoped, install and activate a new region context
	 *     bundle.
	 * </li>
	 * <li>Change the state to INSTALLING and register a new subsystem service.
	 * </li>
	 * <li>Discover the subsystem's content resources. If any mandatory resource
	 *     is missing, an installation failure results.
	 * </li>
	 * <li>Resolve the content resources in order to discover any transitive
	 *     resources. If the resolution fails, an installation failure results.
	 * </li>
	 * <li>Install any transitive resources. A transitive resource becomes a
	 *     constituent of the subsystem with a provision policy of accept
	 *     transitive and that lies on the longest path between this subsystem
	 *     and the root subsystem, inclusively. If any transitive resource fails
	 *     to install, an installation failure results.
	 * </li>
	 * <li>Disable runtime resolution for the content resources.
	 * <li>Install the content resources. If any content resource fails to
	 *     install, an installation failure results.
	 * </li>
	 * <li>If the subsystem is scoped, set up the sharing policy.
	 * </li>
	 * <li>Change the state of the subsystem to INSTALLED.
	 * </li>
	 * <li>Return the new subsystem.
	 * </li>
	 * </ol>
	 * 
	 * @param location - The location identifier of the subsystem to be
	 *        installed.
	 * @param content - The input stream from which this subsystem will be read
	 *        or null to indicate the input stream must be created from the
	 *        specified location identifier. The input stream will always be
	 *        closed when this method completes, even if an exception is thrown.
	 * @return The installed subsystem.
	 * @throws IllegalStateException If this subsystem's state is in 
	 *         {INSTALL_FAILED, UNINSTALLING, UNINSTALLED}.
	 * @throws SubsystemException If the installation failed.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         SubsystemPermission[installed subsystem,LIFECYCLE], and the runtime
	 *         supports permissions.
	 * @see #install(String)
	 */
	public Subsystem install(String location, InputStream content) throws SubsystemException;
	
	/**
	 * Starts this subsystem.
	 * <p/>
	 * The following table shows which actions are associated with each state.
	 * An action of Wait means this method will block until a state transition
	 * occurs, upon which the new state will be evaluated in order to
	 * determine how to proceed. An action of Return means this method returns
	 * immediately without taking any other action.
	 * <p/>
	 * <table border="1"">
	 * 		<tr>
	 * 			<th>State</td>
	 * 			<th>Action</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALLING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALLED</td>
	 * 			<td>Resolve, Start</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALL_FAILED</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>RESOLVING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>RESOLVED</td>
	 * 			<td>Start</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>STARTING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>ACTIVE</td>
	 * 			<td>Return</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>STOPPING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>UNINSTALLING</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>UNINSTALLED</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * </table>
	 * <p/>
	 * All references to changing the state of this subsystem include both
	 * changing the state of the subsystem object as well as the state property
	 * of the subsystem service registration.
	 * <p/>
	 * All start failure flows include the following.
	 * <ul>
	 * 		<li>A change to some specified state.
	 * 		</li>
	 * 		<li>A SubsystemException being thrown, sometimes with a specified
	 *          cause.
	 *      </li>
	 *      <li>All resources started as part of this operation are stopped.
	 *      </li>
	 * </ul>
	 * <p/>
	 * Implementations should be sensitive to the potential for long running
	 * operations and periodically check the current thread for interruption. An
	 * interrupted thread should be treated as a start failure with an
	 * InterruptedException as the cause of the SubsystemException.
	 * <p/>
	 * The following steps are required to start this subsystem.
	 * <p/>
	 * <ol>
	 * 		<li>If this subsystem is in the INSTALLED state, change the state to
	 *          RESOLVING and proceed to step 2. Otherwise, proceed to step 5.
	 *      <li>Enable the content resources of this subsystem for resolution.
	 *      </li>
	 *      <li> Resolve the content resources. A resolution failure results in
	 *           a start failure with a state of INSTALLED.
	 *      </li>
	 *      <li>If the resolution succeeded, change the state to RESOLVED.
	 * 		</li>
	 * 		<li>If this subsystem is in the RESOLVED state, change the state to
	 *          STARTING.
	 *      </li>
	 *      <li>Start all transitive resources that require starting. Any
	 *          resource that fails to start results in a start failure with a
	 *          state of RESOLVED.
	 *      </li>
	 *      <li>Start all content resources that require starting according to
	 *          the specified start order, if any. Any resource that fails to
	 *          start results in a start failure with a state of RESOLVED.
	 *      <li>If none of the eligible resources failed to start, change the
	 *          state to ACTIVE.
	 * 		</li>
	 *      <li>Persist the ACTIVE state of this subsystem. That is, a started
	 *          subsystem must be restarted across Framework and VM restarts.
	 *      </li>
	 * </ol>
	 * <p/> 
	 * @throws SubsystemException If this subsystem fails to start. 
	 * @throws IllegalStateException If this subsystem's state is in
	 *         {INSTALL_FAILED, UNINSTALLING, or UNINSTALLED}.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         SubsystemPermission[this,EXECUTE], and the runtime supports 
	 *         permissions.
	 */
	public void start() throws SubsystemException;
	
	/**
	 * Stops this subsystem.
	 * <p/>
	 * The following table shows which actions are associated with each state.
	 * An action of Wait means this method will block until a state transition
	 * occurs, upon which the new state will be evaluated in order to
	 * determine how to proceed. An action of Return means this method returns
	 * immediately without taking any other action.
	 * <p/>
	 * <table border="1"">
	 * 		<tr>
	 * 			<th>State</td>
	 * 			<th>Action</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALLING</td>
	 * 			<td>Return</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALLED</td>
	 * 			<td>Return</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALL_FAILED</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>RESOLVING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>RESOLVED</td>
	 * 			<td>If this subsystem is in the process of being<br/>
	 *              started, Wait. Otherwise, Return.</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>STARTING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>ACTIVE</td>
	 * 			<td>Stop</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>STOPPING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>UNINSTALLING</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>UNINSTALLED</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * </table>
	 * <p/>
	 * All references to changing the state of this subsystem include both
	 * changing the state of the subsystem object as well as the state property
	 * of the subsystem service registration.
	 * <p/>
	 * All stop failure flows include the following.
	 * <ul>
	 * 		<li>Persistently stop all remaining eligible resources, and log any
	 *          subsequent errors.
	 *      </li>
	 * 		<li>Change the state to RESOLVED.
	 * 		</li>
	 * 		<li>Throw a SubsystemException with the initial error as the cause.
	 *      </li>
	 * </ul>
	 * <p/>
	 * Implementations should be sensitive to the potential for long running
	 * operations and periodically check the current thread for interruption. An
	 * interrupted thread should be treated as an installation failure with an
	 * InterruptedException as the cause of the SubsystemException.
	 * <p/>
	 * The following steps are required to stop this subsystem.
	 * <p/>
	 * <ol>
	 * 		<li>Change the state to STOPPING.
	 * 		</li>
	 *      <li>Persistently stop all eligible resources except for the region
	 *          context bundle. If an error occurs while stopping any resource,
	 *          a stop failure results.
	 *      </li>
	 *      <li>Change the state to RESOLVED.
	 *      </li>
	 * </ol>
	 * @throws SubsystemException If this subsystem fails to start. 
	 * @throws IllegalStateException If this subsystem's state is in
	 *         {INSTALL_FAILED, UNINSTALLING, or UNINSTALLED}.
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         SubsystemPermission[this,EXECUTE], and the runtime supports 
	 *         permissions.
	 */
	public void stop() throws SubsystemException;
	
	/**
	 * Uninstalls this subsystem.
	 * <p/>
	 * The following table shows which actions are associated with each state.
	 * An action of Wait means this method will block until a state transition
	 * occurs, upon which the new state will be evaluated in order to
	 * determine how to proceed. An action of Return means this method returns
	 * immediately without taking any other action.
	 * <p/>
	 * <table border="1"">
	 * 		<tr>
	 * 			<th>State</td>
	 * 			<th>Action</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALLING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALLED</td>
	 * 			<td>Uninstall</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>INSTALL_FAILED</td>
	 * 			<td>IllegalStateException</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>RESOLVING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>RESOLVED</td>
	 * 			<td>If this subsystem is in the process of being<br/>
	 *              started, Wait. Otherwise, Uninstall.</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>STARTING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>ACTIVE</td>
	 * 			<td>Stop, Uninstall</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>STOPPING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>UNINSTALLING</td>
	 * 			<td>Wait</td>
	 * 		</tr>
	 * 		<tr align="center">
	 * 			<td>UNINSTALLED</td>
	 * 			<td>Return</td>
	 * 		</tr>
	 * </table>
	 * <p/>
	 * All references to changing the state of this subsystem include both
	 * changing the state of the subsystem object as well as the state property
	 * of the subsystem service registration.
	 * <p/>
	 * Implementations should be sensitive to the potential for long running
	 * operations and periodically check the current thread for interruption, in
	 * which case a SubsystemException with an InterruptedException as the cause
	 * should be thrown. If an interruption occurs while waiting, this method
	 * should terminate immediately. Once the transition to the UNINSTALLING
	 * state has occurred, however, this method must not terminate due to an
	 * interruption until the uninstall process has completed.
	 * <p/>
	 * The following steps are required to uninstall this subsystem.
	 * <p/>
	 * <ol>
	 * 		<li>Change the state to UNINSTALLING.
	 * 		</li>
	 * 		<li>Uninstall each content resource.
	 *      </li>
	 *      <li>Uninstall each transitive resource.
	 *      </li>
	 *      <li>Change the state to UNINSTALLED.
	 *      </li>
	 *      <li>Unregister the subsystem service.
	 *      </li>
	 *      <li>Uninstall the region context bundle.
	 *      </li>
	 * </ol>
	 * With regard to error handling, once this subsystem has transitioned to
	 * the UNINSTALLING state, every part of each of the above steps must be
	 * attempted. Errors subsequent to the first should be logged. Once the
	 * uninstall process has completed, a SubsystemException must be thrown with
	 * the first error as the cause.
	 * <p/>
	 * @throws SubsystemException If this subsystem fails to uninstall without
	 *         error.
	 * @throws IllegalStateException If this subsystem's state is in
	 *         {INSTALL_FAILED}. 
	 * @throws SecurityException If the caller does not have the appropriate 
	 *         SubsystemPermission[this,LIFECYCLE] and the Java Runtime
	 *         Environment supports permissions.
	 */
	public void uninstall() throws SubsystemException;
}
