package org.osgi.impl.service.wireadmin;

import java.util.*;
import org.osgi.service.log.LogService;
import org.osgi.util.tracker.ServiceTracker;
import org.osgi.service.wireadmin.*;
import java.io.IOException;
import org.osgi.service.cm.*;
import org.osgi.framework.*;

public class WireAdminImpl implements ServiceListener,WireAdmin,ManagedServiceFactory,BundleActivator {

  final static String FACTORY_PID = WireAdmin.class.getName();
  private Hashtable allWires = null;
  private BundleContext context;
  private ServiceReference myReference = null;
  private Hashtable producers = null;
  private Hashtable consumers = null;
  private Hashtable connectedProducers = null;
  private Hashtable connectedConsumers = null;
  private Vector ptot, vtot;
  private ServiceTracker listenerTracker = null;
  private UpdateDispatcher dispatcher = null;
  private Vector justCreated;

  public WireAdminImpl() {
  }

  /**
   * Create a new <tt>Wire</tt> object that connects a <tt>Producer</tt>
   * service to a <tt>Consumer</tt> service.
   *
   * The <tt>Producer</tt> service and <tt>Consumer</tt> service do not
   * have to be registered when the the <tt>Wire</tt> object is created.
   *
   * <p>The <tt>Wire</tt> configuration data is persistently stored.
   * All <tt>Wire</tt> connections are reestablished when the
   * <tt>WireAdmin</tt> service is registered.
   * A <tt>Wire</tt> can be permanently removed by using the
   * {@link #deleteWire} method.
   *
   * <p>The <tt>Wire</tt> object's properties must have case
   * insensitive <tt>String</tt> objects as keys (like the Framework).
   * However, the case of the key must be preserved.
   * The type of the value of the property must be one of the following:
   *
   * <pre>
   * type        = basetype
   * | vector | arrays
   *
   * basetype = String | Integer | Long
   * | Float | Double | Byte
   * | Short | Character
   * | Boolean
   *
   * primitive   = long | int | short
   * | char | byte | double | float
   *
   * arrays   = primitive '[]' | basetype '[]'
   *
   * vector   = Vector of basetype
   * </pre>
   *
   * <p>The <tt>WireAdmin</tt> service must automatically add the
   * following <tt>Wire</tt> properties:
   * <ul>
   * <li>
   * {@link WireConstants#WIREADMIN_PID} set to the value of the wire's
   * persistent identity (PID). This value is generated by the
   * <tt>WireAdmin</tt> service when a <tt>Wire</tt> object is created.
   * </li>
   * <li>
   * {@link WireConstants#WIREADMIN_PRODUCER_PID} set to the value of
   * <tt>Producer</tt> service's PID.
   * </li>
   * <li>
   * {@link WireConstants#WIREADMIN_CONSUMER_PID} set to the value of
   * <tt>Consumer</tt> service's PID.
   * </li>
   * </ul>
   * If the <tt>properties</tt> argument
   * already contains any of these keys, then the supplied values
   * are replaced with the values assigned by the <tt>WireAdmin</tt> service.
   *
   * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
   * {@link WireAdminEvent#WIRE_CREATED}
   * after the new <tt>Wire</tt> object becomes available from {@link #getWires}.
   *
   * @param producerPID The &quot;service.pid&quot; of the <tt>Producer</tt> service
   * to be connected to the <tt>Wire</tt>.
   * @param consumerPID The &quot;service.pid&quot; of the <tt>Consumer</tt> service
   * to be connected to the <tt>Wire</tt>.
   * @param properties The <tt>Wire</tt> object's properties. This argument may be <tt>null</tt>
   * if the caller does not wish to define any <tt>Wire</tt> object's properties.
   * @return The <tt>Wire</tt> object for this connection.
   * @throws java.lang.IllegalArgumentException If
   * <tt>properties</tt> contains case variants of the same key name.
   */
  public Wire createWire(String producerPID, String consumerPID, Dictionary properties) {
    Hashtable copy = new Hashtable();
    Object pkey;
    if (properties != null) {
      for (Enumeration e = properties.keys(); e.hasMoreElements();) {
        pkey = e.nextElement();
        copy.put(pkey, properties.get(pkey));
      }
    }
    properties = copy;
    if (properties!=null) {
      Enumeration en = properties.keys();
      Vector temp = new Vector();
      while (en.hasMoreElements()) {
        Object o = en.nextElement();
        if (! (o instanceof String)) {
          throw new IllegalArgumentException("key must be a string");
        }
        String key = (String)o;
        if (temp.contains(key.toLowerCase())) {
          throw new IllegalArgumentException("property case variant: "+key);
        }
        temp.addElement(key.toLowerCase());
      }
      temp = null;
    }
    WireImpl wire = new WireImpl();
    wire.setParent(this);
    ConfigurationAdmin cm = getCM();
    try {
      Configuration conf = cm.createFactoryConfiguration(FACTORY_PID);
      wire.setPID(conf.getPid());
      wire.setProducerPID(producerPID);
      wire.setConsumerPID(consumerPID);
      if(properties==null) {
        properties = new Hashtable();
      }
      wire.setProperties(properties);
      addWire(wire);
      justCreated.addElement(wire);
      conf.update(wire.getProperties());
      findEndPoints(wire);
      return wire;
    } catch(IOException iox) {
      getLogService().log(LogService.LOG_ERROR,"unable to persist wires using CM",iox);
      return null;
    }
  }

  /**
   * Delete a <tt>Wire</tt>.
   *
   * <p>The <tt>Wire</tt> representing a connection between
   * a <tt>Producer</tt> service and a <tt>Consumer</tt> service is
   * removed.
   * The persistently stored configuration data for the <tt>Wire</tt> object
   * is destroyed. The <tt>Wire</tt> object's method {@link Wire#isValid} will return <tt>false</tt>
   * after it is deleted.
   *
   * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
   * {@link WireAdminEvent#WIRE_DELETED}
   * after the <tt>Wire</tt> object becomes invalid.
   *
   * @param wire The <tt>Wire</tt> object which is to be deleted.
   */
  public void deleteWire(Wire wire) {
    try {
      getCM().getConfiguration(((WireImpl)wire).getPID()).delete();
    } catch(IOException iox) {
      getLogService().log(LogService.LOG_ERROR,"unable to delete wire from CM",iox);
    }
  }

  /**
   * Return the <tt>Wire</tt> objects that match the given <tt>filter</tt>.
   *
   * <p>The list of available <tt>Wire</tt> objects is matched against the
   * specified <tt>filter</tt>. <tt>Wire</tt> objects which match the
   * <tt>filter</tt> are returned. These <tt>Wire</tt> objects are not necessarily
   * connected. The Wire Admin service should not return
   * invalid <tt>Wire</tt> objects, but it is possible that a <tt>Wire</tt>
   * object is deleted after it was placed in the list.
   *
   * <p>The filter matches against the <tt>Wire</tt> object's properties including
   * {@link WireConstants#WIREADMIN_PRODUCER_PID}, {@link WireConstants#WIREADMIN_CONSUMER_PID}
   * and {@link WireConstants#WIREADMIN_PID}.
   *
   * @param filterString Filter string to select <tt>Wire</tt> objects
   * or <tt>null</tt> to select all <tt>Wire</tt> objects.
   * @return An array of <tt>Wire</tt> objects which match the <tt>filter</tt>
   * or <tt>null</tt> if no <tt>Wire</tt> objects match the <tt>filter</tt>.
   * @throws org.osgi.framework.InvalidSyntaxException If the specified <tt>filter</tt>
   * has an invalid syntax.
   * @see "org.osgi.framework.Filter"
   */
  public Wire[] getWires(String filterString) throws InvalidSyntaxException {
    Filter filter = null;
    if (filterString != null) {
      filter = context.createFilter(filterString);
    }
    if(allWires.size() == 0) {
      return null;
    }
    Enumeration e = null;
    Wire[] result = null;
    e = allWires.elements();
    if(filterString!=null) {
      Vector tmpResult = new Vector(allWires.size());
      Wire aWire;
      while(e.hasMoreElements()) {
        aWire = (Wire)e.nextElement();
        if(filter.match(aWire.getProperties())) {
          tmpResult.addElement(aWire);
        }
      }
      e = tmpResult.elements();
      if(tmpResult.size() == 0) {
        return null;
      }
      result = new Wire[tmpResult.size()];
    } else {
      result = new Wire[allWires.size()];
    }

    for(int x=0;x<result.length;x++) {
      result[x] = (Wire)e.nextElement();
    }
    return result;
  }

  /**
   * Update the properties of a <tt>Wire</tt> object.
   *
   * The persistently stored configuration data for the <tt>Wire</tt> object
   * is updated with the new properties and then the <tt>Consumer</tt> and <tt>Producer</tt>
   * services will be called at the respective {@link Consumer#producersConnected}
   * and {@link Producer#consumersConnected} methods.
   *
   * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
   * {@link WireAdminEvent#WIRE_UPDATED}
   * after the updated properties are available from the <tt>Wire</tt> object.
   *
   * @param wire The <tt>Wire</tt> object which is to be updated.
   * @param properties The new <tt>Wire</tt> object's properties or <tt>null</tt> if no properties are required.
   */
  public void updateWire(Wire wire, Dictionary properties) {
    try {
      Dictionary wireProps = wire.getProperties();
      String pid = (String) wireProps.get(WireConstants.WIREADMIN_PID);
      String consumerPID = (String) wireProps.get(WireConstants.WIREADMIN_CONSUMER_PID);
      String producerPID = (String) wireProps.get(WireConstants.WIREADMIN_PRODUCER_PID);
      properties.put(WireConstants.WIREADMIN_PRODUCER_PID, producerPID);
      properties.put(WireConstants.WIREADMIN_CONSUMER_PID, consumerPID);
      properties.put(WireConstants.WIREADMIN_PID, String.valueOf(pid));

      getCM().getConfiguration(((WireImpl)wire).getPID()).update(properties);
    } catch(IOException iox) {
      getLogService().log(LogService.LOG_ERROR,"unable to persist wires via CM",iox);
    }
  }

  /** Forward a WireAdminEvent to all registered WireAdminListeners.
   */
  public void bCast(int type,Wire wire,Throwable throwable) {
    WireAdminEvent event = new WireAdminEvent(myReference,type,wire,throwable);
    ServiceReference[] references = listenerTracker.getServiceReferences();
    if(references==null) {
      return;
    }
    WireAdminListener listener;
    for(int x=0;x<references.length;x++) {
      try {
        int events = ((Integer)references[x].getProperty(WireConstants.WIREADMIN_EVENTS)).intValue();
        if(events==type || (events & type) > 0) {
          listener = (WireAdminListener)context.getService(references[x]);
          listener.wireAdminEvent(event);
        }
      } catch(Exception ex) {
        ex.printStackTrace();
      }
    }
  }

  /**
   * Called when the bundle is started so that the bundle can perform
   * any bundle specific activities to start the bundle.  Bundle programmers
   * can use this method to register the bundle's services or to
   * allocate any resources that the bundle needs.
   *
   * <p>This method must complete and return to its caller in a
   * timely manner.
   *
   * @param context The execution context of the bundle being started.
   * @exception java.lang.Exception If this method throws an exception,
   * the bundle is marked as stopped and the framework will
   * remove the bundle's listeners, unregister all
   * service's registered by the bundle, release all service's
   * used by the bundle.
   */
  public void start(BundleContext context) throws Exception {
    this.context = context;
    allWires = new Hashtable();
    producers = new Hashtable();
    consumers = new Hashtable();
    connectedProducers = new Hashtable();
    connectedConsumers = new Hashtable();
    ptot = new Vector();
    vtot = new Vector();
    justCreated = new Vector();
    dispatcher = new UpdateDispatcher(this);
    ServiceRegistration registration = context.registerService(WireAdmin.class.getName(),this,null);
    myReference = registration.getReference();
    listenerTracker = new ServiceTracker(context,WireAdminListener.class.getName(),null);
    listenerTracker.open();
    checkExistingProducers();
    checkExistingConsumers();
    try {
      context.addServiceListener(this,"(|("+org.osgi.framework.Constants.OBJECTCLASS+
        "="+Producer.class.getName()+")("+org.osgi.framework.Constants.OBJECTCLASS+
         "="+Consumer.class.getName()+"))");
    } catch(InvalidSyntaxException ivsx) {
      ivsx.printStackTrace();
    }
    Hashtable props = new Hashtable(1);
    props.put(org.osgi.framework.Constants.SERVICE_PID,FACTORY_PID);
    context.registerService(ManagedServiceFactory.class.getName(),this,props);

    WireCommandProvider cProvider = new WireCommandProvider(context, this);
    context.registerService("org.osgi.tools.command.CommandProvider", cProvider, null);

  }

  /**
   * Called when the bundle is stopped so that the bundle can perform
   * any bundle specific activities necessary to stop the bundle.
   * In general, this method should undo the work that the
   * {@link #start start} method did. When this method returns the
   * bundle should have no active threads.
   * A stopped bundle should be stopped and should not be calling any
   * framework objects.
   *
   * <p>This method must complete and return to its caller in a
   * timely manner.
   *
   * @param context The execution context of the bundle being stopped.
   * @exception java.lang.Exception If this method throws an exception,
   * the bundle is still marked as stopped and the framework will
   * remove the bundle's listeners, unregister all
   * service's registered by the bundle, release all service's
   * used by the bundle.
   */
  public void stop(BundleContext context) throws Exception {
    // kill all wires
    listenerTracker.close();
    listenerTracker = null;
    dispatcher.stopDispatching();
    dispatcher = null;
    allWires = null;
    producers = null;
    consumers = null;
    connectedProducers = null;
    connectedConsumers = null;
    Iterator it = ptot.iterator();
    while (it.hasNext()) {
      Producer p = (Producer)(it.next());
      p.consumersConnected (null);
    }
    Iterator it2 = vtot.iterator();
    while (it2.hasNext()) {
      Consumer v = (Consumer)(it2.next());
      v.producersConnected (null);
    }
  }

  BundleContext getBundleContext() {
    return context;
  }

  Wire[] getProducerWires(String producerPID) {
    return getWires((Vector)connectedProducers.get(producerPID));
  }

  Wire[] getConsumerWires(String consumerPID) {
    return getWires((Vector)connectedConsumers.get(consumerPID));
  }

  private Wire[] getWires(Vector store) {
    if(store==null || store.size()==0) {
      return null;
    }
    Wire[] result = new Wire[store.size()];
    Enumeration e = store.elements();
    for(int x=0;x<result.length;x++) {
      result[x] = (Wire)e.nextElement();
    }
    return result;
  }

  void addWire(WireImpl wire) {
    allWires.put(wire.getPID(),wire);
    Vector wires = (Vector)producers.get(wire.getProducerPID());
    if(wires==null) {
      wires = new Vector();
      producers.put(wire.getProducerPID(),wires);
    }
    wires.addElement(wire);

    wires = (Vector)consumers.get(wire.getConsumerPID());
    if(wires==null) {
      wires = new Vector();
      consumers.put(wire.getConsumerPID(),wires);
    }
    wires.addElement(wire);
    bCast(WireAdminEvent.WIRE_CREATED,wire,null);
    getLogService().log(LogService.LOG_DEBUG,"created wire with PID "+wire.getProducerPID()+" and CID "+wire.getConsumerPID());
  }

  void removeWire(WireImpl wire) {
    allWires.remove(wire.getPID());
    Vector wires = (Vector)producers.get(wire.getProducerPID());
    if(wires!=null) {
      wires.removeElement(wire);
      if(wires.size()==0) {
        producers.remove(wire.getProducerPID());
      }
    }
    wires = (Vector)consumers.get(wire.getConsumerPID());
    if(wires!=null) {
      wires.removeElement(wire);
      if(wires.size()==0) {
        consumers.remove(wire.getConsumerPID());
      }
    }
  }

  /** A Consumer or Producer has been registered --> look for wires and set their producer/consumer references.
   */
  public Object addingService(ServiceReference reference) {
    Object service = context.getService(reference);
    String[] classes = (String[])
      reference.getProperty(org.osgi.framework.Constants.OBJECTCLASS);
    String pid = (String)reference.getProperty(org.osgi.framework.Constants.SERVICE_PID);
    for(int x=0;x<classes.length;x++) {
      if(classes[x].equals(Producer.class.getName())) {
        Producer producer = (Producer)service;
        Vector wires = (Vector)producers.get(pid);
        boolean noConnectedWires = true;
        WireImpl aWire;
        if(wires!=null) {
          synchronized(wires) {
            for(Enumeration e=wires.elements();e.hasMoreElements();) {
              aWire = (WireImpl)e.nextElement();
              aWire.setProducer(reference);
              if(aWire.isConnected()) {
                noConnectedWires = false;
              }
            }
          }
        }
        else {
        }
        if(noConnectedWires) {
          dispatcher.addProducerUpdate(producer,null, null);
        }
      } else if(classes[x].equals(Consumer.class.getName())) {
        Consumer consumer = (Consumer)service;
        Vector wires = (Vector)consumers.get(pid);
        if(wires!=null) {
          synchronized(wires) {
            for(Enumeration e=wires.elements();e.hasMoreElements();) {
              ((WireImpl)e.nextElement()).setConsumer(reference);
            }
          }
        }else{
          dispatcher.addConsumerUpdate(consumer, null, null);
        }
      }
    }
    return service;
  }

  /** If a Consumer was modified, update the flavors/filter.
   */
  public void modifiedService(ServiceReference reference) {
    String[] classes = (String[])
      reference.getProperty(org.osgi.framework.Constants.OBJECTCLASS);
    for(int x=0;x<classes.length;x++) {
      if(classes[x].equals(Consumer.class.getName())) {
        String pid = (String)reference.getProperty(org.osgi.framework.Constants.SERVICE_PID);
        Vector wires = (Vector)consumers.get(pid);
        synchronized(wires) {
          for(Enumeration e=wires.elements();e.hasMoreElements();) {
            ((WireImpl)e.nextElement()).setConsumer(reference);
          }
        }
      }
    }
  }

  /** Look for wires to disconnect.
   */
  public void removedService(ServiceReference reference) {
    String pid = (String)reference.getProperty(org.osgi.framework.Constants.SERVICE_PID);
    String[] classes = (String[])
      reference.getProperty(org.osgi.framework.Constants.OBJECTCLASS);
    for(int x=0;x<classes.length;x++) {
      if(classes[x].equals(Producer.class.getName())) {
        Vector wires = (Vector)producers.get(pid);
        if(wires!=null) {
          synchronized(wires) {
            for(Enumeration e=wires.elements();e.hasMoreElements();) {
              ((WireImpl)e.nextElement()).setProducer(null);
            }
            //producers.remove(pid);
          }
        }
      } else if(classes[x].equals(Consumer.class.getName())) {
        Vector wires = (Vector)consumers.get(pid);
        if (wires!=null) {
          synchronized(wires) {
            for(Enumeration e=wires.elements();e.hasMoreElements();) {
              ((WireImpl)e.nextElement()).setConsumer(null);
            }
            //consumers.remove(pid);
          }
        }
      }
    }
  }

  LogService getLogService() {
    ServiceReference sr = context.getServiceReference(LogService.class.getName());
    if(sr==null) {
      return null;
    }
    return (LogService)context.getService(sr);
  }

  ConfigurationAdmin getCM() {
    ServiceReference sr = context.getServiceReference(ConfigurationAdmin.class.getName());
    if(sr==null) {
      return null;
    }
    return (ConfigurationAdmin)context.getService(sr);
  }

  /**
   * Remove a service instance.
   *
   * Remove the service instance associated with the PID. If the instance was
   * registered with the service registry, it should be unregistered.
   * <p>If this method throws any Exception, the ConfigurationAdmin
   * must catch it and should log it.
   * <p> The ConfigurationAdmin must call this method on a thread
   * other than the thread which called delete() on the corresponding
   * Configuration object.
   *
   * @param pid the PID of the service to be removed
   */
  public void deleted(String pid) {
    try {
      WireImpl wire = (WireImpl)allWires.get(pid);
      wireDisconnected(wire);
      wire.delete();
      removeWire(wire);
      bCast(WireAdminEvent.WIRE_DELETED,wire,null);
    } catch (Exception e) {
      e.printStackTrace();  //To change body of catch statement use Options | File Templates.
    }
  }

  /**
   * Return a descriptive name of this factory.
   *
   * @return the name for the factory, which might be localized
   */
  public String getName() {
    return "WireAdmin";
  }

  /**
   * Create a new instance, or update the configuration of an
   * existing instance.
   *
   * If the PID of the configuration object is new for the ManagedServiceFactory,
   * then create a new service instance, using the configuration
   * properties provided. Else, update the service instance with the
   * provided properties.
   * <p>
   * If the service instance is registered with the framework, then
   * the configuration properties should be copied to its registry
   * properties. This is not mandatory and
   * security sensitive properties should obviously not be copied.
   * <p> If this method throws any Exception, the
   * ConfigurationAdmin must catch it and should log it.
   * <p>When the implementation of updated() detects any kind of
   * error in the configuration properties, it should create a
   * new ConfigurationException which describes the problem.
   * <p> The ConfigurationAdmin must call this method on a thread
   * other than the thread which necessitated the call-back. This implies that
   * implementors of ManagedServiceFactory can be assured that the
   * call-back will not take place during registration when they
   * execute the registration in a synchronized method.
   *
   * @param pid the PID for this configuration
   * @param properties the configuration properties
   * @throws ConfigurationException when the configuration is invalid
   */
  public void updated(String pid, Dictionary properties) throws ConfigurationException {
    WireImpl wire = (WireImpl)allWires.get(pid);
    getLogService().log(LogService.LOG_INFO,"wire with pid "+pid+" was updated by CM");
    if(wire!=null) {
      if (justCreated.contains(wire)) {
        justCreated.remove(wire);
      }else{
        wire.setProperties(properties);
        bCast(WireAdminEvent.WIRE_UPDATED,wire,null);
      }
    } else {
      // try to create a new one
      String producerPID = (String)properties.get(WireConstants.WIREADMIN_PRODUCER_PID);
      if(producerPID==null) {
        throw new ConfigurationException(WireConstants.WIREADMIN_PRODUCER_PID,"doesn't exist");
      }
      String consumerPID = (String)properties.get(WireConstants.WIREADMIN_CONSUMER_PID);
      if(consumerPID==null) {
        throw new ConfigurationException(WireConstants.WIREADMIN_CONSUMER_PID,"doesn't exist");
      }
      wire = new WireImpl();
      wire.setParent(this);
      wire.setPID(pid);
      wire.setProducerPID(producerPID);
      wire.setConsumerPID(consumerPID);
      if(properties==null) {
        properties = new Hashtable();
      }
      wire.setProperties(properties);
      addWire(wire);
      findEndPoints(wire);
    }
  }

  UpdateDispatcher getUpdateDispatcher() {
    return dispatcher;
  }

  /**
   * Receive notification that a service has had a
   * change occur in it's lifecycle.
   *
   * @param event The ServiceEvent.
   */
  public void serviceChanged(ServiceEvent event) {
    switch(event.getType()) {
      case ServiceEvent.REGISTERED:
        addingService(event.getServiceReference());
        break;
      case ServiceEvent.MODIFIED:
        modifiedService(event.getServiceReference());
        break;
      case ServiceEvent.UNREGISTERING:
        removedService(event.getServiceReference());
        break;
    }
  }

  private void findEndPoints(WireImpl wire) {
    // check if producers/consumers have already been registered
    try {
      ServiceReference[] references = context.getServiceReferences(Producer.class.getName(),
        "(service.pid="+wire.getProducerPID()+")");
      if(references!=null) {
        wire.setProducer(references[0]);
      }
      references = context.getServiceReferences(Consumer.class.getName(),
        "(service.pid="+wire.getConsumerPID()+")");
      if(references!=null) {
        wire.setConsumer(references[0]);
      }
    } catch(InvalidSyntaxException ivsx) {
      ivsx.printStackTrace();
    }
  }

  void wireConnected(WireImpl wire) {
    ptot.add (wire.getProducer());
    Vector wires = (Vector)connectedProducers.get(wire.getProducerPID());
    if(wires==null) {
      wires = new Vector();
      connectedProducers.put(wire.getProducerPID(),wires);
    }
    wires.addElement(wire);
    wires = (Vector)connectedConsumers.get(wire.getConsumerPID());
    if(wires==null) {
      wires = new Vector();
      connectedConsumers.put(wire.getConsumerPID(),wires);
      vtot.add (wire.getConsumer());
    }
    wires.addElement(wire);
    bCast(WireAdminEvent.WIRE_CONNECTED,wire,null);
  }

  void wireDisconnected(WireImpl wire) {
    boolean event = false;
    Vector wires = (Vector)connectedProducers.get(wire.getProducerPID());
    if (wires!=null) {
      event = true;
      wires.removeElement(wire);
      if(wires.size()==0) {
        connectedProducers.remove(wire.getProducerPID());
        ptot.remove (wire.getProducer());
      }
    }

    wires = (Vector)connectedConsumers.get(wire.getConsumerPID());
    if (wires!=null) {
      event = true;
      wires.removeElement(wire);
      if(wires.size()==0) {
        connectedConsumers.remove(wire.getConsumerPID());
        vtot.remove (wire.getConsumer());
      }
    }
    if (event) {
      bCast(WireAdminEvent.WIRE_DISCONNECTED,wire,null);
    }
  }

  void checkExistingConsumers () {
    ServiceReference[] sr = null;
    try {
      sr = context.getServiceReferences ("org.osgi.service.wireadmin.Consumer", null);
    }
    catch (InvalidSyntaxException e) {
// duh
      e.printStackTrace();
      System.exit (0);
    }
    if (sr != null) {
      for (int i = 0; i < sr.length; i++) {
        Consumer c = (Consumer)(context.getService(sr[i]));
        c.producersConnected (null);
      }
    }
  }

  void checkExistingProducers () {
    ServiceReference[] sr = null;
    try {
      sr = context.getServiceReferences ("org.osgi.service.wireadmin.Producer", null);
    }
    catch (InvalidSyntaxException e) {
// duh
      e.printStackTrace();
      System.exit (0);
    }
    if (sr != null) {
      for (int i = 0; i < sr.length; i++) {
        Producer p = (Producer)(context.getService(sr[i]));
        p.consumersConnected (null);
      }
    }
  }


}
