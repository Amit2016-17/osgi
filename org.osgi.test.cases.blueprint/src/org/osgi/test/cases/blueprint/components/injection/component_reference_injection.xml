<?xml version="1.0" encoding="UTF-8"?>
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
    default-activation="eager">

    <!-- a few leaf nodes for others to reference.  These are just named components -->
   <bean id="leaf1" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="leaf1"/>
   </bean>
   <bean id="leaf2" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="leaf2"/>
   </bean>
   <bean id="leaf3" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="leaf3"/>
   </bean>
   <bean id="leaf4" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="leaf4"/>
   </bean>
   <!-- lazyleaf1 will be lazy inited, but will be referenced from the start, so this will start normally -->
   <bean id="lazyleaf1" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection" activation="lazy"
       init-method="init" destroy-method="destroy">
       <argument value="lazyleaf1"/>
   </bean>
   <!-- the component referencing lazyleaf1.  This is not lazy-inited -->
   <bean id="comp1" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="comp1"/>
       <argument ref="lazyleaf1"/>
   </bean>
   <!-- lazyleaf2 will be lazy inited and will not be started until requested from the module context -->
   <bean id="lazyleaf2" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection" activation="lazy"
       init-method="init" destroy-method="destroy">
       <argument value="lazyleaf2"/>
   </bean>
   <!-- lazyleaf3 will be lazy inited and will not be started until the referencing component is requested. -->
   <bean id="lazyleaf3" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection" activation="lazy"
       init-method="init" destroy-method="destroy">
       <argument value="lazyleaf3"/>
   </bean>
   <!-- lazycomp1 will be lazy inited and will not be started until the requested from the module context -->
   <!-- it alsl contains a reference to another lazy-inited leaf node, so this will cascade -->
   <bean id="lazycomp1" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection" activation="lazy"
       init-method="init" destroy-method="destroy">
       <argument value="lazycomp1"/>
       <argument ref="lazyleaf3"/>
   </bean>

   <!-- component referencing two leaf nodes -->
   <bean id="twoleaf" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="twoleaf"/>
       <argument ref="leaf1"/>
       <property name="componentOne">
           <ref component-id="leaf2" />
       </property>
   </bean>

   <!-- component referencing multiple comps, which reference leaf nodes -->
   <bean id="twocomp" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="twocomp"/>
       <argument ref="twoleaf"/>
       <argument ref="comp1"/>
   </bean>

   <!-- component referencing comps via a list -->
   <bean id="twolist" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="twolist"/>
       <property name="componentList">
           <list>
               <ref component-id="twoleaf"/>
               <ref component-id="twocomp"/>
           </list>
       </property>
   </bean>

   <!-- component referencing comps via a set -->
   <bean id="twoset" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="twoset"/>
       <property name="componentSet">
           <set>
               <ref component-id="twoleaf"/>
               <ref component-id="twocomp"/>
           </set>
       </property>
   </bean>

   <!-- component referencing comps via a map, using both keys and value -->
   <bean id="mapref" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="mapref"/>
       <property name="componentMap">
           <map>
               <entry>
                   <key>
                       <ref component-id="leaf1"/>
                   </key>
                   <ref component-id="twoleaf"/>
               </entry>
               <entry key-ref="leaf2" value-ref="twocomp"/>
           </map>
       </property>
   </bean>

   <!-- single component for a depends-on reference -->
   <bean id="dependsleaf1" class="org.osgi.test.cases.blueprint.components.injection.DependentComponent"
       init-method="init" destroy-method="destroy">
       <argument value="dependsleaf1"/>
   </bean>

   <!-- component using a depends-on relationship -->
   <bean id="dependsOnOne" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection" depends-on="dependsleaf1"
       init-method="init" destroy-method="destroy">
       <argument value="dependsOnOne"/>
       <property name="dependsOn">
           <set>
               <value>dependsleaf1</value>
           </set>
       </property>
   </bean>

   <!-- two more components for a depends-on reference, one with lazy initialization -->
   <bean id="dependsleaf2" class="org.osgi.test.cases.blueprint.components.injection.DependentComponent"
       init-method="init" destroy-method="destroy">
       <argument value="dependsleaf2"/>
   </bean>
   <bean id="dependsleaf3" class="org.osgi.test.cases.blueprint.components.injection.DependentComponent" activation="lazy"
       init-method="init" destroy-method="destroy">
       <argument value="dependsleaf3"/>
   </bean>

   <!-- component using a multiple depends-on relationship -->
   <bean id="dependsOnTwo" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection" depends-on="dependsleaf2 dependsleaf3"
       init-method="init" destroy-method="destroy">
       <argument value="dependsOnTwo"/>
       <property name="dependsOn">
           <set>
               <value>dependsleaf2</value>
               <value>dependsleaf3</value>
           </set>
       </property>
   </bean>

   <!-- singleton1 is just the default scope.  We'll create multiple references, but should get just a single instance -->
   <bean id="singleton1" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection"
       init-method="init" destroy-method="destroy">
       <argument value="singleton1"/>
   </bean>

   <!-- singleton2 is default scope explicitly specified.  Again, we should only see a single instance. -->
   <bean id="singleton2" class="org.osgi.test.cases.blueprint.components.injection.ComponentInjection" scope="singleton"
       init-method="init" destroy-method="destroy">
       <argument value="singleton2"/>
   </bean>

   <!-- prototype1 will have prototype scope, which means a new component will be instantiated for each request -->
   <bean id="prototype1" class="org.osgi.test.cases.blueprint.components.injection.PrototypeComponentInjection" scope="prototype"
       init-method="init" destroy-method="destroy">
       <argument value="prototype1"/>
   </bean>

   <!-- prototype2 tests prototype scope and lazy-init in combination. -->
   <bean id="prototype2" class="org.osgi.test.cases.blueprint.components.injection.PrototypeComponentInjection" scope="prototype" activation="lazy"
       init-method="init" destroy-method="destroy">
       <argument value="prototype2"/>
   </bean>

   <!-- prototype3 is only referenced via the module context.  This should not be instantiated until referenced -->
   <bean id="prototype3" class="org.osgi.test.cases.blueprint.components.injection.PrototypeComponentInjection" scope="prototype"
       init-method="init" destroy-method="destroy">
       <argument value="prototype3"/>
   </bean>

   <!-- referenced by a list, so will create unique ones for each element. -->
   <bean id="prototype4" class="org.osgi.test.cases.blueprint.components.injection.PrototypeComponentInjection" scope="prototype"
       init-method="init" destroy-method="destroy">
       <argument value="prototype4"/>
   </bean>

   <!-- Three singletons in a set should reduce to one element -->
   <bean id="threeSingleton1" class="org.osgi.test.cases.blueprint.components.injection.ScopeComponent"
       init-method="init" destroy-method="destroy">
       <argument value="threeSingleton1"/>
       <argument value="1"/>
       <property name="references">
           <set>
               <ref component-id="singleton1"/>
               <ref component-id="singleton1"/>
               <ref component-id="singleton1"/>
           </set>
       </property>
   </bean>

   <!-- Three singletons in a set should reduce to one element -->
   <bean id="threeSingleton2" class="org.osgi.test.cases.blueprint.components.injection.ScopeComponent"
       init-method="init" destroy-method="destroy">
       <argument value="threeSingleton2"/>
       <argument value="1"/>
       <property name="references">
           <set>
               <ref component-id="singleton2"/>
               <ref component-id="singleton2"/>
               <ref component-id="singleton2"/>
           </set>
       </property>
   </bean>

   <!-- Expecting 3 component instances -->
   <bean id="threeListPrototype1" class="org.osgi.test.cases.blueprint.components.injection.ScopeComponent"
       init-method="init" destroy-method="destroy">
       <argument value="threePrototype1"/>
       <argument value="3"/>
       <property name="listReferences">
           <list>
               <ref component-id="prototype4"/>
               <ref component-id="prototype4"/>
               <ref component-id="prototype4"/>
           </list>
       </property>
   </bean>

   <!-- Expecting 3 component instances -->
   <bean id="threePrototype1" class="org.osgi.test.cases.blueprint.components.injection.ScopeComponent"
       init-method="init" destroy-method="destroy">
       <argument value="threePrototype1"/>
       <argument value="3"/>
       <property name="references">
           <set>
               <ref component-id="prototype1"/>
               <ref component-id="prototype1"/>
               <ref component-id="prototype1"/>
           </set>
       </property>
   </bean>

   <!-- Expecting 3 component instances -->
   <bean id="threePrototype2" class="org.osgi.test.cases.blueprint.components.injection.ScopeComponent"
       init-method="init" destroy-method="destroy">
       <argument value="threePrototype2"/>
       <argument value="3"/>
       <property name="references">
           <set>
               <ref component-id="prototype2"/>
               <ref component-id="prototype2"/>
               <ref component-id="prototype2"/>
           </set>
       </property>
   </bean>

   <!-- Expecting 1 component instance -->
   <bean id="inlinePrototype" class="org.osgi.test.cases.blueprint.components.injection.ScopeComponent"
       init-method="init" destroy-method="destroy">
       <argument value="inlinePrototype"/>
       <argument value="1"/>
       <property name="references">
           <set>
               <!-- prototype1 will have prototype scope, which means a new component will be instantiated for each request -->
               <bean class="org.osgi.test.cases.blueprint.components.injection.PrototypeComponentInjection"
                   init-method="init" destroy-method="destroy">
                   <argument value="inlinePrototype1"/>
               </bean>
           </set>
       </property>
   </bean>
</blueprint>

