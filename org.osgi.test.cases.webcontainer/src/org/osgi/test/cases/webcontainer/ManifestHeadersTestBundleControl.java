/*
 * Copyright (c) IBM Corporation (2009). All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.osgi.test.cases.webcontainer;

import java.util.Map;
import java.util.jar.Manifest;

import org.osgi.framework.Bundle;
import org.osgi.service.webcontainer.WebContainer;
import org.osgi.test.cases.webcontainer.validate.BundleManifestValidator;

/**
 * @version $Rev$ $Date$
 * 
 *          abstract test class for webcontainer
 */
public abstract class ManifestHeadersTestBundleControl extends
        WebContainerTestBundleControl {
    protected Bundle b;

    public void setUp() throws Exception {
        super.setUp();
    }

    public void tearDown() throws Exception {
        if (this.b != null && this.b.getState() != Bundle.UNINSTALLED) {
            this.b.uninstall();
        }
        this.b = null;
    }

    /*
     * generalVersionTest to be used by non-error test
     */
    protected Bundle generalHeadersTest(Map options, String warName, boolean start)
            throws Exception {
        // specify install options
        String cp = options.get(WebContainer.WEB_CONTEXT_PATH) == null ? null
                : (String) options.get(WebContainer.WEB_CONTEXT_PATH);
        // install the war file
        log("install and start war file: " + warName + " at contextPath " + cp);
        Bundle b = null;
        try {
            b = installBundle(super.getWarURL(warName, options), start);
        } catch (Exception e) {
            fail("bundle install should succeed. " + e.getCause());
        }
        assertNotNull("Bundle b should not be null", b);
        Manifest originalManifest = super.getManifestFromWarName(warName);

        // check manifest generated correctly
        BundleManifestValidator validator = new BundleManifestValidator(b,
                originalManifest, options, this.debug);
        try {
            validator.validate();
        } catch (IllegalArgumentException e) {
            fail("version format is valid - should not be getting an IllegalArgumentException"
                    + e.getCause());
        } catch (Exception e) {
            fail("should not get any exception during validation "
                    + e.getCause());
        }

        if (cp == null) {
            // let's find out the actual web-contextpath first since it is
            // generated by the system
            cp = (String) b.getHeaders().get(WebContainer.WEB_CONTEXT_PATH);
        }

        // rough test able to access the app
        assertTrue("should be able to access " + cp, super.ableAccessPath(cp));

        if (!start) {
            // test unable to access pathes yet as it is not started
            assertEquals("Bundle status should be Resolved but not Active", b
                    .getState(), Bundle.RESOLVED);
            assertFalse(
                    "Bundle not started yet - should not be able to access "
                            + cp, super.ableAccessPath(cp));
            b.start();
        }

        assertEquals("Bundle status should be Active", b.getState(),
                Bundle.ACTIVE);
        try {
            String response = super.getResponse(cp);
            super.checkHomeResponse(response, warName);
        } catch (Exception e) {
            fail("should not be getting an exception here " + e.getMessage());
        }

        b.stop();
        // test unable to access pathes yet as it is not started
        assertEquals("Bundle status should be Resolved but not Active", b
                .getState(), Bundle.RESOLVED);
        assertFalse("Bundle not started yet - should not be able to access "
                + cp, super.ableAccessPath(cp));

        if (start) {
            b.start();
        }
        return b;
    }

}
