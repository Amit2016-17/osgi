/*
 * Master Gradle build script
 *
 * Depends on bnd_* values from gradle.properties.
 * bndWorkspace and cnf properties must be set by settings.gradle.
 */

/* Configure the cnf project first */
configure(cnf) { project ->
  plugins.apply BndPlugin
}

/* Configure the subprojects */
subprojects { project ->
  plugins.apply BndPlugin
}

/* BndPlugin classes */
class BndPlugin implements Plugin<Project> {
  private Project project
  private bndProject
  private boolean preCompileRefresh

  void apply(Project p) {
    p.configure(p) { project ->
      this.project = project
      this.bndProject = bndWorkspace.getProject(name)
      this.preCompileRefresh = parseBoolean(bnd_preCompileRefresh)
      bndProject.prepare();
      if (!bndProject.isValid()) {
        checkErrors()
        throw new GradleException("Project ${bndProject.name} is not a valid bnd project")
      }
      extensions.create('bnd', BndProperties, bndProject)
      bnd.ext.project = bndProject
      convention.plugins.bnd = new BndPluginConvention(this)
      bnd.ext.verbose = parseBoolean(bnd('verbose','false'))

      buildDir = relativePath(bndProject.targetDir)
      plugins.apply 'java'

      defaultTasks = [bnd_defaultTask]

      /* We use the same directory for java and resources. */
      sourceSets {
        main {
          java.srcDirs = resources.srcDirs = files(bndProject.sourcePath.collect { relativePath(it) })
          output.classesDir = output.resourcesDir = relativePath(bndProject.srcOutput)
        }
        test {
          java.srcDirs = resources.srcDirs = files(relativePath(bndProject.testSrc))
          output.classesDir = output.resourcesDir = relativePath(bndProject.testOutput)
        }
      }
      bnd.ext.allSrcDirs = files(bndProject.allsourcepath)
      sourceCompatibility = bnd('javac.source', sourceCompatibility)
      def javacTarget = bnd('javac.target', targetCompatibility)
      def bootclasspath = files(bndProject.bootclasspath.collect { it.file })
      if (javacTarget == 'jsr14') {
        javacTarget = '1.5'
        bootclasspath = files(bndProject.getBundle('ee.j2se', '1.5', null, ['strategy':'lowest']).file)
      }
      targetCompatibility = javacTarget
      def profile = bnd('javac.profile', '')
      def javac = bnd('javac', 'javac')
      def javacDebug = parseBoolean(bnd('javac.debug','false'))
      def compileOptions = {
        if (javacDebug) {
          options.debugOptions.debugLevel = 'source,lines,vars'
        }
        options.verbose = bnd.verbose
        options.listFiles = logger.isEnabled(LogLevel.INFO)
        options.deprecation = true
        options.encoding = 'UTF-8'
        if (javac != 'javac') {
          options.fork = true
          options.forkOptions.executable = javac
        }
        if (!bootclasspath.empty) {
          options.fork = true
          options.bootClasspath = bootclasspath.asPath
        }
        if (!profile.empty) {
          options.compilerArgs += ['-profile', profile]
        }
      }

      compileJava {
        configure compileOptions
        classpath = files(bndProject.buildpath.collect { it.file } - sourceSets.main.output.classesDir)
        if (logger.isEnabled(LogLevel.INFO)) {
          doFirst {
            logger.info "Compile ${sourceSets.main.java.srcDirs} to ${sourceSets.main.output.classesDir}"
            if (profile.empty) {
              logger.info "-source ${sourceCompatibility} -target ${targetCompatibility}"
            } else {
              logger.info "-source ${sourceCompatibility} -target ${targetCompatibility} -profile ${profile}"
            }
            logger.info "-classpath ${classpath.asPath}"
            if (options.bootClasspath != null) {
              logger.info "-bootclasspath ${options.bootClasspath}"
            }
          }
        }
        if (preCompileRefresh) {
          doFirst {
            logger.info 'Refreshing the bnd Project before compilation.'
            bndProject.refresh()
            bndProject.propertiesChanged()
            bndProject.clear()
            bndProject.prepare()
            classpath = files(bndProject.buildpath.collect { it.file } - sourceSets.main.output.classesDir)
          }
        }
      }

      compileTestJava {
        configure compileOptions
        classpath = files(bndProject.testpath.collect { it.file } - sourceSets.test.output.classesDir)
        if (preCompileRefresh) {
          doFirst {
            logger.info 'Refreshing the bnd Project before compilation.'
            bndProject.refresh()
            bndProject.propertiesChanged()
            bndProject.clear()
            bndProject.prepare()
            classpath = files(bndProject.testpath.collect { it.file } - sourceSets.test.output.classesDir)
          }
        }
      }

      processResources {
        def srcDirs = sourceSets.main.resources.srcDirs
        def outputDir = sourceSets.main.output.resourcesDir
        inputs.files.each {
          def input = it.absolutePath
          srcDirs.each {
            input -= it
          }
          outputs.file new File(outputDir, input)
        }
      }

      processTestResources {
        def srcDirs = sourceSets.test.resources.srcDirs
        def outputDir = sourceSets.test.output.resourcesDir
        inputs.files.each {
          def input = it.absolutePath
          srcDirs.each {
            input -= it
          }
          outputs.file new File(outputDir, input)
        }
      }

      jar {
        description 'Assemble the project bundles.'
        deleteAllActions() // Replace the standard jar task actions
        enabled !bndProject.noBundles
        if (enabled) {
          /* bnd can include any class on the classpath */
          inputs.files compileJava.classpath.collect {
            it.file ? it : fileTree(it)
          }
          /* all other files in the project like bnd and resources */
          inputs.files fileTree(projectDir) {
            exclude sourceSets.main.java.srcDirs.collect { relativePath(it) }
            exclude sourceSets.test.java.srcDirs.collect { relativePath(it) }
            exclude sourceSets.test.output.files.collect { relativePath(it) }
            exclude relativePath(buildDir)
            exclude '.*' // eclipse and git metadata
          }
          outputs.files bndProject.deliverables.collect { it.file }
          doLast {
            def built
            try {
              built = bndProject.build()
            } catch (Exception e) {
              throw new GradleException("Project ${bndProject.name} failed to build", e)
            }
            checkErrors()
            if (built != null) {
              logger.info 'Generated bundles:'
              built.each {
                logger.info "${it}"
              }
            }
          }
          if (!parseBoolean(bnd('nodeploy','false'))) {
            doLast {
              def deploySet = fileTree(buildDir).include(bnd.bin_includes.split(','))
              def boolean first = true
              deploySet.each {
                try {
                  bndProject.deploy(it)
                } catch (Exception e) {
                  throw new GradleException("Project ${bndProject.name} failed to deploy", e)
                }
                checkErrors()
                if (first) {
                  first = false
                  logger.info 'Deployed bundles:'
                }
                logger.info "${it}"
              }
            }
          }
        }
      }

      check {
        dependsOn assemble
        doLast {
          try {
            bndProject.test()
          } catch (Exception e) {
            throw new GradleException("Project ${bndProject.name} failed to test", e)
          }
          checkErrors()
        }
      }

      clean {
        /* Also clean compiler output */
        dependsOn cleanCompileJava, cleanCompileTestJava
        if (project == cnf) {
          /* clean bnd cache */
          doLast {
            project.delete(file('cache'))
          }
        }
      }

      docsDirName = 'javadoc'
      javadoc {
        description "Use the :${bnd_build}:${name} task instead."
        enabled false
        dependsOn.clear()
        deleteAllActions()
      }

      task('echo') {
        description 'Displays project information.'
        group 'help'
        doLast {
          println "verbose:                ${bnd.verbose}"
          println "project.workspace:      ${rootDir}"
          println "project.dir:            ${projectDir}"
          println "project.name:           ${project.name}"
          println "project.output:         ${sourceSets.main.output.classesDir}"
          println "project.sourcepath:     ${files(sourceSets.main.java.srcDirs).asPath}"
          println "project.allsourcepath:  ${bnd.allSrcDirs.asPath}"
          println "project.buildpath:      ${compileJava.classpath.asPath}"
          println "project.testpath:       ${compileTestJava.classpath.asPath}"
          println "project.dependson:      ${bndProject.dependson.collect{it.name}}"
          println "project.bootclasspath:  ${compileJava.options.bootClasspath}"
          println "javac:                  ${compileJava.options.forkOptions.executable}"
          println "javac.source:           ${sourceCompatibility}"
          println "javac.target:           ${targetCompatibility}"
          println "javac.compliance:       ${bnd.javac_compliance}"
          println "javac.profile:          ${profile}"
          println "base.modfied:           ${bnd.base_modified} (${bnd.base_modified_readable})"
          println "target:                 ${buildDir}"
          println "repo:                   ${bnd.repo}"
          println "licensed-repo:          ${bnd('licensed-repo')}"
          println "released-repo:          ${bnd('released-repo')}"
          println "nodeploy:               ${parseBoolean(bnd.nodeploy)}"
        }
      }

      if (project != cnf) {
        dependencies.add('compile', cnf)
      }
      bndProject.dependson.each {
        dependencies.add('compile', rootProject.project(it.name))
      }
    }
  }

  private void checkErrors() {
    def int errorCount = 0
    bndProject.warnings.each {
      project.logger.warn "Warning: ${it}"
    }
    bndProject.errors.each {
      project.logger.error "Error  : ${it}"
      errorCount++
    }
    if (!bndProject.isOk()) {
      def str = 'even though no errors were reported'
      if (errorCount == 1) {
        str = 'one error was reported'
      } else if (errorCount > 1) {
        str = "${errorCount} errors were reported"
      }
      throw new GradleException("Project ${bndProject.name} is invalid, ${str}")
    }
  }

  private boolean parseBoolean(String value) {
    return 'on'.equalsIgnoreCase(value) || 'true'.equalsIgnoreCase(value)
  }
}

class BndProperties {
  private final bndProject
  BndProperties(bndProject) {
    this.bndProject = bndProject
  }
  String get(String name) {
    def String value = bndProject.getProperty(name)
    if (value instanceof String) {
      value = value.trim()
    }
    return value
  }
  Object get(String name, Object defaultValue) {
    def value = get(name)
    if (value == null) {
      value = defaultValue
    }
    return value
  }
  String propertyMissing(String name) {
    def String value = get(name)
    if (value == null) {
      value = get(name.replace('_','.'))
    }
    return value
  }
}

class BndPluginConvention {
  private final Project project
  BndPluginConvention(BndPlugin plugin) {
   this.project = plugin.project
  }
  String bnd(String name) {
    return project.bnd.get(name)
  }
  Object bnd(String name, Object defaultValue) {
    return project.bnd.get(name, defaultValue)
  }
}
